"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/livekit-client";
exports.ids = ["vendor-chunks/livekit-client"];
exports.modules = {

/***/ "(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/livekit-client/dist/livekit-client.esm.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AudioPresets: () => (/* binding */ AudioPresets),\n/* harmony export */   BackupCodecPolicy: () => (/* binding */ BackupCodecPolicy),\n/* harmony export */   BaseKeyProvider: () => (/* binding */ BaseKeyProvider),\n/* harmony export */   CheckStatus: () => (/* binding */ CheckStatus),\n/* harmony export */   Checker: () => (/* binding */ Checker),\n/* harmony export */   ConnectionCheck: () => (/* binding */ ConnectionCheck),\n/* harmony export */   ConnectionError: () => (/* binding */ ConnectionError),\n/* harmony export */   ConnectionErrorReason: () => (/* binding */ ConnectionErrorReason),\n/* harmony export */   ConnectionQuality: () => (/* binding */ ConnectionQuality),\n/* harmony export */   ConnectionState: () => (/* binding */ ConnectionState),\n/* harmony export */   CriticalTimers: () => (/* binding */ CriticalTimers),\n/* harmony export */   CryptorError: () => (/* binding */ CryptorError),\n/* harmony export */   CryptorErrorReason: () => (/* binding */ CryptorErrorReason),\n/* harmony export */   CryptorEvent: () => (/* binding */ CryptorEvent),\n/* harmony export */   DataPacket_Kind: () => (/* binding */ DataPacket_Kind),\n/* harmony export */   DefaultReconnectPolicy: () => (/* binding */ DefaultReconnectPolicy),\n/* harmony export */   DeviceUnsupportedError: () => (/* binding */ DeviceUnsupportedError),\n/* harmony export */   DisconnectReason: () => (/* binding */ DisconnectReason),\n/* harmony export */   EncryptionEvent: () => (/* binding */ EncryptionEvent),\n/* harmony export */   EngineEvent: () => (/* binding */ EngineEvent),\n/* harmony export */   ExternalE2EEKeyProvider: () => (/* binding */ ExternalE2EEKeyProvider),\n/* harmony export */   KeyHandlerEvent: () => (/* binding */ KeyHandlerEvent),\n/* harmony export */   KeyProviderEvent: () => (/* binding */ KeyProviderEvent),\n/* harmony export */   LivekitError: () => (/* binding */ LivekitError),\n/* harmony export */   LocalAudioTrack: () => (/* binding */ LocalAudioTrack),\n/* harmony export */   LocalParticipant: () => (/* binding */ LocalParticipant),\n/* harmony export */   LocalTrack: () => (/* binding */ LocalTrack),\n/* harmony export */   LocalTrackPublication: () => (/* binding */ LocalTrackPublication),\n/* harmony export */   LocalVideoTrack: () => (/* binding */ LocalVideoTrack),\n/* harmony export */   LogLevel: () => (/* binding */ LogLevel),\n/* harmony export */   LoggerNames: () => (/* binding */ LoggerNames),\n/* harmony export */   MediaDeviceFailure: () => (/* binding */ MediaDeviceFailure),\n/* harmony export */   Mutex: () => (/* binding */ _),\n/* harmony export */   NegotiationError: () => (/* binding */ NegotiationError),\n/* harmony export */   Participant: () => (/* binding */ Participant),\n/* harmony export */   ParticipantEvent: () => (/* binding */ ParticipantEvent),\n/* harmony export */   ParticipantKind: () => (/* binding */ ParticipantInfo_Kind),\n/* harmony export */   PublishDataError: () => (/* binding */ PublishDataError),\n/* harmony export */   PublishTrackError: () => (/* binding */ PublishTrackError),\n/* harmony export */   RemoteAudioTrack: () => (/* binding */ RemoteAudioTrack),\n/* harmony export */   RemoteParticipant: () => (/* binding */ RemoteParticipant),\n/* harmony export */   RemoteTrack: () => (/* binding */ RemoteTrack),\n/* harmony export */   RemoteTrackPublication: () => (/* binding */ RemoteTrackPublication),\n/* harmony export */   RemoteVideoTrack: () => (/* binding */ RemoteVideoTrack),\n/* harmony export */   Room: () => (/* binding */ Room),\n/* harmony export */   RoomEvent: () => (/* binding */ RoomEvent),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   ScreenSharePresets: () => (/* binding */ ScreenSharePresets),\n/* harmony export */   SignalRequestError: () => (/* binding */ SignalRequestError),\n/* harmony export */   SubscriptionError: () => (/* binding */ SubscriptionError),\n/* harmony export */   Track: () => (/* binding */ Track),\n/* harmony export */   TrackEvent: () => (/* binding */ TrackEvent),\n/* harmony export */   TrackInvalidError: () => (/* binding */ TrackInvalidError),\n/* harmony export */   TrackPublication: () => (/* binding */ TrackPublication),\n/* harmony export */   TrackType: () => (/* binding */ TrackType),\n/* harmony export */   UnexpectedConnectionState: () => (/* binding */ UnexpectedConnectionState),\n/* harmony export */   UnsupportedServer: () => (/* binding */ UnsupportedServer),\n/* harmony export */   VideoPreset: () => (/* binding */ VideoPreset),\n/* harmony export */   VideoPresets: () => (/* binding */ VideoPresets),\n/* harmony export */   VideoPresets43: () => (/* binding */ VideoPresets43),\n/* harmony export */   VideoQuality: () => (/* binding */ VideoQuality),\n/* harmony export */   attachToElement: () => (/* binding */ attachToElement),\n/* harmony export */   compareVersions: () => (/* binding */ compareVersions),\n/* harmony export */   createAudioAnalyser: () => (/* binding */ createAudioAnalyser),\n/* harmony export */   createE2EEKey: () => (/* binding */ createE2EEKey),\n/* harmony export */   createKeyMaterialFromBuffer: () => (/* binding */ createKeyMaterialFromBuffer),\n/* harmony export */   createKeyMaterialFromString: () => (/* binding */ createKeyMaterialFromString),\n/* harmony export */   createLocalAudioTrack: () => (/* binding */ createLocalAudioTrack),\n/* harmony export */   createLocalScreenTracks: () => (/* binding */ createLocalScreenTracks),\n/* harmony export */   createLocalTracks: () => (/* binding */ createLocalTracks),\n/* harmony export */   createLocalVideoTrack: () => (/* binding */ createLocalVideoTrack),\n/* harmony export */   deriveKeys: () => (/* binding */ deriveKeys),\n/* harmony export */   detachTrack: () => (/* binding */ detachTrack),\n/* harmony export */   facingModeFromDeviceLabel: () => (/* binding */ facingModeFromDeviceLabel),\n/* harmony export */   facingModeFromLocalTrack: () => (/* binding */ facingModeFromLocalTrack),\n/* harmony export */   getBrowser: () => (/* binding */ getBrowser),\n/* harmony export */   getEmptyAudioStreamTrack: () => (/* binding */ getEmptyAudioStreamTrack),\n/* harmony export */   getEmptyVideoStreamTrack: () => (/* binding */ getEmptyVideoStreamTrack),\n/* harmony export */   getLogger: () => (/* binding */ getLogger),\n/* harmony export */   importKey: () => (/* binding */ importKey),\n/* harmony export */   isAudioTrack: () => (/* binding */ isAudioTrack),\n/* harmony export */   isBackupCodec: () => (/* binding */ isBackupCodec),\n/* harmony export */   isBrowserSupported: () => (/* binding */ isBrowserSupported),\n/* harmony export */   isE2EESupported: () => (/* binding */ isE2EESupported),\n/* harmony export */   isInsertableStreamSupported: () => (/* binding */ isInsertableStreamSupported),\n/* harmony export */   isLocalParticipant: () => (/* binding */ isLocalParticipant),\n/* harmony export */   isLocalTrack: () => (/* binding */ isLocalTrack),\n/* harmony export */   isRemoteParticipant: () => (/* binding */ isRemoteParticipant),\n/* harmony export */   isRemoteTrack: () => (/* binding */ isRemoteTrack),\n/* harmony export */   isScriptTransformSupported: () => (/* binding */ isScriptTransformSupported),\n/* harmony export */   isVideoFrame: () => (/* binding */ isVideoFrame),\n/* harmony export */   isVideoTrack: () => (/* binding */ isVideoTrack),\n/* harmony export */   needsRbspUnescaping: () => (/* binding */ needsRbspUnescaping),\n/* harmony export */   parseRbsp: () => (/* binding */ parseRbsp),\n/* harmony export */   protocolVersion: () => (/* binding */ protocolVersion),\n/* harmony export */   ratchet: () => (/* binding */ ratchet),\n/* harmony export */   setLogExtension: () => (/* binding */ setLogExtension),\n/* harmony export */   setLogLevel: () => (/* binding */ setLogLevel),\n/* harmony export */   supportsAV1: () => (/* binding */ supportsAV1),\n/* harmony export */   supportsAdaptiveStream: () => (/* binding */ supportsAdaptiveStream),\n/* harmony export */   supportsDynacast: () => (/* binding */ supportsDynacast),\n/* harmony export */   supportsVP9: () => (/* binding */ supportsVP9),\n/* harmony export */   version: () => (/* binding */ version),\n/* harmony export */   videoCodecs: () => (/* binding */ videoCodecs),\n/* harmony export */   writeRbsp: () => (/* binding */ writeRbsp)\n/* harmony export */ });\nfunction _mergeNamespaces(n, m) {\n    m.forEach(function(e) {\n        e && typeof e !== \"string\" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {\n            if (k !== \"default\" && !(k in n)) {\n                var d = Object.getOwnPropertyDescriptor(e, k);\n                Object.defineProperty(n, k, d.get ? d : {\n                    enumerable: true,\n                    get: function() {\n                        return e[k];\n                    }\n                });\n            }\n        });\n    });\n    return Object.freeze(n);\n}\nvar e = Object.defineProperty;\nvar h = (i, s, t)=>s in i ? e(i, s, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value: t\n    }) : i[s] = t;\nvar o = (i, s, t)=>h(i, typeof s != \"symbol\" ? s + \"\" : s, t);\nclass _ {\n    constructor(){\n        o(this, \"_locking\");\n        o(this, \"_locks\");\n        this._locking = Promise.resolve(), this._locks = 0;\n    }\n    isLocked() {\n        return this._locks > 0;\n    }\n    lock() {\n        this._locks += 1;\n        let s;\n        const t = new Promise((l)=>s = ()=>{\n                this._locks -= 1, l();\n            }), c = this._locking.then(()=>s);\n        return this._locking = this._locking.then(()=>t), c;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Assert that condition is truthy or throw error (with message)\n */ function assert(condition, msg) {\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions -- we want the implicit conversion to boolean\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nconst FLOAT32_MAX = 3.4028234663852886e38, FLOAT32_MIN = -34028234663852886e22, UINT32_MAX = 0xffffffff, INT32_MAX = 0x7fffffff, INT32_MIN = -2147483648;\n/**\n * Assert a valid signed protobuf 32-bit integer.\n */ function assertInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid int 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > INT32_MAX || arg < INT32_MIN) throw new Error(\"invalid int 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid unsigned protobuf 32-bit integer.\n */ function assertUInt32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid uint 32: \" + typeof arg);\n    if (!Number.isInteger(arg) || arg > UINT32_MAX || arg < 0) throw new Error(\"invalid uint 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n/**\n * Assert a valid protobuf float value.\n */ function assertFloat32(arg) {\n    if (typeof arg !== \"number\") throw new Error(\"invalid float 32: \" + typeof arg);\n    if (!Number.isFinite(arg)) return;\n    if (arg > FLOAT32_MAX || arg < FLOAT32_MIN) throw new Error(\"invalid float 32: \" + arg); // eslint-disable-line @typescript-eslint/restrict-plus-operands -- we want the implicit conversion to string\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nconst enumTypeSymbol = Symbol(\"@bufbuild/protobuf/enum-type\");\n/**\n * Get reflection information from a generated enum.\n * If this function is called on something other than a generated\n * enum, it raises an error.\n */ function getEnumType(enumObject) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-explicit-any\n    const t = enumObject[enumTypeSymbol];\n    assert(t, \"missing enum type on enum object\");\n    return t; // eslint-disable-line @typescript-eslint/no-unsafe-return\n}\n/**\n * Sets reflection information on a generated enum.\n */ function setEnumType(enumObject, typeName, values, opt) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-explicit-any\n    enumObject[enumTypeSymbol] = makeEnumType(typeName, values.map((v)=>({\n            no: v.no,\n            name: v.name,\n            localName: enumObject[v.no]\n        })));\n}\n/**\n * Create a new EnumType with the given values.\n */ function makeEnumType(typeName, values, // eslint-disable-next-line @typescript-eslint/no-unused-vars\n_opt) {\n    const names = Object.create(null);\n    const numbers = Object.create(null);\n    const normalValues = [];\n    for (const value of values){\n        // We do not surface options at this time\n        // const value: EnumValueInfo = {...v, options: v.options ?? emptyReadonlyObject};\n        const n = normalizeEnumValue(value);\n        normalValues.push(n);\n        names[value.name] = n;\n        numbers[value.no] = n;\n    }\n    return {\n        typeName,\n        values: normalValues,\n        // We do not surface options at this time\n        // options: opt?.options ?? Object.create(null),\n        findName (name) {\n            return names[name];\n        },\n        findNumber (no) {\n            return numbers[no];\n        }\n    };\n}\n/**\n * Create a new enum object with the given values.\n * Sets reflection information.\n */ function makeEnum(typeName, values, opt) {\n    const enumObject = {};\n    for (const value of values){\n        const n = normalizeEnumValue(value);\n        enumObject[n.localName] = n.no;\n        enumObject[n.no] = n.localName;\n    }\n    setEnumType(enumObject, typeName, values);\n    return enumObject;\n}\nfunction normalizeEnumValue(value) {\n    if (\"localName\" in value) {\n        return value;\n    }\n    return Object.assign(Object.assign({}, value), {\n        localName: value.name\n    });\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Message is the base class of every message, generated, or created at\n * runtime.\n *\n * It is _not_ safe to extend this class. If you want to create a message at\n * run time, use proto3.makeMessageType().\n */ class Message {\n    /**\n   * Compare with a message of the same type.\n   * Note that this function disregards extensions and unknown fields.\n   */ equals(other) {\n        return this.getType().runtime.util.equals(this.getType(), this, other);\n    }\n    /**\n   * Create a deep copy.\n   */ clone() {\n        return this.getType().runtime.util.clone(this);\n    }\n    /**\n   * Parse from binary data, merging fields.\n   *\n   * Repeated fields are appended. Map entries are added, overwriting\n   * existing keys.\n   *\n   * If a message field is already present, it will be merged with the\n   * new data.\n   */ fromBinary(bytes, options) {\n        const type = this.getType(), format = type.runtime.bin, opt = format.makeReadOptions(options);\n        format.readMessage(this, opt.readerFactory(bytes), bytes.byteLength, opt);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON value.\n   */ fromJson(jsonValue, options) {\n        const type = this.getType(), format = type.runtime.json, opt = format.makeReadOptions(options);\n        format.readMessage(type, jsonValue, opt, this);\n        return this;\n    }\n    /**\n   * Parse a message from a JSON string.\n   */ fromJsonString(jsonString, options) {\n        let json;\n        try {\n            json = JSON.parse(jsonString);\n        } catch (e) {\n            throw new Error(\"cannot decode \".concat(this.getType().typeName, \" from JSON: \").concat(e instanceof Error ? e.message : String(e)));\n        }\n        return this.fromJson(json, options);\n    }\n    /**\n   * Serialize the message to binary data.\n   */ toBinary(options) {\n        const type = this.getType(), bin = type.runtime.bin, opt = bin.makeWriteOptions(options), writer = opt.writerFactory();\n        bin.writeMessage(this, writer, opt);\n        return writer.finish();\n    }\n    /**\n   * Serialize the message to a JSON value, a JavaScript value that can be\n   * passed to JSON.stringify().\n   */ toJson(options) {\n        const type = this.getType(), json = type.runtime.json, opt = json.makeWriteOptions(options);\n        return json.writeMessage(this, opt);\n    }\n    /**\n   * Serialize the message to a JSON string.\n   */ toJsonString(options) {\n        var _a;\n        const value = this.toJson(options);\n        return JSON.stringify(value, null, (_a = options === null || options === void 0 ? void 0 : options.prettySpaces) !== null && _a !== void 0 ? _a : 0);\n    }\n    /**\n   * Override for serialization behavior. This will be invoked when calling\n   * JSON.stringify on this message (i.e. JSON.stringify(msg)).\n   *\n   * Note that this will not serialize google.protobuf.Any with a packed\n   * message because the protobuf JSON format specifies that it needs to be\n   * unpacked, and this is only possible with a type registry to look up the\n   * message type.  As a result, attempting to serialize a message with this\n   * type will throw an Error.\n   *\n   * This method is protected because you should not need to invoke it\n   * directly -- instead use JSON.stringify or toJsonString for\n   * stringified JSON.  Alternatively, if actual JSON is desired, you should\n   * use toJson.\n   */ toJSON() {\n        return this.toJson({\n            emitDefaultValues: true\n        });\n    }\n    /**\n   * Retrieve the MessageType of this message - a singleton that represents\n   * the protobuf message declaration and provides metadata for reflection-\n   * based operations.\n   */ getType() {\n        // Any class that extends Message _must_ provide a complete static\n        // implementation of MessageType.\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return\n        return Object.getPrototypeOf(this).constructor;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new message type using the given runtime.\n */ function makeMessageType(runtime, typeName, fields, opt) {\n    var _a;\n    const localName = (_a = opt === null || opt === void 0 ? void 0 : opt.localName) !== null && _a !== void 0 ? _a : typeName.substring(typeName.lastIndexOf(\".\") + 1);\n    const type = {\n        [localName]: function(data) {\n            runtime.util.initFields(this);\n            runtime.util.initPartial(data, this);\n        }\n    }[localName];\n    Object.setPrototypeOf(type.prototype, new Message());\n    Object.assign(type, {\n        runtime,\n        typeName,\n        fields: runtime.util.newFieldList(fields),\n        fromBinary (bytes, options) {\n            return new type().fromBinary(bytes, options);\n        },\n        fromJson (jsonValue, options) {\n            return new type().fromJson(jsonValue, options);\n        },\n        fromJsonString (jsonString, options) {\n            return new type().fromJsonString(jsonString, options);\n        },\n        equals (a, b) {\n            return runtime.util.equals(type, a, b);\n        }\n    });\n    return type;\n}\n// Copyright 2008 Google Inc.  All rights reserved.\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are\n// met:\n//\n// * Redistributions of source code must retain the above copyright\n// notice, this list of conditions and the following disclaimer.\n// * Redistributions in binary form must reproduce the above\n// copyright notice, this list of conditions and the following disclaimer\n// in the documentation and/or other materials provided with the\n// distribution.\n// * Neither the name of Google Inc. nor the names of its\n// contributors may be used to endorse or promote products derived from\n// this software without specific prior written permission.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n//\n// Code generated by the Protocol Buffer compiler is owned by the owner\n// of the input file used when generating it.  This code is not\n// standalone and requires a support library to be linked with it.  This\n// support library is itself covered by the above license.\n/* eslint-disable prefer-const,@typescript-eslint/restrict-plus-operands */ /**\n * Read a 64 bit varint as two JS numbers.\n *\n * Returns tuple:\n * [0]: low bits\n * [1]: high bits\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L175\n */ function varint64read() {\n    let lowBits = 0;\n    let highBits = 0;\n    for(let shift = 0; shift < 28; shift += 7){\n        let b = this.buf[this.pos++];\n        lowBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    let middleByte = this.buf[this.pos++];\n    // last four bits of the first 32 bit number\n    lowBits |= (middleByte & 0x0f) << 28;\n    // 3 upper bits are part of the next 32 bit number\n    highBits = (middleByte & 0x70) >> 4;\n    if ((middleByte & 0x80) == 0) {\n        this.assertBounds();\n        return [\n            lowBits,\n            highBits\n        ];\n    }\n    for(let shift = 3; shift <= 31; shift += 7){\n        let b = this.buf[this.pos++];\n        highBits |= (b & 0x7f) << shift;\n        if ((b & 0x80) == 0) {\n            this.assertBounds();\n            return [\n                lowBits,\n                highBits\n            ];\n        }\n    }\n    throw new Error(\"invalid varint\");\n}\n/**\n * Write a 64 bit varint, given as two JS numbers, to the given bytes array.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/writer.js#L344\n */ function varint64write(lo, hi, bytes) {\n    for(let i = 0; i < 28; i = i + 7){\n        const shift = lo >>> i;\n        const hasNext = !(shift >>> 7 == 0 && hi == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    const splitBits = lo >>> 28 & 0x0f | (hi & 0x07) << 4;\n    const hasMoreBits = !(hi >> 3 == 0);\n    bytes.push((hasMoreBits ? splitBits | 0x80 : splitBits) & 0xff);\n    if (!hasMoreBits) {\n        return;\n    }\n    for(let i = 3; i < 31; i = i + 7){\n        const shift = hi >>> i;\n        const hasNext = !(shift >>> 7 == 0);\n        const byte = (hasNext ? shift | 0x80 : shift) & 0xff;\n        bytes.push(byte);\n        if (!hasNext) {\n            return;\n        }\n    }\n    bytes.push(hi >>> 31 & 0x01);\n}\n// constants for binary math\nconst TWO_PWR_32_DBL = 0x100000000;\n/**\n * Parse decimal string of 64 bit integer value as two JS numbers.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64FromString(dec) {\n    // Check for minus sign.\n    const minus = dec[0] === \"-\";\n    if (minus) {\n        dec = dec.slice(1);\n    }\n    // Work 6 decimal digits at a time, acting like we're converting base 1e6\n    // digits to binary. This is safe to do with floating point math because\n    // Number.isSafeInteger(ALL_32_BITS * 1e6) == true.\n    const base = 1e6;\n    let lowBits = 0;\n    let highBits = 0;\n    function add1e6digit(begin, end) {\n        // Note: Number('') is 0.\n        const digit1e6 = Number(dec.slice(begin, end));\n        highBits *= base;\n        lowBits = lowBits * base + digit1e6;\n        // Carry bits from lowBits to\n        if (lowBits >= TWO_PWR_32_DBL) {\n            highBits = highBits + (lowBits / TWO_PWR_32_DBL | 0);\n            lowBits = lowBits % TWO_PWR_32_DBL;\n        }\n    }\n    add1e6digit(-24, -18);\n    add1e6digit(-18, -12);\n    add1e6digit(-12, -6);\n    add1e6digit(-6);\n    return minus ? negate(lowBits, highBits) : newBits(lowBits, highBits);\n}\n/**\n * Losslessly converts a 64-bit signed integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function int64ToString(lo, hi) {\n    let bits = newBits(lo, hi);\n    // If we're treating the input as a signed value and the high bit is set, do\n    // a manual two's complement conversion before the decimal conversion.\n    const negative = bits.hi & 0x80000000;\n    if (negative) {\n        bits = negate(bits.lo, bits.hi);\n    }\n    const result = uInt64ToString(bits.lo, bits.hi);\n    return negative ? \"-\" + result : result;\n}\n/**\n * Losslessly converts a 64-bit unsigned integer in 32:32 split representation\n * into a decimal string.\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf-javascript/blob/a428c58273abad07c66071d9753bc4d1289de426/experimental/runtime/int64.js#L10\n */ function uInt64ToString(lo, hi) {\n    ({ lo, hi } = toUnsigned(lo, hi));\n    // Skip the expensive conversion if the number is small enough to use the\n    // built-in conversions.\n    // Number.MAX_SAFE_INTEGER = 0x001FFFFF FFFFFFFF, thus any number with\n    // highBits <= 0x1FFFFF can be safely expressed with a double and retain\n    // integer precision.\n    // Proven by: Number.isSafeInteger(0x1FFFFF * 2**32 + 0xFFFFFFFF) == true.\n    if (hi <= 0x1FFFFF) {\n        return String(TWO_PWR_32_DBL * hi + lo);\n    }\n    // What this code is doing is essentially converting the input number from\n    // base-2 to base-1e7, which allows us to represent the 64-bit range with\n    // only 3 (very large) digits. Those digits are then trivial to convert to\n    // a base-10 string.\n    // The magic numbers used here are -\n    // 2^24 = 16777216 = (1,6777216) in base-1e7.\n    // 2^48 = 281474976710656 = (2,8147497,6710656) in base-1e7.\n    // Split 32:32 representation into 16:24:24 representation so our\n    // intermediate digits don't overflow.\n    const low = lo & 0xFFFFFF;\n    const mid = (lo >>> 24 | hi << 8) & 0xFFFFFF;\n    const high = hi >> 16 & 0xFFFF;\n    // Assemble our three base-1e7 digits, ignoring carries. The maximum\n    // value in a digit at this step is representable as a 48-bit integer, which\n    // can be stored in a 64-bit floating point number.\n    let digitA = low + mid * 6777216 + high * 6710656;\n    let digitB = mid + high * 8147497;\n    let digitC = high * 2;\n    // Apply carries from A to B and from B to C.\n    const base = 10000000;\n    if (digitA >= base) {\n        digitB += Math.floor(digitA / base);\n        digitA %= base;\n    }\n    if (digitB >= base) {\n        digitC += Math.floor(digitB / base);\n        digitB %= base;\n    }\n    // If digitC is 0, then we should have returned in the trivial code path\n    // at the top for non-safe integers. Given this, we can assume both digitB\n    // and digitA need leading zeros.\n    return digitC.toString() + decimalFrom1e7WithLeadingZeros(digitB) + decimalFrom1e7WithLeadingZeros(digitA);\n}\nfunction toUnsigned(lo, hi) {\n    return {\n        lo: lo >>> 0,\n        hi: hi >>> 0\n    };\n}\nfunction newBits(lo, hi) {\n    return {\n        lo: lo | 0,\n        hi: hi | 0\n    };\n}\n/**\n * Returns two's compliment negation of input.\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#Signed_32-bit_integers\n */ function negate(lowBits, highBits) {\n    highBits = ~highBits;\n    if (lowBits) {\n        lowBits = ~lowBits + 1;\n    } else {\n        // If lowBits is 0, then bitwise-not is 0xFFFFFFFF,\n        // adding 1 to that, results in 0x100000000, which leaves\n        // the low bits 0x0 and simply adds one to the high bits.\n        highBits += 1;\n    }\n    return newBits(lowBits, highBits);\n}\n/**\n * Returns decimal representation of digit1e7 with leading zeros.\n */ const decimalFrom1e7WithLeadingZeros = (digit1e7)=>{\n    const partial = String(digit1e7);\n    return \"0000000\".slice(partial.length) + partial;\n};\n/**\n * Write a 32 bit varint, signed or unsigned. Same as `varint64write(0, value, bytes)`\n *\n * Copyright 2008 Google Inc.  All rights reserved.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/1b18833f4f2a2f681f4e4a25cdf3b0a43115ec26/js/binary/encoder.js#L144\n */ function varint32write(value, bytes) {\n    if (value >= 0) {\n        // write value as varint 32\n        while(value > 0x7f){\n            bytes.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        bytes.push(value);\n    } else {\n        for(let i = 0; i < 9; i++){\n            bytes.push(value & 127 | 128);\n            value = value >> 7;\n        }\n        bytes.push(1);\n    }\n}\n/**\n * Read an unsigned 32 bit varint.\n *\n * See https://github.com/protocolbuffers/protobuf/blob/8a71927d74a4ce34efe2d8769fda198f52d20d12/js/experimental/runtime/kernel/buffer_decoder.js#L220\n */ function varint32read() {\n    let b = this.buf[this.pos++];\n    let result = b & 0x7f;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 7;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 14;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    b = this.buf[this.pos++];\n    result |= (b & 0x7f) << 21;\n    if ((b & 0x80) == 0) {\n        this.assertBounds();\n        return result;\n    }\n    // Extract only last 4 bits\n    b = this.buf[this.pos++];\n    result |= (b & 0x0f) << 28;\n    for(let readBytes = 5; (b & 0x80) !== 0 && readBytes < 10; readBytes++)b = this.buf[this.pos++];\n    if ((b & 0x80) != 0) throw new Error(\"invalid varint\");\n    this.assertBounds();\n    // Result can have 32 bits, convert it to unsigned\n    return result >>> 0;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeInt64Support() {\n    const dv = new DataView(new ArrayBuffer(8));\n    // note that Safari 14 implements BigInt, but not the DataView methods\n    const ok = typeof BigInt === \"function\" && typeof dv.getBigInt64 === \"function\" && typeof dv.getBigUint64 === \"function\" && typeof dv.setBigInt64 === \"function\" && typeof dv.setBigUint64 === \"function\" && (typeof process != \"object\" || typeof process.env != \"object\" || process.env.BUF_BIGINT_DISABLE !== \"1\");\n    if (ok) {\n        const MIN = BigInt(\"-9223372036854775808\"), MAX = BigInt(\"9223372036854775807\"), UMIN = BigInt(\"0\"), UMAX = BigInt(\"18446744073709551615\");\n        return {\n            zero: BigInt(0),\n            supported: true,\n            parse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > MAX || bi < MIN) {\n                    throw new Error(\"int64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            uParse (value) {\n                const bi = typeof value == \"bigint\" ? value : BigInt(value);\n                if (bi > UMAX || bi < UMIN) {\n                    throw new Error(\"uint64 invalid: \".concat(value));\n                }\n                return bi;\n            },\n            enc (value) {\n                dv.setBigInt64(0, this.parse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            uEnc (value) {\n                dv.setBigInt64(0, this.uParse(value), true);\n                return {\n                    lo: dv.getInt32(0, true),\n                    hi: dv.getInt32(4, true)\n                };\n            },\n            dec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigInt64(0, true);\n            },\n            uDec (lo, hi) {\n                dv.setInt32(0, lo, true);\n                dv.setInt32(4, hi, true);\n                return dv.getBigUint64(0, true);\n            }\n        };\n    }\n    const assertInt64String = (value)=>assert(/^-?[0-9]+$/.test(value), \"int64 invalid: \".concat(value));\n    const assertUInt64String = (value)=>assert(/^[0-9]+$/.test(value), \"uint64 invalid: \".concat(value));\n    return {\n        zero: \"0\",\n        supported: false,\n        parse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return value;\n        },\n        uParse (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return value;\n        },\n        enc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertInt64String(value);\n            return int64FromString(value);\n        },\n        uEnc (value) {\n            if (typeof value != \"string\") {\n                value = value.toString();\n            }\n            assertUInt64String(value);\n            return int64FromString(value);\n        },\n        dec (lo, hi) {\n            return int64ToString(lo, hi);\n        },\n        uDec (lo, hi) {\n            return uInt64ToString(lo, hi);\n        }\n    };\n}\nconst protoInt64 = makeInt64Support();\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Scalar value types. This is a subset of field types declared by protobuf\n * enum google.protobuf.FieldDescriptorProto.Type The types GROUP and MESSAGE\n * are omitted, but the numerical values are identical.\n */ var ScalarType;\n(function(ScalarType) {\n    // 0 is reserved for errors.\n    // Order is weird for historical reasons.\n    ScalarType[ScalarType[\"DOUBLE\"] = 1] = \"DOUBLE\";\n    ScalarType[ScalarType[\"FLOAT\"] = 2] = \"FLOAT\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT64\"] = 3] = \"INT64\";\n    ScalarType[ScalarType[\"UINT64\"] = 4] = \"UINT64\";\n    // Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if\n    // negative values are likely.\n    ScalarType[ScalarType[\"INT32\"] = 5] = \"INT32\";\n    ScalarType[ScalarType[\"FIXED64\"] = 6] = \"FIXED64\";\n    ScalarType[ScalarType[\"FIXED32\"] = 7] = \"FIXED32\";\n    ScalarType[ScalarType[\"BOOL\"] = 8] = \"BOOL\";\n    ScalarType[ScalarType[\"STRING\"] = 9] = \"STRING\";\n    // Tag-delimited aggregate.\n    // Group type is deprecated and not supported in proto3. However, Proto3\n    // implementations should still be able to parse the group wire format and\n    // treat group fields as unknown fields.\n    // TYPE_GROUP = 10,\n    // TYPE_MESSAGE = 11,  // Length-delimited aggregate.\n    // New in version 2.\n    ScalarType[ScalarType[\"BYTES\"] = 12] = \"BYTES\";\n    ScalarType[ScalarType[\"UINT32\"] = 13] = \"UINT32\";\n    // TYPE_ENUM = 14,\n    ScalarType[ScalarType[\"SFIXED32\"] = 15] = \"SFIXED32\";\n    ScalarType[ScalarType[\"SFIXED64\"] = 16] = \"SFIXED64\";\n    ScalarType[ScalarType[\"SINT32\"] = 17] = \"SINT32\";\n    ScalarType[ScalarType[\"SINT64\"] = 18] = \"SINT64\";\n})(ScalarType || (ScalarType = {}));\n/**\n * JavaScript representation of fields with 64 bit integral types (int64, uint64,\n * sint64, fixed64, sfixed64).\n *\n * This is a subset of google.protobuf.FieldOptions.JSType, which defines JS_NORMAL,\n * JS_STRING, and JS_NUMBER. Protobuf-ES uses BigInt by default, but will use\n * String if `[jstype = JS_STRING]` is specified.\n *\n * ```protobuf\n * uint64 field_a = 1; // BigInt\n * uint64 field_b = 2 [jstype = JS_NORMAL]; // BigInt\n * uint64 field_b = 2 [jstype = JS_NUMBER]; // BigInt\n * uint64 field_b = 2 [jstype = JS_STRING]; // String\n * ```\n */ var LongType;\n(function(LongType) {\n    /**\n   * Use JavaScript BigInt.\n   */ LongType[LongType[\"BIGINT\"] = 0] = \"BIGINT\";\n    /**\n   * Use JavaScript String.\n   *\n   * Field option `[jstype = JS_STRING]`.\n   */ LongType[LongType[\"STRING\"] = 1] = \"STRING\";\n})(LongType || (LongType = {}));\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if both scalar values are equal.\n */ function scalarEquals(type, a, b) {\n    if (a === b) {\n        // This correctly matches equal values except BYTES and (possibly) 64-bit integers.\n        return true;\n    }\n    // Special case BYTES - we need to compare each byte individually\n    if (type == ScalarType.BYTES) {\n        if (!(a instanceof Uint8Array) || !(b instanceof Uint8Array)) {\n            return false;\n        }\n        if (a.length !== b.length) {\n            return false;\n        }\n        for(let i = 0; i < a.length; i++){\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    // Special case 64-bit integers - we support number, string and bigint representation.\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(type){\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // Loose comparison will match between 0n, 0 and \"0\".\n            return a == b;\n    }\n    // Anything that hasn't been caught by strict comparison or special cased\n    // BYTES and 64-bit integers is not equal.\n    return false;\n}\n/**\n * Returns the zero value for the given scalar type.\n */ function scalarZeroValue(type, longType) {\n    switch(type){\n        case ScalarType.BOOL:\n            return false;\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            return longType == 0 ? protoInt64.zero : \"0\";\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            return 0.0;\n        case ScalarType.BYTES:\n            return new Uint8Array(0);\n        case ScalarType.STRING:\n            return \"\";\n        default:\n            // Handles INT32, UINT32, SINT32, FIXED32, SFIXED32.\n            // We do not use individual cases to save a few bytes code size.\n            return 0;\n    }\n}\n/**\n * Returns true for a zero-value. For example, an integer has the zero-value `0`,\n * a boolean is `false`, a string is `\"\"`, and bytes is an empty Uint8Array.\n *\n * In proto3, zero-values are not written to the wire, unless the field is\n * optional or repeated.\n */ function isScalarZeroValue(type, value) {\n    switch(type){\n        case ScalarType.BOOL:\n            return value === false;\n        case ScalarType.STRING:\n            return value === \"\";\n        case ScalarType.BYTES:\n            return value instanceof Uint8Array && !value.byteLength;\n        default:\n            return value == 0;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/restrict-plus-operands */ /**\n * Protobuf binary format wire types.\n *\n * A wire type provides just enough information to find the length of the\n * following value.\n *\n * See https://developers.google.com/protocol-buffers/docs/encoding#structure\n */ var WireType;\n(function(WireType) {\n    /**\n   * Used for int32, int64, uint32, uint64, sint32, sint64, bool, enum\n   */ WireType[WireType[\"Varint\"] = 0] = \"Varint\";\n    /**\n   * Used for fixed64, sfixed64, double.\n   * Always 8 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit64\"] = 1] = \"Bit64\";\n    /**\n   * Used for string, bytes, embedded messages, packed repeated fields\n   *\n   * Only repeated numeric types (types which use the varint, 32-bit,\n   * or 64-bit wire types) can be packed. In proto3, such fields are\n   * packed by default.\n   */ WireType[WireType[\"LengthDelimited\"] = 2] = \"LengthDelimited\";\n    /**\n   * Start of a tag-delimited aggregate, such as a proto2 group, or a message\n   * in editions with message_encoding = DELIMITED.\n   */ WireType[WireType[\"StartGroup\"] = 3] = \"StartGroup\";\n    /**\n   * End of a tag-delimited aggregate.\n   */ WireType[WireType[\"EndGroup\"] = 4] = \"EndGroup\";\n    /**\n   * Used for fixed32, sfixed32, float.\n   * Always 4 bytes with little-endian byte order.\n   */ WireType[WireType[\"Bit32\"] = 5] = \"Bit32\";\n})(WireType || (WireType = {}));\nclass BinaryWriter {\n    constructor(textEncoder){\n        /**\n     * Previous fork states.\n     */ this.stack = [];\n        this.textEncoder = textEncoder !== null && textEncoder !== void 0 ? textEncoder : new TextEncoder();\n        this.chunks = [];\n        this.buf = [];\n    }\n    /**\n   * Return all bytes written and reset this writer.\n   */ finish() {\n        this.chunks.push(new Uint8Array(this.buf)); // flush the buffer\n        let len = 0;\n        for(let i = 0; i < this.chunks.length; i++)len += this.chunks[i].length;\n        let bytes = new Uint8Array(len);\n        let offset = 0;\n        for(let i = 0; i < this.chunks.length; i++){\n            bytes.set(this.chunks[i], offset);\n            offset += this.chunks[i].length;\n        }\n        this.chunks = [];\n        return bytes;\n    }\n    /**\n   * Start a new fork for length-delimited data like a message\n   * or a packed repeated field.\n   *\n   * Must be joined later with `join()`.\n   */ fork() {\n        this.stack.push({\n            chunks: this.chunks,\n            buf: this.buf\n        });\n        this.chunks = [];\n        this.buf = [];\n        return this;\n    }\n    /**\n   * Join the last fork. Write its length and bytes, then\n   * return to the previous state.\n   */ join() {\n        // get chunk of fork\n        let chunk = this.finish();\n        // restore previous state\n        let prev = this.stack.pop();\n        if (!prev) throw new Error(\"invalid state, fork stack empty\");\n        this.chunks = prev.chunks;\n        this.buf = prev.buf;\n        // write length of chunk as varint\n        this.uint32(chunk.byteLength);\n        return this.raw(chunk);\n    }\n    /**\n   * Writes a tag (field number and wire type).\n   *\n   * Equivalent to `uint32( (fieldNo << 3 | type) >>> 0 )`.\n   *\n   * Generated code should compute the tag ahead of time and call `uint32()`.\n   */ tag(fieldNo, type) {\n        return this.uint32((fieldNo << 3 | type) >>> 0);\n    }\n    /**\n   * Write a chunk of raw bytes.\n   */ raw(chunk) {\n        if (this.buf.length) {\n            this.chunks.push(new Uint8Array(this.buf));\n            this.buf = [];\n        }\n        this.chunks.push(chunk);\n        return this;\n    }\n    /**\n   * Write a `uint32` value, an unsigned 32 bit varint.\n   */ uint32(value) {\n        assertUInt32(value);\n        // write value as varint 32, inlined for speed\n        while(value > 0x7f){\n            this.buf.push(value & 0x7f | 0x80);\n            value = value >>> 7;\n        }\n        this.buf.push(value);\n        return this;\n    }\n    /**\n   * Write a `int32` value, a signed 32 bit varint.\n   */ int32(value) {\n        assertInt32(value);\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `bool` value, a variant.\n   */ bool(value) {\n        this.buf.push(value ? 1 : 0);\n        return this;\n    }\n    /**\n   * Write a `bytes` value, length-delimited arbitrary data.\n   */ bytes(value) {\n        this.uint32(value.byteLength); // write length of chunk as varint\n        return this.raw(value);\n    }\n    /**\n   * Write a `string` value, length-delimited data converted to UTF-8 text.\n   */ string(value) {\n        let chunk = this.textEncoder.encode(value);\n        this.uint32(chunk.byteLength); // write length of chunk as varint\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `float` value, 32-bit floating point number.\n   */ float(value) {\n        assertFloat32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setFloat32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `double` value, a 64-bit floating point number.\n   */ double(value) {\n        let chunk = new Uint8Array(8);\n        new DataView(chunk.buffer).setFloat64(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed32` value, an unsigned, fixed-length 32-bit integer.\n   */ fixed32(value) {\n        assertUInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setUint32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sfixed32` value, a signed, fixed-length 32-bit integer.\n   */ sfixed32(value) {\n        assertInt32(value);\n        let chunk = new Uint8Array(4);\n        new DataView(chunk.buffer).setInt32(0, value, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `sint32` value, a signed, zigzag-encoded 32-bit varint.\n   */ sint32(value) {\n        assertInt32(value);\n        // zigzag encode\n        value = (value << 1 ^ value >> 31) >>> 0;\n        varint32write(value, this.buf);\n        return this;\n    }\n    /**\n   * Write a `fixed64` value, a signed, fixed-length 64-bit integer.\n   */ sfixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.enc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `fixed64` value, an unsigned, fixed-length 64 bit integer.\n   */ fixed64(value) {\n        let chunk = new Uint8Array(8), view = new DataView(chunk.buffer), tc = protoInt64.uEnc(value);\n        view.setInt32(0, tc.lo, true);\n        view.setInt32(4, tc.hi, true);\n        return this.raw(chunk);\n    }\n    /**\n   * Write a `int64` value, a signed 64-bit varint.\n   */ int64(value) {\n        let tc = protoInt64.enc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `sint64` value, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64(value) {\n        let tc = protoInt64.enc(value), // zigzag encode\n        sign = tc.hi >> 31, lo = tc.lo << 1 ^ sign, hi = (tc.hi << 1 | tc.lo >>> 31) ^ sign;\n        varint64write(lo, hi, this.buf);\n        return this;\n    }\n    /**\n   * Write a `uint64` value, an unsigned 64-bit varint.\n   */ uint64(value) {\n        let tc = protoInt64.uEnc(value);\n        varint64write(tc.lo, tc.hi, this.buf);\n        return this;\n    }\n}\nclass BinaryReader {\n    constructor(buf, textDecoder){\n        this.varint64 = varint64read; // dirty cast for `this`\n        /**\n     * Read a `uint32` field, an unsigned 32 bit varint.\n     */ this.uint32 = varint32read; // dirty cast for `this` and access to protected `buf`\n        this.buf = buf;\n        this.len = buf.length;\n        this.pos = 0;\n        this.view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);\n        this.textDecoder = textDecoder !== null && textDecoder !== void 0 ? textDecoder : new TextDecoder();\n    }\n    /**\n   * Reads a tag - field number and wire type.\n   */ tag() {\n        let tag = this.uint32(), fieldNo = tag >>> 3, wireType = tag & 7;\n        if (fieldNo <= 0 || wireType < 0 || wireType > 5) throw new Error(\"illegal tag: field no \" + fieldNo + \" wire type \" + wireType);\n        return [\n            fieldNo,\n            wireType\n        ];\n    }\n    /**\n   * Skip one element and return the skipped data.\n   *\n   * When skipping StartGroup, provide the tags field number to check for\n   * matching field number in the EndGroup tag.\n   */ skip(wireType, fieldNo) {\n        let start = this.pos;\n        switch(wireType){\n            case WireType.Varint:\n                while(this.buf[this.pos++] & 0x80){\n                // ignore\n                }\n                break;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit64:\n                this.pos += 4;\n            // eslint-disable-next-line\n            // @ts-ignore TS7029: Fallthrough case in switch\n            case WireType.Bit32:\n                this.pos += 4;\n                break;\n            case WireType.LengthDelimited:\n                let len = this.uint32();\n                this.pos += len;\n                break;\n            case WireType.StartGroup:\n                for(;;){\n                    const [fn, wt] = this.tag();\n                    if (wt === WireType.EndGroup) {\n                        if (fieldNo !== undefined && fn !== fieldNo) {\n                            throw new Error(\"invalid end group tag\");\n                        }\n                        break;\n                    }\n                    this.skip(wt, fn);\n                }\n                break;\n            default:\n                throw new Error(\"cant skip wire type \" + wireType);\n        }\n        this.assertBounds();\n        return this.buf.subarray(start, this.pos);\n    }\n    /**\n   * Throws error if position in byte array is out of range.\n   */ assertBounds() {\n        if (this.pos > this.len) throw new RangeError(\"premature EOF\");\n    }\n    /**\n   * Read a `int32` field, a signed 32 bit varint.\n   */ int32() {\n        return this.uint32() | 0;\n    }\n    /**\n   * Read a `sint32` field, a signed, zigzag-encoded 32-bit varint.\n   */ sint32() {\n        let zze = this.uint32();\n        // decode zigzag\n        return zze >>> 1 ^ -(zze & 1);\n    }\n    /**\n   * Read a `int64` field, a signed 64-bit varint.\n   */ int64() {\n        return protoInt64.dec(...this.varint64());\n    }\n    /**\n   * Read a `uint64` field, an unsigned 64-bit varint.\n   */ uint64() {\n        return protoInt64.uDec(...this.varint64());\n    }\n    /**\n   * Read a `sint64` field, a signed, zig-zag-encoded 64-bit varint.\n   */ sint64() {\n        let [lo, hi] = this.varint64();\n        // decode zig zag\n        let s = -(lo & 1);\n        lo = (lo >>> 1 | (hi & 1) << 31) ^ s;\n        hi = hi >>> 1 ^ s;\n        return protoInt64.dec(lo, hi);\n    }\n    /**\n   * Read a `bool` field, a variant.\n   */ bool() {\n        let [lo, hi] = this.varint64();\n        return lo !== 0 || hi !== 0;\n    }\n    /**\n   * Read a `fixed32` field, an unsigned, fixed-length 32-bit integer.\n   */ fixed32() {\n        return this.view.getUint32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `sfixed32` field, a signed, fixed-length 32-bit integer.\n   */ sfixed32() {\n        return this.view.getInt32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `fixed64` field, an unsigned, fixed-length 64 bit integer.\n   */ fixed64() {\n        return protoInt64.uDec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `fixed64` field, a signed, fixed-length 64-bit integer.\n   */ sfixed64() {\n        return protoInt64.dec(this.sfixed32(), this.sfixed32());\n    }\n    /**\n   * Read a `float` field, 32-bit floating point number.\n   */ float() {\n        return this.view.getFloat32((this.pos += 4) - 4, true);\n    }\n    /**\n   * Read a `double` field, a 64-bit floating point number.\n   */ double() {\n        return this.view.getFloat64((this.pos += 8) - 8, true);\n    }\n    /**\n   * Read a `bytes` field, length-delimited arbitrary data.\n   */ bytes() {\n        let len = this.uint32(), start = this.pos;\n        this.pos += len;\n        this.assertBounds();\n        return this.buf.subarray(start, start + len);\n    }\n    /**\n   * Read a `string` field, length-delimited data converted to UTF-8 text.\n   */ string() {\n        return this.textDecoder.decode(this.bytes());\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Create a new extension using the given runtime.\n */ function makeExtension(runtime, typeName, extendee, field) {\n    let fi;\n    return {\n        typeName,\n        extendee,\n        get field () {\n            if (!fi) {\n                const i = typeof field == \"function\" ? field() : field;\n                i.name = typeName.split(\".\").pop();\n                i.jsonName = \"[\".concat(typeName, \"]\");\n                fi = runtime.util.newFieldList([\n                    i\n                ]).list()[0];\n            }\n            return fi;\n        },\n        runtime\n    };\n}\n/**\n * Create a container that allows us to read extension fields into it with the\n * same logic as regular fields.\n */ function createExtensionContainer(extension) {\n    const localName = extension.field.localName;\n    const container = Object.create(null);\n    container[localName] = initExtensionField(extension);\n    return [\n        container,\n        ()=>container[localName]\n    ];\n}\nfunction initExtensionField(ext) {\n    const field = ext.field;\n    if (field.repeated) {\n        return [];\n    }\n    if (field.default !== undefined) {\n        return field.default;\n    }\n    switch(field.kind){\n        case \"enum\":\n            return field.T.values[0].no;\n        case \"scalar\":\n            return scalarZeroValue(field.T, field.L);\n        case \"message\":\n            // eslint-disable-next-line no-case-declarations\n            const T = field.T, value = new T();\n            return T.fieldWrapper ? T.fieldWrapper.unwrapField(value) : value;\n        case \"map\":\n            throw \"map fields are not allowed to be extensions\";\n    }\n}\n/**\n * Helper to filter unknown fields, optimized based on field type.\n */ function filterUnknownFields(unknownFields, field) {\n    if (!field.repeated && (field.kind == \"enum\" || field.kind == \"scalar\")) {\n        // singular scalar fields do not merge, we pick the last\n        for(let i = unknownFields.length - 1; i >= 0; --i){\n            if (unknownFields[i].no == field.no) {\n                return [\n                    unknownFields[i]\n                ];\n            }\n        }\n        return [];\n    }\n    return unknownFields.filter((uf)=>uf.no === field.no);\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/ban-ts-comment, @typescript-eslint/no-unnecessary-condition, prefer-const */ // lookup table from base64 character to byte\nlet encTable = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".split(\"\");\n// lookup table from base64 character *code* to byte because lookup by number is fast\nlet decTable = [];\nfor(let i = 0; i < encTable.length; i++)decTable[encTable[i].charCodeAt(0)] = i;\n// support base64url variants\ndecTable[\"-\".charCodeAt(0)] = encTable.indexOf(\"+\");\ndecTable[\"_\".charCodeAt(0)] = encTable.indexOf(\"/\");\nconst protoBase64 = {\n    /**\n   * Decodes a base64 string to a byte array.\n   *\n   * - ignores white-space, including line breaks and tabs\n   * - allows inner padding (can decode concatenated base64 strings)\n   * - does not require padding\n   * - understands base64url encoding:\n   *   \"-\" instead of \"+\",\n   *   \"_\" instead of \"/\",\n   *   no padding\n   */ dec (base64Str) {\n        // estimate byte size, not accounting for inner padding and whitespace\n        let es = base64Str.length * 3 / 4;\n        if (base64Str[base64Str.length - 2] == \"=\") es -= 2;\n        else if (base64Str[base64Str.length - 1] == \"=\") es -= 1;\n        let bytes = new Uint8Array(es), bytePos = 0, // position in byte array\n        groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // previous byte\n        for(let i = 0; i < base64Str.length; i++){\n            b = decTable[base64Str.charCodeAt(i)];\n            if (b === undefined) {\n                switch(base64Str[i]){\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"=\":\n                        groupPos = 0;\n                    // reset state when padding found\n                    // @ts-ignore TS7029: Fallthrough case in switch\n                    case \"\\n\":\n                    case \"\\r\":\n                    case \"\t\":\n                    case \" \":\n                        continue;\n                    // skip white-space, and padding\n                    default:\n                        throw Error(\"invalid base64 string.\");\n                }\n            }\n            switch(groupPos){\n                case 0:\n                    p = b;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    bytes[bytePos++] = p << 2 | (b & 48) >> 4;\n                    p = b;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    bytes[bytePos++] = (p & 15) << 4 | (b & 60) >> 2;\n                    p = b;\n                    groupPos = 3;\n                    break;\n                case 3:\n                    bytes[bytePos++] = (p & 3) << 6 | b;\n                    groupPos = 0;\n                    break;\n            }\n        }\n        if (groupPos == 1) throw Error(\"invalid base64 string.\");\n        return bytes.subarray(0, bytePos);\n    },\n    /**\n   * Encode a byte array to a base64 string.\n   */ enc (bytes) {\n        let base64 = \"\", groupPos = 0, // position in base64 group\n        b, // current byte\n        p = 0; // carry over from previous byte\n        for(let i = 0; i < bytes.length; i++){\n            b = bytes[i];\n            switch(groupPos){\n                case 0:\n                    base64 += encTable[b >> 2];\n                    p = (b & 3) << 4;\n                    groupPos = 1;\n                    break;\n                case 1:\n                    base64 += encTable[p | b >> 4];\n                    p = (b & 15) << 2;\n                    groupPos = 2;\n                    break;\n                case 2:\n                    base64 += encTable[p | b >> 6];\n                    base64 += encTable[b & 63];\n                    groupPos = 0;\n                    break;\n            }\n        }\n        // add output padding\n        if (groupPos) {\n            base64 += encTable[p];\n            base64 += \"=\";\n            if (groupPos == 1) base64 += \"=\";\n        }\n        return base64;\n    }\n};\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Retrieve an extension value from a message.\n *\n * The function never returns undefined. Use hasExtension() to check whether an\n * extension is set. If the extension is not set, this function returns the\n * default value (if one was specified in the protobuf source), or the zero value\n * (for example `0` for numeric types, `[]` for repeated extension fields, and\n * an empty message instance for message fields).\n *\n * Extensions are stored as unknown fields on a message. To mutate an extension\n * value, make sure to store the new value with setExtension() after mutating.\n *\n * If the extension does not extend the given message, an error is raised.\n */ function getExtension(message, extension, options) {\n    assertExtendee(extension, message);\n    const opt = extension.runtime.bin.makeReadOptions(options);\n    const ufs = filterUnknownFields(message.getType().runtime.bin.listUnknownFields(message), extension.field);\n    const [container, get] = createExtensionContainer(extension);\n    for (const uf of ufs){\n        extension.runtime.bin.readField(container, opt.readerFactory(uf.data), extension.field, uf.wireType, opt);\n    }\n    return get();\n}\n/**\n * Set an extension value on a message. If the message already has a value for\n * this extension, the value is replaced.\n *\n * If the extension does not extend the given message, an error is raised.\n */ function setExtension(message, extension, value, options) {\n    assertExtendee(extension, message);\n    const readOpt = extension.runtime.bin.makeReadOptions(options);\n    const writeOpt = extension.runtime.bin.makeWriteOptions(options);\n    if (hasExtension(message, extension)) {\n        const ufs = message.getType().runtime.bin.listUnknownFields(message).filter((uf)=>uf.no != extension.field.no);\n        message.getType().runtime.bin.discardUnknownFields(message);\n        for (const uf of ufs){\n            message.getType().runtime.bin.onUnknownField(message, uf.no, uf.wireType, uf.data);\n        }\n    }\n    const writer = writeOpt.writerFactory();\n    let f = extension.field;\n    // Implicit presence does not apply to extensions, see https://github.com/protocolbuffers/protobuf/issues/8234\n    // We patch the field info to use explicit presence:\n    if (!f.opt && !f.repeated && (f.kind == \"enum\" || f.kind == \"scalar\")) {\n        f = Object.assign(Object.assign({}, extension.field), {\n            opt: true\n        });\n    }\n    extension.runtime.bin.writeField(f, value, writer, writeOpt);\n    const reader = readOpt.readerFactory(writer.finish());\n    while(reader.pos < reader.len){\n        const [no, wireType] = reader.tag();\n        const data = reader.skip(wireType, no);\n        message.getType().runtime.bin.onUnknownField(message, no, wireType, data);\n    }\n}\n/**\n * Check whether an extension is set on a message.\n */ function hasExtension(message, extension) {\n    const messageType = message.getType();\n    return extension.extendee.typeName === messageType.typeName && !!messageType.runtime.bin.listUnknownFields(message).find((uf)=>uf.no == extension.field.no);\n}\nfunction assertExtendee(extension, message) {\n    assert(extension.extendee.typeName == message.getType().typeName, \"extension \".concat(extension.typeName, \" can only be applied to message \").concat(extension.extendee.typeName));\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns true if the field is set.\n */ function isFieldSet(field, target) {\n    const localName = field.localName;\n    if (field.repeated) {\n        return target[localName].length > 0;\n    }\n    if (field.oneof) {\n        return target[field.oneof.localName].case === localName; // eslint-disable-line @typescript-eslint/no-unsafe-member-access\n    }\n    switch(field.kind){\n        case \"enum\":\n        case \"scalar\":\n            if (field.opt || field.req) {\n                // explicit presence\n                return target[localName] !== undefined;\n            }\n            // implicit presence\n            if (field.kind == \"enum\") {\n                return target[localName] !== field.T.values[0].no;\n            }\n            return !isScalarZeroValue(field.T, target[localName]);\n        case \"message\":\n            return target[localName] !== undefined;\n        case \"map\":\n            return Object.keys(target[localName]).length > 0;\n    }\n}\n/**\n * Resets the field, so that isFieldSet() will return false.\n */ function clearField(field, target) {\n    const localName = field.localName;\n    const implicitPresence = !field.opt && !field.req;\n    if (field.repeated) {\n        target[localName] = [];\n    } else if (field.oneof) {\n        target[field.oneof.localName] = {\n            case: undefined\n        };\n    } else {\n        switch(field.kind){\n            case \"map\":\n                target[localName] = {};\n                break;\n            case \"enum\":\n                target[localName] = implicitPresence ? field.T.values[0].no : undefined;\n                break;\n            case \"scalar\":\n                target[localName] = implicitPresence ? scalarZeroValue(field.T, field.L) : undefined;\n                break;\n            case \"message\":\n                target[localName] = undefined;\n                break;\n        }\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Check whether the given object is any subtype of Message or is a specific\n * Message by passing the type.\n *\n * Just like `instanceof`, `isMessage` narrows the type. The advantage of\n * `isMessage` is that it compares identity by the message type name, not by\n * class identity. This makes it robust against the dual package hazard and\n * similar situations, where the same message is duplicated.\n *\n * This function is _mostly_ equivalent to the `instanceof` operator. For\n * example, `isMessage(foo, MyMessage)` is the same as `foo instanceof MyMessage`,\n * and `isMessage(foo)` is the same as `foo instanceof Message`. In most cases,\n * `isMessage` should be preferred over `instanceof`.\n *\n * However, due to the fact that `isMessage` does not use class identity, there\n * are subtle differences between this function and `instanceof`. Notably,\n * calling `isMessage` on an explicit type of Message will return false.\n */ function isMessage(arg, type) {\n    if (arg === null || typeof arg != \"object\") {\n        return false;\n    }\n    if (!Object.getOwnPropertyNames(Message.prototype).every((m)=>m in arg && typeof arg[m] == \"function\")) {\n        return false;\n    }\n    const actualType = arg.getType();\n    if (actualType === null || typeof actualType != \"function\" || !(\"typeName\" in actualType) || typeof actualType.typeName != \"string\") {\n        return false;\n    }\n    return type === undefined ? true : actualType.typeName == type.typeName;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Wrap a primitive message field value in its corresponding wrapper\n * message. This function is idempotent.\n */ function wrapField(type, value) {\n    if (isMessage(value) || !type.fieldWrapper) {\n        return value;\n    }\n    return type.fieldWrapper.wrapField(value);\n}\n({\n    \"google.protobuf.DoubleValue\": ScalarType.DOUBLE,\n    \"google.protobuf.FloatValue\": ScalarType.FLOAT,\n    \"google.protobuf.Int64Value\": ScalarType.INT64,\n    \"google.protobuf.UInt64Value\": ScalarType.UINT64,\n    \"google.protobuf.Int32Value\": ScalarType.INT32,\n    \"google.protobuf.UInt32Value\": ScalarType.UINT32,\n    \"google.protobuf.BoolValue\": ScalarType.BOOL,\n    \"google.protobuf.StringValue\": ScalarType.STRING,\n    \"google.protobuf.BytesValue\": ScalarType.BYTES\n});\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable no-case-declarations,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call */ // Default options for parsing JSON.\nconst jsonReadDefaults = {\n    ignoreUnknownFields: false\n};\n// Default options for serializing to JSON.\nconst jsonWriteDefaults = {\n    emitDefaultValues: false,\n    enumAsInteger: false,\n    useProtoFieldName: false,\n    prettySpaces: 0\n};\nfunction makeReadOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, jsonReadDefaults), options) : jsonReadDefaults;\n}\nfunction makeWriteOptions$1(options) {\n    return options ? Object.assign(Object.assign({}, jsonWriteDefaults), options) : jsonWriteDefaults;\n}\nconst tokenNull = Symbol();\nconst tokenIgnoredUnknownEnum = Symbol();\nfunction makeJsonFormat() {\n    return {\n        makeReadOptions: makeReadOptions$1,\n        makeWriteOptions: makeWriteOptions$1,\n        readMessage (type, json, options, message) {\n            if (json == null || Array.isArray(json) || typeof json != \"object\") {\n                throw new Error(\"cannot decode message \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n            }\n            message = message !== null && message !== void 0 ? message : new type();\n            const oneofSeen = new Map();\n            const registry = options.typeRegistry;\n            for (const [jsonKey, jsonValue] of Object.entries(json)){\n                const field = type.fields.findJsonName(jsonKey);\n                if (field) {\n                    if (field.oneof) {\n                        if (jsonValue === null && field.kind == \"scalar\") {\n                            continue;\n                        }\n                        const seen = oneofSeen.get(field.oneof);\n                        if (seen !== undefined) {\n                            throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: multiple keys for oneof \"').concat(field.oneof.name, '\" present: \"').concat(seen, '\", \"').concat(jsonKey, '\"'));\n                        }\n                        oneofSeen.set(field.oneof, jsonKey);\n                    }\n                    readField$1(message, jsonValue, field, options, type);\n                } else {\n                    let found = false;\n                    if ((registry === null || registry === void 0 ? void 0 : registry.findExtension) && jsonKey.startsWith(\"[\") && jsonKey.endsWith(\"]\")) {\n                        const ext = registry.findExtension(jsonKey.substring(1, jsonKey.length - 1));\n                        if (ext && ext.extendee.typeName == type.typeName) {\n                            found = true;\n                            const [container, get] = createExtensionContainer(ext);\n                            readField$1(container, jsonValue, ext.field, options, ext);\n                            // We pass on the options as BinaryReadOptions/BinaryWriteOptions,\n                            // so that users can bring their own binary reader and writer factories\n                            // if necessary.\n                            setExtension(message, ext, get(), options);\n                        }\n                    }\n                    if (!found && !options.ignoreUnknownFields) {\n                        throw new Error(\"cannot decode message \".concat(type.typeName, ' from JSON: key \"').concat(jsonKey, '\" is unknown'));\n                    }\n                }\n            }\n            return message;\n        },\n        writeMessage (message, options) {\n            const type = message.getType();\n            const json = {};\n            let field;\n            try {\n                for (field of type.fields.byNumber()){\n                    if (!isFieldSet(field, message)) {\n                        // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n                        if (field.req) {\n                            throw \"required field not set\";\n                        }\n                        if (!options.emitDefaultValues) {\n                            continue;\n                        }\n                        if (!canEmitFieldDefaultValue(field)) {\n                            continue;\n                        }\n                    }\n                    const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n                    const jsonValue = writeField$1(field, value, options);\n                    if (jsonValue !== undefined) {\n                        json[options.useProtoFieldName ? field.name : field.jsonName] = jsonValue;\n                    }\n                }\n                const registry = options.typeRegistry;\n                if (registry === null || registry === void 0 ? void 0 : registry.findExtensionFor) {\n                    for (const uf of type.runtime.bin.listUnknownFields(message)){\n                        const ext = registry.findExtensionFor(type.typeName, uf.no);\n                        if (ext && hasExtension(message, ext)) {\n                            // We pass on the options as BinaryReadOptions, so that users can bring their own\n                            // binary reader factory if necessary.\n                            const value = getExtension(message, ext, options);\n                            const jsonValue = writeField$1(ext.field, value, options);\n                            if (jsonValue !== undefined) {\n                                json[ext.field.jsonName] = jsonValue;\n                            }\n                        }\n                    }\n                }\n            } catch (e) {\n                const m = field ? \"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to JSON\") : \"cannot encode message \".concat(type.typeName, \" to JSON\");\n                const r = e instanceof Error ? e.message : String(e);\n                throw new Error(m + (r.length > 0 ? \": \".concat(r) : \"\"));\n            }\n            return json;\n        },\n        readScalar (type, json, longType) {\n            // The signature of our internal function has changed. For backwards-\n            // compatibility, we support the old form that is part of the public API\n            // through the interface JsonFormat.\n            return readScalar$1(type, json, longType !== null && longType !== void 0 ? longType : LongType.BIGINT, true);\n        },\n        writeScalar (type, value, emitDefaultValues) {\n            // The signature of our internal function has changed. For backwards-\n            // compatibility, we support the old form that is part of the public API\n            // through the interface JsonFormat.\n            if (value === undefined) {\n                return undefined;\n            }\n            if (emitDefaultValues || isScalarZeroValue(type, value)) {\n                return writeScalar$1(type, value);\n            }\n            return undefined;\n        },\n        debug: debugJsonValue\n    };\n}\nfunction debugJsonValue(json) {\n    if (json === null) {\n        return \"null\";\n    }\n    switch(typeof json){\n        case \"object\":\n            return Array.isArray(json) ? \"array\" : \"object\";\n        case \"string\":\n            return json.length > 100 ? \"string\" : '\"'.concat(json.split('\"').join('\\\\\"'), '\"');\n        default:\n            return String(json);\n    }\n}\n// Read a JSON value for a field.\n// The \"parentType\" argument is only used to provide context in errors.\nfunction readField$1(target, jsonValue, field, options, parentType) {\n    let localName = field.localName;\n    if (field.repeated) {\n        assert(field.kind != \"map\");\n        if (jsonValue === null) {\n            return;\n        }\n        if (!Array.isArray(jsonValue)) {\n            throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n        }\n        const targetArray = target[localName];\n        for (const jsonItem of jsonValue){\n            if (jsonItem === null) {\n                throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem)));\n            }\n            switch(field.kind){\n                case \"message\":\n                    targetArray.push(field.T.fromJson(jsonItem, options));\n                    break;\n                case \"enum\":\n                    const enumValue = readEnum(field.T, jsonItem, options.ignoreUnknownFields, true);\n                    if (enumValue !== tokenIgnoredUnknownEnum) {\n                        targetArray.push(enumValue);\n                    }\n                    break;\n                case \"scalar\":\n                    try {\n                        targetArray.push(readScalar$1(field.T, jsonItem, field.L, true));\n                    } catch (e) {\n                        let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonItem));\n                        if (e instanceof Error && e.message.length > 0) {\n                            m += \": \".concat(e.message);\n                        }\n                        throw new Error(m);\n                    }\n                    break;\n            }\n        }\n    } else if (field.kind == \"map\") {\n        if (jsonValue === null) {\n            return;\n        }\n        if (typeof jsonValue != \"object\" || Array.isArray(jsonValue)) {\n            throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue)));\n        }\n        const targetMap = target[localName];\n        for (const [jsonMapKey, jsonMapValue] of Object.entries(jsonValue)){\n            if (jsonMapValue === null) {\n                throw new Error(\"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: map value null\"));\n            }\n            let key;\n            try {\n                key = readMapKey(field.K, jsonMapKey);\n            } catch (e) {\n                let m = \"cannot decode map key for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                if (e instanceof Error && e.message.length > 0) {\n                    m += \": \".concat(e.message);\n                }\n                throw new Error(m);\n            }\n            switch(field.V.kind){\n                case \"message\":\n                    targetMap[key] = field.V.T.fromJson(jsonMapValue, options);\n                    break;\n                case \"enum\":\n                    const enumValue = readEnum(field.V.T, jsonMapValue, options.ignoreUnknownFields, true);\n                    if (enumValue !== tokenIgnoredUnknownEnum) {\n                        targetMap[key] = enumValue;\n                    }\n                    break;\n                case \"scalar\":\n                    try {\n                        targetMap[key] = readScalar$1(field.V.T, jsonMapValue, LongType.BIGINT, true);\n                    } catch (e) {\n                        let m = \"cannot decode map value for field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                        if (e instanceof Error && e.message.length > 0) {\n                            m += \": \".concat(e.message);\n                        }\n                        throw new Error(m);\n                    }\n                    break;\n            }\n        }\n    } else {\n        if (field.oneof) {\n            target = target[field.oneof.localName] = {\n                case: localName\n            };\n            localName = \"value\";\n        }\n        switch(field.kind){\n            case \"message\":\n                const messageType = field.T;\n                if (jsonValue === null && messageType.typeName != \"google.protobuf.Value\") {\n                    return;\n                }\n                let currentValue = target[localName];\n                if (isMessage(currentValue)) {\n                    currentValue.fromJson(jsonValue, options);\n                } else {\n                    target[localName] = currentValue = messageType.fromJson(jsonValue, options);\n                    if (messageType.fieldWrapper && !field.oneof) {\n                        target[localName] = messageType.fieldWrapper.unwrapField(currentValue);\n                    }\n                }\n                break;\n            case \"enum\":\n                const enumValue = readEnum(field.T, jsonValue, options.ignoreUnknownFields, false);\n                switch(enumValue){\n                    case tokenNull:\n                        clearField(field, target);\n                        break;\n                    case tokenIgnoredUnknownEnum:\n                        break;\n                    default:\n                        target[localName] = enumValue;\n                        break;\n                }\n                break;\n            case \"scalar\":\n                try {\n                    const scalarValue = readScalar$1(field.T, jsonValue, field.L, false);\n                    switch(scalarValue){\n                        case tokenNull:\n                            clearField(field, target);\n                            break;\n                        default:\n                            target[localName] = scalarValue;\n                            break;\n                    }\n                } catch (e) {\n                    let m = \"cannot decode field \".concat(parentType.typeName, \".\").concat(field.name, \" from JSON: \").concat(debugJsonValue(jsonValue));\n                    if (e instanceof Error && e.message.length > 0) {\n                        m += \": \".concat(e.message);\n                    }\n                    throw new Error(m);\n                }\n                break;\n        }\n    }\n}\nfunction readMapKey(type, json) {\n    if (type === ScalarType.BOOL) {\n        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n        switch(json){\n            case \"true\":\n                json = true;\n                break;\n            case \"false\":\n                json = false;\n                break;\n        }\n    }\n    return readScalar$1(type, json, LongType.BIGINT, true).toString();\n}\nfunction readScalar$1(type, json, longType, nullAsZeroValue) {\n    if (json === null) {\n        if (nullAsZeroValue) {\n            return scalarZeroValue(type, longType);\n        }\n        return tokenNull;\n    }\n    // every valid case in the switch below returns, and every fall\n    // through is regarded as a failure.\n    switch(type){\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.DOUBLE:\n        case ScalarType.FLOAT:\n            if (json === \"NaN\") return Number.NaN;\n            if (json === \"Infinity\") return Number.POSITIVE_INFINITY;\n            if (json === \"-Infinity\") return Number.NEGATIVE_INFINITY;\n            if (json === \"\") {\n                break;\n            }\n            if (typeof json == \"string\" && json.trim().length !== json.length) {\n                break;\n            }\n            if (typeof json != \"string\" && typeof json != \"number\") {\n                break;\n            }\n            const float = Number(json);\n            if (Number.isNaN(float)) {\n                break;\n            }\n            if (!Number.isFinite(float)) {\n                break;\n            }\n            if (type == ScalarType.FLOAT) assertFloat32(float);\n            return float;\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.UINT32:\n            let int32;\n            if (typeof json == \"number\") int32 = json;\n            else if (typeof json == \"string\" && json.length > 0) {\n                if (json.trim().length === json.length) int32 = Number(json);\n            }\n            if (int32 === undefined) break;\n            if (type == ScalarType.UINT32 || type == ScalarType.FIXED32) assertUInt32(int32);\n            else assertInt32(int32);\n            return int32;\n        // int64, fixed64, uint64: JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const long = protoInt64.parse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? long.toString() : long;\n        case ScalarType.FIXED64:\n        case ScalarType.UINT64:\n            if (typeof json != \"number\" && typeof json != \"string\") break;\n            const uLong = protoInt64.uParse(json);\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            return longType ? uLong.toString() : uLong;\n        // bool:\n        case ScalarType.BOOL:\n            if (typeof json !== \"boolean\") break;\n            return json;\n        // string:\n        case ScalarType.STRING:\n            if (typeof json !== \"string\") {\n                break;\n            }\n            // A string must always contain UTF-8 encoded or 7-bit ASCII.\n            // We validate with encodeURIComponent, which appears to be the fastest widely available option.\n            try {\n                encodeURIComponent(json);\n            } catch (e) {\n                throw new Error(\"invalid UTF8\");\n            }\n            return json;\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            if (json === \"\") return new Uint8Array(0);\n            if (typeof json !== \"string\") break;\n            return protoBase64.dec(json);\n    }\n    throw new Error();\n}\nfunction readEnum(type, json, ignoreUnknownFields, nullAsZeroValue) {\n    if (json === null) {\n        if (type.typeName == \"google.protobuf.NullValue\") {\n            return 0; // google.protobuf.NullValue.NULL_VALUE = 0\n        }\n        return nullAsZeroValue ? type.values[0].no : tokenNull;\n    }\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check\n    switch(typeof json){\n        case \"number\":\n            if (Number.isInteger(json)) {\n                return json;\n            }\n            break;\n        case \"string\":\n            const value = type.findName(json);\n            if (value !== undefined) {\n                return value.no;\n            }\n            if (ignoreUnknownFields) {\n                return tokenIgnoredUnknownEnum;\n            }\n            break;\n    }\n    throw new Error(\"cannot decode enum \".concat(type.typeName, \" from JSON: \").concat(debugJsonValue(json)));\n}\n// Decide whether an unset field should be emitted with JSON write option `emitDefaultValues`\nfunction canEmitFieldDefaultValue(field) {\n    if (field.repeated || field.kind == \"map\") {\n        // maps are {}, repeated fields are []\n        return true;\n    }\n    if (field.oneof) {\n        // oneof fields are never emitted\n        return false;\n    }\n    if (field.kind == \"message\") {\n        // singular message field are allowed to emit JSON null, but we do not\n        return false;\n    }\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (field.opt || field.req) {\n        // the field uses explicit presence, so we cannot emit a zero value\n        return false;\n    }\n    return true;\n}\nfunction writeField$1(field, value, options) {\n    if (field.kind == \"map\") {\n        assert(typeof value == \"object\" && value != null);\n        const jsonObj = {};\n        const entries = Object.entries(value);\n        switch(field.V.kind){\n            case \"scalar\":\n                for (const [entryKey, entryValue] of entries){\n                    jsonObj[entryKey.toString()] = writeScalar$1(field.V.T, entryValue); // JSON standard allows only (double quoted) string as property key\n                }\n                break;\n            case \"message\":\n                for (const [entryKey, entryValue] of entries){\n                    // JSON standard allows only (double quoted) string as property key\n                    jsonObj[entryKey.toString()] = entryValue.toJson(options);\n                }\n                break;\n            case \"enum\":\n                const enumType = field.V.T;\n                for (const [entryKey, entryValue] of entries){\n                    // JSON standard allows only (double quoted) string as property key\n                    jsonObj[entryKey.toString()] = writeEnum(enumType, entryValue, options.enumAsInteger);\n                }\n                break;\n        }\n        return options.emitDefaultValues || entries.length > 0 ? jsonObj : undefined;\n    }\n    if (field.repeated) {\n        assert(Array.isArray(value));\n        const jsonArr = [];\n        switch(field.kind){\n            case \"scalar\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(writeScalar$1(field.T, value[i]));\n                }\n                break;\n            case \"enum\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(writeEnum(field.T, value[i], options.enumAsInteger));\n                }\n                break;\n            case \"message\":\n                for(let i = 0; i < value.length; i++){\n                    jsonArr.push(value[i].toJson(options));\n                }\n                break;\n        }\n        return options.emitDefaultValues || jsonArr.length > 0 ? jsonArr : undefined;\n    }\n    switch(field.kind){\n        case \"scalar\":\n            return writeScalar$1(field.T, value);\n        case \"enum\":\n            return writeEnum(field.T, value, options.enumAsInteger);\n        case \"message\":\n            return wrapField(field.T, value).toJson(options);\n    }\n}\nfunction writeEnum(type, value, enumAsInteger) {\n    var _a;\n    assert(typeof value == \"number\");\n    if (type.typeName == \"google.protobuf.NullValue\") {\n        return null;\n    }\n    if (enumAsInteger) {\n        return value;\n    }\n    const val = type.findNumber(value);\n    return (_a = val === null || val === void 0 ? void 0 : val.name) !== null && _a !== void 0 ? _a : value; // if we don't know the enum value, just return the number\n}\nfunction writeScalar$1(type, value) {\n    switch(type){\n        // int32, fixed32, uint32: JSON value will be a decimal number. Either numbers or strings are accepted.\n        case ScalarType.INT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n            assert(typeof value == \"number\");\n            return value;\n        // float, double: JSON value will be a number or one of the special string values \"NaN\", \"Infinity\", and \"-Infinity\".\n        // Either numbers or strings are accepted. Exponent notation is also accepted.\n        case ScalarType.FLOAT:\n        // assertFloat32(value);\n        case ScalarType.DOUBLE:\n            // eslint-disable-line no-fallthrough\n            assert(typeof value == \"number\");\n            if (Number.isNaN(value)) return \"NaN\";\n            if (value === Number.POSITIVE_INFINITY) return \"Infinity\";\n            if (value === Number.NEGATIVE_INFINITY) return \"-Infinity\";\n            return value;\n        // string:\n        case ScalarType.STRING:\n            assert(typeof value == \"string\");\n            return value;\n        // bool:\n        case ScalarType.BOOL:\n            assert(typeof value == \"boolean\");\n            return value;\n        // JSON value will be a decimal string. Either numbers or strings are accepted.\n        case ScalarType.UINT64:\n        case ScalarType.FIXED64:\n        case ScalarType.INT64:\n        case ScalarType.SFIXED64:\n        case ScalarType.SINT64:\n            assert(typeof value == \"bigint\" || typeof value == \"string\" || typeof value == \"number\");\n            return value.toString();\n        // bytes: JSON value will be the data encoded as a string using standard base64 encoding with paddings.\n        // Either standard or URL-safe base64 encoding with/without paddings are accepted.\n        case ScalarType.BYTES:\n            assert(value instanceof Uint8Array);\n            return protoBase64.enc(value);\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable prefer-const,no-case-declarations,@typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-call,@typescript-eslint/no-unsafe-return */ const unknownFieldsSymbol = Symbol(\"@bufbuild/protobuf/unknown-fields\");\n// Default options for parsing binary data.\nconst readDefaults = {\n    readUnknownFields: true,\n    readerFactory: (bytes)=>new BinaryReader(bytes)\n};\n// Default options for serializing binary data.\nconst writeDefaults = {\n    writeUnknownFields: true,\n    writerFactory: ()=>new BinaryWriter()\n};\nfunction makeReadOptions(options) {\n    return options ? Object.assign(Object.assign({}, readDefaults), options) : readDefaults;\n}\nfunction makeWriteOptions(options) {\n    return options ? Object.assign(Object.assign({}, writeDefaults), options) : writeDefaults;\n}\nfunction makeBinaryFormat() {\n    return {\n        makeReadOptions,\n        makeWriteOptions,\n        listUnknownFields (message) {\n            var _a;\n            return (_a = message[unknownFieldsSymbol]) !== null && _a !== void 0 ? _a : [];\n        },\n        discardUnknownFields (message) {\n            delete message[unknownFieldsSymbol];\n        },\n        writeUnknownFields (message, writer) {\n            const m = message;\n            const c = m[unknownFieldsSymbol];\n            if (c) {\n                for (const f of c){\n                    writer.tag(f.no, f.wireType).raw(f.data);\n                }\n            }\n        },\n        onUnknownField (message, no, wireType, data) {\n            const m = message;\n            if (!Array.isArray(m[unknownFieldsSymbol])) {\n                m[unknownFieldsSymbol] = [];\n            }\n            m[unknownFieldsSymbol].push({\n                no,\n                wireType,\n                data\n            });\n        },\n        readMessage (message, reader, lengthOrEndTagFieldNo, options, delimitedMessageEncoding) {\n            const type = message.getType();\n            // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n            const end = delimitedMessageEncoding ? reader.len : reader.pos + lengthOrEndTagFieldNo;\n            let fieldNo, wireType;\n            while(reader.pos < end){\n                [fieldNo, wireType] = reader.tag();\n                if (delimitedMessageEncoding === true && wireType == WireType.EndGroup) {\n                    break;\n                }\n                const field = type.fields.find(fieldNo);\n                if (!field) {\n                    const data = reader.skip(wireType, fieldNo);\n                    if (options.readUnknownFields) {\n                        this.onUnknownField(message, fieldNo, wireType, data);\n                    }\n                    continue;\n                }\n                readField(message, reader, field, wireType, options);\n            }\n            if (delimitedMessageEncoding && // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n            (wireType != WireType.EndGroup || fieldNo !== lengthOrEndTagFieldNo)) {\n                throw new Error(\"invalid end group tag\");\n            }\n        },\n        readField,\n        writeMessage (message, writer, options) {\n            const type = message.getType();\n            for (const field of type.fields.byNumber()){\n                if (!isFieldSet(field, message)) {\n                    if (field.req) {\n                        throw new Error(\"cannot encode field \".concat(type.typeName, \".\").concat(field.name, \" to binary: required field not set\"));\n                    }\n                    continue;\n                }\n                const value = field.oneof ? message[field.oneof.localName].value : message[field.localName];\n                writeField(field, value, writer, options);\n            }\n            if (options.writeUnknownFields) {\n                this.writeUnknownFields(message, writer);\n            }\n            return writer;\n        },\n        writeField (field, value, writer, options) {\n            // The behavior of our internal function has changed, it does no longer\n            // accept `undefined` values for singular scalar and map.\n            // For backwards-compatibility, we support the old form that is part of\n            // the public API through the interface BinaryFormat.\n            if (value === undefined) {\n                return undefined;\n            }\n            writeField(field, value, writer, options);\n        }\n    };\n}\nfunction readField(target, // eslint-disable-line @typescript-eslint/no-explicit-any -- `any` is the best choice for dynamic access\nreader, field, wireType, options) {\n    let { repeated, localName } = field;\n    if (field.oneof) {\n        target = target[field.oneof.localName];\n        if (target.case != localName) {\n            delete target.value;\n        }\n        target.case = localName;\n        localName = \"value\";\n    }\n    switch(field.kind){\n        case \"scalar\":\n        case \"enum\":\n            const scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n            let read = readScalar;\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison -- acceptable since it's covered by tests\n            if (field.kind == \"scalar\" && field.L > 0) {\n                read = readScalarLTString;\n            }\n            if (repeated) {\n                let arr = target[localName]; // safe to assume presence of array, oneof cannot contain repeated values\n                const isPacked = wireType == WireType.LengthDelimited && scalarType != ScalarType.STRING && scalarType != ScalarType.BYTES;\n                if (isPacked) {\n                    let e = reader.uint32() + reader.pos;\n                    while(reader.pos < e){\n                        arr.push(read(reader, scalarType));\n                    }\n                } else {\n                    arr.push(read(reader, scalarType));\n                }\n            } else {\n                target[localName] = read(reader, scalarType);\n            }\n            break;\n        case \"message\":\n            const messageType = field.T;\n            if (repeated) {\n                // safe to assume presence of array, oneof cannot contain repeated values\n                target[localName].push(readMessageField(reader, new messageType(), options, field));\n            } else {\n                if (isMessage(target[localName])) {\n                    readMessageField(reader, target[localName], options, field);\n                } else {\n                    target[localName] = readMessageField(reader, new messageType(), options, field);\n                    if (messageType.fieldWrapper && !field.oneof && !field.repeated) {\n                        target[localName] = messageType.fieldWrapper.unwrapField(target[localName]);\n                    }\n                }\n            }\n            break;\n        case \"map\":\n            let [mapKey, mapVal] = readMapEntry(field, reader, options);\n            // safe to assume presence of map object, oneof cannot contain repeated values\n            target[localName][mapKey] = mapVal;\n            break;\n    }\n}\n// Read a message, avoiding MessageType.fromBinary() to re-use the\n// BinaryReadOptions and the IBinaryReader.\nfunction readMessageField(reader, message, options, field) {\n    const format = message.getType().runtime.bin;\n    const delimited = field === null || field === void 0 ? void 0 : field.delimited;\n    format.readMessage(message, reader, delimited ? field.no : reader.uint32(), // eslint-disable-line @typescript-eslint/strict-boolean-expressions\n    options, delimited);\n    return message;\n}\n// Read a map field, expecting key field = 1, value field = 2\nfunction readMapEntry(field, reader, options) {\n    const length = reader.uint32(), end = reader.pos + length;\n    let key, val;\n    while(reader.pos < end){\n        const [fieldNo] = reader.tag();\n        switch(fieldNo){\n            case 1:\n                key = readScalar(reader, field.K);\n                break;\n            case 2:\n                switch(field.V.kind){\n                    case \"scalar\":\n                        val = readScalar(reader, field.V.T);\n                        break;\n                    case \"enum\":\n                        val = reader.int32();\n                        break;\n                    case \"message\":\n                        val = readMessageField(reader, new field.V.T(), options, undefined);\n                        break;\n                }\n                break;\n        }\n    }\n    if (key === undefined) {\n        key = scalarZeroValue(field.K, LongType.BIGINT);\n    }\n    if (typeof key != \"string\" && typeof key != \"number\") {\n        key = key.toString();\n    }\n    if (val === undefined) {\n        switch(field.V.kind){\n            case \"scalar\":\n                val = scalarZeroValue(field.V.T, LongType.BIGINT);\n                break;\n            case \"enum\":\n                val = field.V.T.values[0].no;\n                break;\n            case \"message\":\n                val = new field.V.T();\n                break;\n        }\n    }\n    return [\n        key,\n        val\n    ];\n}\n// Read a scalar value, but return 64 bit integral types (int64, uint64,\n// sint64, fixed64, sfixed64) as string instead of bigint.\nfunction readScalarLTString(reader, type) {\n    const v = readScalar(reader, type);\n    return typeof v == \"bigint\" ? v.toString() : v;\n}\n// Does not use scalarTypeInfo() for better performance.\nfunction readScalar(reader, type) {\n    switch(type){\n        case ScalarType.STRING:\n            return reader.string();\n        case ScalarType.BOOL:\n            return reader.bool();\n        case ScalarType.DOUBLE:\n            return reader.double();\n        case ScalarType.FLOAT:\n            return reader.float();\n        case ScalarType.INT32:\n            return reader.int32();\n        case ScalarType.INT64:\n            return reader.int64();\n        case ScalarType.UINT64:\n            return reader.uint64();\n        case ScalarType.FIXED64:\n            return reader.fixed64();\n        case ScalarType.BYTES:\n            return reader.bytes();\n        case ScalarType.FIXED32:\n            return reader.fixed32();\n        case ScalarType.SFIXED32:\n            return reader.sfixed32();\n        case ScalarType.SFIXED64:\n            return reader.sfixed64();\n        case ScalarType.SINT64:\n            return reader.sint64();\n        case ScalarType.UINT32:\n            return reader.uint32();\n        case ScalarType.SINT32:\n            return reader.sint32();\n    }\n}\nfunction writeField(field, value, writer, options) {\n    assert(value !== undefined);\n    const repeated = field.repeated;\n    switch(field.kind){\n        case \"scalar\":\n        case \"enum\":\n            let scalarType = field.kind == \"enum\" ? ScalarType.INT32 : field.T;\n            if (repeated) {\n                assert(Array.isArray(value));\n                if (field.packed) {\n                    writePacked(writer, scalarType, field.no, value);\n                } else {\n                    for (const item of value){\n                        writeScalar(writer, scalarType, field.no, item);\n                    }\n                }\n            } else {\n                writeScalar(writer, scalarType, field.no, value);\n            }\n            break;\n        case \"message\":\n            if (repeated) {\n                assert(Array.isArray(value));\n                for (const item of value){\n                    writeMessageField(writer, options, field, item);\n                }\n            } else {\n                writeMessageField(writer, options, field, value);\n            }\n            break;\n        case \"map\":\n            assert(typeof value == \"object\" && value != null);\n            for (const [key, val] of Object.entries(value)){\n                writeMapEntry(writer, options, field, key, val);\n            }\n            break;\n    }\n}\nfunction writeMapEntry(writer, options, field, key, value) {\n    writer.tag(field.no, WireType.LengthDelimited);\n    writer.fork();\n    // javascript only allows number or string for object properties\n    // we convert from our representation to the protobuf type\n    let keyValue = key;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- we deliberately handle just the special cases for map keys\n    switch(field.K){\n        case ScalarType.INT32:\n        case ScalarType.FIXED32:\n        case ScalarType.UINT32:\n        case ScalarType.SFIXED32:\n        case ScalarType.SINT32:\n            keyValue = Number.parseInt(key);\n            break;\n        case ScalarType.BOOL:\n            assert(key == \"true\" || key == \"false\");\n            keyValue = key == \"true\";\n            break;\n    }\n    // write key, expecting key field number = 1\n    writeScalar(writer, field.K, 1, keyValue);\n    // write value, expecting value field number = 2\n    switch(field.V.kind){\n        case \"scalar\":\n            writeScalar(writer, field.V.T, 2, value);\n            break;\n        case \"enum\":\n            writeScalar(writer, ScalarType.INT32, 2, value);\n            break;\n        case \"message\":\n            assert(value !== undefined);\n            writer.tag(2, WireType.LengthDelimited).bytes(value.toBinary(options));\n            break;\n    }\n    writer.join();\n}\n// Value must not be undefined\nfunction writeMessageField(writer, options, field, value) {\n    const message = wrapField(field.T, value);\n    // eslint-disable-next-line @typescript-eslint/strict-boolean-expressions\n    if (field.delimited) writer.tag(field.no, WireType.StartGroup).raw(message.toBinary(options)).tag(field.no, WireType.EndGroup);\n    else writer.tag(field.no, WireType.LengthDelimited).bytes(message.toBinary(options));\n}\nfunction writeScalar(writer, type, fieldNo, value) {\n    assert(value !== undefined);\n    let [wireType, method] = scalarTypeInfo(type);\n    writer.tag(fieldNo, wireType)[method](value);\n}\nfunction writePacked(writer, type, fieldNo, value) {\n    if (!value.length) {\n        return;\n    }\n    writer.tag(fieldNo, WireType.LengthDelimited).fork();\n    let [, method] = scalarTypeInfo(type);\n    for(let i = 0; i < value.length; i++){\n        writer[method](value[i]);\n    }\n    writer.join();\n}\n/**\n * Get information for writing a scalar value.\n *\n * Returns tuple:\n * [0]: appropriate WireType\n * [1]: name of the appropriate method of IBinaryWriter\n * [2]: whether the given value is a default value for proto3 semantics\n *\n * If argument `value` is omitted, [2] is always false.\n */ // TODO replace call-sites writeScalar() and writePacked(), then remove\nfunction scalarTypeInfo(type) {\n    let wireType = WireType.Varint;\n    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- INT32, UINT32, SINT32 are covered by the defaults\n    switch(type){\n        case ScalarType.BYTES:\n        case ScalarType.STRING:\n            wireType = WireType.LengthDelimited;\n            break;\n        case ScalarType.DOUBLE:\n        case ScalarType.FIXED64:\n        case ScalarType.SFIXED64:\n            wireType = WireType.Bit64;\n            break;\n        case ScalarType.FIXED32:\n        case ScalarType.SFIXED32:\n        case ScalarType.FLOAT:\n            wireType = WireType.Bit32;\n            break;\n    }\n    const method = ScalarType[type].toLowerCase();\n    return [\n        wireType,\n        method\n    ];\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/* eslint-disable @typescript-eslint/no-explicit-any,@typescript-eslint/no-unsafe-assignment,@typescript-eslint/no-unsafe-member-access,@typescript-eslint/no-unsafe-return,@typescript-eslint/no-unsafe-argument,no-case-declarations */ function makeUtilCommon() {\n    return {\n        setEnumType,\n        initPartial (source, target) {\n            if (source === undefined) {\n                return;\n            }\n            const type = target.getType();\n            for (const member of type.fields.byMember()){\n                const localName = member.localName, t = target, s = source;\n                if (s[localName] == null) {\n                    continue;\n                }\n                switch(member.kind){\n                    case \"oneof\":\n                        const sk = s[localName].case;\n                        if (sk === undefined) {\n                            continue;\n                        }\n                        const sourceField = member.findField(sk);\n                        let val = s[localName].value;\n                        if (sourceField && sourceField.kind == \"message\" && !isMessage(val, sourceField.T)) {\n                            val = new sourceField.T(val);\n                        } else if (sourceField && sourceField.kind === \"scalar\" && sourceField.T === ScalarType.BYTES) {\n                            val = toU8Arr(val);\n                        }\n                        t[localName] = {\n                            case: sk,\n                            value: val\n                        };\n                        break;\n                    case \"scalar\":\n                    case \"enum\":\n                        let copy = s[localName];\n                        if (member.T === ScalarType.BYTES) {\n                            copy = member.repeated ? copy.map(toU8Arr) : toU8Arr(copy);\n                        }\n                        t[localName] = copy;\n                        break;\n                    case \"map\":\n                        switch(member.V.kind){\n                            case \"scalar\":\n                            case \"enum\":\n                                if (member.V.T === ScalarType.BYTES) {\n                                    for (const [k, v] of Object.entries(s[localName])){\n                                        t[localName][k] = toU8Arr(v);\n                                    }\n                                } else {\n                                    Object.assign(t[localName], s[localName]);\n                                }\n                                break;\n                            case \"message\":\n                                const messageType = member.V.T;\n                                for (const k of Object.keys(s[localName])){\n                                    let val = s[localName][k];\n                                    if (!messageType.fieldWrapper) {\n                                        // We only take partial input for messages that are not a wrapper type.\n                                        // For those messages, we recursively normalize the partial input.\n                                        val = new messageType(val);\n                                    }\n                                    t[localName][k] = val;\n                                }\n                                break;\n                        }\n                        break;\n                    case \"message\":\n                        const mt = member.T;\n                        if (member.repeated) {\n                            t[localName] = s[localName].map((val)=>isMessage(val, mt) ? val : new mt(val));\n                        } else {\n                            const val = s[localName];\n                            if (mt.fieldWrapper) {\n                                if (// We can't use BytesValue.typeName as that will create a circular import\n                                mt.typeName === \"google.protobuf.BytesValue\") {\n                                    t[localName] = toU8Arr(val);\n                                } else {\n                                    t[localName] = val;\n                                }\n                            } else {\n                                t[localName] = isMessage(val, mt) ? val : new mt(val);\n                            }\n                        }\n                        break;\n                }\n            }\n        },\n        // TODO use isFieldSet() here to support future field presence\n        equals (type, a, b) {\n            if (a === b) {\n                return true;\n            }\n            if (!a || !b) {\n                return false;\n            }\n            return type.fields.byMember().every((m)=>{\n                const va = a[m.localName];\n                const vb = b[m.localName];\n                if (m.repeated) {\n                    if (va.length !== vb.length) {\n                        return false;\n                    }\n                    // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- repeated fields are never \"map\"\n                    switch(m.kind){\n                        case \"message\":\n                            return va.every((a, i)=>m.T.equals(a, vb[i]));\n                        case \"scalar\":\n                            return va.every((a, i)=>scalarEquals(m.T, a, vb[i]));\n                        case \"enum\":\n                            return va.every((a, i)=>scalarEquals(ScalarType.INT32, a, vb[i]));\n                    }\n                    throw new Error(\"repeated cannot contain \".concat(m.kind));\n                }\n                switch(m.kind){\n                    case \"message\":\n                        return m.T.equals(va, vb);\n                    case \"enum\":\n                        return scalarEquals(ScalarType.INT32, va, vb);\n                    case \"scalar\":\n                        return scalarEquals(m.T, va, vb);\n                    case \"oneof\":\n                        if (va.case !== vb.case) {\n                            return false;\n                        }\n                        const s = m.findField(va.case);\n                        if (s === undefined) {\n                            return true;\n                        }\n                        // eslint-disable-next-line @typescript-eslint/switch-exhaustiveness-check -- oneof fields are never \"map\"\n                        switch(s.kind){\n                            case \"message\":\n                                return s.T.equals(va.value, vb.value);\n                            case \"enum\":\n                                return scalarEquals(ScalarType.INT32, va.value, vb.value);\n                            case \"scalar\":\n                                return scalarEquals(s.T, va.value, vb.value);\n                        }\n                        throw new Error(\"oneof cannot contain \".concat(s.kind));\n                    case \"map\":\n                        const keys = Object.keys(va).concat(Object.keys(vb));\n                        switch(m.V.kind){\n                            case \"message\":\n                                const messageType = m.V.T;\n                                return keys.every((k)=>messageType.equals(va[k], vb[k]));\n                            case \"enum\":\n                                return keys.every((k)=>scalarEquals(ScalarType.INT32, va[k], vb[k]));\n                            case \"scalar\":\n                                const scalarType = m.V.T;\n                                return keys.every((k)=>scalarEquals(scalarType, va[k], vb[k]));\n                        }\n                        break;\n                }\n            });\n        },\n        // TODO use isFieldSet() here to support future field presence\n        clone (message) {\n            const type = message.getType(), target = new type(), any = target;\n            for (const member of type.fields.byMember()){\n                const source = message[member.localName];\n                let copy;\n                if (member.repeated) {\n                    copy = source.map(cloneSingularField);\n                } else if (member.kind == \"map\") {\n                    copy = any[member.localName];\n                    for (const [key, v] of Object.entries(source)){\n                        copy[key] = cloneSingularField(v);\n                    }\n                } else if (member.kind == \"oneof\") {\n                    const f = member.findField(source.case);\n                    copy = f ? {\n                        case: source.case,\n                        value: cloneSingularField(source.value)\n                    } : {\n                        case: undefined\n                    };\n                } else {\n                    copy = cloneSingularField(source);\n                }\n                any[member.localName] = copy;\n            }\n            for (const uf of type.runtime.bin.listUnknownFields(message)){\n                type.runtime.bin.onUnknownField(any, uf.no, uf.wireType, uf.data);\n            }\n            return target;\n        }\n    };\n}\n// clone a single field value - i.e. the element type of repeated fields, the value type of maps\nfunction cloneSingularField(value) {\n    if (value === undefined) {\n        return value;\n    }\n    if (isMessage(value)) {\n        return value.clone();\n    }\n    if (value instanceof Uint8Array) {\n        const c = new Uint8Array(value.byteLength);\n        c.set(value);\n        return c;\n    }\n    return value;\n}\n// converts any ArrayLike<number> to Uint8Array if necessary.\nfunction toU8Arr(input) {\n    return input instanceof Uint8Array ? input : new Uint8Array(input);\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nfunction makeProtoRuntime(syntax, newFieldList, initFields) {\n    return {\n        syntax,\n        json: makeJsonFormat(),\n        bin: makeBinaryFormat(),\n        util: Object.assign(Object.assign({}, makeUtilCommon()), {\n            newFieldList,\n            initFields\n        }),\n        makeMessageType (typeName, fields, opt) {\n            return makeMessageType(this, typeName, fields, opt);\n        },\n        makeEnum,\n        makeEnumType,\n        getEnumType,\n        makeExtension (typeName, extendee, field) {\n            return makeExtension(this, typeName, extendee, field);\n        }\n    };\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalFieldList {\n    constructor(fields, normalizer){\n        this._fields = fields;\n        this._normalizer = normalizer;\n    }\n    findJsonName(jsonName) {\n        if (!this.jsonNames) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.jsonName] = t[f.name] = f;\n            }\n            this.jsonNames = t;\n        }\n        return this.jsonNames[jsonName];\n    }\n    find(fieldNo) {\n        if (!this.numbers) {\n            const t = {};\n            for (const f of this.list()){\n                t[f.no] = f;\n            }\n            this.numbers = t;\n        }\n        return this.numbers[fieldNo];\n    }\n    list() {\n        if (!this.all) {\n            this.all = this._normalizer(this._fields);\n        }\n        return this.all;\n    }\n    byNumber() {\n        if (!this.numbersAsc) {\n            this.numbersAsc = this.list().concat().sort((a, b)=>a.no - b.no);\n        }\n        return this.numbersAsc;\n    }\n    byMember() {\n        if (!this.members) {\n            this.members = [];\n            const a = this.members;\n            let o;\n            for (const f of this.list()){\n                if (f.oneof) {\n                    if (f.oneof !== o) {\n                        o = f.oneof;\n                        a.push(o);\n                    }\n                } else {\n                    a.push(f);\n                }\n            }\n        }\n        return this.members;\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Returns the name of a protobuf element in generated code.\n *\n * Field names - including oneofs - are converted to lowerCamelCase. For\n * messages, enumerations and services, the package name is stripped from\n * the type name. For nested messages and enumerations, the names are joined\n * with an underscore. For methods, the first character is made lowercase.\n */ /**\n * Returns the name of a field in generated code.\n */ function localFieldName(protoName, inOneof) {\n    const name = protoCamelCase(protoName);\n    if (inOneof) {\n        // oneof member names are not properties, but values of the `case` property.\n        return name;\n    }\n    return safeObjectProperty(safeMessageProperty(name));\n}\n/**\n * Returns the name of a oneof group in generated code.\n */ function localOneofName(protoName) {\n    return localFieldName(protoName, false);\n}\n/**\n * Returns the JSON name for a protobuf field, exactly like protoc does.\n */ const fieldJsonName = protoCamelCase;\n/**\n * Converts snake_case to protoCamelCase according to the convention\n * used by protoc to convert a field name to a JSON name.\n */ function protoCamelCase(snakeCase) {\n    let capNext = false;\n    const b = [];\n    for(let i = 0; i < snakeCase.length; i++){\n        let c = snakeCase.charAt(i);\n        switch(c){\n            case \"_\":\n                capNext = true;\n                break;\n            case \"0\":\n            case \"1\":\n            case \"2\":\n            case \"3\":\n            case \"4\":\n            case \"5\":\n            case \"6\":\n            case \"7\":\n            case \"8\":\n            case \"9\":\n                b.push(c);\n                capNext = false;\n                break;\n            default:\n                if (capNext) {\n                    capNext = false;\n                    c = c.toUpperCase();\n                }\n                b.push(c);\n                break;\n        }\n    }\n    return b.join(\"\");\n}\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const reservedObjectProperties = new Set([\n    // names reserved by JavaScript\n    \"constructor\",\n    \"toString\",\n    \"toJSON\",\n    \"valueOf\"\n]);\n/**\n * Names that cannot be used for object properties because they are reserved\n * by the runtime.\n */ const reservedMessageProperties = new Set([\n    // names reserved by the runtime\n    \"getType\",\n    \"clone\",\n    \"equals\",\n    \"fromBinary\",\n    \"fromJson\",\n    \"fromJsonString\",\n    \"toBinary\",\n    \"toJson\",\n    \"toJsonString\",\n    // names reserved by the runtime for the future\n    \"toObject\"\n]);\nconst fallback = (name)=>\"\".concat(name, \"$\");\n/**\n * Will wrap names that are Object prototype properties or names reserved\n * for `Message`s.\n */ const safeMessageProperty = (name)=>{\n    if (reservedMessageProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n/**\n * Names that cannot be used for object properties because they are reserved\n * by built-in JavaScript properties.\n */ const safeObjectProperty = (name)=>{\n    if (reservedObjectProperties.has(name)) {\n        return fallback(name);\n    }\n    return name;\n};\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nclass InternalOneofInfo {\n    constructor(name){\n        this.kind = \"oneof\";\n        this.repeated = false;\n        this.packed = false;\n        this.opt = false;\n        this.req = false;\n        this.default = undefined;\n        this.fields = [];\n        this.name = name;\n        this.localName = localOneofName(name);\n    }\n    addField(field) {\n        assert(field.oneof === this, \"field \".concat(field.name, \" not one of \").concat(this.name));\n        this.fields.push(field);\n    }\n    findField(localName) {\n        if (!this._lookup) {\n            this._lookup = Object.create(null);\n            for(let i = 0; i < this.fields.length; i++){\n                this._lookup[this.fields[i].localName] = this.fields[i];\n            }\n        }\n        return this._lookup[localName];\n    }\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Convert a collection of field info to an array of normalized FieldInfo.\n *\n * The argument `packedByDefault` specifies whether fields that do not specify\n * `packed` should be packed (proto3) or unpacked (proto2).\n */ function normalizeFieldInfos(fieldInfos, packedByDefault) {\n    var _a, _b, _c, _d, _e, _f;\n    const r = [];\n    let o;\n    for (const field of typeof fieldInfos == \"function\" ? fieldInfos() : fieldInfos){\n        const f = field;\n        f.localName = localFieldName(field.name, field.oneof !== undefined);\n        f.jsonName = (_a = field.jsonName) !== null && _a !== void 0 ? _a : fieldJsonName(field.name);\n        f.repeated = (_b = field.repeated) !== null && _b !== void 0 ? _b : false;\n        if (field.kind == \"scalar\") {\n            f.L = (_c = field.L) !== null && _c !== void 0 ? _c : LongType.BIGINT;\n        }\n        f.delimited = (_d = field.delimited) !== null && _d !== void 0 ? _d : false;\n        f.req = (_e = field.req) !== null && _e !== void 0 ? _e : false;\n        f.opt = (_f = field.opt) !== null && _f !== void 0 ? _f : false;\n        if (field.packed === undefined) {\n            {\n                f.packed = field.kind == \"enum\" || field.kind == \"scalar\" && field.T != ScalarType.BYTES && field.T != ScalarType.STRING;\n            }\n        }\n        // We do not surface options at this time\n        // f.options = field.options ?? emptyReadonlyObject;\n        if (field.oneof !== undefined) {\n            const ooname = typeof field.oneof == \"string\" ? field.oneof : field.oneof.name;\n            if (!o || o.name != ooname) {\n                o = new InternalOneofInfo(ooname);\n            }\n            f.oneof = o;\n            o.addField(f);\n        }\n        r.push(f);\n    }\n    return r;\n}\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * Provides functionality for messages defined with the proto3 syntax.\n */ const proto3 = makeProtoRuntime(\"proto3\", (fields)=>{\n    return new InternalFieldList(fields, (source)=>normalizeFieldInfos(source));\n}, // TODO merge with proto2 and initExtensionField, also see initPartial, equals, clone\n(target)=>{\n    for (const member of target.getType().fields.byMember()){\n        if (member.opt) {\n            continue;\n        }\n        const name = member.localName, t = target;\n        if (member.repeated) {\n            t[name] = [];\n            continue;\n        }\n        switch(member.kind){\n            case \"oneof\":\n                t[name] = {\n                    case: undefined\n                };\n                break;\n            case \"enum\":\n                t[name] = 0;\n                break;\n            case \"map\":\n                t[name] = {};\n                break;\n            case \"scalar\":\n                t[name] = scalarZeroValue(member.T, member.L);\n                break;\n        }\n    }\n});\n// Copyright 2021-2024 Buf Technologies, Inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n/**\n * A Timestamp represents a point in time independent of any time zone or local\n * calendar, encoded as a count of seconds and fractions of seconds at\n * nanosecond resolution. The count is relative to an epoch at UTC midnight on\n * January 1, 1970, in the proleptic Gregorian calendar which extends the\n * Gregorian calendar backwards to year one.\n *\n * All minutes are 60 seconds long. Leap seconds are \"smeared\" so that no leap\n * second table is needed for interpretation, using a [24-hour linear\n * smear](https://developers.google.com/time/smear).\n *\n * The range is from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59.999999999Z. By\n * restricting to that range, we ensure that we can convert to and from [RFC\n * 3339](https://www.ietf.org/rfc/rfc3339.txt) date strings.\n *\n * # Examples\n *\n * Example 1: Compute Timestamp from POSIX `time()`.\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(time(NULL));\n *     timestamp.set_nanos(0);\n *\n * Example 2: Compute Timestamp from POSIX `gettimeofday()`.\n *\n *     struct timeval tv;\n *     gettimeofday(&tv, NULL);\n *\n *     Timestamp timestamp;\n *     timestamp.set_seconds(tv.tv_sec);\n *     timestamp.set_nanos(tv.tv_usec * 1000);\n *\n * Example 3: Compute Timestamp from Win32 `GetSystemTimeAsFileTime()`.\n *\n *     FILETIME ft;\n *     GetSystemTimeAsFileTime(&ft);\n *     UINT64 ticks = (((UINT64)ft.dwHighDateTime) << 32) | ft.dwLowDateTime;\n *\n *     // A Windows tick is 100 nanoseconds. Windows epoch 1601-01-01T00:00:00Z\n *     // is 11644473600 seconds before Unix epoch 1970-01-01T00:00:00Z.\n *     Timestamp timestamp;\n *     timestamp.set_seconds((INT64) ((ticks / 10000000) - 11644473600LL));\n *     timestamp.set_nanos((INT32) ((ticks % 10000000) * 100));\n *\n * Example 4: Compute Timestamp from Java `System.currentTimeMillis()`.\n *\n *     long millis = System.currentTimeMillis();\n *\n *     Timestamp timestamp = Timestamp.newBuilder().setSeconds(millis / 1000)\n *         .setNanos((int) ((millis % 1000) * 1000000)).build();\n *\n * Example 5: Compute Timestamp from Java `Instant.now()`.\n *\n *     Instant now = Instant.now();\n *\n *     Timestamp timestamp =\n *         Timestamp.newBuilder().setSeconds(now.getEpochSecond())\n *             .setNanos(now.getNano()).build();\n *\n * Example 6: Compute Timestamp from current time in Python.\n *\n *     timestamp = Timestamp()\n *     timestamp.GetCurrentTime()\n *\n * # JSON Mapping\n *\n * In JSON format, the Timestamp type is encoded as a string in the\n * [RFC 3339](https://www.ietf.org/rfc/rfc3339.txt) format. That is, the\n * format is \"{year}-{month}-{day}T{hour}:{min}:{sec}[.{frac_sec}]Z\"\n * where {year} is always expressed using four digits while {month}, {day},\n * {hour}, {min}, and {sec} are zero-padded to two digits each. The fractional\n * seconds, which can go up to 9 digits (i.e. up to 1 nanosecond resolution),\n * are optional. The \"Z\" suffix indicates the timezone (\"UTC\"); the timezone\n * is required. A proto3 JSON serializer should always use UTC (as indicated by\n * \"Z\") when printing the Timestamp type and a proto3 JSON parser should be\n * able to accept both UTC and other timezones (as indicated by an offset).\n *\n * For example, \"2017-01-15T01:30:15.01Z\" encodes 15.01 seconds past\n * 01:30 UTC on January 15, 2017.\n *\n * In JavaScript, one can convert a Date object to this format using the\n * standard\n * [toISOString()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString)\n * method. In Python, a standard `datetime.datetime` object can be converted\n * to this format using\n * [`strftime`](https://docs.python.org/2/library/time.html#time.strftime) with\n * the time format spec '%Y-%m-%dT%H:%M:%S.%fZ'. Likewise, in Java, one can use\n * the Joda Time's [`ISODateTimeFormat.dateTime()`](\n * http://joda-time.sourceforge.net/apidocs/org/joda/time/format/ISODateTimeFormat.html#dateTime()\n * ) to obtain a formatter capable of generating timestamps in this format.\n *\n *\n * @generated from message google.protobuf.Timestamp\n */ class Timestamp extends Message {\n    constructor(data){\n        super();\n        /**\n     * Represents seconds of UTC time since Unix epoch\n     * 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to\n     * 9999-12-31T23:59:59Z inclusive.\n     *\n     * @generated from field: int64 seconds = 1;\n     */ this.seconds = protoInt64.zero;\n        /**\n     * Non-negative fractions of a second at nanosecond resolution. Negative\n     * second values with fractions must still have non-negative nanos values\n     * that count forward in time. Must be from 0 to 999,999,999\n     * inclusive.\n     *\n     * @generated from field: int32 nanos = 2;\n     */ this.nanos = 0;\n        proto3.util.initPartial(data, this);\n    }\n    fromJson(json, options) {\n        if (typeof json !== \"string\") {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: \".concat(proto3.json.debug(json)));\n        }\n        const matches = json.match(/^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2}):([0-9]{2})(?:Z|\\.([0-9]{3,9})Z|([+-][0-9][0-9]:[0-9][0-9]))$/);\n        if (!matches) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        const ms = Date.parse(matches[1] + \"-\" + matches[2] + \"-\" + matches[3] + \"T\" + matches[4] + \":\" + matches[5] + \":\" + matches[6] + (matches[8] ? matches[8] : \"Z\"));\n        if (Number.isNaN(ms)) {\n            throw new Error(\"cannot decode google.protobuf.Timestamp from JSON: invalid RFC 3339 string\");\n        }\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot decode message google.protobuf.Timestamp from JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        this.seconds = protoInt64.parse(ms / 1000);\n        this.nanos = 0;\n        if (matches[7]) {\n            this.nanos = parseInt(\"1\" + matches[7] + \"0\".repeat(9 - matches[7].length)) - 1000000000;\n        }\n        return this;\n    }\n    toJson(options) {\n        const ms = Number(this.seconds) * 1000;\n        if (ms < Date.parse(\"0001-01-01T00:00:00Z\") || ms > Date.parse(\"9999-12-31T23:59:59Z\")) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: must be from 0001-01-01T00:00:00Z to 9999-12-31T23:59:59Z inclusive\");\n        }\n        if (this.nanos < 0) {\n            throw new Error(\"cannot encode google.protobuf.Timestamp to JSON: nanos must not be negative\");\n        }\n        let z = \"Z\";\n        if (this.nanos > 0) {\n            const nanosStr = (this.nanos + 1000000000).toString().substring(1);\n            if (nanosStr.substring(3) === \"000000\") {\n                z = \".\" + nanosStr.substring(0, 3) + \"Z\";\n            } else if (nanosStr.substring(6) === \"000\") {\n                z = \".\" + nanosStr.substring(0, 6) + \"Z\";\n            } else {\n                z = \".\" + nanosStr + \"Z\";\n            }\n        }\n        return new Date(ms).toISOString().replace(\".000Z\", z);\n    }\n    toDate() {\n        return new Date(Number(this.seconds) * 1000 + Math.ceil(this.nanos / 1000000));\n    }\n    static now() {\n        return Timestamp.fromDate(new Date());\n    }\n    static fromDate(date) {\n        const ms = date.getTime();\n        return new Timestamp({\n            seconds: protoInt64.parse(Math.floor(ms / 1000)),\n            nanos: ms % 1000 * 1000000\n        });\n    }\n    static fromBinary(bytes, options) {\n        return new Timestamp().fromBinary(bytes, options);\n    }\n    static fromJson(jsonValue, options) {\n        return new Timestamp().fromJson(jsonValue, options);\n    }\n    static fromJsonString(jsonString, options) {\n        return new Timestamp().fromJsonString(jsonString, options);\n    }\n    static equals(a, b) {\n        return proto3.util.equals(Timestamp, a, b);\n    }\n}\nTimestamp.runtime = proto3;\nTimestamp.typeName = \"google.protobuf.Timestamp\";\nTimestamp.fields = proto3.util.newFieldList(()=>[\n        {\n            no: 1,\n            name: \"seconds\",\n            kind: \"scalar\",\n            T: 3 /* ScalarType.INT64 */ \n        },\n        {\n            no: 2,\n            name: \"nanos\",\n            kind: \"scalar\",\n            T: 5 /* ScalarType.INT32 */ \n        }\n    ]);\nconst MetricsBatch = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MetricsBatch\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"normalized_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"str_data\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"time_series\",\n            kind: \"message\",\n            T: TimeSeriesMetric,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"events\",\n            kind: \"message\",\n            T: EventMetric,\n            repeated: true\n        }\n    ]);\nconst TimeSeriesMetric = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TimeSeriesMetric\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"samples\",\n            kind: \"message\",\n            T: MetricSample,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"rid\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst MetricSample = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MetricSample\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"normalized_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 3,\n            name: \"value\",\n            kind: \"scalar\",\n            T: 2\n        }\n    ]);\nconst EventMetric = /* @__PURE__ */ proto3.makeMessageType(\"livekit.EventMetric\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"start_timestamp_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 5,\n            name: \"end_timestamp_ms\",\n            kind: \"scalar\",\n            T: 3,\n            opt: true\n        },\n        {\n            no: 6,\n            name: \"normalized_start_timestamp\",\n            kind: \"message\",\n            T: Timestamp\n        },\n        {\n            no: 7,\n            name: \"normalized_end_timestamp\",\n            kind: \"message\",\n            T: Timestamp,\n            opt: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"rid\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst BackupCodecPolicy$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.BackupCodecPolicy\", [\n    {\n        no: 0,\n        name: \"PREFER_REGRESSION\"\n    },\n    {\n        no: 1,\n        name: \"SIMULCAST\"\n    },\n    {\n        no: 2,\n        name: \"REGRESSION\"\n    }\n]);\nconst TrackType = /* @__PURE__ */ proto3.makeEnum(\"livekit.TrackType\", [\n    {\n        no: 0,\n        name: \"AUDIO\"\n    },\n    {\n        no: 1,\n        name: \"VIDEO\"\n    },\n    {\n        no: 2,\n        name: \"DATA\"\n    }\n]);\nconst TrackSource = /* @__PURE__ */ proto3.makeEnum(\"livekit.TrackSource\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"CAMERA\"\n    },\n    {\n        no: 2,\n        name: \"MICROPHONE\"\n    },\n    {\n        no: 3,\n        name: \"SCREEN_SHARE\"\n    },\n    {\n        no: 4,\n        name: \"SCREEN_SHARE_AUDIO\"\n    }\n]);\nconst VideoQuality$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.VideoQuality\", [\n    {\n        no: 0,\n        name: \"LOW\"\n    },\n    {\n        no: 1,\n        name: \"MEDIUM\"\n    },\n    {\n        no: 2,\n        name: \"HIGH\"\n    },\n    {\n        no: 3,\n        name: \"OFF\"\n    }\n]);\nconst ConnectionQuality$1 = /* @__PURE__ */ proto3.makeEnum(\"livekit.ConnectionQuality\", [\n    {\n        no: 0,\n        name: \"POOR\"\n    },\n    {\n        no: 1,\n        name: \"GOOD\"\n    },\n    {\n        no: 2,\n        name: \"EXCELLENT\"\n    },\n    {\n        no: 3,\n        name: \"LOST\"\n    }\n]);\nconst ClientConfigSetting = /* @__PURE__ */ proto3.makeEnum(\"livekit.ClientConfigSetting\", [\n    {\n        no: 0,\n        name: \"UNSET\"\n    },\n    {\n        no: 1,\n        name: \"DISABLED\"\n    },\n    {\n        no: 2,\n        name: \"ENABLED\"\n    }\n]);\nconst DisconnectReason = /* @__PURE__ */ proto3.makeEnum(\"livekit.DisconnectReason\", [\n    {\n        no: 0,\n        name: \"UNKNOWN_REASON\"\n    },\n    {\n        no: 1,\n        name: \"CLIENT_INITIATED\"\n    },\n    {\n        no: 2,\n        name: \"DUPLICATE_IDENTITY\"\n    },\n    {\n        no: 3,\n        name: \"SERVER_SHUTDOWN\"\n    },\n    {\n        no: 4,\n        name: \"PARTICIPANT_REMOVED\"\n    },\n    {\n        no: 5,\n        name: \"ROOM_DELETED\"\n    },\n    {\n        no: 6,\n        name: \"STATE_MISMATCH\"\n    },\n    {\n        no: 7,\n        name: \"JOIN_FAILURE\"\n    },\n    {\n        no: 8,\n        name: \"MIGRATION\"\n    },\n    {\n        no: 9,\n        name: \"SIGNAL_CLOSE\"\n    },\n    {\n        no: 10,\n        name: \"ROOM_CLOSED\"\n    },\n    {\n        no: 11,\n        name: \"USER_UNAVAILABLE\"\n    },\n    {\n        no: 12,\n        name: \"USER_REJECTED\"\n    },\n    {\n        no: 13,\n        name: \"SIP_TRUNK_FAILURE\"\n    }\n]);\nconst ReconnectReason = /* @__PURE__ */ proto3.makeEnum(\"livekit.ReconnectReason\", [\n    {\n        no: 0,\n        name: \"RR_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"RR_SIGNAL_DISCONNECTED\"\n    },\n    {\n        no: 2,\n        name: \"RR_PUBLISHER_FAILED\"\n    },\n    {\n        no: 3,\n        name: \"RR_SUBSCRIBER_FAILED\"\n    },\n    {\n        no: 4,\n        name: \"RR_SWITCH_CANDIDATE\"\n    }\n]);\nconst SubscriptionError = /* @__PURE__ */ proto3.makeEnum(\"livekit.SubscriptionError\", [\n    {\n        no: 0,\n        name: \"SE_UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"SE_CODEC_UNSUPPORTED\"\n    },\n    {\n        no: 2,\n        name: \"SE_TRACK_NOTFOUND\"\n    }\n]);\nconst AudioTrackFeature = /* @__PURE__ */ proto3.makeEnum(\"livekit.AudioTrackFeature\", [\n    {\n        no: 0,\n        name: \"TF_STEREO\"\n    },\n    {\n        no: 1,\n        name: \"TF_NO_DTX\"\n    },\n    {\n        no: 2,\n        name: \"TF_AUTO_GAIN_CONTROL\"\n    },\n    {\n        no: 3,\n        name: \"TF_ECHO_CANCELLATION\"\n    },\n    {\n        no: 4,\n        name: \"TF_NOISE_SUPPRESSION\"\n    },\n    {\n        no: 5,\n        name: \"TF_ENHANCED_NOISE_CANCELLATION\"\n    }\n]);\nconst Room$1 = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Room\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"empty_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 14,\n            name: \"departure_timeout\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"max_participants\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"creation_time\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 15,\n            name: \"creation_time_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 6,\n            name: \"turn_password\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"enabled_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 8,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"num_participants\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 11,\n            name: \"num_publishers\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 10,\n            name: \"active_recording\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 13,\n            name: \"version\",\n            kind: \"message\",\n            T: TimedVersion\n        }\n    ]);\nconst Codec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Codec\", ()=>[\n        {\n            no: 1,\n            name: \"mime\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"fmtp_line\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantPermission\", ()=>[\n        {\n            no: 1,\n            name: \"can_subscribe\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"can_publish\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"can_publish_data\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 9,\n            name: \"can_publish_sources\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource),\n            repeated: true\n        },\n        {\n            no: 7,\n            name: \"hidden\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"recorder\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 10,\n            name: \"can_update_metadata\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 11,\n            name: \"agent\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 12,\n            name: \"can_subscribe_metrics\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst ParticipantInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_State)\n        },\n        {\n            no: 4,\n            name: \"tracks\",\n            kind: \"message\",\n            T: TrackInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"joined_at\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 17,\n            name: \"joined_at_ms\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 9,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 11,\n            name: \"permission\",\n            kind: \"message\",\n            T: ParticipantPermission\n        },\n        {\n            no: 12,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 13,\n            name: \"is_publisher\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 14,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_Kind)\n        },\n        {\n            no: 15,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 16,\n            name: \"disconnect_reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        },\n        {\n            no: 18,\n            name: \"kind_details\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ParticipantInfo_KindDetail),\n            repeated: true\n        }\n    ]);\nconst ParticipantInfo_State = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.State\", [\n    {\n        no: 0,\n        name: \"JOINING\"\n    },\n    {\n        no: 1,\n        name: \"JOINED\"\n    },\n    {\n        no: 2,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 3,\n        name: \"DISCONNECTED\"\n    }\n]);\nconst ParticipantInfo_Kind = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.Kind\", [\n    {\n        no: 0,\n        name: \"STANDARD\"\n    },\n    {\n        no: 1,\n        name: \"INGRESS\"\n    },\n    {\n        no: 2,\n        name: \"EGRESS\"\n    },\n    {\n        no: 3,\n        name: \"SIP\"\n    },\n    {\n        no: 4,\n        name: \"AGENT\"\n    }\n]);\nconst ParticipantInfo_KindDetail = /* @__PURE__ */ proto3.makeEnum(\"livekit.ParticipantInfo.KindDetail\", [\n    {\n        no: 0,\n        name: \"CLOUD_AGENT\"\n    },\n    {\n        no: 1,\n        name: \"FORWARDED\"\n    }\n]);\nconst Encryption_Type = /* @__PURE__ */ proto3.makeEnum(\"livekit.Encryption.Type\", [\n    {\n        no: 0,\n        name: \"NONE\"\n    },\n    {\n        no: 1,\n        name: \"GCM\"\n    },\n    {\n        no: 2,\n        name: \"CUSTOM\"\n    }\n]);\nconst SimulcastCodecInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulcastCodecInfo\", ()=>[\n        {\n            no: 1,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\nconst TrackInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 3,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 7,\n            name: \"simulcast\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 9,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 10,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 12,\n            name: \"mid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 13,\n            name: \"codecs\",\n            kind: \"message\",\n            T: SimulcastCodecInfo,\n            repeated: true\n        },\n        {\n            no: 14,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 15,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 16,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 17,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 18,\n            name: \"version\",\n            kind: \"message\",\n            T: TimedVersion\n        },\n        {\n            no: 19,\n            name: \"audio_features\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioTrackFeature),\n            repeated: true\n        },\n        {\n            no: 20,\n            name: \"backup_codec_policy\",\n            kind: \"enum\",\n            T: proto3.getEnumType(BackupCodecPolicy$1)\n        }\n    ]);\nconst VideoLayer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.VideoLayer\", ()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"bitrate\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"ssrc\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst DataPacket = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataPacket\", ()=>[\n        {\n            no: 1,\n            name: \"kind\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataPacket_Kind)\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"user\",\n            kind: \"message\",\n            T: UserPacket,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"speaker\",\n            kind: \"message\",\n            T: ActiveSpeakerUpdate,\n            oneof: \"value\"\n        },\n        {\n            no: 6,\n            name: \"sip_dtmf\",\n            kind: \"message\",\n            T: SipDTMF,\n            oneof: \"value\"\n        },\n        {\n            no: 7,\n            name: \"transcription\",\n            kind: \"message\",\n            T: Transcription,\n            oneof: \"value\"\n        },\n        {\n            no: 8,\n            name: \"metrics\",\n            kind: \"message\",\n            T: MetricsBatch,\n            oneof: \"value\"\n        },\n        {\n            no: 9,\n            name: \"chat_message\",\n            kind: \"message\",\n            T: ChatMessage,\n            oneof: \"value\"\n        },\n        {\n            no: 10,\n            name: \"rpc_request\",\n            kind: \"message\",\n            T: RpcRequest,\n            oneof: \"value\"\n        },\n        {\n            no: 11,\n            name: \"rpc_ack\",\n            kind: \"message\",\n            T: RpcAck,\n            oneof: \"value\"\n        },\n        {\n            no: 12,\n            name: \"rpc_response\",\n            kind: \"message\",\n            T: RpcResponse,\n            oneof: \"value\"\n        },\n        {\n            no: 13,\n            name: \"stream_header\",\n            kind: \"message\",\n            T: DataStream_Header,\n            oneof: \"value\"\n        },\n        {\n            no: 14,\n            name: \"stream_chunk\",\n            kind: \"message\",\n            T: DataStream_Chunk,\n            oneof: \"value\"\n        },\n        {\n            no: 15,\n            name: \"stream_trailer\",\n            kind: \"message\",\n            T: DataStream_Trailer,\n            oneof: \"value\"\n        }\n    ]);\nconst DataPacket_Kind = /* @__PURE__ */ proto3.makeEnum(\"livekit.DataPacket.Kind\", [\n    {\n        no: 0,\n        name: \"RELIABLE\"\n    },\n    {\n        no: 1,\n        name: \"LOSSY\"\n    }\n]);\nconst ActiveSpeakerUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ActiveSpeakerUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\nconst SpeakerInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SpeakerInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"level\",\n            kind: \"scalar\",\n            T: 2\n        },\n        {\n            no: 3,\n            name: \"active\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst UserPacket = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UserPacket\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 3,\n            name: \"destination_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"destination_identities\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 8,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9,\n            opt: true\n        },\n        {\n            no: 9,\n            name: \"start_time\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 10,\n            name: \"end_time\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 11,\n            name: \"nonce\",\n            kind: \"scalar\",\n            T: 12\n        }\n    ]);\nconst SipDTMF = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SipDTMF\", ()=>[\n        {\n            no: 3,\n            name: \"code\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 4,\n            name: \"digit\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst Transcription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Transcription\", ()=>[\n        {\n            no: 2,\n            name: \"transcribed_participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"track_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"segments\",\n            kind: \"message\",\n            T: TranscriptionSegment,\n            repeated: true\n        }\n    ]);\nconst TranscriptionSegment = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TranscriptionSegment\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"text\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"start_time\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 4,\n            name: \"end_time\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 5,\n            name: \"final\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 6,\n            name: \"language\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ChatMessage = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ChatMessage\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 3,\n            name: \"edit_timestamp\",\n            kind: \"scalar\",\n            T: 3,\n            opt: true\n        },\n        {\n            no: 4,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"deleted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 6,\n            name: \"generated\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst RpcRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcRequest\", ()=>[\n        {\n            no: 1,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"method\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"response_timeout_ms\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst RpcAck = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcAck\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst RpcResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcResponse\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"payload\",\n            kind: \"scalar\",\n            T: 9,\n            oneof: \"value\"\n        },\n        {\n            no: 3,\n            name: \"error\",\n            kind: \"message\",\n            T: RpcError$1,\n            oneof: \"value\"\n        }\n    ]);\nconst RpcError$1 = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RpcError\", ()=>[\n        {\n            no: 1,\n            name: \"code\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"data\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantTracks = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantTracks\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        }\n    ]);\nconst ServerInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ServerInfo\", ()=>[\n        {\n            no: 1,\n            name: \"edition\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ServerInfo_Edition)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"node_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"debug_info\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"agent_protocol\",\n            kind: \"scalar\",\n            T: 5\n        }\n    ]);\nconst ServerInfo_Edition = /* @__PURE__ */ proto3.makeEnum(\"livekit.ServerInfo.Edition\", [\n    {\n        no: 0,\n        name: \"Standard\"\n    },\n    {\n        no: 1,\n        name: \"Cloud\"\n    }\n]);\nconst ClientInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ClientInfo\", ()=>[\n        {\n            no: 1,\n            name: \"sdk\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientInfo_SDK)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"protocol\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 4,\n            name: \"os\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"os_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 6,\n            name: \"device_model\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 7,\n            name: \"browser\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 8,\n            name: \"browser_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 9,\n            name: \"address\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"network\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 11,\n            name: \"other_sdks\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ClientInfo_SDK = /* @__PURE__ */ proto3.makeEnum(\"livekit.ClientInfo.SDK\", [\n    {\n        no: 0,\n        name: \"UNKNOWN\"\n    },\n    {\n        no: 1,\n        name: \"JS\"\n    },\n    {\n        no: 2,\n        name: \"SWIFT\"\n    },\n    {\n        no: 3,\n        name: \"ANDROID\"\n    },\n    {\n        no: 4,\n        name: \"FLUTTER\"\n    },\n    {\n        no: 5,\n        name: \"GO\"\n    },\n    {\n        no: 6,\n        name: \"UNITY\"\n    },\n    {\n        no: 7,\n        name: \"REACT_NATIVE\"\n    },\n    {\n        no: 8,\n        name: \"RUST\"\n    },\n    {\n        no: 9,\n        name: \"PYTHON\"\n    },\n    {\n        no: 10,\n        name: \"CPP\"\n    },\n    {\n        no: 11,\n        name: \"UNITY_WEB\"\n    },\n    {\n        no: 12,\n        name: \"NODE\"\n    }\n]);\nconst ClientConfiguration = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ClientConfiguration\", ()=>[\n        {\n            no: 1,\n            name: \"video\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 2,\n            name: \"screen\",\n            kind: \"message\",\n            T: VideoConfiguration\n        },\n        {\n            no: 3,\n            name: \"resume_connection\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        },\n        {\n            no: 4,\n            name: \"disabled_codecs\",\n            kind: \"message\",\n            T: DisabledCodecs\n        },\n        {\n            no: 5,\n            name: \"force_relay\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\nconst VideoConfiguration = /* @__PURE__ */ proto3.makeMessageType(\"livekit.VideoConfiguration\", ()=>[\n        {\n            no: 1,\n            name: \"hardware_encoder\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ClientConfigSetting)\n        }\n    ]);\nconst DisabledCodecs = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DisabledCodecs\", ()=>[\n        {\n            no: 1,\n            name: \"codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"publish\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        }\n    ]);\nconst TimedVersion = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TimedVersion\", ()=>[\n        {\n            no: 1,\n            name: \"unix_micro\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"ticks\",\n            kind: \"scalar\",\n            T: 5\n        }\n    ]);\nconst DataStream_OperationType = /* @__PURE__ */ proto3.makeEnum(\"livekit.DataStream.OperationType\", [\n    {\n        no: 0,\n        name: \"CREATE\"\n    },\n    {\n        no: 1,\n        name: \"UPDATE\"\n    },\n    {\n        no: 2,\n        name: \"DELETE\"\n    },\n    {\n        no: 3,\n        name: \"REACTION\"\n    }\n]);\nconst DataStream_TextHeader = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.TextHeader\", ()=>[\n        {\n            no: 1,\n            name: \"operation_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DataStream_OperationType)\n        },\n        {\n            no: 2,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 3,\n            name: \"reply_to_stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"attached_stream_ids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"generated\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ], {\n    localName: \"DataStream_TextHeader\"\n});\nconst DataStream_ByteHeader = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.ByteHeader\", ()=>[\n        {\n            no: 1,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ], {\n    localName: \"DataStream_ByteHeader\"\n});\nconst DataStream_Header = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Header\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 3,\n            name: \"topic\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 4,\n            name: \"mime_type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"total_length\",\n            kind: \"scalar\",\n            T: 4,\n            opt: true\n        },\n        {\n            no: 7,\n            name: \"encryption_type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 8,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 9,\n            name: \"text_header\",\n            kind: \"message\",\n            T: DataStream_TextHeader,\n            oneof: \"content_header\"\n        },\n        {\n            no: 10,\n            name: \"byte_header\",\n            kind: \"message\",\n            T: DataStream_ByteHeader,\n            oneof: \"content_header\"\n        }\n    ], {\n    localName: \"DataStream_Header\"\n});\nconst DataStream_Chunk = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Chunk\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"chunk_index\",\n            kind: \"scalar\",\n            T: 4\n        },\n        {\n            no: 3,\n            name: \"content\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 4,\n            name: \"version\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 5,\n            name: \"iv\",\n            kind: \"scalar\",\n            T: 12,\n            opt: true\n        }\n    ], {\n    localName: \"DataStream_Chunk\"\n});\nconst DataStream_Trailer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataStream.Trailer\", ()=>[\n        {\n            no: 1,\n            name: \"stream_id\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        }\n    ], {\n    localName: \"DataStream_Trailer\"\n});\nconst SignalTarget = /* @__PURE__ */ proto3.makeEnum(\"livekit.SignalTarget\", [\n    {\n        no: 0,\n        name: \"PUBLISHER\"\n    },\n    {\n        no: 1,\n        name: \"SUBSCRIBER\"\n    }\n]);\nconst StreamState = /* @__PURE__ */ proto3.makeEnum(\"livekit.StreamState\", [\n    {\n        no: 0,\n        name: \"ACTIVE\"\n    },\n    {\n        no: 1,\n        name: \"PAUSED\"\n    }\n]);\nconst CandidateProtocol = /* @__PURE__ */ proto3.makeEnum(\"livekit.CandidateProtocol\", [\n    {\n        no: 0,\n        name: \"UDP\"\n    },\n    {\n        no: 1,\n        name: \"TCP\"\n    },\n    {\n        no: 2,\n        name: \"TLS\"\n    }\n]);\nconst SignalRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SignalRequest\", ()=>[\n        {\n            no: 1,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"add_track\",\n            kind: \"message\",\n            T: AddTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription,\n            oneof: \"message\"\n        },\n        {\n            no: 7,\n            name: \"track_setting\",\n            kind: \"message\",\n            T: UpdateTrackSettings,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"update_layers\",\n            kind: \"message\",\n            T: UpdateVideoLayers,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"subscription_permission\",\n            kind: \"message\",\n            T: SubscriptionPermission,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"sync_state\",\n            kind: \"message\",\n            T: SyncState,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"simulate\",\n            kind: \"message\",\n            T: SimulateScenario,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"ping\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"update_metadata\",\n            kind: \"message\",\n            T: UpdateParticipantMetadata,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"ping_req\",\n            kind: \"message\",\n            T: Ping,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"update_audio_track\",\n            kind: \"message\",\n            T: UpdateLocalAudioTrack,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"update_video_track\",\n            kind: \"message\",\n            T: UpdateLocalVideoTrack,\n            oneof: \"message\"\n        }\n    ]);\nconst SignalResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SignalResponse\", ()=>[\n        {\n            no: 1,\n            name: \"join\",\n            kind: \"message\",\n            T: JoinResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 2,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 3,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription,\n            oneof: \"message\"\n        },\n        {\n            no: 4,\n            name: \"trickle\",\n            kind: \"message\",\n            T: TrickleRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 5,\n            name: \"update\",\n            kind: \"message\",\n            T: ParticipantUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 6,\n            name: \"track_published\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 8,\n            name: \"leave\",\n            kind: \"message\",\n            T: LeaveRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 9,\n            name: \"mute\",\n            kind: \"message\",\n            T: MuteTrackRequest,\n            oneof: \"message\"\n        },\n        {\n            no: 10,\n            name: \"speakers_changed\",\n            kind: \"message\",\n            T: SpeakersChanged,\n            oneof: \"message\"\n        },\n        {\n            no: 11,\n            name: \"room_update\",\n            kind: \"message\",\n            T: RoomUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 12,\n            name: \"connection_quality\",\n            kind: \"message\",\n            T: ConnectionQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 13,\n            name: \"stream_state_update\",\n            kind: \"message\",\n            T: StreamStateUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 14,\n            name: \"subscribed_quality_update\",\n            kind: \"message\",\n            T: SubscribedQualityUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 15,\n            name: \"subscription_permission_update\",\n            kind: \"message\",\n            T: SubscriptionPermissionUpdate,\n            oneof: \"message\"\n        },\n        {\n            no: 16,\n            name: \"refresh_token\",\n            kind: \"scalar\",\n            T: 9,\n            oneof: \"message\"\n        },\n        {\n            no: 17,\n            name: \"track_unpublished\",\n            kind: \"message\",\n            T: TrackUnpublishedResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 18,\n            name: \"pong\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"message\"\n        },\n        {\n            no: 19,\n            name: \"reconnect\",\n            kind: \"message\",\n            T: ReconnectResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 20,\n            name: \"pong_resp\",\n            kind: \"message\",\n            T: Pong,\n            oneof: \"message\"\n        },\n        {\n            no: 21,\n            name: \"subscription_response\",\n            kind: \"message\",\n            T: SubscriptionResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 22,\n            name: \"request_response\",\n            kind: \"message\",\n            T: RequestResponse,\n            oneof: \"message\"\n        },\n        {\n            no: 23,\n            name: \"track_subscribed\",\n            kind: \"message\",\n            T: TrackSubscribed,\n            oneof: \"message\"\n        }\n    ]);\nconst SimulcastCodec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulcastCodec\", ()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst AddTrackRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.AddTrackRequest\", ()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"type\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackType)\n        },\n        {\n            no: 4,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 5,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 7,\n            name: \"disable_dtx\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 8,\n            name: \"source\",\n            kind: \"enum\",\n            T: proto3.getEnumType(TrackSource)\n        },\n        {\n            no: 9,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        },\n        {\n            no: 10,\n            name: \"simulcast_codecs\",\n            kind: \"message\",\n            T: SimulcastCodec,\n            repeated: true\n        },\n        {\n            no: 11,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 12,\n            name: \"stereo\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 13,\n            name: \"disable_red\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 14,\n            name: \"encryption\",\n            kind: \"enum\",\n            T: proto3.getEnumType(Encryption_Type)\n        },\n        {\n            no: 15,\n            name: \"stream\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 16,\n            name: \"backup_codec_policy\",\n            kind: \"enum\",\n            T: proto3.getEnumType(BackupCodecPolicy$1)\n        }\n    ]);\nconst TrickleRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrickleRequest\", ()=>[\n        {\n            no: 1,\n            name: \"candidateInit\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        },\n        {\n            no: 3,\n            name: \"final\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst MuteTrackRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.MuteTrackRequest\", ()=>[\n        {\n            no: 1,\n            name: \"sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"muted\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst JoinResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.JoinResponse\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        },\n        {\n            no: 2,\n            name: \"participant\",\n            kind: \"message\",\n            T: ParticipantInfo\n        },\n        {\n            no: 3,\n            name: \"other_participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"server_version\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 5,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 6,\n            name: \"subscriber_primary\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 7,\n            name: \"alternative_url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 8,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        },\n        {\n            no: 9,\n            name: \"server_region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 10,\n            name: \"ping_timeout\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 11,\n            name: \"ping_interval\",\n            kind: \"scalar\",\n            T: 5\n        },\n        {\n            no: 12,\n            name: \"server_info\",\n            kind: \"message\",\n            T: ServerInfo\n        },\n        {\n            no: 13,\n            name: \"sif_trailer\",\n            kind: \"scalar\",\n            T: 12\n        },\n        {\n            no: 14,\n            name: \"enabled_publish_codecs\",\n            kind: \"message\",\n            T: Codec,\n            repeated: true\n        },\n        {\n            no: 15,\n            name: \"fast_publish\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst ReconnectResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ReconnectResponse\", ()=>[\n        {\n            no: 1,\n            name: \"ice_servers\",\n            kind: \"message\",\n            T: ICEServer,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"client_configuration\",\n            kind: \"message\",\n            T: ClientConfiguration\n        }\n    ]);\nconst TrackPublishedResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackPublishedResponse\", ()=>[\n        {\n            no: 1,\n            name: \"cid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track\",\n            kind: \"message\",\n            T: TrackInfo\n        }\n    ]);\nconst TrackUnpublishedResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackUnpublishedResponse\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SessionDescription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SessionDescription\", ()=>[\n        {\n            no: 1,\n            name: \"type\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"sdp\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst ParticipantUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ParticipantUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"participants\",\n            kind: \"message\",\n            T: ParticipantInfo,\n            repeated: true\n        }\n    ]);\nconst UpdateSubscription = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateSubscription\", ()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"subscribe\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"participant_tracks\",\n            kind: \"message\",\n            T: ParticipantTracks,\n            repeated: true\n        }\n    ]);\nconst UpdateTrackSettings = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateTrackSettings\", ()=>[\n        {\n            no: 1,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"disabled\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 4,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 5,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 6,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 7,\n            name: \"fps\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 8,\n            name: \"priority\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst UpdateLocalAudioTrack = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateLocalAudioTrack\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"features\",\n            kind: \"enum\",\n            T: proto3.getEnumType(AudioTrackFeature),\n            repeated: true\n        }\n    ]);\nconst UpdateLocalVideoTrack = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateLocalVideoTrack\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"width\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"height\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst LeaveRequest = /* @__PURE__ */ proto3.makeMessageType(\"livekit.LeaveRequest\", ()=>[\n        {\n            no: 1,\n            name: \"can_reconnect\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(DisconnectReason)\n        },\n        {\n            no: 3,\n            name: \"action\",\n            kind: \"enum\",\n            T: proto3.getEnumType(LeaveRequest_Action)\n        },\n        {\n            no: 4,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionSettings\n        }\n    ]);\nconst LeaveRequest_Action = /* @__PURE__ */ proto3.makeEnum(\"livekit.LeaveRequest.Action\", [\n    {\n        no: 0,\n        name: \"DISCONNECT\"\n    },\n    {\n        no: 1,\n        name: \"RESUME\"\n    },\n    {\n        no: 2,\n        name: \"RECONNECT\"\n    }\n]);\nconst UpdateVideoLayers = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateVideoLayers\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"layers\",\n            kind: \"message\",\n            T: VideoLayer,\n            repeated: true\n        }\n    ]);\nconst UpdateParticipantMetadata = /* @__PURE__ */ proto3.makeMessageType(\"livekit.UpdateParticipantMetadata\", ()=>[\n        {\n            no: 1,\n            name: \"metadata\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"name\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"attributes\",\n            kind: \"map\",\n            K: 9,\n            V: {\n                kind: \"scalar\",\n                T: 9\n            }\n        },\n        {\n            no: 4,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 13\n        }\n    ]);\nconst ICEServer = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ICEServer\", ()=>[\n        {\n            no: 1,\n            name: \"urls\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 2,\n            name: \"username\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"credential\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SpeakersChanged = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SpeakersChanged\", ()=>[\n        {\n            no: 1,\n            name: \"speakers\",\n            kind: \"message\",\n            T: SpeakerInfo,\n            repeated: true\n        }\n    ]);\nconst RoomUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RoomUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"room\",\n            kind: \"message\",\n            T: Room$1\n        }\n    ]);\nconst ConnectionQualityInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ConnectionQualityInfo\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(ConnectionQuality$1)\n        },\n        {\n            no: 3,\n            name: \"score\",\n            kind: \"scalar\",\n            T: 2\n        }\n    ]);\nconst ConnectionQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.ConnectionQualityUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"updates\",\n            kind: \"message\",\n            T: ConnectionQualityInfo,\n            repeated: true\n        }\n    ]);\nconst StreamStateInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.StreamStateInfo\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"state\",\n            kind: \"enum\",\n            T: proto3.getEnumType(StreamState)\n        }\n    ]);\nconst StreamStateUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.StreamStateUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"stream_states\",\n            kind: \"message\",\n            T: StreamStateInfo,\n            repeated: true\n        }\n    ]);\nconst SubscribedQuality = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedQuality\", ()=>[\n        {\n            no: 1,\n            name: \"quality\",\n            kind: \"enum\",\n            T: proto3.getEnumType(VideoQuality$1)\n        },\n        {\n            no: 2,\n            name: \"enabled\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst SubscribedCodec = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedCodec\", ()=>[\n        {\n            no: 1,\n            name: \"codec\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        }\n    ]);\nconst SubscribedQualityUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscribedQualityUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"subscribed_qualities\",\n            kind: \"message\",\n            T: SubscribedQuality,\n            repeated: true\n        },\n        {\n            no: 3,\n            name: \"subscribed_codecs\",\n            kind: \"message\",\n            T: SubscribedCodec,\n            repeated: true\n        }\n    ]);\nconst TrackPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackPermission\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"all_tracks\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 3,\n            name: \"track_sids\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"participant_identity\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst SubscriptionPermission = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionPermission\", ()=>[\n        {\n            no: 1,\n            name: \"all_participants\",\n            kind: \"scalar\",\n            T: 8\n        },\n        {\n            no: 2,\n            name: \"track_permissions\",\n            kind: \"message\",\n            T: TrackPermission,\n            repeated: true\n        }\n    ]);\nconst SubscriptionPermissionUpdate = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionPermissionUpdate\", ()=>[\n        {\n            no: 1,\n            name: \"participant_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"allowed\",\n            kind: \"scalar\",\n            T: 8\n        }\n    ]);\nconst SyncState = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SyncState\", ()=>[\n        {\n            no: 1,\n            name: \"answer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 2,\n            name: \"subscription\",\n            kind: \"message\",\n            T: UpdateSubscription\n        },\n        {\n            no: 3,\n            name: \"publish_tracks\",\n            kind: \"message\",\n            T: TrackPublishedResponse,\n            repeated: true\n        },\n        {\n            no: 4,\n            name: \"data_channels\",\n            kind: \"message\",\n            T: DataChannelInfo,\n            repeated: true\n        },\n        {\n            no: 5,\n            name: \"offer\",\n            kind: \"message\",\n            T: SessionDescription\n        },\n        {\n            no: 6,\n            name: \"track_sids_disabled\",\n            kind: \"scalar\",\n            T: 9,\n            repeated: true\n        }\n    ]);\nconst DataChannelInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.DataChannelInfo\", ()=>[\n        {\n            no: 1,\n            name: \"label\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"id\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 3,\n            name: \"target\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SignalTarget)\n        }\n    ]);\nconst SimulateScenario = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SimulateScenario\", ()=>[\n        {\n            no: 1,\n            name: \"speaker_update\",\n            kind: \"scalar\",\n            T: 5,\n            oneof: \"scenario\"\n        },\n        {\n            no: 2,\n            name: \"node_failure\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 3,\n            name: \"migration\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 4,\n            name: \"server_leave\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 5,\n            name: \"switch_candidate_protocol\",\n            kind: \"enum\",\n            T: proto3.getEnumType(CandidateProtocol),\n            oneof: \"scenario\"\n        },\n        {\n            no: 6,\n            name: \"subscriber_bandwidth\",\n            kind: \"scalar\",\n            T: 3,\n            oneof: \"scenario\"\n        },\n        {\n            no: 7,\n            name: \"disconnect_signal_on_resume\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 8,\n            name: \"disconnect_signal_on_resume_no_messages\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        },\n        {\n            no: 9,\n            name: \"leave_request_full_reconnect\",\n            kind: \"scalar\",\n            T: 8,\n            oneof: \"scenario\"\n        }\n    ]);\nconst Ping = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Ping\", ()=>[\n        {\n            no: 1,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"rtt\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst Pong = /* @__PURE__ */ proto3.makeMessageType(\"livekit.Pong\", ()=>[\n        {\n            no: 1,\n            name: \"last_ping_timestamp\",\n            kind: \"scalar\",\n            T: 3\n        },\n        {\n            no: 2,\n            name: \"timestamp\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst RegionSettings = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RegionSettings\", ()=>[\n        {\n            no: 1,\n            name: \"regions\",\n            kind: \"message\",\n            T: RegionInfo,\n            repeated: true\n        }\n    ]);\nconst RegionInfo = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RegionInfo\", ()=>[\n        {\n            no: 1,\n            name: \"region\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"url\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 3,\n            name: \"distance\",\n            kind: \"scalar\",\n            T: 3\n        }\n    ]);\nconst SubscriptionResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.SubscriptionResponse\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        },\n        {\n            no: 2,\n            name: \"err\",\n            kind: \"enum\",\n            T: proto3.getEnumType(SubscriptionError)\n        }\n    ]);\nconst RequestResponse = /* @__PURE__ */ proto3.makeMessageType(\"livekit.RequestResponse\", ()=>[\n        {\n            no: 1,\n            name: \"request_id\",\n            kind: \"scalar\",\n            T: 13\n        },\n        {\n            no: 2,\n            name: \"reason\",\n            kind: \"enum\",\n            T: proto3.getEnumType(RequestResponse_Reason)\n        },\n        {\n            no: 3,\n            name: \"message\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nconst RequestResponse_Reason = /* @__PURE__ */ proto3.makeEnum(\"livekit.RequestResponse.Reason\", [\n    {\n        no: 0,\n        name: \"OK\"\n    },\n    {\n        no: 1,\n        name: \"NOT_FOUND\"\n    },\n    {\n        no: 2,\n        name: \"NOT_ALLOWED\"\n    },\n    {\n        no: 3,\n        name: \"LIMIT_EXCEEDED\"\n    }\n]);\nconst TrackSubscribed = /* @__PURE__ */ proto3.makeMessageType(\"livekit.TrackSubscribed\", ()=>[\n        {\n            no: 1,\n            name: \"track_sid\",\n            kind: \"scalar\",\n            T: 9\n        }\n    ]);\nfunction getDefaultExportFromCjs(x) {\n    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, \"default\") ? x[\"default\"] : x;\n}\nvar loglevel$1 = {\n    exports: {}\n};\n/*\n* loglevel - https://github.com/pimterry/loglevel\n*\n* Copyright (c) 2013 Tim Perry\n* Licensed under the MIT license.\n*/ var loglevel = loglevel$1.exports;\nvar hasRequiredLoglevel;\nfunction requireLoglevel() {\n    if (hasRequiredLoglevel) return loglevel$1.exports;\n    hasRequiredLoglevel = 1;\n    (function(module) {\n        (function(root, definition) {\n            if (module.exports) {\n                module.exports = definition();\n            } else {\n                root.log = definition();\n            }\n        })(loglevel, function() {\n            // Slightly dubious tricks to cut down minimized file size\n            var noop = function() {};\n            var undefinedType = \"undefined\";\n            var isIE = \"undefined\" !== undefinedType && typeof window.navigator !== undefinedType && /Trident\\/|MSIE /.test(window.navigator.userAgent);\n            var logMethods = [\n                \"trace\",\n                \"debug\",\n                \"info\",\n                \"warn\",\n                \"error\"\n            ];\n            var _loggersByName = {};\n            var defaultLogger = null;\n            // Cross-browser bind equivalent that works at least back to IE6\n            function bindMethod(obj, methodName) {\n                var method = obj[methodName];\n                if (typeof method.bind === \"function\") {\n                    return method.bind(obj);\n                } else {\n                    try {\n                        return Function.prototype.bind.call(method, obj);\n                    } catch (e) {\n                        // Missing bind shim or IE8 + Modernizr, fallback to wrapping\n                        return function() {\n                            return Function.prototype.apply.apply(method, [\n                                obj,\n                                arguments\n                            ]);\n                        };\n                    }\n                }\n            }\n            // Trace() doesn't print the message in IE, so for that case we need to wrap it\n            function traceForIE() {\n                if (console.log) {\n                    if (console.log.apply) {\n                        console.log.apply(console, arguments);\n                    } else {\n                        // In old IE, native console methods themselves don't have apply().\n                        Function.prototype.apply.apply(console.log, [\n                            console,\n                            arguments\n                        ]);\n                    }\n                }\n                if (console.trace) console.trace();\n            }\n            // Build the best logging method possible for this env\n            // Wherever possible we want to bind, not wrap, to preserve stack traces\n            function realMethod(methodName) {\n                if (methodName === \"debug\") {\n                    methodName = \"log\";\n                }\n                if (typeof console === undefinedType) {\n                    return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives\n                } else if (methodName === \"trace\" && isIE) {\n                    return traceForIE;\n                } else if (console[methodName] !== undefined) {\n                    return bindMethod(console, methodName);\n                } else if (console.log !== undefined) {\n                    return bindMethod(console, \"log\");\n                } else {\n                    return noop;\n                }\n            }\n            // These private functions always need `this` to be set properly\n            function replaceLoggingMethods() {\n                /*jshint validthis:true */ var level = this.getLevel();\n                // Replace the actual methods.\n                for(var i = 0; i < logMethods.length; i++){\n                    var methodName = logMethods[i];\n                    this[methodName] = i < level ? noop : this.methodFactory(methodName, level, this.name);\n                }\n                // Define log.log as an alias for log.debug\n                this.log = this.debug;\n                // Return any important warnings.\n                if (typeof console === undefinedType && level < this.levels.SILENT) {\n                    return \"No console available for logging\";\n                }\n            }\n            // In old IE versions, the console isn't present until you first open it.\n            // We build realMethod() replacements here that regenerate logging methods\n            function enableLoggingWhenConsoleArrives(methodName) {\n                return function() {\n                    if (typeof console !== undefinedType) {\n                        replaceLoggingMethods.call(this);\n                        this[methodName].apply(this, arguments);\n                    }\n                };\n            }\n            // By default, we use closely bound real methods wherever possible, and\n            // otherwise we wait for a console to appear, and then try again.\n            function defaultMethodFactory(methodName, _level, _loggerName) {\n                /*jshint validthis:true */ return realMethod(methodName) || enableLoggingWhenConsoleArrives.apply(this, arguments);\n            }\n            function Logger(name, factory) {\n                // Private instance variables.\n                var self = this;\n                /**\n         * The level inherited from a parent logger (or a global default). We\n         * cache this here rather than delegating to the parent so that it stays\n         * in sync with the actual logging methods that we have installed (the\n         * parent could change levels but we might not have rebuilt the loggers\n         * in this child yet).\n         * @type {number}\n         */ var inheritedLevel;\n                /**\n         * The default level for this logger, if any. If set, this overrides\n         * `inheritedLevel`.\n         * @type {number|null}\n         */ var defaultLevel;\n                /**\n         * A user-specific level for this logger. If set, this overrides\n         * `defaultLevel`.\n         * @type {number|null}\n         */ var userLevel;\n                var storageKey = \"loglevel\";\n                if (typeof name === \"string\") {\n                    storageKey += \":\" + name;\n                } else if (typeof name === \"symbol\") {\n                    storageKey = undefined;\n                }\n                function persistLevelIfPossible(levelNum) {\n                    var levelName = (logMethods[levelNum] || \"silent\").toUpperCase();\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    // Use localStorage if available\n                    try {\n                        window.localStorage[storageKey] = levelName;\n                        return;\n                    } catch (ignore) {}\n                    // Use session cookie as fallback\n                    try {\n                        window.document.cookie = encodeURIComponent(storageKey) + \"=\" + levelName + \";\";\n                    } catch (ignore) {}\n                }\n                function getPersistedLevel() {\n                    var storedLevel;\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    try {\n                        storedLevel = window.localStorage[storageKey];\n                    } catch (ignore) {}\n                    // Fallback to cookies if local storage gives us nothing\n                    if (typeof storedLevel === undefinedType) {\n                        try {\n                            var cookie = window.document.cookie;\n                            var cookieName = encodeURIComponent(storageKey);\n                            var location = cookie.indexOf(cookieName + \"=\");\n                            if (location !== -1) {\n                                storedLevel = /^([^;]+)/.exec(cookie.slice(location + cookieName.length + 1))[1];\n                            }\n                        } catch (ignore) {}\n                    }\n                    // If the stored level is not valid, treat it as if nothing was stored.\n                    if (self.levels[storedLevel] === undefined) {\n                        storedLevel = undefined;\n                    }\n                    return storedLevel;\n                }\n                function clearPersistedLevel() {\n                    if (\"undefined\" === undefinedType || !storageKey) return;\n                    // Use localStorage if available\n                    try {\n                        window.localStorage.removeItem(storageKey);\n                    } catch (ignore) {}\n                    // Use session cookie as fallback\n                    try {\n                        window.document.cookie = encodeURIComponent(storageKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 UTC\";\n                    } catch (ignore) {}\n                }\n                function normalizeLevel(input) {\n                    var level = input;\n                    if (typeof level === \"string\" && self.levels[level.toUpperCase()] !== undefined) {\n                        level = self.levels[level.toUpperCase()];\n                    }\n                    if (typeof level === \"number\" && level >= 0 && level <= self.levels.SILENT) {\n                        return level;\n                    } else {\n                        throw new TypeError(\"log.setLevel() called with invalid level: \" + input);\n                    }\n                }\n                /*\n         *\n         * Public logger API - see https://github.com/pimterry/loglevel for details\n         *\n         */ self.name = name;\n                self.levels = {\n                    \"TRACE\": 0,\n                    \"DEBUG\": 1,\n                    \"INFO\": 2,\n                    \"WARN\": 3,\n                    \"ERROR\": 4,\n                    \"SILENT\": 5\n                };\n                self.methodFactory = factory || defaultMethodFactory;\n                self.getLevel = function() {\n                    if (userLevel != null) {\n                        return userLevel;\n                    } else if (defaultLevel != null) {\n                        return defaultLevel;\n                    } else {\n                        return inheritedLevel;\n                    }\n                };\n                self.setLevel = function(level, persist) {\n                    userLevel = normalizeLevel(level);\n                    if (persist !== false) {\n                        // defaults to true\n                        persistLevelIfPossible(userLevel);\n                    }\n                    // NOTE: in v2, this should call rebuild(), which updates children.\n                    return replaceLoggingMethods.call(self);\n                };\n                self.setDefaultLevel = function(level) {\n                    defaultLevel = normalizeLevel(level);\n                    if (!getPersistedLevel()) {\n                        self.setLevel(level, false);\n                    }\n                };\n                self.resetLevel = function() {\n                    userLevel = null;\n                    clearPersistedLevel();\n                    replaceLoggingMethods.call(self);\n                };\n                self.enableAll = function(persist) {\n                    self.setLevel(self.levels.TRACE, persist);\n                };\n                self.disableAll = function(persist) {\n                    self.setLevel(self.levels.SILENT, persist);\n                };\n                self.rebuild = function() {\n                    if (defaultLogger !== self) {\n                        inheritedLevel = normalizeLevel(defaultLogger.getLevel());\n                    }\n                    replaceLoggingMethods.call(self);\n                    if (defaultLogger === self) {\n                        for(var childName in _loggersByName){\n                            _loggersByName[childName].rebuild();\n                        }\n                    }\n                };\n                // Initialize all the internal levels.\n                inheritedLevel = normalizeLevel(defaultLogger ? defaultLogger.getLevel() : \"WARN\");\n                var initialLevel = getPersistedLevel();\n                if (initialLevel != null) {\n                    userLevel = normalizeLevel(initialLevel);\n                }\n                replaceLoggingMethods.call(self);\n            }\n            /*\n       *\n       * Top-level API\n       *\n       */ defaultLogger = new Logger();\n            defaultLogger.getLogger = function getLogger(name) {\n                if (typeof name !== \"symbol\" && typeof name !== \"string\" || name === \"\") {\n                    throw new TypeError(\"You must supply a name when creating a logger.\");\n                }\n                var logger = _loggersByName[name];\n                if (!logger) {\n                    logger = _loggersByName[name] = new Logger(name, defaultLogger.methodFactory);\n                }\n                return logger;\n            };\n            // Grab the current global log variable in case of overwrite\n            var _log = \"undefined\" !== undefinedType ? window.log : undefined;\n            defaultLogger.noConflict = function() {\n                if (\"undefined\" !== undefinedType && window.log === defaultLogger) {\n                    window.log = _log;\n                }\n                return defaultLogger;\n            };\n            defaultLogger.getLoggers = function getLoggers() {\n                return _loggersByName;\n            };\n            // ES6 default export, for compatibility\n            defaultLogger[\"default\"] = defaultLogger;\n            return defaultLogger;\n        });\n    })(loglevel$1);\n    return loglevel$1.exports;\n}\nvar loglevelExports = requireLoglevel();\nvar LogLevel;\n(function(LogLevel) {\n    LogLevel[LogLevel[\"trace\"] = 0] = \"trace\";\n    LogLevel[LogLevel[\"debug\"] = 1] = \"debug\";\n    LogLevel[LogLevel[\"info\"] = 2] = \"info\";\n    LogLevel[LogLevel[\"warn\"] = 3] = \"warn\";\n    LogLevel[LogLevel[\"error\"] = 4] = \"error\";\n    LogLevel[LogLevel[\"silent\"] = 5] = \"silent\";\n})(LogLevel || (LogLevel = {}));\nvar LoggerNames;\n(function(LoggerNames) {\n    LoggerNames[\"Default\"] = \"livekit\";\n    LoggerNames[\"Room\"] = \"livekit-room\";\n    LoggerNames[\"Participant\"] = \"livekit-participant\";\n    LoggerNames[\"Track\"] = \"livekit-track\";\n    LoggerNames[\"Publication\"] = \"livekit-track-publication\";\n    LoggerNames[\"Engine\"] = \"livekit-engine\";\n    LoggerNames[\"Signal\"] = \"livekit-signal\";\n    LoggerNames[\"PCManager\"] = \"livekit-pc-manager\";\n    LoggerNames[\"PCTransport\"] = \"livekit-pc-transport\";\n    LoggerNames[\"E2EE\"] = \"lk-e2ee\";\n})(LoggerNames || (LoggerNames = {}));\nlet livekitLogger = loglevelExports.getLogger(\"livekit\");\nconst livekitLoggers = Object.values(LoggerNames).map((name)=>loglevelExports.getLogger(name));\nlivekitLogger.setDefaultLevel(LogLevel.info);\n/**\n * @internal\n */ function getLogger(name) {\n    const logger = loglevelExports.getLogger(name);\n    logger.setDefaultLevel(livekitLogger.getLevel());\n    return logger;\n}\nfunction setLogLevel(level, loggerName) {\n    if (loggerName) {\n        loglevelExports.getLogger(loggerName).setLevel(level);\n    } else {\n        for (const logger of livekitLoggers){\n            logger.setLevel(level);\n        }\n    }\n}\n/**\n * use this to hook into the logging function to allow sending internal livekit logs to third party services\n * if set, the browser logs will lose their stacktrace information (see https://github.com/pimterry/loglevel#writing-plugins)\n */ function setLogExtension(extension, logger) {\n    const loggers = logger ? [\n        logger\n    ] : livekitLoggers;\n    loggers.forEach((logR)=>{\n        const originalFactory = logR.methodFactory;\n        logR.methodFactory = (methodName, configLevel, loggerName)=>{\n            const rawMethod = originalFactory(methodName, configLevel, loggerName);\n            const logLevel = LogLevel[methodName];\n            const needLog = logLevel >= configLevel && logLevel < LogLevel.silent;\n            return (msg, context)=>{\n                if (context) rawMethod(msg, context);\n                else rawMethod(msg);\n                if (needLog) {\n                    extension(logLevel, msg, context);\n                }\n            };\n        };\n        logR.setLevel(logR.getLevel());\n    });\n}\nconst workerLogger = loglevelExports.getLogger(\"lk-e2ee\");\nconst maxRetryDelay = 7000;\nconst DEFAULT_RETRY_DELAYS_IN_MS = [\n    0,\n    300,\n    2 * 2 * 300,\n    3 * 3 * 300,\n    4 * 4 * 300,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay,\n    maxRetryDelay\n];\nclass DefaultReconnectPolicy {\n    constructor(retryDelays){\n        this._retryDelays = retryDelays !== undefined ? [\n            ...retryDelays\n        ] : DEFAULT_RETRY_DELAYS_IN_MS;\n    }\n    nextRetryDelayInMs(context) {\n        if (context.retryCount >= this._retryDelays.length) return null;\n        const retryDelay = this._retryDelays[context.retryCount];\n        if (context.retryCount <= 1) return retryDelay;\n        return retryDelay + Math.random() * 1000;\n    }\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol, Iterator */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __values(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function() {\n            if (o && i >= o.length) o = void 0;\n            return {\n                value: o && o[i++],\n                done: !o\n            };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\nfunction __asyncValues(o) {\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n    var m = o[Symbol.asyncIterator], i;\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function() {\n        return this;\n    }, i);\n    function verb(n) {\n        i[n] = o[n] && function(v) {\n            return new Promise(function(resolve, reject) {\n                v = o[n](v), settle(resolve, reject, v.done, v.value);\n            });\n        };\n    }\n    function settle(resolve, reject, d, v) {\n        Promise.resolve(v).then(function(v) {\n            resolve({\n                value: v,\n                done: d\n            });\n        }, reject);\n    }\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar events = {\n    exports: {}\n};\nvar hasRequiredEvents;\nfunction requireEvents() {\n    if (hasRequiredEvents) return events.exports;\n    hasRequiredEvents = 1;\n    var R = typeof Reflect === \"object\" ? Reflect : null;\n    var ReflectApply = R && typeof R.apply === \"function\" ? R.apply : function ReflectApply(target, receiver, args) {\n        return Function.prototype.apply.call(target, receiver, args);\n    };\n    var ReflectOwnKeys;\n    if (R && typeof R.ownKeys === \"function\") {\n        ReflectOwnKeys = R.ownKeys;\n    } else if (Object.getOwnPropertySymbols) {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));\n        };\n    } else {\n        ReflectOwnKeys = function ReflectOwnKeys(target) {\n            return Object.getOwnPropertyNames(target);\n        };\n    }\n    function ProcessEmitWarning(warning) {\n        if (console && console.warn) console.warn(warning);\n    }\n    var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n        return value !== value;\n    };\n    function EventEmitter() {\n        EventEmitter.init.call(this);\n    }\n    events.exports = EventEmitter;\n    events.exports.once = once;\n    // Backwards-compat with node 0.10.x\n    EventEmitter.EventEmitter = EventEmitter;\n    EventEmitter.prototype._events = undefined;\n    EventEmitter.prototype._eventsCount = 0;\n    EventEmitter.prototype._maxListeners = undefined;\n    // By default EventEmitters will print a warning if more than 10 listeners are\n    // added to it. This is a useful default which helps finding memory leaks.\n    var defaultMaxListeners = 10;\n    function checkListener(listener) {\n        if (typeof listener !== \"function\") {\n            throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n        }\n    }\n    Object.defineProperty(EventEmitter, \"defaultMaxListeners\", {\n        enumerable: true,\n        get: function() {\n            return defaultMaxListeners;\n        },\n        set: function(arg) {\n            if (typeof arg !== \"number\" || arg < 0 || NumberIsNaN(arg)) {\n                throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + \".\");\n            }\n            defaultMaxListeners = arg;\n        }\n    });\n    EventEmitter.init = function() {\n        if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n        }\n        this._maxListeners = this._maxListeners || undefined;\n    };\n    // Obviously not all Emitters should be limited to 10. This function allows\n    // that to be increased. Set to zero for unlimited.\n    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n        if (typeof n !== \"number\" || n < 0 || NumberIsNaN(n)) {\n            throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + \".\");\n        }\n        this._maxListeners = n;\n        return this;\n    };\n    function _getMaxListeners(that) {\n        if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;\n        return that._maxListeners;\n    }\n    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n        return _getMaxListeners(this);\n    };\n    EventEmitter.prototype.emit = function emit(type) {\n        var args = [];\n        for(var i = 1; i < arguments.length; i++)args.push(arguments[i]);\n        var doError = type === \"error\";\n        var events = this._events;\n        if (events !== undefined) doError = doError && events.error === undefined;\n        else if (!doError) return false;\n        // If there is no 'error' event listener then throw.\n        if (doError) {\n            var er;\n            if (args.length > 0) er = args[0];\n            if (er instanceof Error) {\n                // Note: The comments on the `throw` lines are intentional, they show\n                // up in Node's output if this results in an unhandled exception.\n                throw er; // Unhandled 'error' event\n            }\n            // At least give some kind of context to the user\n            var err = new Error(\"Unhandled error.\" + (er ? \" (\" + er.message + \")\" : \"\"));\n            err.context = er;\n            throw err; // Unhandled 'error' event\n        }\n        var handler = events[type];\n        if (handler === undefined) return false;\n        if (typeof handler === \"function\") {\n            ReflectApply(handler, this, args);\n        } else {\n            var len = handler.length;\n            var listeners = arrayClone(handler, len);\n            for(var i = 0; i < len; ++i)ReflectApply(listeners[i], this, args);\n        }\n        return true;\n    };\n    function _addListener(target, type, listener, prepend) {\n        var m;\n        var events;\n        var existing;\n        checkListener(listener);\n        events = target._events;\n        if (events === undefined) {\n            events = target._events = Object.create(null);\n            target._eventsCount = 0;\n        } else {\n            // To avoid recursion in the case that type === \"newListener\"! Before\n            // adding it to the listeners, first emit \"newListener\".\n            if (events.newListener !== undefined) {\n                target.emit(\"newListener\", type, listener.listener ? listener.listener : listener);\n                // Re-assign `events` because a newListener handler could have caused the\n                // this._events to be assigned to a new object\n                events = target._events;\n            }\n            existing = events[type];\n        }\n        if (existing === undefined) {\n            // Optimize the case of one listener. Don't need the extra array object.\n            existing = events[type] = listener;\n            ++target._eventsCount;\n        } else {\n            if (typeof existing === \"function\") {\n                // Adding the second element, need to change to array.\n                existing = events[type] = prepend ? [\n                    listener,\n                    existing\n                ] : [\n                    existing,\n                    listener\n                ];\n            // If we've already got an array, just append.\n            } else if (prepend) {\n                existing.unshift(listener);\n            } else {\n                existing.push(listener);\n            }\n            // Check for listener leak\n            m = _getMaxListeners(target);\n            if (m > 0 && existing.length > m && !existing.warned) {\n                existing.warned = true;\n                // No error code for this since it is a Warning\n                // eslint-disable-next-line no-restricted-syntax\n                var w = new Error(\"Possible EventEmitter memory leak detected. \" + existing.length + \" \" + String(type) + \" listeners \" + \"added. Use emitter.setMaxListeners() to \" + \"increase limit\");\n                w.name = \"MaxListenersExceededWarning\";\n                w.emitter = target;\n                w.type = type;\n                w.count = existing.length;\n                ProcessEmitWarning(w);\n            }\n        }\n        return target;\n    }\n    EventEmitter.prototype.addListener = function addListener(type, listener) {\n        return _addListener(this, type, listener, false);\n    };\n    EventEmitter.prototype.on = EventEmitter.prototype.addListener;\n    EventEmitter.prototype.prependListener = function prependListener(type, listener) {\n        return _addListener(this, type, listener, true);\n    };\n    function onceWrapper() {\n        if (!this.fired) {\n            this.target.removeListener(this.type, this.wrapFn);\n            this.fired = true;\n            if (arguments.length === 0) return this.listener.call(this.target);\n            return this.listener.apply(this.target, arguments);\n        }\n    }\n    function _onceWrap(target, type, listener) {\n        var state = {\n            fired: false,\n            wrapFn: undefined,\n            target: target,\n            type: type,\n            listener: listener\n        };\n        var wrapped = onceWrapper.bind(state);\n        wrapped.listener = listener;\n        state.wrapFn = wrapped;\n        return wrapped;\n    }\n    EventEmitter.prototype.once = function once(type, listener) {\n        checkListener(listener);\n        this.on(type, _onceWrap(this, type, listener));\n        return this;\n    };\n    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {\n        checkListener(listener);\n        this.prependListener(type, _onceWrap(this, type, listener));\n        return this;\n    };\n    // Emits a 'removeListener' event if and only if the listener was removed.\n    EventEmitter.prototype.removeListener = function removeListener(type, listener) {\n        var list, events, position, i, originalListener;\n        checkListener(listener);\n        events = this._events;\n        if (events === undefined) return this;\n        list = events[type];\n        if (list === undefined) return this;\n        if (list === listener || list.listener === listener) {\n            if (--this._eventsCount === 0) this._events = Object.create(null);\n            else {\n                delete events[type];\n                if (events.removeListener) this.emit(\"removeListener\", type, list.listener || listener);\n            }\n        } else if (typeof list !== \"function\") {\n            position = -1;\n            for(i = list.length - 1; i >= 0; i--){\n                if (list[i] === listener || list[i].listener === listener) {\n                    originalListener = list[i].listener;\n                    position = i;\n                    break;\n                }\n            }\n            if (position < 0) return this;\n            if (position === 0) list.shift();\n            else {\n                spliceOne(list, position);\n            }\n            if (list.length === 1) events[type] = list[0];\n            if (events.removeListener !== undefined) this.emit(\"removeListener\", type, originalListener || listener);\n        }\n        return this;\n    };\n    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {\n        var listeners, events, i;\n        events = this._events;\n        if (events === undefined) return this;\n        // not listening for removeListener, no need to emit\n        if (events.removeListener === undefined) {\n            if (arguments.length === 0) {\n                this._events = Object.create(null);\n                this._eventsCount = 0;\n            } else if (events[type] !== undefined) {\n                if (--this._eventsCount === 0) this._events = Object.create(null);\n                else delete events[type];\n            }\n            return this;\n        }\n        // emit removeListener for all listeners on all events\n        if (arguments.length === 0) {\n            var keys = Object.keys(events);\n            var key;\n            for(i = 0; i < keys.length; ++i){\n                key = keys[i];\n                if (key === \"removeListener\") continue;\n                this.removeAllListeners(key);\n            }\n            this.removeAllListeners(\"removeListener\");\n            this._events = Object.create(null);\n            this._eventsCount = 0;\n            return this;\n        }\n        listeners = events[type];\n        if (typeof listeners === \"function\") {\n            this.removeListener(type, listeners);\n        } else if (listeners !== undefined) {\n            // LIFO order\n            for(i = listeners.length - 1; i >= 0; i--){\n                this.removeListener(type, listeners[i]);\n            }\n        }\n        return this;\n    };\n    function _listeners(target, type, unwrap) {\n        var events = target._events;\n        if (events === undefined) return [];\n        var evlistener = events[type];\n        if (evlistener === undefined) return [];\n        if (typeof evlistener === \"function\") return unwrap ? [\n            evlistener.listener || evlistener\n        ] : [\n            evlistener\n        ];\n        return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n    }\n    EventEmitter.prototype.listeners = function listeners(type) {\n        return _listeners(this, type, true);\n    };\n    EventEmitter.prototype.rawListeners = function rawListeners(type) {\n        return _listeners(this, type, false);\n    };\n    EventEmitter.listenerCount = function(emitter, type) {\n        if (typeof emitter.listenerCount === \"function\") {\n            return emitter.listenerCount(type);\n        } else {\n            return listenerCount.call(emitter, type);\n        }\n    };\n    EventEmitter.prototype.listenerCount = listenerCount;\n    function listenerCount(type) {\n        var events = this._events;\n        if (events !== undefined) {\n            var evlistener = events[type];\n            if (typeof evlistener === \"function\") {\n                return 1;\n            } else if (evlistener !== undefined) {\n                return evlistener.length;\n            }\n        }\n        return 0;\n    }\n    EventEmitter.prototype.eventNames = function eventNames() {\n        return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n    };\n    function arrayClone(arr, n) {\n        var copy = new Array(n);\n        for(var i = 0; i < n; ++i)copy[i] = arr[i];\n        return copy;\n    }\n    function spliceOne(list, index) {\n        for(; index + 1 < list.length; index++)list[index] = list[index + 1];\n        list.pop();\n    }\n    function unwrapListeners(arr) {\n        var ret = new Array(arr.length);\n        for(var i = 0; i < ret.length; ++i){\n            ret[i] = arr[i].listener || arr[i];\n        }\n        return ret;\n    }\n    function once(emitter, name) {\n        return new Promise(function(resolve, reject) {\n            function errorListener(err) {\n                emitter.removeListener(name, resolver);\n                reject(err);\n            }\n            function resolver() {\n                if (typeof emitter.removeListener === \"function\") {\n                    emitter.removeListener(\"error\", errorListener);\n                }\n                resolve([].slice.call(arguments));\n            }\n            eventTargetAgnosticAddListener(emitter, name, resolver, {\n                once: true\n            });\n            if (name !== \"error\") {\n                addErrorHandlerIfEventEmitter(emitter, errorListener, {\n                    once: true\n                });\n            }\n        });\n    }\n    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {\n        if (typeof emitter.on === \"function\") {\n            eventTargetAgnosticAddListener(emitter, \"error\", handler, flags);\n        }\n    }\n    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {\n        if (typeof emitter.on === \"function\") {\n            if (flags.once) {\n                emitter.once(name, listener);\n            } else {\n                emitter.on(name, listener);\n            }\n        } else if (typeof emitter.addEventListener === \"function\") {\n            // EventTarget does not have `error` event semantics like Node\n            // EventEmitters, we do not listen for `error` events here.\n            emitter.addEventListener(name, function wrapListener(arg) {\n                // IE does not have builtin `{ once: true }` support so we\n                // have to do it manually.\n                if (flags.once) {\n                    emitter.removeEventListener(name, wrapListener);\n                }\n                listener(arg);\n            });\n        } else {\n            throw new TypeError('The \"emitter\" argument must be of type EventEmitter. Received type ' + typeof emitter);\n        }\n    }\n    return events.exports;\n}\nvar eventsExports = requireEvents();\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ let logDisabled_ = true;\nlet deprecationWarnings_ = true;\n/**\n * Extract browser version out of the provided user agent string.\n *\n * @param {!string} uastring userAgent string.\n * @param {!string} expr Regular expression used as match criteria.\n * @param {!number} pos position in the version string to be returned.\n * @return {!number} browser version.\n */ function extractVersion(uastring, expr, pos) {\n    const match = uastring.match(expr);\n    return match && match.length >= pos && parseInt(match[pos], 10);\n}\n// Wraps the peerconnection event eventNameToWrap in a function\n// which returns the modified event object (or false to prevent\n// the event).\nfunction wrapPeerConnectionEvent(window1, eventNameToWrap, wrapper) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    const nativeAddEventListener = proto.addEventListener;\n    proto.addEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap) {\n            return nativeAddEventListener.apply(this, arguments);\n        }\n        const wrappedCallback = (e)=>{\n            const modifiedEvent = wrapper(e);\n            if (modifiedEvent) {\n                if (cb.handleEvent) {\n                    cb.handleEvent(modifiedEvent);\n                } else {\n                    cb(modifiedEvent);\n                }\n            }\n        };\n        this._eventMap = this._eventMap || {};\n        if (!this._eventMap[eventNameToWrap]) {\n            this._eventMap[eventNameToWrap] = new Map();\n        }\n        this._eventMap[eventNameToWrap].set(cb, wrappedCallback);\n        return nativeAddEventListener.apply(this, [\n            nativeEventName,\n            wrappedCallback\n        ]);\n    };\n    const nativeRemoveEventListener = proto.removeEventListener;\n    proto.removeEventListener = function(nativeEventName, cb) {\n        if (nativeEventName !== eventNameToWrap || !this._eventMap || !this._eventMap[eventNameToWrap]) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        if (!this._eventMap[eventNameToWrap].has(cb)) {\n            return nativeRemoveEventListener.apply(this, arguments);\n        }\n        const unwrappedCb = this._eventMap[eventNameToWrap].get(cb);\n        this._eventMap[eventNameToWrap].delete(cb);\n        if (this._eventMap[eventNameToWrap].size === 0) {\n            delete this._eventMap[eventNameToWrap];\n        }\n        if (Object.keys(this._eventMap).length === 0) {\n            delete this._eventMap;\n        }\n        return nativeRemoveEventListener.apply(this, [\n            nativeEventName,\n            unwrappedCb\n        ]);\n    };\n    Object.defineProperty(proto, \"on\" + eventNameToWrap, {\n        get () {\n            return this[\"_on\" + eventNameToWrap];\n        },\n        set (cb) {\n            if (this[\"_on\" + eventNameToWrap]) {\n                this.removeEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap]);\n                delete this[\"_on\" + eventNameToWrap];\n            }\n            if (cb) {\n                this.addEventListener(eventNameToWrap, this[\"_on\" + eventNameToWrap] = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n}\nfunction disableLog(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    logDisabled_ = bool;\n    return bool ? \"adapter.js logging disabled\" : \"adapter.js logging enabled\";\n}\n/**\n * Disable or enable deprecation warnings\n * @param {!boolean} bool set to true to disable warnings.\n */ function disableWarnings(bool) {\n    if (typeof bool !== \"boolean\") {\n        return new Error(\"Argument type: \" + typeof bool + \". Please use a boolean.\");\n    }\n    deprecationWarnings_ = !bool;\n    return \"adapter.js deprecation warnings \" + (bool ? \"disabled\" : \"enabled\");\n}\nfunction log() {\n    if (false) {}\n}\n/**\n * Shows a deprecation warning suggesting the modern and spec-compatible API.\n */ function deprecated(oldMethod, newMethod) {\n    if (!deprecationWarnings_) {\n        return;\n    }\n    console.warn(oldMethod + \" is deprecated, please use \" + newMethod + \" instead.\");\n}\n/**\n * Browser detector.\n *\n * @return {object} result containing browser and version\n *     properties.\n */ function detectBrowser(window1) {\n    // Returned result object.\n    const result = {\n        browser: null,\n        version: null\n    };\n    // Fail early if it's not a browser\n    if (typeof window1 === \"undefined\" || !window1.navigator || !window1.navigator.userAgent) {\n        result.browser = \"Not a browser.\";\n        return result;\n    }\n    const { navigator: navigator1 } = window1;\n    // Prefer navigator.userAgentData.\n    if (navigator1.userAgentData && navigator1.userAgentData.brands) {\n        const chromium = navigator1.userAgentData.brands.find((brand)=>{\n            return brand.brand === \"Chromium\";\n        });\n        if (chromium) {\n            return {\n                browser: \"chrome\",\n                version: parseInt(chromium.version, 10)\n            };\n        }\n    }\n    if (navigator1.mozGetUserMedia) {\n        // Firefox.\n        result.browser = \"firefox\";\n        result.version = extractVersion(navigator1.userAgent, /Firefox\\/(\\d+)\\./, 1);\n    } else if (navigator1.webkitGetUserMedia || window1.isSecureContext === false && window1.webkitRTCPeerConnection) {\n        // Chrome, Chromium, Webview, Opera.\n        // Version matches Chrome/WebRTC version.\n        // Chrome 74 removed webkitGetUserMedia on http as well so we need the\n        // more complicated fallback to webkitRTCPeerConnection.\n        result.browser = \"chrome\";\n        result.version = extractVersion(navigator1.userAgent, /Chrom(e|ium)\\/(\\d+)\\./, 2);\n    } else if (window1.RTCPeerConnection && navigator1.userAgent.match(/AppleWebKit\\/(\\d+)\\./)) {\n        // Safari.\n        result.browser = \"safari\";\n        result.version = extractVersion(navigator1.userAgent, /AppleWebKit\\/(\\d+)\\./, 1);\n        result.supportsUnifiedPlan = window1.RTCRtpTransceiver && \"currentDirection\" in window1.RTCRtpTransceiver.prototype;\n    } else {\n        // Default fallthrough: not supported.\n        result.browser = \"Not a supported browser.\";\n        return result;\n    }\n    return result;\n}\n/**\n * Checks if something is an object.\n *\n * @param {*} val The something you want to check.\n * @return true if val is an object, false otherwise.\n */ function isObject(val) {\n    return Object.prototype.toString.call(val) === \"[object Object]\";\n}\n/**\n * Remove all empty objects and undefined values\n * from a nested object -- an enhanced and vanilla version\n * of Lodash's `compact`.\n */ function compactObject(data) {\n    if (!isObject(data)) {\n        return data;\n    }\n    return Object.keys(data).reduce(function(accumulator, key) {\n        const isObj = isObject(data[key]);\n        const value = isObj ? compactObject(data[key]) : data[key];\n        const isEmptyObject = isObj && !Object.keys(value).length;\n        if (value === undefined || isEmptyObject) {\n            return accumulator;\n        }\n        return Object.assign(accumulator, {\n            [key]: value\n        });\n    }, {});\n}\n/* iterates the stats graph recursively. */ function walkStats(stats, base, resultSet) {\n    if (!base || resultSet.has(base.id)) {\n        return;\n    }\n    resultSet.set(base.id, base);\n    Object.keys(base).forEach((name)=>{\n        if (name.endsWith(\"Id\")) {\n            walkStats(stats, stats.get(base[name]), resultSet);\n        } else if (name.endsWith(\"Ids\")) {\n            base[name].forEach((id)=>{\n                walkStats(stats, stats.get(id), resultSet);\n            });\n        }\n    });\n}\n/* filter getStats for a sender/receiver track. */ function filterStats(result, track, outbound) {\n    const streamStatsType = outbound ? \"outbound-rtp\" : \"inbound-rtp\";\n    const filteredResult = new Map();\n    if (track === null) {\n        return filteredResult;\n    }\n    const trackStats = [];\n    result.forEach((value)=>{\n        if (value.type === \"track\" && value.trackIdentifier === track.id) {\n            trackStats.push(value);\n        }\n    });\n    trackStats.forEach((trackStat)=>{\n        result.forEach((stats)=>{\n            if (stats.type === streamStatsType && stats.trackId === trackStat.id) {\n                walkStats(result, stats, filteredResult);\n            }\n        });\n    });\n    return filteredResult;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ const logging = log;\nfunction shimGetUserMedia$2(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    if (!navigator1.mediaDevices) {\n        return;\n    }\n    const constraintsToChrome_ = function(c) {\n        if (typeof c !== \"object\" || c.mandatory || c.optional) {\n            return c;\n        }\n        const cc = {};\n        Object.keys(c).forEach((key)=>{\n            if (key === \"require\" || key === \"advanced\" || key === \"mediaSource\") {\n                return;\n            }\n            const r = typeof c[key] === \"object\" ? c[key] : {\n                ideal: c[key]\n            };\n            if (r.exact !== undefined && typeof r.exact === \"number\") {\n                r.min = r.max = r.exact;\n            }\n            const oldname_ = function(prefix, name) {\n                if (prefix) {\n                    return prefix + name.charAt(0).toUpperCase() + name.slice(1);\n                }\n                return name === \"deviceId\" ? \"sourceId\" : name;\n            };\n            if (r.ideal !== undefined) {\n                cc.optional = cc.optional || [];\n                let oc = {};\n                if (typeof r.ideal === \"number\") {\n                    oc[oldname_(\"min\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                    oc = {};\n                    oc[oldname_(\"max\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                } else {\n                    oc[oldname_(\"\", key)] = r.ideal;\n                    cc.optional.push(oc);\n                }\n            }\n            if (r.exact !== undefined && typeof r.exact !== \"number\") {\n                cc.mandatory = cc.mandatory || {};\n                cc.mandatory[oldname_(\"\", key)] = r.exact;\n            } else {\n                [\n                    \"min\",\n                    \"max\"\n                ].forEach((mix)=>{\n                    if (r[mix] !== undefined) {\n                        cc.mandatory = cc.mandatory || {};\n                        cc.mandatory[oldname_(mix, key)] = r[mix];\n                    }\n                });\n            }\n        });\n        if (c.advanced) {\n            cc.optional = (cc.optional || []).concat(c.advanced);\n        }\n        return cc;\n    };\n    const shimConstraints_ = function(constraints, func) {\n        if (browserDetails.version >= 61) {\n            return func(constraints);\n        }\n        constraints = JSON.parse(JSON.stringify(constraints));\n        if (constraints && typeof constraints.audio === \"object\") {\n            const remap = function(obj, a, b) {\n                if (a in obj && !(b in obj)) {\n                    obj[b] = obj[a];\n                    delete obj[a];\n                }\n            };\n            constraints = JSON.parse(JSON.stringify(constraints));\n            remap(constraints.audio, \"autoGainControl\", \"googAutoGainControl\");\n            remap(constraints.audio, \"noiseSuppression\", \"googNoiseSuppression\");\n            constraints.audio = constraintsToChrome_(constraints.audio);\n        }\n        if (constraints && typeof constraints.video === \"object\") {\n            // Shim facingMode for mobile & surface pro.\n            let face = constraints.video.facingMode;\n            face = face && (typeof face === \"object\" ? face : {\n                ideal: face\n            });\n            const getSupportedFacingModeLies = browserDetails.version < 66;\n            if (face && (face.exact === \"user\" || face.exact === \"environment\" || face.ideal === \"user\" || face.ideal === \"environment\") && !(navigator1.mediaDevices.getSupportedConstraints && navigator1.mediaDevices.getSupportedConstraints().facingMode && !getSupportedFacingModeLies)) {\n                delete constraints.video.facingMode;\n                let matches;\n                if (face.exact === \"environment\" || face.ideal === \"environment\") {\n                    matches = [\n                        \"back\",\n                        \"rear\"\n                    ];\n                } else if (face.exact === \"user\" || face.ideal === \"user\") {\n                    matches = [\n                        \"front\"\n                    ];\n                }\n                if (matches) {\n                    // Look for matches in label, or use last cam for back (typical).\n                    return navigator1.mediaDevices.enumerateDevices().then((devices)=>{\n                        devices = devices.filter((d)=>d.kind === \"videoinput\");\n                        let dev = devices.find((d)=>matches.some((match)=>d.label.toLowerCase().includes(match)));\n                        if (!dev && devices.length && matches.includes(\"back\")) {\n                            dev = devices[devices.length - 1]; // more likely the back cam\n                        }\n                        if (dev) {\n                            constraints.video.deviceId = face.exact ? {\n                                exact: dev.deviceId\n                            } : {\n                                ideal: dev.deviceId\n                            };\n                        }\n                        constraints.video = constraintsToChrome_(constraints.video);\n                        logging(\"chrome: \" + JSON.stringify(constraints));\n                        return func(constraints);\n                    });\n                }\n            }\n            constraints.video = constraintsToChrome_(constraints.video);\n        }\n        logging(\"chrome: \" + JSON.stringify(constraints));\n        return func(constraints);\n    };\n    const shimError_ = function(e) {\n        if (browserDetails.version >= 64) {\n            return e;\n        }\n        return {\n            name: ({\n                PermissionDeniedError: \"NotAllowedError\",\n                PermissionDismissedError: \"NotAllowedError\",\n                InvalidStateError: \"NotAllowedError\",\n                DevicesNotFoundError: \"NotFoundError\",\n                ConstraintNotSatisfiedError: \"OverconstrainedError\",\n                TrackStartError: \"NotReadableError\",\n                MediaDeviceFailedDueToShutdown: \"NotAllowedError\",\n                MediaDeviceKillSwitchOn: \"NotAllowedError\",\n                TabCaptureError: \"AbortError\",\n                ScreenCaptureError: \"AbortError\",\n                DeviceCaptureError: \"AbortError\"\n            })[e.name] || e.name,\n            message: e.message,\n            constraint: e.constraint || e.constraintName,\n            toString () {\n                return this.name + (this.message && \": \") + this.message;\n            }\n        };\n    };\n    const getUserMedia_ = function(constraints, onSuccess, onError) {\n        shimConstraints_(constraints, (c)=>{\n            navigator1.webkitGetUserMedia(c, onSuccess, (e)=>{\n                if (onError) {\n                    onError(shimError_(e));\n                }\n            });\n        });\n    };\n    navigator1.getUserMedia = getUserMedia_.bind(navigator1);\n    // Even though Chrome 45 has navigator.mediaDevices and a getUserMedia\n    // function which returns a Promise, it does not accept spec-style\n    // constraints.\n    if (navigator1.mediaDevices.getUserMedia) {\n        const origGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(cs) {\n            return shimConstraints_(cs, (c)=>origGetUserMedia(c).then((stream)=>{\n                    if (c.audio && !stream.getAudioTracks().length || c.video && !stream.getVideoTracks().length) {\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                        throw new DOMException(\"\", \"NotFoundError\");\n                    }\n                    return stream;\n                }, (e)=>Promise.reject(shimError_(e))));\n        };\n    }\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimMediaStream(window1) {\n    window1.MediaStream = window1.MediaStream || window1.webkitMediaStream;\n}\nfunction shimOnTrack$1(window1) {\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"ontrack\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"ontrack\", {\n            get () {\n                return this._ontrack;\n            },\n            set (f) {\n                if (this._ontrack) {\n                    this.removeEventListener(\"track\", this._ontrack);\n                }\n                this.addEventListener(\"track\", this._ontrack = f);\n            },\n            enumerable: true,\n            configurable: true\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            if (!this._ontrackpoly) {\n                this._ontrackpoly = (e)=>{\n                    // onaddstream does not fire when a track is added to an existing\n                    // stream. But stream.onaddtrack is implemented so we use that.\n                    e.stream.addEventListener(\"addtrack\", (te)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === te.track.id);\n                        } else {\n                            receiver = {\n                                track: te.track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = te.track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                    e.stream.getTracks().forEach((track)=>{\n                        let receiver;\n                        if (window1.RTCPeerConnection.prototype.getReceivers) {\n                            receiver = this.getReceivers().find((r)=>r.track && r.track.id === track.id);\n                        } else {\n                            receiver = {\n                                track\n                            };\n                        }\n                        const event = new Event(\"track\");\n                        event.track = track;\n                        event.receiver = receiver;\n                        event.transceiver = {\n                            receiver\n                        };\n                        event.streams = [\n                            e.stream\n                        ];\n                        this.dispatchEvent(event);\n                    });\n                };\n                this.addEventListener(\"addstream\", this._ontrackpoly);\n            }\n            return origSetRemoteDescription.apply(this, arguments);\n        };\n    } else {\n        // even if RTCRtpTransceiver is in window, it is only used and\n        // emitted in unified-plan. Unfortunately this means we need\n        // to unconditionally wrap the event.\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            if (!e.transceiver) {\n                Object.defineProperty(e, \"transceiver\", {\n                    value: {\n                        receiver: e.receiver\n                    }\n                });\n            }\n            return e;\n        });\n    }\n}\nfunction shimGetSendersWithDtmf(window1) {\n    // Overrides addTrack/removeTrack, depends on shimAddTrackRemoveTrack.\n    if (typeof window1 === \"object\" && window1.RTCPeerConnection && !(\"getSenders\" in window1.RTCPeerConnection.prototype) && \"createDTMFSender\" in window1.RTCPeerConnection.prototype) {\n        const shimSenderWithDtmf = function(pc, track) {\n            return {\n                track,\n                get dtmf () {\n                    if (this._dtmf === undefined) {\n                        if (track.kind === \"audio\") {\n                            this._dtmf = pc.createDTMFSender(track);\n                        } else {\n                            this._dtmf = null;\n                        }\n                    }\n                    return this._dtmf;\n                },\n                _pc: pc\n            };\n        };\n        // augment addTrack when getSenders is not available.\n        if (!window1.RTCPeerConnection.prototype.getSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                this._senders = this._senders || [];\n                return this._senders.slice(); // return a copy of the internal state.\n            };\n            const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n                let sender = origAddTrack.apply(this, arguments);\n                if (!sender) {\n                    sender = shimSenderWithDtmf(this, track);\n                    this._senders.push(sender);\n                }\n                return sender;\n            };\n            const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n            window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n                origRemoveTrack.apply(this, arguments);\n                const idx = this._senders.indexOf(sender);\n                if (idx !== -1) {\n                    this._senders.splice(idx, 1);\n                }\n            };\n        }\n        const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            this._senders = this._senders || [];\n            origAddStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                this._senders.push(shimSenderWithDtmf(this, track));\n            });\n        };\n        const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            this._senders = this._senders || [];\n            origRemoveStream.apply(this, [\n                stream\n            ]);\n            stream.getTracks().forEach((track)=>{\n                const sender = this._senders.find((s)=>s.track === track);\n                if (sender) {\n                    // remove sender\n                    this._senders.splice(this._senders.indexOf(sender), 1);\n                }\n            });\n        };\n    } else if (typeof window1 === \"object\" && window1.RTCPeerConnection && \"getSenders\" in window1.RTCPeerConnection.prototype && \"createDTMFSender\" in window1.RTCPeerConnection.prototype && window1.RTCRtpSender && !(\"dtmf\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n        Object.defineProperty(window1.RTCRtpSender.prototype, \"dtmf\", {\n            get () {\n                if (this._dtmf === undefined) {\n                    if (this.track.kind === \"audio\") {\n                        this._dtmf = this._pc.createDTMFSender(this.track);\n                    } else {\n                        this._dtmf = null;\n                    }\n                }\n                return this._dtmf;\n            }\n        });\n    }\n}\nfunction shimSenderReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender && window1.RTCRtpReceiver)) {\n        return;\n    }\n    // shim sender stats.\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype)) {\n        const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n        if (origGetSenders) {\n            window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n                const senders = origGetSenders.apply(this, []);\n                senders.forEach((sender)=>sender._pc = this);\n                return senders;\n            };\n        }\n        const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n        if (origAddTrack) {\n            window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n                const sender = origAddTrack.apply(this, arguments);\n                sender._pc = this;\n                return sender;\n            };\n        }\n        window1.RTCRtpSender.prototype.getStats = function getStats() {\n            const sender = this;\n            return this._pc.getStats().then((result)=>/* Note: this will include stats of all senders that\n       *   send a track with the same id as sender.track as\n       *   it is not possible to identify the RTCRtpSender.\n       */ filterStats(result, sender.track, true));\n        };\n    }\n    // shim receiver stats.\n    if (!(\"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n        if (origGetReceivers) {\n            window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n                const receivers = origGetReceivers.apply(this, []);\n                receivers.forEach((receiver)=>receiver._pc = this);\n                return receivers;\n            };\n        }\n        wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n            e.receiver._pc = e.srcElement;\n            return e;\n        });\n        window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n            const receiver = this;\n            return this._pc.getStats().then((result)=>filterStats(result, receiver.track, false));\n        };\n    }\n    if (!(\"getStats\" in window1.RTCRtpSender.prototype && \"getStats\" in window1.RTCRtpReceiver.prototype)) {\n        return;\n    }\n    // shim RTCPeerConnection.getStats(track).\n    const origGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        if (arguments.length > 0 && arguments[0] instanceof window1.MediaStreamTrack) {\n            const track = arguments[0];\n            let sender;\n            let receiver;\n            let err;\n            this.getSenders().forEach((s)=>{\n                if (s.track === track) {\n                    if (sender) {\n                        err = true;\n                    } else {\n                        sender = s;\n                    }\n                }\n            });\n            this.getReceivers().forEach((r)=>{\n                if (r.track === track) {\n                    if (receiver) {\n                        err = true;\n                    } else {\n                        receiver = r;\n                    }\n                }\n                return r.track === track;\n            });\n            if (err || sender && receiver) {\n                return Promise.reject(new DOMException(\"There are more than one sender or receiver for the track.\", \"InvalidAccessError\"));\n            } else if (sender) {\n                return sender.getStats();\n            } else if (receiver) {\n                return receiver.getStats();\n            }\n            return Promise.reject(new DOMException(\"There is no sender or receiver for the track.\", \"InvalidAccessError\"));\n        }\n        return origGetStats.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrackWithNative(window1) {\n    // shim addTrack/removeTrack with native variants in order to make\n    // the interactions with legacy getLocalStreams behave as in other browsers.\n    // Keeps a mapping stream.id => [stream, rtpsenders...]\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        return Object.keys(this._shimmedLocalStreams).map((streamId)=>this._shimmedLocalStreams[streamId][0]);\n    };\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (!stream) {\n            return origAddTrack.apply(this, arguments);\n        }\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        const sender = origAddTrack.apply(this, arguments);\n        if (!this._shimmedLocalStreams[stream.id]) {\n            this._shimmedLocalStreams[stream.id] = [\n                stream,\n                sender\n            ];\n        } else if (this._shimmedLocalStreams[stream.id].indexOf(sender) === -1) {\n            this._shimmedLocalStreams[stream.id].push(sender);\n        }\n        return sender;\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        const existingSenders = this.getSenders();\n        origAddStream.apply(this, arguments);\n        const newSenders = this.getSenders().filter((newSender)=>existingSenders.indexOf(newSender) === -1);\n        this._shimmedLocalStreams[stream.id] = [\n            stream\n        ].concat(newSenders);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        delete this._shimmedLocalStreams[stream.id];\n        return origRemoveStream.apply(this, arguments);\n    };\n    const origRemoveTrack = window1.RTCPeerConnection.prototype.removeTrack;\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        this._shimmedLocalStreams = this._shimmedLocalStreams || {};\n        if (sender) {\n            Object.keys(this._shimmedLocalStreams).forEach((streamId)=>{\n                const idx = this._shimmedLocalStreams[streamId].indexOf(sender);\n                if (idx !== -1) {\n                    this._shimmedLocalStreams[streamId].splice(idx, 1);\n                }\n                if (this._shimmedLocalStreams[streamId].length === 1) {\n                    delete this._shimmedLocalStreams[streamId];\n                }\n            });\n        }\n        return origRemoveTrack.apply(this, arguments);\n    };\n}\nfunction shimAddTrackRemoveTrack(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim addTrack and removeTrack.\n    if (window1.RTCPeerConnection.prototype.addTrack && browserDetails.version >= 65) {\n        return shimAddTrackRemoveTrackWithNative(window1);\n    }\n    // also shim pc.getLocalStreams when addTrack is shimmed\n    // to return the original streams.\n    const origGetLocalStreams = window1.RTCPeerConnection.prototype.getLocalStreams;\n    window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n        const nativeStreams = origGetLocalStreams.apply(this);\n        this._reverseStreams = this._reverseStreams || {};\n        return nativeStreams.map((stream)=>this._reverseStreams[stream.id]);\n    };\n    const origAddStream = window1.RTCPeerConnection.prototype.addStream;\n    window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        stream.getTracks().forEach((track)=>{\n            const alreadyExists = this.getSenders().find((s)=>s.track === track);\n            if (alreadyExists) {\n                throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n            }\n        });\n        // Add identity mapping for consistency with addTrack.\n        // Unless this is being used with a stream from addTrack.\n        if (!this._reverseStreams[stream.id]) {\n            const newStream = new window1.MediaStream(stream.getTracks());\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            stream = newStream;\n        }\n        origAddStream.apply(this, [\n            stream\n        ]);\n    };\n    const origRemoveStream = window1.RTCPeerConnection.prototype.removeStream;\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        origRemoveStream.apply(this, [\n            this._streams[stream.id] || stream\n        ]);\n        delete this._reverseStreams[this._streams[stream.id] ? this._streams[stream.id].id : stream.id];\n        delete this._streams[stream.id];\n    };\n    window1.RTCPeerConnection.prototype.addTrack = function addTrack(track, stream) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        const streams = [].slice.call(arguments, 1);\n        if (streams.length !== 1 || !streams[0].getTracks().find((t)=>t === track)) {\n            // this is not fully correct but all we can manage without\n            // [[associated MediaStreams]] internal slot.\n            throw new DOMException(\"The adapter.js addTrack polyfill only supports a single \" + \" stream which is associated with the specified track.\", \"NotSupportedError\");\n        }\n        const alreadyExists = this.getSenders().find((s)=>s.track === track);\n        if (alreadyExists) {\n            throw new DOMException(\"Track already exists.\", \"InvalidAccessError\");\n        }\n        this._streams = this._streams || {};\n        this._reverseStreams = this._reverseStreams || {};\n        const oldStream = this._streams[stream.id];\n        if (oldStream) {\n            // this is using odd Chrome behaviour, use with caution:\n            // https://bugs.chromium.org/p/webrtc/issues/detail?id=7815\n            // Note: we rely on the high-level addTrack/dtmf shim to\n            // create the sender with a dtmf sender.\n            oldStream.addTrack(track);\n            // Trigger ONN async.\n            Promise.resolve().then(()=>{\n                this.dispatchEvent(new Event(\"negotiationneeded\"));\n            });\n        } else {\n            const newStream = new window1.MediaStream([\n                track\n            ]);\n            this._streams[stream.id] = newStream;\n            this._reverseStreams[newStream.id] = stream;\n            this.addStream(newStream);\n        }\n        return this.getSenders().find((s)=>s.track === track);\n    };\n    // replace the internal stream id with the external one and\n    // vice versa.\n    function replaceInternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(internalStream.id, \"g\"), externalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    function replaceExternalStreamId(pc, description) {\n        let sdp = description.sdp;\n        Object.keys(pc._reverseStreams || []).forEach((internalId)=>{\n            const externalStream = pc._reverseStreams[internalId];\n            const internalStream = pc._streams[externalStream.id];\n            sdp = sdp.replace(new RegExp(externalStream.id, \"g\"), internalStream.id);\n        });\n        return new RTCSessionDescription({\n            type: description.type,\n            sdp\n        });\n    }\n    [\n        \"createOffer\",\n        \"createAnswer\"\n    ].forEach(function(method) {\n        const nativeMethod = window1.RTCPeerConnection.prototype[method];\n        const methodObj = {\n            [method] () {\n                const args = arguments;\n                const isLegacyCall = arguments.length && typeof arguments[0] === \"function\";\n                if (isLegacyCall) {\n                    return nativeMethod.apply(this, [\n                        (description)=>{\n                            const desc = replaceInternalStreamId(this, description);\n                            args[0].apply(null, [\n                                desc\n                            ]);\n                        },\n                        (err)=>{\n                            if (args[1]) {\n                                args[1].apply(null, err);\n                            }\n                        },\n                        arguments[2]\n                    ]);\n                }\n                return nativeMethod.apply(this, arguments).then((description)=>replaceInternalStreamId(this, description));\n            }\n        };\n        window1.RTCPeerConnection.prototype[method] = methodObj[method];\n    });\n    const origSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        if (!arguments.length || !arguments[0].type) {\n            return origSetLocalDescription.apply(this, arguments);\n        }\n        arguments[0] = replaceExternalStreamId(this, arguments[0]);\n        return origSetLocalDescription.apply(this, arguments);\n    };\n    // TODO: mangle getStats: https://w3c.github.io/webrtc-stats/#dom-rtcmediastreamstats-streamidentifier\n    const origLocalDescription = Object.getOwnPropertyDescriptor(window1.RTCPeerConnection.prototype, \"localDescription\");\n    Object.defineProperty(window1.RTCPeerConnection.prototype, \"localDescription\", {\n        get () {\n            const description = origLocalDescription.get.apply(this);\n            if (description.type === \"\") {\n                return description;\n            }\n            return replaceInternalStreamId(this, description);\n        }\n    });\n    window1.RTCPeerConnection.prototype.removeTrack = function removeTrack(sender) {\n        if (this.signalingState === \"closed\") {\n            throw new DOMException(\"The RTCPeerConnection's signalingState is 'closed'.\", \"InvalidStateError\");\n        }\n        // We can not yet check for sender instanceof RTCRtpSender\n        // since we shim RTPSender. So we check if sender._pc is set.\n        if (!sender._pc) {\n            throw new DOMException(\"Argument 1 of RTCPeerConnection.removeTrack \" + \"does not implement interface RTCRtpSender.\", \"TypeError\");\n        }\n        const isLocal = sender._pc === this;\n        if (!isLocal) {\n            throw new DOMException(\"Sender was not created by this connection.\", \"InvalidAccessError\");\n        }\n        // Search for the native stream the senders track belongs to.\n        this._streams = this._streams || {};\n        let stream;\n        Object.keys(this._streams).forEach((streamid)=>{\n            const hasTrack = this._streams[streamid].getTracks().find((track)=>sender.track === track);\n            if (hasTrack) {\n                stream = this._streams[streamid];\n            }\n        });\n        if (stream) {\n            if (stream.getTracks().length === 1) {\n                // if this is the last track of the stream, remove the stream. This\n                // takes care of any shimmed _senders.\n                this.removeStream(this._reverseStreams[stream.id]);\n            } else {\n                // relying on the same odd chrome behaviour as above.\n                stream.removeTrack(sender.track);\n            }\n            this.dispatchEvent(new Event(\"negotiationneeded\"));\n        }\n    };\n}\nfunction shimPeerConnection$1(window1, browserDetails) {\n    if (!window1.RTCPeerConnection && window1.webkitRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.webkitRTCPeerConnection;\n    }\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // shim implicit creation of RTCSessionDescription/RTCIceCandidate\n    if (browserDetails.version < 53) {\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n}\n// Attempt to fix ONN in plan-b mode.\nfunction fixNegotiationNeeded(window1, browserDetails) {\n    wrapPeerConnectionEvent(window1, \"negotiationneeded\", (e)=>{\n        const pc = e.target;\n        if (browserDetails.version < 72 || pc.getConfiguration && pc.getConfiguration().sdpSemantics === \"plan-b\") {\n            if (pc.signalingState !== \"stable\") {\n                return;\n            }\n        }\n        return e;\n    });\n}\nvar chromeShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    fixNegotiationNeeded: fixNegotiationNeeded,\n    shimAddTrackRemoveTrack: shimAddTrackRemoveTrack,\n    shimAddTrackRemoveTrackWithNative: shimAddTrackRemoveTrackWithNative,\n    shimGetSendersWithDtmf: shimGetSendersWithDtmf,\n    shimGetUserMedia: shimGetUserMedia$2,\n    shimMediaStream: shimMediaStream,\n    shimOnTrack: shimOnTrack$1,\n    shimPeerConnection: shimPeerConnection$1,\n    shimSenderReceiverGetStats: shimSenderReceiverGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetUserMedia$1(window1, browserDetails) {\n    const navigator1 = window1 && window1.navigator;\n    const MediaStreamTrack1 = window1 && window1.MediaStreamTrack;\n    navigator1.getUserMedia = function(constraints, onSuccess, onError) {\n        // Replace Firefox 44+'s deprecation warning with unprefixed version.\n        deprecated(\"navigator.getUserMedia\", \"navigator.mediaDevices.getUserMedia\");\n        navigator1.mediaDevices.getUserMedia(constraints).then(onSuccess, onError);\n    };\n    if (!(browserDetails.version > 55 && \"autoGainControl\" in navigator1.mediaDevices.getSupportedConstraints())) {\n        const remap = function(obj, a, b) {\n            if (a in obj && !(b in obj)) {\n                obj[b] = obj[a];\n                delete obj[a];\n            }\n        };\n        const nativeGetUserMedia = navigator1.mediaDevices.getUserMedia.bind(navigator1.mediaDevices);\n        navigator1.mediaDevices.getUserMedia = function(c) {\n            if (typeof c === \"object\" && typeof c.audio === \"object\") {\n                c = JSON.parse(JSON.stringify(c));\n                remap(c.audio, \"autoGainControl\", \"mozAutoGainControl\");\n                remap(c.audio, \"noiseSuppression\", \"mozNoiseSuppression\");\n            }\n            return nativeGetUserMedia(c);\n        };\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.getSettings) {\n            const nativeGetSettings = MediaStreamTrack1.prototype.getSettings;\n            MediaStreamTrack1.prototype.getSettings = function() {\n                const obj = nativeGetSettings.apply(this, arguments);\n                remap(obj, \"mozAutoGainControl\", \"autoGainControl\");\n                remap(obj, \"mozNoiseSuppression\", \"noiseSuppression\");\n                return obj;\n            };\n        }\n        if (MediaStreamTrack1 && MediaStreamTrack1.prototype.applyConstraints) {\n            const nativeApplyConstraints = MediaStreamTrack1.prototype.applyConstraints;\n            MediaStreamTrack1.prototype.applyConstraints = function(c) {\n                if (this.kind === \"audio\" && typeof c === \"object\") {\n                    c = JSON.parse(JSON.stringify(c));\n                    remap(c, \"autoGainControl\", \"mozAutoGainControl\");\n                    remap(c, \"noiseSuppression\", \"mozNoiseSuppression\");\n                }\n                return nativeApplyConstraints.apply(this, [\n                    c\n                ]);\n            };\n        }\n    }\n}\n/*\n *  Copyright (c) 2018 The adapter.js project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimGetDisplayMedia(window1, preferredMediaSource) {\n    if (window1.navigator.mediaDevices && \"getDisplayMedia\" in window1.navigator.mediaDevices) {\n        return;\n    }\n    if (!window1.navigator.mediaDevices) {\n        return;\n    }\n    window1.navigator.mediaDevices.getDisplayMedia = function getDisplayMedia(constraints) {\n        if (!(constraints && constraints.video)) {\n            const err = new DOMException(\"getDisplayMedia without video \" + \"constraints is undefined\");\n            err.name = \"NotFoundError\";\n            // from https://heycam.github.io/webidl/#idl-DOMException-error-names\n            err.code = 8;\n            return Promise.reject(err);\n        }\n        if (constraints.video === true) {\n            constraints.video = {\n                mediaSource: preferredMediaSource\n            };\n        } else {\n            constraints.video.mediaSource = preferredMediaSource;\n        }\n        return window1.navigator.mediaDevices.getUserMedia(constraints);\n    };\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimOnTrack(window1) {\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimPeerConnection(window1, browserDetails) {\n    if (typeof window1 !== \"object\" || !(window1.RTCPeerConnection || window1.mozRTCPeerConnection)) {\n        return; // probably media.peerconnection.enabled=false in about:config\n    }\n    if (!window1.RTCPeerConnection && window1.mozRTCPeerConnection) {\n        // very basic support for old versions.\n        window1.RTCPeerConnection = window1.mozRTCPeerConnection;\n    }\n    if (browserDetails.version < 53) {\n        // shim away need for obsolete RTCIceCandidate/RTCSessionDescription.\n        [\n            \"setLocalDescription\",\n            \"setRemoteDescription\",\n            \"addIceCandidate\"\n        ].forEach(function(method) {\n            const nativeMethod = window1.RTCPeerConnection.prototype[method];\n            const methodObj = {\n                [method] () {\n                    arguments[0] = new (method === \"addIceCandidate\" ? window1.RTCIceCandidate : window1.RTCSessionDescription)(arguments[0]);\n                    return nativeMethod.apply(this, arguments);\n                }\n            };\n            window1.RTCPeerConnection.prototype[method] = methodObj[method];\n        });\n    }\n    const modernStatsTypes = {\n        inboundrtp: \"inbound-rtp\",\n        outboundrtp: \"outbound-rtp\",\n        candidatepair: \"candidate-pair\",\n        localcandidate: \"local-candidate\",\n        remotecandidate: \"remote-candidate\"\n    };\n    const nativeGetStats = window1.RTCPeerConnection.prototype.getStats;\n    window1.RTCPeerConnection.prototype.getStats = function getStats() {\n        const [selector, onSucc, onErr] = arguments;\n        return nativeGetStats.apply(this, [\n            selector || null\n        ]).then((stats)=>{\n            if (browserDetails.version < 53 && !onSucc) {\n                // Shim only promise getStats with spec-hyphens in type names\n                // Leave callback version alone; misc old uses of forEach before Map\n                try {\n                    stats.forEach((stat)=>{\n                        stat.type = modernStatsTypes[stat.type] || stat.type;\n                    });\n                } catch (e) {\n                    if (e.name !== \"TypeError\") {\n                        throw e;\n                    }\n                    // Avoid TypeError: \"type\" is read-only, in old versions. 34-43ish\n                    stats.forEach((stat, i)=>{\n                        stats.set(i, Object.assign({}, stat, {\n                            type: modernStatsTypes[stat.type] || stat.type\n                        }));\n                    });\n                }\n            }\n            return stats;\n        }).then(onSucc, onErr);\n    };\n}\nfunction shimSenderGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpSender.prototype) {\n        return;\n    }\n    const origGetSenders = window1.RTCPeerConnection.prototype.getSenders;\n    if (origGetSenders) {\n        window1.RTCPeerConnection.prototype.getSenders = function getSenders() {\n            const senders = origGetSenders.apply(this, []);\n            senders.forEach((sender)=>sender._pc = this);\n            return senders;\n        };\n    }\n    const origAddTrack = window1.RTCPeerConnection.prototype.addTrack;\n    if (origAddTrack) {\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack() {\n            const sender = origAddTrack.apply(this, arguments);\n            sender._pc = this;\n            return sender;\n        };\n    }\n    window1.RTCRtpSender.prototype.getStats = function getStats() {\n        return this.track ? this._pc.getStats(this.track) : Promise.resolve(new Map());\n    };\n}\nfunction shimReceiverGetStats(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection && window1.RTCRtpSender)) {\n        return;\n    }\n    if (window1.RTCRtpSender && \"getStats\" in window1.RTCRtpReceiver.prototype) {\n        return;\n    }\n    const origGetReceivers = window1.RTCPeerConnection.prototype.getReceivers;\n    if (origGetReceivers) {\n        window1.RTCPeerConnection.prototype.getReceivers = function getReceivers() {\n            const receivers = origGetReceivers.apply(this, []);\n            receivers.forEach((receiver)=>receiver._pc = this);\n            return receivers;\n        };\n    }\n    wrapPeerConnectionEvent(window1, \"track\", (e)=>{\n        e.receiver._pc = e.srcElement;\n        return e;\n    });\n    window1.RTCRtpReceiver.prototype.getStats = function getStats() {\n        return this._pc.getStats(this.track);\n    };\n}\nfunction shimRemoveStream(window1) {\n    if (!window1.RTCPeerConnection || \"removeStream\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n        deprecated(\"removeStream\", \"removeTrack\");\n        this.getSenders().forEach((sender)=>{\n            if (sender.track && stream.getTracks().includes(sender.track)) {\n                this.removeTrack(sender);\n            }\n        });\n    };\n}\nfunction shimRTCDataChannel(window1) {\n    // rename DataChannel to RTCDataChannel (native fix in FF60):\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1173851\n    if (window1.DataChannel && !window1.RTCDataChannel) {\n        window1.RTCDataChannel = window1.DataChannel;\n    }\n}\nfunction shimAddTransceiver(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origAddTransceiver = window1.RTCPeerConnection.prototype.addTransceiver;\n    if (origAddTransceiver) {\n        window1.RTCPeerConnection.prototype.addTransceiver = function addTransceiver() {\n            this.setParametersPromises = [];\n            // WebIDL input coercion and validation\n            let sendEncodings = arguments[1] && arguments[1].sendEncodings;\n            if (sendEncodings === undefined) {\n                sendEncodings = [];\n            }\n            sendEncodings = [\n                ...sendEncodings\n            ];\n            const shouldPerformCheck = sendEncodings.length > 0;\n            if (shouldPerformCheck) {\n                // If sendEncodings params are provided, validate grammar\n                sendEncodings.forEach((encodingParam)=>{\n                    if (\"rid\" in encodingParam) {\n                        const ridRegex = /^[a-z0-9]{0,16}$/i;\n                        if (!ridRegex.test(encodingParam.rid)) {\n                            throw new TypeError(\"Invalid RID value provided.\");\n                        }\n                    }\n                    if (\"scaleResolutionDownBy\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.scaleResolutionDownBy) >= 1.0)) {\n                            throw new RangeError(\"scale_resolution_down_by must be >= 1.0\");\n                        }\n                    }\n                    if (\"maxFramerate\" in encodingParam) {\n                        if (!(parseFloat(encodingParam.maxFramerate) >= 0)) {\n                            throw new RangeError(\"max_framerate must be >= 0.0\");\n                        }\n                    }\n                });\n            }\n            const transceiver = origAddTransceiver.apply(this, arguments);\n            if (shouldPerformCheck) {\n                // Check if the init options were applied. If not we do this in an\n                // asynchronous way and save the promise reference in a global object.\n                // This is an ugly hack, but at the same time is way more robust than\n                // checking the sender parameters before and after the createOffer\n                // Also note that after the createoffer we are not 100% sure that\n                // the params were asynchronously applied so we might miss the\n                // opportunity to recreate offer.\n                const { sender } = transceiver;\n                const params = sender.getParameters();\n                if (!(\"encodings\" in params) || // Avoid being fooled by patched getParameters() below.\n                params.encodings.length === 1 && Object.keys(params.encodings[0]).length === 0) {\n                    params.encodings = sendEncodings;\n                    sender.sendEncodings = sendEncodings;\n                    this.setParametersPromises.push(sender.setParameters(params).then(()=>{\n                        delete sender.sendEncodings;\n                    }).catch(()=>{\n                        delete sender.sendEncodings;\n                    }));\n                }\n            }\n            return transceiver;\n        };\n    }\n}\nfunction shimGetParameters(window1) {\n    if (!(typeof window1 === \"object\" && window1.RTCRtpSender)) {\n        return;\n    }\n    const origGetParameters = window1.RTCRtpSender.prototype.getParameters;\n    if (origGetParameters) {\n        window1.RTCRtpSender.prototype.getParameters = function getParameters() {\n            const params = origGetParameters.apply(this, arguments);\n            if (!(\"encodings\" in params)) {\n                params.encodings = [].concat(this.sendEncodings || [\n                    {}\n                ]);\n            }\n            return params;\n        };\n    }\n}\nfunction shimCreateOffer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateOffer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimCreateAnswer(window1) {\n    // https://github.com/webrtcHacks/adapter/issues/998#issuecomment-516921647\n    // Firefox ignores the init sendEncodings options passed to addTransceiver\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1396918\n    if (!(typeof window1 === \"object\" && window1.RTCPeerConnection)) {\n        return;\n    }\n    const origCreateAnswer = window1.RTCPeerConnection.prototype.createAnswer;\n    window1.RTCPeerConnection.prototype.createAnswer = function createAnswer() {\n        if (this.setParametersPromises && this.setParametersPromises.length) {\n            return Promise.all(this.setParametersPromises).then(()=>{\n                return origCreateAnswer.apply(this, arguments);\n            }).finally(()=>{\n                this.setParametersPromises = [];\n            });\n        }\n        return origCreateAnswer.apply(this, arguments);\n    };\n}\nvar firefoxShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAddTransceiver: shimAddTransceiver,\n    shimCreateAnswer: shimCreateAnswer,\n    shimCreateOffer: shimCreateOffer,\n    shimGetDisplayMedia: shimGetDisplayMedia,\n    shimGetParameters: shimGetParameters,\n    shimGetUserMedia: shimGetUserMedia$1,\n    shimOnTrack: shimOnTrack,\n    shimPeerConnection: shimPeerConnection,\n    shimRTCDataChannel: shimRTCDataChannel,\n    shimReceiverGetStats: shimReceiverGetStats,\n    shimRemoveStream: shimRemoveStream,\n    shimSenderGetStats: shimSenderGetStats\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ function shimLocalStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getLocalStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getLocalStreams = function getLocalStreams() {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            return this._localStreams;\n        };\n    }\n    if (!(\"addStream\" in window1.RTCPeerConnection.prototype)) {\n        const _addTrack = window1.RTCPeerConnection.prototype.addTrack;\n        window1.RTCPeerConnection.prototype.addStream = function addStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            if (!this._localStreams.includes(stream)) {\n                this._localStreams.push(stream);\n            }\n            // Try to emulate Chrome's behaviour of adding in audio-video order.\n            // Safari orders by track id.\n            stream.getAudioTracks().forEach((track)=>_addTrack.call(this, track, stream));\n            stream.getVideoTracks().forEach((track)=>_addTrack.call(this, track, stream));\n        };\n        window1.RTCPeerConnection.prototype.addTrack = function addTrack(track) {\n            for(var _len = arguments.length, streams = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                streams[_key - 1] = arguments[_key];\n            }\n            if (streams) {\n                streams.forEach((stream)=>{\n                    if (!this._localStreams) {\n                        this._localStreams = [\n                            stream\n                        ];\n                    } else if (!this._localStreams.includes(stream)) {\n                        this._localStreams.push(stream);\n                    }\n                });\n            }\n            return _addTrack.apply(this, arguments);\n        };\n    }\n    if (!(\"removeStream\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.removeStream = function removeStream(stream) {\n            if (!this._localStreams) {\n                this._localStreams = [];\n            }\n            const index = this._localStreams.indexOf(stream);\n            if (index === -1) {\n                return;\n            }\n            this._localStreams.splice(index, 1);\n            const tracks = stream.getTracks();\n            this.getSenders().forEach((sender)=>{\n                if (tracks.includes(sender.track)) {\n                    this.removeTrack(sender);\n                }\n            });\n        };\n    }\n}\nfunction shimRemoteStreamsAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"getRemoteStreams\" in window1.RTCPeerConnection.prototype)) {\n        window1.RTCPeerConnection.prototype.getRemoteStreams = function getRemoteStreams() {\n            return this._remoteStreams ? this._remoteStreams : [];\n        };\n    }\n    if (!(\"onaddstream\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"onaddstream\", {\n            get () {\n                return this._onaddstream;\n            },\n            set (f) {\n                if (this._onaddstream) {\n                    this.removeEventListener(\"addstream\", this._onaddstream);\n                    this.removeEventListener(\"track\", this._onaddstreampoly);\n                }\n                this.addEventListener(\"addstream\", this._onaddstream = f);\n                this.addEventListener(\"track\", this._onaddstreampoly = (e)=>{\n                    e.streams.forEach((stream)=>{\n                        if (!this._remoteStreams) {\n                            this._remoteStreams = [];\n                        }\n                        if (this._remoteStreams.includes(stream)) {\n                            return;\n                        }\n                        this._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        this.dispatchEvent(event);\n                    });\n                });\n            }\n        });\n        const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n        window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n            const pc = this;\n            if (!this._onaddstreampoly) {\n                this.addEventListener(\"track\", this._onaddstreampoly = function(e) {\n                    e.streams.forEach((stream)=>{\n                        if (!pc._remoteStreams) {\n                            pc._remoteStreams = [];\n                        }\n                        if (pc._remoteStreams.indexOf(stream) >= 0) {\n                            return;\n                        }\n                        pc._remoteStreams.push(stream);\n                        const event = new Event(\"addstream\");\n                        event.stream = stream;\n                        pc.dispatchEvent(event);\n                    });\n                });\n            }\n            return origSetRemoteDescription.apply(pc, arguments);\n        };\n    }\n}\nfunction shimCallbacksAPI(window1) {\n    if (typeof window1 !== \"object\" || !window1.RTCPeerConnection) {\n        return;\n    }\n    const prototype = window1.RTCPeerConnection.prototype;\n    const origCreateOffer = prototype.createOffer;\n    const origCreateAnswer = prototype.createAnswer;\n    const setLocalDescription = prototype.setLocalDescription;\n    const setRemoteDescription = prototype.setRemoteDescription;\n    const addIceCandidate = prototype.addIceCandidate;\n    prototype.createOffer = function createOffer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateOffer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.createAnswer = function createAnswer(successCallback, failureCallback) {\n        const options = arguments.length >= 2 ? arguments[2] : arguments[0];\n        const promise = origCreateAnswer.apply(this, [\n            options\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    let withCallback = function(description, successCallback, failureCallback) {\n        const promise = setLocalDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setLocalDescription = withCallback;\n    withCallback = function(description, successCallback, failureCallback) {\n        const promise = setRemoteDescription.apply(this, [\n            description\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.setRemoteDescription = withCallback;\n    withCallback = function(candidate, successCallback, failureCallback) {\n        const promise = addIceCandidate.apply(this, [\n            candidate\n        ]);\n        if (!failureCallback) {\n            return promise;\n        }\n        promise.then(successCallback, failureCallback);\n        return Promise.resolve();\n    };\n    prototype.addIceCandidate = withCallback;\n}\nfunction shimGetUserMedia(window1) {\n    const navigator1 = window1 && window1.navigator;\n    if (navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        // shim not needed in Safari 12.1\n        const mediaDevices = navigator1.mediaDevices;\n        const _getUserMedia = mediaDevices.getUserMedia.bind(mediaDevices);\n        navigator1.mediaDevices.getUserMedia = (constraints)=>{\n            return _getUserMedia(shimConstraints(constraints));\n        };\n    }\n    if (!navigator1.getUserMedia && navigator1.mediaDevices && navigator1.mediaDevices.getUserMedia) {\n        navigator1.getUserMedia = (function getUserMedia(constraints, cb, errcb) {\n            navigator1.mediaDevices.getUserMedia(constraints).then(cb, errcb);\n        }).bind(navigator1);\n    }\n}\nfunction shimConstraints(constraints) {\n    if (constraints && constraints.video !== undefined) {\n        return Object.assign({}, constraints, {\n            video: compactObject(constraints.video)\n        });\n    }\n    return constraints;\n}\nfunction shimRTCIceServerUrls(window1) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    // migrate from non-spec RTCIceServer.url to RTCIceServer.urls\n    const OrigPeerConnection = window1.RTCPeerConnection;\n    window1.RTCPeerConnection = function RTCPeerConnection1(pcConfig, pcConstraints) {\n        if (pcConfig && pcConfig.iceServers) {\n            const newIceServers = [];\n            for(let i = 0; i < pcConfig.iceServers.length; i++){\n                let server = pcConfig.iceServers[i];\n                if (server.urls === undefined && server.url) {\n                    deprecated(\"RTCIceServer.url\", \"RTCIceServer.urls\");\n                    server = JSON.parse(JSON.stringify(server));\n                    server.urls = server.url;\n                    delete server.url;\n                    newIceServers.push(server);\n                } else {\n                    newIceServers.push(pcConfig.iceServers[i]);\n                }\n            }\n            pcConfig.iceServers = newIceServers;\n        }\n        return new OrigPeerConnection(pcConfig, pcConstraints);\n    };\n    window1.RTCPeerConnection.prototype = OrigPeerConnection.prototype;\n    // wrap static methods. Currently just generateCertificate.\n    if (\"generateCertificate\" in OrigPeerConnection) {\n        Object.defineProperty(window1.RTCPeerConnection, \"generateCertificate\", {\n            get () {\n                return OrigPeerConnection.generateCertificate;\n            }\n        });\n    }\n}\nfunction shimTrackEventTransceiver(window1) {\n    // Add event.transceiver member over deprecated event.receiver\n    if (typeof window1 === \"object\" && window1.RTCTrackEvent && \"receiver\" in window1.RTCTrackEvent.prototype && !(\"transceiver\" in window1.RTCTrackEvent.prototype)) {\n        Object.defineProperty(window1.RTCTrackEvent.prototype, \"transceiver\", {\n            get () {\n                return {\n                    receiver: this.receiver\n                };\n            }\n        });\n    }\n}\nfunction shimCreateOfferLegacy(window1) {\n    const origCreateOffer = window1.RTCPeerConnection.prototype.createOffer;\n    window1.RTCPeerConnection.prototype.createOffer = function createOffer(offerOptions) {\n        if (offerOptions) {\n            if (typeof offerOptions.offerToReceiveAudio !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveAudio = !!offerOptions.offerToReceiveAudio;\n            }\n            const audioTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"audio\");\n            if (offerOptions.offerToReceiveAudio === false && audioTransceiver) {\n                if (audioTransceiver.direction === \"sendrecv\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        audioTransceiver.direction = \"sendonly\";\n                    }\n                } else if (audioTransceiver.direction === \"recvonly\") {\n                    if (audioTransceiver.setDirection) {\n                        audioTransceiver.setDirection(\"inactive\");\n                    } else {\n                        audioTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveAudio === true && !audioTransceiver) {\n                this.addTransceiver(\"audio\", {\n                    direction: \"recvonly\"\n                });\n            }\n            if (typeof offerOptions.offerToReceiveVideo !== \"undefined\") {\n                // support bit values\n                offerOptions.offerToReceiveVideo = !!offerOptions.offerToReceiveVideo;\n            }\n            const videoTransceiver = this.getTransceivers().find((transceiver)=>transceiver.receiver.track.kind === \"video\");\n            if (offerOptions.offerToReceiveVideo === false && videoTransceiver) {\n                if (videoTransceiver.direction === \"sendrecv\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"sendonly\");\n                    } else {\n                        videoTransceiver.direction = \"sendonly\";\n                    }\n                } else if (videoTransceiver.direction === \"recvonly\") {\n                    if (videoTransceiver.setDirection) {\n                        videoTransceiver.setDirection(\"inactive\");\n                    } else {\n                        videoTransceiver.direction = \"inactive\";\n                    }\n                }\n            } else if (offerOptions.offerToReceiveVideo === true && !videoTransceiver) {\n                this.addTransceiver(\"video\", {\n                    direction: \"recvonly\"\n                });\n            }\n        }\n        return origCreateOffer.apply(this, arguments);\n    };\n}\nfunction shimAudioContext(window1) {\n    if (typeof window1 !== \"object\" || window1.AudioContext) {\n        return;\n    }\n    window1.AudioContext = window1.webkitAudioContext;\n}\nvar safariShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    shimAudioContext: shimAudioContext,\n    shimCallbacksAPI: shimCallbacksAPI,\n    shimConstraints: shimConstraints,\n    shimCreateOfferLegacy: shimCreateOfferLegacy,\n    shimGetUserMedia: shimGetUserMedia,\n    shimLocalStreamsAPI: shimLocalStreamsAPI,\n    shimRTCIceServerUrls: shimRTCIceServerUrls,\n    shimRemoteStreamsAPI: shimRemoteStreamsAPI,\n    shimTrackEventTransceiver: shimTrackEventTransceiver\n});\nvar sdp$1 = {\n    exports: {}\n};\n/* eslint-env node */ var hasRequiredSdp;\nfunction requireSdp() {\n    if (hasRequiredSdp) return sdp$1.exports;\n    hasRequiredSdp = 1;\n    (function(module) {\n        // SDP helpers.\n        const SDPUtils = {};\n        // Generate an alphanumeric identifier for cname or mids.\n        // TODO: use UUIDs instead? https://gist.github.com/jed/982883\n        SDPUtils.generateIdentifier = function() {\n            return Math.random().toString(36).substring(2, 12);\n        };\n        // The RTCP CNAME used by all peerconnections from the same JS.\n        SDPUtils.localCName = SDPUtils.generateIdentifier();\n        // Splits SDP into lines, dealing with both CRLF and LF.\n        SDPUtils.splitLines = function(blob) {\n            return blob.trim().split(\"\\n\").map((line)=>line.trim());\n        };\n        // Splits SDP into sessionpart and mediasections. Ensures CRLF.\n        SDPUtils.splitSections = function(blob) {\n            const parts = blob.split(\"\\nm=\");\n            return parts.map((part, index)=>(index > 0 ? \"m=\" + part : part).trim() + \"\\r\\n\");\n        };\n        // Returns the session description.\n        SDPUtils.getDescription = function(blob) {\n            const sections = SDPUtils.splitSections(blob);\n            return sections && sections[0];\n        };\n        // Returns the individual media sections.\n        SDPUtils.getMediaSections = function(blob) {\n            const sections = SDPUtils.splitSections(blob);\n            sections.shift();\n            return sections;\n        };\n        // Returns lines that start with a certain prefix.\n        SDPUtils.matchPrefix = function(blob, prefix) {\n            return SDPUtils.splitLines(blob).filter((line)=>line.indexOf(prefix) === 0);\n        };\n        // Parses an ICE candidate line. Sample input:\n        // candidate:702786350 2 udp 41819902 8.8.8.8 60769 typ relay raddr 8.8.8.8\n        // rport 55996\"\n        // Input can be prefixed with a=.\n        SDPUtils.parseCandidate = function(line) {\n            let parts;\n            // Parse both variants.\n            if (line.indexOf(\"a=candidate:\") === 0) {\n                parts = line.substring(12).split(\" \");\n            } else {\n                parts = line.substring(10).split(\" \");\n            }\n            const candidate = {\n                foundation: parts[0],\n                component: {\n                    1: \"rtp\",\n                    2: \"rtcp\"\n                }[parts[1]] || parts[1],\n                protocol: parts[2].toLowerCase(),\n                priority: parseInt(parts[3], 10),\n                ip: parts[4],\n                address: parts[4],\n                // address is an alias for ip.\n                port: parseInt(parts[5], 10),\n                // skip parts[6] == 'typ'\n                type: parts[7]\n            };\n            for(let i = 8; i < parts.length; i += 2){\n                switch(parts[i]){\n                    case \"raddr\":\n                        candidate.relatedAddress = parts[i + 1];\n                        break;\n                    case \"rport\":\n                        candidate.relatedPort = parseInt(parts[i + 1], 10);\n                        break;\n                    case \"tcptype\":\n                        candidate.tcpType = parts[i + 1];\n                        break;\n                    case \"ufrag\":\n                        candidate.ufrag = parts[i + 1]; // for backward compatibility.\n                        candidate.usernameFragment = parts[i + 1];\n                        break;\n                    default:\n                        // extension handling, in particular ufrag. Don't overwrite.\n                        if (candidate[parts[i]] === undefined) {\n                            candidate[parts[i]] = parts[i + 1];\n                        }\n                        break;\n                }\n            }\n            return candidate;\n        };\n        // Translates a candidate object into SDP candidate attribute.\n        // This does not include the a= prefix!\n        SDPUtils.writeCandidate = function(candidate) {\n            const sdp = [];\n            sdp.push(candidate.foundation);\n            const component = candidate.component;\n            if (component === \"rtp\") {\n                sdp.push(1);\n            } else if (component === \"rtcp\") {\n                sdp.push(2);\n            } else {\n                sdp.push(component);\n            }\n            sdp.push(candidate.protocol.toUpperCase());\n            sdp.push(candidate.priority);\n            sdp.push(candidate.address || candidate.ip);\n            sdp.push(candidate.port);\n            const type = candidate.type;\n            sdp.push(\"typ\");\n            sdp.push(type);\n            if (type !== \"host\" && candidate.relatedAddress && candidate.relatedPort) {\n                sdp.push(\"raddr\");\n                sdp.push(candidate.relatedAddress);\n                sdp.push(\"rport\");\n                sdp.push(candidate.relatedPort);\n            }\n            if (candidate.tcpType && candidate.protocol.toLowerCase() === \"tcp\") {\n                sdp.push(\"tcptype\");\n                sdp.push(candidate.tcpType);\n            }\n            if (candidate.usernameFragment || candidate.ufrag) {\n                sdp.push(\"ufrag\");\n                sdp.push(candidate.usernameFragment || candidate.ufrag);\n            }\n            return \"candidate:\" + sdp.join(\" \");\n        };\n        // Parses an ice-options line, returns an array of option tags.\n        // Sample input:\n        // a=ice-options:foo bar\n        SDPUtils.parseIceOptions = function(line) {\n            return line.substring(14).split(\" \");\n        };\n        // Parses a rtpmap line, returns RTCRtpCoddecParameters. Sample input:\n        // a=rtpmap:111 opus/48000/2\n        SDPUtils.parseRtpMap = function(line) {\n            let parts = line.substring(9).split(\" \");\n            const parsed = {\n                payloadType: parseInt(parts.shift(), 10) // was: id\n            };\n            parts = parts[0].split(\"/\");\n            parsed.name = parts[0];\n            parsed.clockRate = parseInt(parts[1], 10); // was: clockrate\n            parsed.channels = parts.length === 3 ? parseInt(parts[2], 10) : 1;\n            // legacy alias, got renamed back to channels in ORTC.\n            parsed.numChannels = parsed.channels;\n            return parsed;\n        };\n        // Generates a rtpmap line from RTCRtpCodecCapability or\n        // RTCRtpCodecParameters.\n        SDPUtils.writeRtpMap = function(codec) {\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            const channels = codec.channels || codec.numChannels || 1;\n            return \"a=rtpmap:\" + pt + \" \" + codec.name + \"/\" + codec.clockRate + (channels !== 1 ? \"/\" + channels : \"\") + \"\\r\\n\";\n        };\n        // Parses a extmap line (headerextension from RFC 5285). Sample input:\n        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n        // a=extmap:2/sendonly urn:ietf:params:rtp-hdrext:toffset\n        SDPUtils.parseExtmap = function(line) {\n            const parts = line.substring(9).split(\" \");\n            return {\n                id: parseInt(parts[0], 10),\n                direction: parts[0].indexOf(\"/\") > 0 ? parts[0].split(\"/\")[1] : \"sendrecv\",\n                uri: parts[1],\n                attributes: parts.slice(2).join(\" \")\n            };\n        };\n        // Generates an extmap line from RTCRtpHeaderExtensionParameters or\n        // RTCRtpHeaderExtension.\n        SDPUtils.writeExtmap = function(headerExtension) {\n            return \"a=extmap:\" + (headerExtension.id || headerExtension.preferredId) + (headerExtension.direction && headerExtension.direction !== \"sendrecv\" ? \"/\" + headerExtension.direction : \"\") + \" \" + headerExtension.uri + (headerExtension.attributes ? \" \" + headerExtension.attributes : \"\") + \"\\r\\n\";\n        };\n        // Parses a fmtp line, returns dictionary. Sample input:\n        // a=fmtp:96 vbr=on;cng=on\n        // Also deals with vbr=on; cng=on\n        SDPUtils.parseFmtp = function(line) {\n            const parsed = {};\n            let kv;\n            const parts = line.substring(line.indexOf(\" \") + 1).split(\";\");\n            for(let j = 0; j < parts.length; j++){\n                kv = parts[j].trim().split(\"=\");\n                parsed[kv[0].trim()] = kv[1];\n            }\n            return parsed;\n        };\n        // Generates a fmtp line from RTCRtpCodecCapability or RTCRtpCodecParameters.\n        SDPUtils.writeFmtp = function(codec) {\n            let line = \"\";\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            if (codec.parameters && Object.keys(codec.parameters).length) {\n                const params = [];\n                Object.keys(codec.parameters).forEach((param)=>{\n                    if (codec.parameters[param] !== undefined) {\n                        params.push(param + \"=\" + codec.parameters[param]);\n                    } else {\n                        params.push(param);\n                    }\n                });\n                line += \"a=fmtp:\" + pt + \" \" + params.join(\";\") + \"\\r\\n\";\n            }\n            return line;\n        };\n        // Parses a rtcp-fb line, returns RTCPRtcpFeedback object. Sample input:\n        // a=rtcp-fb:98 nack rpsi\n        SDPUtils.parseRtcpFb = function(line) {\n            const parts = line.substring(line.indexOf(\" \") + 1).split(\" \");\n            return {\n                type: parts.shift(),\n                parameter: parts.join(\" \")\n            };\n        };\n        // Generate a=rtcp-fb lines from RTCRtpCodecCapability or RTCRtpCodecParameters.\n        SDPUtils.writeRtcpFb = function(codec) {\n            let lines = \"\";\n            let pt = codec.payloadType;\n            if (codec.preferredPayloadType !== undefined) {\n                pt = codec.preferredPayloadType;\n            }\n            if (codec.rtcpFeedback && codec.rtcpFeedback.length) {\n                // FIXME: special handling for trr-int?\n                codec.rtcpFeedback.forEach((fb)=>{\n                    lines += \"a=rtcp-fb:\" + pt + \" \" + fb.type + (fb.parameter && fb.parameter.length ? \" \" + fb.parameter : \"\") + \"\\r\\n\";\n                });\n            }\n            return lines;\n        };\n        // Parses a RFC 5576 ssrc media attribute. Sample input:\n        // a=ssrc:3735928559 cname:something\n        SDPUtils.parseSsrcMedia = function(line) {\n            const sp = line.indexOf(\" \");\n            const parts = {\n                ssrc: parseInt(line.substring(7, sp), 10)\n            };\n            const colon = line.indexOf(\":\", sp);\n            if (colon > -1) {\n                parts.attribute = line.substring(sp + 1, colon);\n                parts.value = line.substring(colon + 1);\n            } else {\n                parts.attribute = line.substring(sp + 1);\n            }\n            return parts;\n        };\n        // Parse a ssrc-group line (see RFC 5576). Sample input:\n        // a=ssrc-group:semantics 12 34\n        SDPUtils.parseSsrcGroup = function(line) {\n            const parts = line.substring(13).split(\" \");\n            return {\n                semantics: parts.shift(),\n                ssrcs: parts.map((ssrc)=>parseInt(ssrc, 10))\n            };\n        };\n        // Extracts the MID (RFC 5888) from a media section.\n        // Returns the MID or undefined if no mid line was found.\n        SDPUtils.getMid = function(mediaSection) {\n            const mid = SDPUtils.matchPrefix(mediaSection, \"a=mid:\")[0];\n            if (mid) {\n                return mid.substring(6);\n            }\n        };\n        // Parses a fingerprint line for DTLS-SRTP.\n        SDPUtils.parseFingerprint = function(line) {\n            const parts = line.substring(14).split(\" \");\n            return {\n                algorithm: parts[0].toLowerCase(),\n                // algorithm is case-sensitive in Edge.\n                value: parts[1].toUpperCase() // the definition is upper-case in RFC 4572.\n            };\n        };\n        // Extracts DTLS parameters from SDP media section or sessionpart.\n        // FIXME: for consistency with other functions this should only\n        //   get the fingerprint line as input. See also getIceParameters.\n        SDPUtils.getDtlsParameters = function(mediaSection, sessionpart) {\n            const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=fingerprint:\");\n            // Note: a=setup line is ignored since we use the 'auto' role in Edge.\n            return {\n                role: \"auto\",\n                fingerprints: lines.map(SDPUtils.parseFingerprint)\n            };\n        };\n        // Serializes DTLS parameters to SDP.\n        SDPUtils.writeDtlsParameters = function(params, setupType) {\n            let sdp = \"a=setup:\" + setupType + \"\\r\\n\";\n            params.fingerprints.forEach((fp)=>{\n                sdp += \"a=fingerprint:\" + fp.algorithm + \" \" + fp.value + \"\\r\\n\";\n            });\n            return sdp;\n        };\n        // Parses a=crypto lines into\n        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#dictionary-rtcsrtpsdesparameters-members\n        SDPUtils.parseCryptoLine = function(line) {\n            const parts = line.substring(9).split(\" \");\n            return {\n                tag: parseInt(parts[0], 10),\n                cryptoSuite: parts[1],\n                keyParams: parts[2],\n                sessionParams: parts.slice(3)\n            };\n        };\n        SDPUtils.writeCryptoLine = function(parameters) {\n            return \"a=crypto:\" + parameters.tag + \" \" + parameters.cryptoSuite + \" \" + (typeof parameters.keyParams === \"object\" ? SDPUtils.writeCryptoKeyParams(parameters.keyParams) : parameters.keyParams) + (parameters.sessionParams ? \" \" + parameters.sessionParams.join(\" \") : \"\") + \"\\r\\n\";\n        };\n        // Parses the crypto key parameters into\n        //   https://rawgit.com/aboba/edgertc/master/msortc-rs4.html#rtcsrtpkeyparam*\n        SDPUtils.parseCryptoKeyParams = function(keyParams) {\n            if (keyParams.indexOf(\"inline:\") !== 0) {\n                return null;\n            }\n            const parts = keyParams.substring(7).split(\"|\");\n            return {\n                keyMethod: \"inline\",\n                keySalt: parts[0],\n                lifeTime: parts[1],\n                mkiValue: parts[2] ? parts[2].split(\":\")[0] : undefined,\n                mkiLength: parts[2] ? parts[2].split(\":\")[1] : undefined\n            };\n        };\n        SDPUtils.writeCryptoKeyParams = function(keyParams) {\n            return keyParams.keyMethod + \":\" + keyParams.keySalt + (keyParams.lifeTime ? \"|\" + keyParams.lifeTime : \"\") + (keyParams.mkiValue && keyParams.mkiLength ? \"|\" + keyParams.mkiValue + \":\" + keyParams.mkiLength : \"\");\n        };\n        // Extracts all SDES parameters.\n        SDPUtils.getCryptoParameters = function(mediaSection, sessionpart) {\n            const lines = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=crypto:\");\n            return lines.map(SDPUtils.parseCryptoLine);\n        };\n        // Parses ICE information from SDP media section or sessionpart.\n        // FIXME: for consistency with other functions this should only\n        //   get the ice-ufrag and ice-pwd lines as input.\n        SDPUtils.getIceParameters = function(mediaSection, sessionpart) {\n            const ufrag = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-ufrag:\")[0];\n            const pwd = SDPUtils.matchPrefix(mediaSection + sessionpart, \"a=ice-pwd:\")[0];\n            if (!(ufrag && pwd)) {\n                return null;\n            }\n            return {\n                usernameFragment: ufrag.substring(12),\n                password: pwd.substring(10)\n            };\n        };\n        // Serializes ICE parameters to SDP.\n        SDPUtils.writeIceParameters = function(params) {\n            let sdp = \"a=ice-ufrag:\" + params.usernameFragment + \"\\r\\n\" + \"a=ice-pwd:\" + params.password + \"\\r\\n\";\n            if (params.iceLite) {\n                sdp += \"a=ice-lite\\r\\n\";\n            }\n            return sdp;\n        };\n        // Parses the SDP media section and returns RTCRtpParameters.\n        SDPUtils.parseRtpParameters = function(mediaSection) {\n            const description = {\n                codecs: [],\n                headerExtensions: [],\n                fecMechanisms: [],\n                rtcp: []\n            };\n            const lines = SDPUtils.splitLines(mediaSection);\n            const mline = lines[0].split(\" \");\n            description.profile = mline[2];\n            for(let i = 3; i < mline.length; i++){\n                // find all codecs from mline[3..]\n                const pt = mline[i];\n                const rtpmapline = SDPUtils.matchPrefix(mediaSection, \"a=rtpmap:\" + pt + \" \")[0];\n                if (rtpmapline) {\n                    const codec = SDPUtils.parseRtpMap(rtpmapline);\n                    const fmtps = SDPUtils.matchPrefix(mediaSection, \"a=fmtp:\" + pt + \" \");\n                    // Only the first a=fmtp:<pt> is considered.\n                    codec.parameters = fmtps.length ? SDPUtils.parseFmtp(fmtps[0]) : {};\n                    codec.rtcpFeedback = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:\" + pt + \" \").map(SDPUtils.parseRtcpFb);\n                    description.codecs.push(codec);\n                    // parse FEC mechanisms from rtpmap lines.\n                    switch(codec.name.toUpperCase()){\n                        case \"RED\":\n                        case \"ULPFEC\":\n                            description.fecMechanisms.push(codec.name.toUpperCase());\n                            break;\n                    }\n                }\n            }\n            SDPUtils.matchPrefix(mediaSection, \"a=extmap:\").forEach((line)=>{\n                description.headerExtensions.push(SDPUtils.parseExtmap(line));\n            });\n            const wildcardRtcpFb = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-fb:* \").map(SDPUtils.parseRtcpFb);\n            description.codecs.forEach((codec)=>{\n                wildcardRtcpFb.forEach((fb)=>{\n                    const duplicate = codec.rtcpFeedback.find((existingFeedback)=>{\n                        return existingFeedback.type === fb.type && existingFeedback.parameter === fb.parameter;\n                    });\n                    if (!duplicate) {\n                        codec.rtcpFeedback.push(fb);\n                    }\n                });\n            });\n            // FIXME: parse rtcp.\n            return description;\n        };\n        // Generates parts of the SDP media section describing the capabilities /\n        // parameters.\n        SDPUtils.writeRtpDescription = function(kind, caps) {\n            let sdp = \"\";\n            // Build the mline.\n            sdp += \"m=\" + kind + \" \";\n            sdp += caps.codecs.length > 0 ? \"9\" : \"0\"; // reject if no codecs.\n            sdp += \" \" + (caps.profile || \"UDP/TLS/RTP/SAVPF\") + \" \";\n            sdp += caps.codecs.map((codec)=>{\n                if (codec.preferredPayloadType !== undefined) {\n                    return codec.preferredPayloadType;\n                }\n                return codec.payloadType;\n            }).join(\" \") + \"\\r\\n\";\n            sdp += \"c=IN IP4 0.0.0.0\\r\\n\";\n            sdp += \"a=rtcp:9 IN IP4 0.0.0.0\\r\\n\";\n            // Add a=rtpmap lines for each codec. Also fmtp and rtcp-fb.\n            caps.codecs.forEach((codec)=>{\n                sdp += SDPUtils.writeRtpMap(codec);\n                sdp += SDPUtils.writeFmtp(codec);\n                sdp += SDPUtils.writeRtcpFb(codec);\n            });\n            let maxptime = 0;\n            caps.codecs.forEach((codec)=>{\n                if (codec.maxptime > maxptime) {\n                    maxptime = codec.maxptime;\n                }\n            });\n            if (maxptime > 0) {\n                sdp += \"a=maxptime:\" + maxptime + \"\\r\\n\";\n            }\n            if (caps.headerExtensions) {\n                caps.headerExtensions.forEach((extension)=>{\n                    sdp += SDPUtils.writeExtmap(extension);\n                });\n            }\n            // FIXME: write fecMechanisms.\n            return sdp;\n        };\n        // Parses the SDP media section and returns an array of\n        // RTCRtpEncodingParameters.\n        SDPUtils.parseRtpEncodingParameters = function(mediaSection) {\n            const encodingParameters = [];\n            const description = SDPUtils.parseRtpParameters(mediaSection);\n            const hasRed = description.fecMechanisms.indexOf(\"RED\") !== -1;\n            const hasUlpfec = description.fecMechanisms.indexOf(\"ULPFEC\") !== -1;\n            // filter a=ssrc:... cname:, ignore PlanB-msid\n            const ssrcs = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((parts)=>parts.attribute === \"cname\");\n            const primarySsrc = ssrcs.length > 0 && ssrcs[0].ssrc;\n            let secondarySsrc;\n            const flows = SDPUtils.matchPrefix(mediaSection, \"a=ssrc-group:FID\").map((line)=>{\n                const parts = line.substring(17).split(\" \");\n                return parts.map((part)=>parseInt(part, 10));\n            });\n            if (flows.length > 0 && flows[0].length > 1 && flows[0][0] === primarySsrc) {\n                secondarySsrc = flows[0][1];\n            }\n            description.codecs.forEach((codec)=>{\n                if (codec.name.toUpperCase() === \"RTX\" && codec.parameters.apt) {\n                    let encParam = {\n                        ssrc: primarySsrc,\n                        codecPayloadType: parseInt(codec.parameters.apt, 10)\n                    };\n                    if (primarySsrc && secondarySsrc) {\n                        encParam.rtx = {\n                            ssrc: secondarySsrc\n                        };\n                    }\n                    encodingParameters.push(encParam);\n                    if (hasRed) {\n                        encParam = JSON.parse(JSON.stringify(encParam));\n                        encParam.fec = {\n                            ssrc: primarySsrc,\n                            mechanism: hasUlpfec ? \"red+ulpfec\" : \"red\"\n                        };\n                        encodingParameters.push(encParam);\n                    }\n                }\n            });\n            if (encodingParameters.length === 0 && primarySsrc) {\n                encodingParameters.push({\n                    ssrc: primarySsrc\n                });\n            }\n            // we support both b=AS and b=TIAS but interpret AS as TIAS.\n            let bandwidth = SDPUtils.matchPrefix(mediaSection, \"b=\");\n            if (bandwidth.length) {\n                if (bandwidth[0].indexOf(\"b=TIAS:\") === 0) {\n                    bandwidth = parseInt(bandwidth[0].substring(7), 10);\n                } else if (bandwidth[0].indexOf(\"b=AS:\") === 0) {\n                    // use formula from JSEP to convert b=AS to TIAS value.\n                    bandwidth = parseInt(bandwidth[0].substring(5), 10) * 1000 * 0.95 - 50 * 40 * 8;\n                } else {\n                    bandwidth = undefined;\n                }\n                encodingParameters.forEach((params)=>{\n                    params.maxBitrate = bandwidth;\n                });\n            }\n            return encodingParameters;\n        };\n        // parses http://draft.ortc.org/#rtcrtcpparameters*\n        SDPUtils.parseRtcpParameters = function(mediaSection) {\n            const rtcpParameters = {};\n            // Gets the first SSRC. Note that with RTX there might be multiple\n            // SSRCs.\n            const remoteSsrc = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((obj)=>obj.attribute === \"cname\")[0];\n            if (remoteSsrc) {\n                rtcpParameters.cname = remoteSsrc.value;\n                rtcpParameters.ssrc = remoteSsrc.ssrc;\n            }\n            // Edge uses the compound attribute instead of reducedSize\n            // compound is !reducedSize\n            const rsize = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-rsize\");\n            rtcpParameters.reducedSize = rsize.length > 0;\n            rtcpParameters.compound = rsize.length === 0;\n            // parses the rtcp-mux attrbute.\n            // Note that Edge does not support unmuxed RTCP.\n            const mux = SDPUtils.matchPrefix(mediaSection, \"a=rtcp-mux\");\n            rtcpParameters.mux = mux.length > 0;\n            return rtcpParameters;\n        };\n        SDPUtils.writeRtcpParameters = function(rtcpParameters) {\n            let sdp = \"\";\n            if (rtcpParameters.reducedSize) {\n                sdp += \"a=rtcp-rsize\\r\\n\";\n            }\n            if (rtcpParameters.mux) {\n                sdp += \"a=rtcp-mux\\r\\n\";\n            }\n            if (rtcpParameters.ssrc !== undefined && rtcpParameters.cname) {\n                sdp += \"a=ssrc:\" + rtcpParameters.ssrc + \" cname:\" + rtcpParameters.cname + \"\\r\\n\";\n            }\n            return sdp;\n        };\n        // parses either a=msid: or a=ssrc:... msid lines and returns\n        // the id of the MediaStream and MediaStreamTrack.\n        SDPUtils.parseMsid = function(mediaSection) {\n            let parts;\n            const spec = SDPUtils.matchPrefix(mediaSection, \"a=msid:\");\n            if (spec.length === 1) {\n                parts = spec[0].substring(7).split(\" \");\n                return {\n                    stream: parts[0],\n                    track: parts[1]\n                };\n            }\n            const planB = SDPUtils.matchPrefix(mediaSection, \"a=ssrc:\").map((line)=>SDPUtils.parseSsrcMedia(line)).filter((msidParts)=>msidParts.attribute === \"msid\");\n            if (planB.length > 0) {\n                parts = planB[0].value.split(\" \");\n                return {\n                    stream: parts[0],\n                    track: parts[1]\n                };\n            }\n        };\n        // SCTP\n        // parses draft-ietf-mmusic-sctp-sdp-26 first and falls back\n        // to draft-ietf-mmusic-sctp-sdp-05\n        SDPUtils.parseSctpDescription = function(mediaSection) {\n            const mline = SDPUtils.parseMLine(mediaSection);\n            const maxSizeLine = SDPUtils.matchPrefix(mediaSection, \"a=max-message-size:\");\n            let maxMessageSize;\n            if (maxSizeLine.length > 0) {\n                maxMessageSize = parseInt(maxSizeLine[0].substring(19), 10);\n            }\n            if (isNaN(maxMessageSize)) {\n                maxMessageSize = 65536;\n            }\n            const sctpPort = SDPUtils.matchPrefix(mediaSection, \"a=sctp-port:\");\n            if (sctpPort.length > 0) {\n                return {\n                    port: parseInt(sctpPort[0].substring(12), 10),\n                    protocol: mline.fmt,\n                    maxMessageSize\n                };\n            }\n            const sctpMapLines = SDPUtils.matchPrefix(mediaSection, \"a=sctpmap:\");\n            if (sctpMapLines.length > 0) {\n                const parts = sctpMapLines[0].substring(10).split(\" \");\n                return {\n                    port: parseInt(parts[0], 10),\n                    protocol: parts[1],\n                    maxMessageSize\n                };\n            }\n        };\n        // SCTP\n        // outputs the draft-ietf-mmusic-sctp-sdp-26 version that all browsers\n        // support by now receiving in this format, unless we originally parsed\n        // as the draft-ietf-mmusic-sctp-sdp-05 format (indicated by the m-line\n        // protocol of DTLS/SCTP -- without UDP/ or TCP/)\n        SDPUtils.writeSctpDescription = function(media, sctp) {\n            let output = [];\n            if (media.protocol !== \"DTLS/SCTP\") {\n                output = [\n                    \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.protocol + \"\\r\\n\",\n                    \"c=IN IP4 0.0.0.0\\r\\n\",\n                    \"a=sctp-port:\" + sctp.port + \"\\r\\n\"\n                ];\n            } else {\n                output = [\n                    \"m=\" + media.kind + \" 9 \" + media.protocol + \" \" + sctp.port + \"\\r\\n\",\n                    \"c=IN IP4 0.0.0.0\\r\\n\",\n                    \"a=sctpmap:\" + sctp.port + \" \" + sctp.protocol + \" 65535\\r\\n\"\n                ];\n            }\n            if (sctp.maxMessageSize !== undefined) {\n                output.push(\"a=max-message-size:\" + sctp.maxMessageSize + \"\\r\\n\");\n            }\n            return output.join(\"\");\n        };\n        // Generate a session ID for SDP.\n        // https://tools.ietf.org/html/draft-ietf-rtcweb-jsep-20#section-5.2.1\n        // recommends using a cryptographically random +ve 64-bit value\n        // but right now this should be acceptable and within the right range\n        SDPUtils.generateSessionId = function() {\n            return Math.random().toString().substr(2, 22);\n        };\n        // Write boiler plate for start of SDP\n        // sessId argument is optional - if not supplied it will\n        // be generated randomly\n        // sessVersion is optional and defaults to 2\n        // sessUser is optional and defaults to 'thisisadapterortc'\n        SDPUtils.writeSessionBoilerplate = function(sessId, sessVer, sessUser) {\n            let sessionId;\n            const version = sessVer !== undefined ? sessVer : 2;\n            if (sessId) {\n                sessionId = sessId;\n            } else {\n                sessionId = SDPUtils.generateSessionId();\n            }\n            const user = sessUser || \"thisisadapterortc\";\n            // FIXME: sess-id should be an NTP timestamp.\n            return \"v=0\\r\\n\" + \"o=\" + user + \" \" + sessionId + \" \" + version + \" IN IP4 127.0.0.1\\r\\n\" + \"s=-\\r\\n\" + \"t=0 0\\r\\n\";\n        };\n        // Gets the direction from the mediaSection or the sessionpart.\n        SDPUtils.getDirection = function(mediaSection, sessionpart) {\n            // Look for sendrecv, sendonly, recvonly, inactive, default to sendrecv.\n            const lines = SDPUtils.splitLines(mediaSection);\n            for(let i = 0; i < lines.length; i++){\n                switch(lines[i]){\n                    case \"a=sendrecv\":\n                    case \"a=sendonly\":\n                    case \"a=recvonly\":\n                    case \"a=inactive\":\n                        return lines[i].substring(2);\n                }\n            }\n            if (sessionpart) {\n                return SDPUtils.getDirection(sessionpart);\n            }\n            return \"sendrecv\";\n        };\n        SDPUtils.getKind = function(mediaSection) {\n            const lines = SDPUtils.splitLines(mediaSection);\n            const mline = lines[0].split(\" \");\n            return mline[0].substring(2);\n        };\n        SDPUtils.isRejected = function(mediaSection) {\n            return mediaSection.split(\" \", 2)[1] === \"0\";\n        };\n        SDPUtils.parseMLine = function(mediaSection) {\n            const lines = SDPUtils.splitLines(mediaSection);\n            const parts = lines[0].substring(2).split(\" \");\n            return {\n                kind: parts[0],\n                port: parseInt(parts[1], 10),\n                protocol: parts[2],\n                fmt: parts.slice(3).join(\" \")\n            };\n        };\n        SDPUtils.parseOLine = function(mediaSection) {\n            const line = SDPUtils.matchPrefix(mediaSection, \"o=\")[0];\n            const parts = line.substring(2).split(\" \");\n            return {\n                username: parts[0],\n                sessionId: parts[1],\n                sessionVersion: parseInt(parts[2], 10),\n                netType: parts[3],\n                addressType: parts[4],\n                address: parts[5]\n            };\n        };\n        // a very naive interpretation of a valid SDP.\n        SDPUtils.isValidSDP = function(blob) {\n            if (typeof blob !== \"string\" || blob.length === 0) {\n                return false;\n            }\n            const lines = SDPUtils.splitLines(blob);\n            for(let i = 0; i < lines.length; i++){\n                if (lines[i].length < 2 || lines[i].charAt(1) !== \"=\") {\n                    return false;\n                }\n            // TODO: check the modifier a bit more.\n            }\n            return true;\n        };\n        // Expose public methods.\n        {\n            module.exports = SDPUtils;\n        }\n    })(sdp$1);\n    return sdp$1.exports;\n}\nvar sdpExports = requireSdp();\nvar SDPUtils = /*@__PURE__*/ getDefaultExportFromCjs(sdpExports);\nvar sdp = /*#__PURE__*/ _mergeNamespaces({\n    __proto__: null,\n    default: SDPUtils\n}, [\n    sdpExports\n]);\n/*\n *  Copyright (c) 2017 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ function shimRTCIceCandidate(window1) {\n    // foundation is arbitrarily chosen as an indicator for full support for\n    // https://w3c.github.io/webrtc-pc/#rtcicecandidate-interface\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"foundation\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    const NativeRTCIceCandidate = window1.RTCIceCandidate;\n    window1.RTCIceCandidate = function RTCIceCandidate1(args) {\n        // Remove the a= which shouldn't be part of the candidate string.\n        if (typeof args === \"object\" && args.candidate && args.candidate.indexOf(\"a=\") === 0) {\n            args = JSON.parse(JSON.stringify(args));\n            args.candidate = args.candidate.substring(2);\n        }\n        if (args.candidate && args.candidate.length) {\n            // Augment the native candidate with the parsed fields.\n            const nativeCandidate = new NativeRTCIceCandidate(args);\n            const parsedCandidate = SDPUtils.parseCandidate(args.candidate);\n            for(const key in parsedCandidate){\n                if (!(key in nativeCandidate)) {\n                    Object.defineProperty(nativeCandidate, key, {\n                        value: parsedCandidate[key]\n                    });\n                }\n            }\n            // Override serializer to not serialize the extra attributes.\n            nativeCandidate.toJSON = function toJSON() {\n                return {\n                    candidate: nativeCandidate.candidate,\n                    sdpMid: nativeCandidate.sdpMid,\n                    sdpMLineIndex: nativeCandidate.sdpMLineIndex,\n                    usernameFragment: nativeCandidate.usernameFragment\n                };\n            };\n            return nativeCandidate;\n        }\n        return new NativeRTCIceCandidate(args);\n    };\n    window1.RTCIceCandidate.prototype = NativeRTCIceCandidate.prototype;\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            Object.defineProperty(e, \"candidate\", {\n                value: new window1.RTCIceCandidate(e.candidate),\n                writable: \"false\"\n            });\n        }\n        return e;\n    });\n}\nfunction shimRTCIceCandidateRelayProtocol(window1) {\n    if (!window1.RTCIceCandidate || window1.RTCIceCandidate && \"relayProtocol\" in window1.RTCIceCandidate.prototype) {\n        return;\n    }\n    // Hook up the augmented candidate in onicecandidate and\n    // addEventListener('icecandidate', ...)\n    wrapPeerConnectionEvent(window1, \"icecandidate\", (e)=>{\n        if (e.candidate) {\n            const parsedCandidate = SDPUtils.parseCandidate(e.candidate.candidate);\n            if (parsedCandidate.type === \"relay\") {\n                // This is a libwebrtc-specific mapping of local type preference\n                // to relayProtocol.\n                e.candidate.relayProtocol = ({\n                    0: \"tls\",\n                    1: \"tcp\",\n                    2: \"udp\"\n                })[parsedCandidate.priority >> 24];\n            }\n        }\n        return e;\n    });\n}\nfunction shimMaxMessageSize(window1, browserDetails) {\n    if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (!(\"sctp\" in window1.RTCPeerConnection.prototype)) {\n        Object.defineProperty(window1.RTCPeerConnection.prototype, \"sctp\", {\n            get () {\n                return typeof this._sctp === \"undefined\" ? null : this._sctp;\n            }\n        });\n    }\n    const sctpInDescription = function(description) {\n        if (!description || !description.sdp) {\n            return false;\n        }\n        const sections = SDPUtils.splitSections(description.sdp);\n        sections.shift();\n        return sections.some((mediaSection)=>{\n            const mLine = SDPUtils.parseMLine(mediaSection);\n            return mLine && mLine.kind === \"application\" && mLine.protocol.indexOf(\"SCTP\") !== -1;\n        });\n    };\n    const getRemoteFirefoxVersion = function(description) {\n        // TODO: Is there a better solution for detecting Firefox?\n        const match = description.sdp.match(/mozilla...THIS_IS_SDPARTA-(\\d+)/);\n        if (match === null || match.length < 2) {\n            return -1;\n        }\n        const version = parseInt(match[1], 10);\n        // Test for NaN (yes, this is ugly)\n        return version !== version ? -1 : version;\n    };\n    const getCanSendMaxMessageSize = function(remoteIsFirefox) {\n        // Every implementation we know can send at least 64 KiB.\n        // Note: Although Chrome is technically able to send up to 256 KiB, the\n        //       data does not reach the other peer reliably.\n        //       See: https://bugs.chromium.org/p/webrtc/issues/detail?id=8419\n        let canSendMaxMessageSize = 65536;\n        if (browserDetails.browser === \"firefox\") {\n            if (browserDetails.version < 57) {\n                if (remoteIsFirefox === -1) {\n                    // FF < 57 will send in 16 KiB chunks using the deprecated PPID\n                    // fragmentation.\n                    canSendMaxMessageSize = 16384;\n                } else {\n                    // However, other FF (and RAWRTC) can reassemble PPID-fragmented\n                    // messages. Thus, supporting ~2 GiB when sending.\n                    canSendMaxMessageSize = 2147483637;\n                }\n            } else if (browserDetails.version < 60) {\n                // Currently, all FF >= 57 will reset the remote maximum message size\n                // to the default value when a data channel is created at a later\n                // stage. :(\n                // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n                canSendMaxMessageSize = browserDetails.version === 57 ? 65535 : 65536;\n            } else {\n                // FF >= 60 supports sending ~2 GiB\n                canSendMaxMessageSize = 2147483637;\n            }\n        }\n        return canSendMaxMessageSize;\n    };\n    const getMaxMessageSize = function(description, remoteIsFirefox) {\n        // Note: 65536 bytes is the default value from the SDP spec. Also,\n        //       every implementation we know supports receiving 65536 bytes.\n        let maxMessageSize = 65536;\n        // FF 57 has a slightly incorrect default remote max message size, so\n        // we need to adjust it here to avoid a failure when sending.\n        // See: https://bugzilla.mozilla.org/show_bug.cgi?id=1425697\n        if (browserDetails.browser === \"firefox\" && browserDetails.version === 57) {\n            maxMessageSize = 65535;\n        }\n        const match = SDPUtils.matchPrefix(description.sdp, \"a=max-message-size:\");\n        if (match.length > 0) {\n            maxMessageSize = parseInt(match[0].substring(19), 10);\n        } else if (browserDetails.browser === \"firefox\" && remoteIsFirefox !== -1) {\n            // If the maximum message size is not present in the remote SDP and\n            // both local and remote are Firefox, the remote peer can receive\n            // ~2 GiB.\n            maxMessageSize = 2147483637;\n        }\n        return maxMessageSize;\n    };\n    const origSetRemoteDescription = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription() {\n        this._sctp = null;\n        // Chrome decided to not expose .sctp in plan-b mode.\n        // As usual, adapter.js has to do an 'ugly worakaround'\n        // to cover up the mess.\n        if (browserDetails.browser === \"chrome\" && browserDetails.version >= 76) {\n            const { sdpSemantics } = this.getConfiguration();\n            if (sdpSemantics === \"plan-b\") {\n                Object.defineProperty(this, \"sctp\", {\n                    get () {\n                        return typeof this._sctp === \"undefined\" ? null : this._sctp;\n                    },\n                    enumerable: true,\n                    configurable: true\n                });\n            }\n        }\n        if (sctpInDescription(arguments[0])) {\n            // Check if the remote is FF.\n            const isFirefox = getRemoteFirefoxVersion(arguments[0]);\n            // Get the maximum message size the local peer is capable of sending\n            const canSendMMS = getCanSendMaxMessageSize(isFirefox);\n            // Get the maximum message size of the remote peer.\n            const remoteMMS = getMaxMessageSize(arguments[0], isFirefox);\n            // Determine final maximum message size\n            let maxMessageSize;\n            if (canSendMMS === 0 && remoteMMS === 0) {\n                maxMessageSize = Number.POSITIVE_INFINITY;\n            } else if (canSendMMS === 0 || remoteMMS === 0) {\n                maxMessageSize = Math.max(canSendMMS, remoteMMS);\n            } else {\n                maxMessageSize = Math.min(canSendMMS, remoteMMS);\n            }\n            // Create a dummy RTCSctpTransport object and the 'maxMessageSize'\n            // attribute.\n            const sctp = {};\n            Object.defineProperty(sctp, \"maxMessageSize\", {\n                get () {\n                    return maxMessageSize;\n                }\n            });\n            this._sctp = sctp;\n        }\n        return origSetRemoteDescription.apply(this, arguments);\n    };\n}\nfunction shimSendThrowTypeError(window1) {\n    if (!(window1.RTCPeerConnection && \"createDataChannel\" in window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    // Note: Although Firefox >= 57 has a native implementation, the maximum\n    //       message size can be reset for all data channels at a later stage.\n    //       See: https://bugzilla.mozilla.org/show_bug.cgi?id=1426831\n    function wrapDcSend(dc, pc) {\n        const origDataChannelSend = dc.send;\n        dc.send = function send() {\n            const data = arguments[0];\n            const length = data.length || data.size || data.byteLength;\n            if (dc.readyState === \"open\" && pc.sctp && length > pc.sctp.maxMessageSize) {\n                throw new TypeError(\"Message too large (can send a maximum of \" + pc.sctp.maxMessageSize + \" bytes)\");\n            }\n            return origDataChannelSend.apply(dc, arguments);\n        };\n    }\n    const origCreateDataChannel = window1.RTCPeerConnection.prototype.createDataChannel;\n    window1.RTCPeerConnection.prototype.createDataChannel = function createDataChannel() {\n        const dataChannel = origCreateDataChannel.apply(this, arguments);\n        wrapDcSend(dataChannel, this);\n        return dataChannel;\n    };\n    wrapPeerConnectionEvent(window1, \"datachannel\", (e)=>{\n        wrapDcSend(e.channel, e.target);\n        return e;\n    });\n}\n/* shims RTCConnectionState by pretending it is the same as iceConnectionState.\n * See https://bugs.chromium.org/p/webrtc/issues/detail?id=6145#c12\n * for why this is a valid hack in Chrome. In Firefox it is slightly incorrect\n * since DTLS failures would be hidden. See\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1265827\n * for the Firefox tracking bug.\n */ function shimConnectionState(window1) {\n    if (!window1.RTCPeerConnection || \"connectionState\" in window1.RTCPeerConnection.prototype) {\n        return;\n    }\n    const proto = window1.RTCPeerConnection.prototype;\n    Object.defineProperty(proto, \"connectionState\", {\n        get () {\n            return ({\n                completed: \"connected\",\n                checking: \"connecting\"\n            })[this.iceConnectionState] || this.iceConnectionState;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(proto, \"onconnectionstatechange\", {\n        get () {\n            return this._onconnectionstatechange || null;\n        },\n        set (cb) {\n            if (this._onconnectionstatechange) {\n                this.removeEventListener(\"connectionstatechange\", this._onconnectionstatechange);\n                delete this._onconnectionstatechange;\n            }\n            if (cb) {\n                this.addEventListener(\"connectionstatechange\", this._onconnectionstatechange = cb);\n            }\n        },\n        enumerable: true,\n        configurable: true\n    });\n    [\n        \"setLocalDescription\",\n        \"setRemoteDescription\"\n    ].forEach((method)=>{\n        const origMethod = proto[method];\n        proto[method] = function() {\n            if (!this._connectionstatechangepoly) {\n                this._connectionstatechangepoly = (e)=>{\n                    const pc = e.target;\n                    if (pc._lastConnectionState !== pc.connectionState) {\n                        pc._lastConnectionState = pc.connectionState;\n                        const newEvent = new Event(\"connectionstatechange\", e);\n                        pc.dispatchEvent(newEvent);\n                    }\n                    return e;\n                };\n                this.addEventListener(\"iceconnectionstatechange\", this._connectionstatechangepoly);\n            }\n            return origMethod.apply(this, arguments);\n        };\n    });\n}\nfunction removeExtmapAllowMixed(window1, browserDetails) {\n    /* remove a=extmap-allow-mixed for webrtc.org < M71 */ if (!window1.RTCPeerConnection) {\n        return;\n    }\n    if (browserDetails.browser === \"chrome\" && browserDetails.version >= 71) {\n        return;\n    }\n    if (browserDetails.browser === \"safari\" && browserDetails.version >= 605) {\n        return;\n    }\n    const nativeSRD = window1.RTCPeerConnection.prototype.setRemoteDescription;\n    window1.RTCPeerConnection.prototype.setRemoteDescription = function setRemoteDescription(desc) {\n        if (desc && desc.sdp && desc.sdp.indexOf(\"\\na=extmap-allow-mixed\") !== -1) {\n            const sdp = desc.sdp.split(\"\\n\").filter((line)=>{\n                return line.trim() !== \"a=extmap-allow-mixed\";\n            }).join(\"\\n\");\n            // Safari enforces read-only-ness of RTCSessionDescription fields.\n            if (window1.RTCSessionDescription && desc instanceof window1.RTCSessionDescription) {\n                arguments[0] = new window1.RTCSessionDescription({\n                    type: desc.type,\n                    sdp\n                });\n            } else {\n                desc.sdp = sdp;\n            }\n        }\n        return nativeSRD.apply(this, arguments);\n    };\n}\nfunction shimAddIceCandidateNullOrEmpty(window1, browserDetails) {\n    // Support for addIceCandidate(null or undefined)\n    // as well as addIceCandidate({candidate: \"\", ...})\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=978582\n    // Note: must be called before other polyfills which change the signature.\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeAddIceCandidate = window1.RTCPeerConnection.prototype.addIceCandidate;\n    if (!nativeAddIceCandidate || nativeAddIceCandidate.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.addIceCandidate = function addIceCandidate() {\n        if (!arguments[0]) {\n            if (arguments[1]) {\n                arguments[1].apply(null);\n            }\n            return Promise.resolve();\n        }\n        // Firefox 68+ emits and processes {candidate: \"\", ...}, ignore\n        // in older versions.\n        // Native support for ignoring exists for Chrome M77+.\n        // Safari ignores as well, exact version unknown but works in the same\n        // version that also ignores addIceCandidate(null).\n        if ((browserDetails.browser === \"chrome\" && browserDetails.version < 78 || browserDetails.browser === \"firefox\" && browserDetails.version < 68 || browserDetails.browser === \"safari\") && arguments[0] && arguments[0].candidate === \"\") {\n            return Promise.resolve();\n        }\n        return nativeAddIceCandidate.apply(this, arguments);\n    };\n}\n// Note: Make sure to call this ahead of APIs that modify\n// setLocalDescription.length\nfunction shimParameterlessSetLocalDescription(window1, browserDetails) {\n    if (!(window1.RTCPeerConnection && window1.RTCPeerConnection.prototype)) {\n        return;\n    }\n    const nativeSetLocalDescription = window1.RTCPeerConnection.prototype.setLocalDescription;\n    if (!nativeSetLocalDescription || nativeSetLocalDescription.length === 0) {\n        return;\n    }\n    window1.RTCPeerConnection.prototype.setLocalDescription = function setLocalDescription() {\n        let desc = arguments[0] || {};\n        if (typeof desc !== \"object\" || desc.type && desc.sdp) {\n            return nativeSetLocalDescription.apply(this, arguments);\n        }\n        // The remaining steps should technically happen when SLD comes off the\n        // RTCPeerConnection's operations chain (not ahead of going on it), but\n        // this is too difficult to shim. Instead, this shim only covers the\n        // common case where the operations chain is empty. This is imperfect, but\n        // should cover many cases. Rationale: Even if we can't reduce the glare\n        // window to zero on imperfect implementations, there's value in tapping\n        // into the perfect negotiation pattern that several browsers support.\n        desc = {\n            type: desc.type,\n            sdp: desc.sdp\n        };\n        if (!desc.type) {\n            switch(this.signalingState){\n                case \"stable\":\n                case \"have-local-offer\":\n                case \"have-remote-pranswer\":\n                    desc.type = \"offer\";\n                    break;\n                default:\n                    desc.type = \"answer\";\n                    break;\n            }\n        }\n        if (desc.sdp || desc.type !== \"offer\" && desc.type !== \"answer\") {\n            return nativeSetLocalDescription.apply(this, [\n                desc\n            ]);\n        }\n        const func = desc.type === \"offer\" ? this.createOffer : this.createAnswer;\n        return func.apply(this).then((d)=>nativeSetLocalDescription.apply(this, [\n                d\n            ]));\n    };\n}\nvar commonShim = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    removeExtmapAllowMixed: removeExtmapAllowMixed,\n    shimAddIceCandidateNullOrEmpty: shimAddIceCandidateNullOrEmpty,\n    shimConnectionState: shimConnectionState,\n    shimMaxMessageSize: shimMaxMessageSize,\n    shimParameterlessSetLocalDescription: shimParameterlessSetLocalDescription,\n    shimRTCIceCandidate: shimRTCIceCandidate,\n    shimRTCIceCandidateRelayProtocol: shimRTCIceCandidateRelayProtocol,\n    shimSendThrowTypeError: shimSendThrowTypeError\n});\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ // Shimming starts here.\nfunction adapterFactory() {\n    let { window: window1 } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        shimChrome: true,\n        shimFirefox: true,\n        shimSafari: true\n    };\n    // Utils.\n    const logging = log;\n    const browserDetails = detectBrowser(window1);\n    const adapter = {\n        browserDetails,\n        commonShim,\n        extractVersion: extractVersion,\n        disableLog: disableLog,\n        disableWarnings: disableWarnings,\n        // Expose sdp as a convenience. For production apps include directly.\n        sdp\n    };\n    // Shim browser if found.\n    switch(browserDetails.browser){\n        case \"chrome\":\n            if (!chromeShim || !shimPeerConnection$1 || !options.shimChrome) {\n                logging(\"Chrome shim is not included in this adapter release.\");\n                return adapter;\n            }\n            if (browserDetails.version === null) {\n                logging(\"Chrome shim can not determine version, not shimming.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming chrome.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = chromeShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$2(window1, browserDetails);\n            shimMediaStream(window1);\n            shimPeerConnection$1(window1, browserDetails);\n            shimOnTrack$1(window1);\n            shimAddTrackRemoveTrack(window1, browserDetails);\n            shimGetSendersWithDtmf(window1);\n            shimSenderReceiverGetStats(window1);\n            fixNegotiationNeeded(window1, browserDetails);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        case \"firefox\":\n            if (!firefoxShim || !shimPeerConnection || !options.shimFirefox) {\n                logging(\"Firefox shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming firefox.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = firefoxShim;\n            // Must be called before shimPeerConnection.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimGetUserMedia$1(window1, browserDetails);\n            shimPeerConnection(window1, browserDetails);\n            shimOnTrack(window1);\n            shimRemoveStream(window1);\n            shimSenderGetStats(window1);\n            shimReceiverGetStats(window1);\n            shimRTCDataChannel(window1);\n            shimAddTransceiver(window1);\n            shimGetParameters(window1);\n            shimCreateOffer(window1);\n            shimCreateAnswer(window1);\n            shimRTCIceCandidate(window1);\n            shimConnectionState(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            break;\n        case \"safari\":\n            if (!safariShim || !options.shimSafari) {\n                logging(\"Safari shim is not included in this adapter release.\");\n                return adapter;\n            }\n            logging(\"adapter.js shimming safari.\");\n            // Export to the adapter global object visible in the browser.\n            adapter.browserShim = safariShim;\n            // Must be called before shimCallbackAPI.\n            shimAddIceCandidateNullOrEmpty(window1, browserDetails);\n            shimParameterlessSetLocalDescription(window1);\n            shimRTCIceServerUrls(window1);\n            shimCreateOfferLegacy(window1);\n            shimCallbacksAPI(window1);\n            shimLocalStreamsAPI(window1);\n            shimRemoteStreamsAPI(window1);\n            shimTrackEventTransceiver(window1);\n            shimGetUserMedia(window1);\n            shimAudioContext(window1);\n            shimRTCIceCandidate(window1);\n            shimRTCIceCandidateRelayProtocol(window1);\n            shimMaxMessageSize(window1, browserDetails);\n            shimSendThrowTypeError(window1);\n            removeExtmapAllowMixed(window1, browserDetails);\n            break;\n        default:\n            logging(\"Unsupported browser!\");\n            break;\n    }\n    return adapter;\n}\n/*\n *  Copyright (c) 2016 The WebRTC project authors. All Rights Reserved.\n *\n *  Use of this source code is governed by a BSD-style license\n *  that can be found in the LICENSE file in the root of the source\n *  tree.\n */ /* eslint-env node */ adapterFactory({\n    window:  true ? undefined : 0\n});\nconst ENCRYPTION_ALGORITHM = \"AES-GCM\";\n// How many consecutive frames can fail decrypting before a particular key gets marked as invalid\nconst DECRYPTION_FAILURE_TOLERANCE = 10;\n// flag set to indicate that e2ee has been setup for sender/receiver;\nconst E2EE_FLAG = \"lk_e2ee\";\nconst SALT = \"LKFrameEncryptionKey\";\nconst KEY_PROVIDER_DEFAULTS = {\n    sharedKey: false,\n    ratchetSalt: SALT,\n    ratchetWindowSize: 8,\n    failureTolerance: DECRYPTION_FAILURE_TOLERANCE,\n    keyringSize: 16,\n    allowKeyExtraction: false\n};\nvar KeyProviderEvent;\n(function(KeyProviderEvent) {\n    KeyProviderEvent[\"SetKey\"] = \"setKey\";\n    KeyProviderEvent[\"RatchetRequest\"] = \"ratchetRequest\";\n    KeyProviderEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyProviderEvent || (KeyProviderEvent = {}));\nvar KeyHandlerEvent;\n(function(KeyHandlerEvent) {\n    KeyHandlerEvent[\"KeyRatcheted\"] = \"keyRatcheted\";\n})(KeyHandlerEvent || (KeyHandlerEvent = {}));\nvar EncryptionEvent;\n(function(EncryptionEvent) {\n    EncryptionEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    EncryptionEvent[\"EncryptionError\"] = \"encryptionError\";\n})(EncryptionEvent || (EncryptionEvent = {}));\nvar CryptorEvent;\n(function(CryptorEvent) {\n    CryptorEvent[\"Error\"] = \"cryptorError\";\n})(CryptorEvent || (CryptorEvent = {}));\nfunction isE2EESupported() {\n    return isInsertableStreamSupported() || isScriptTransformSupported();\n}\nfunction isScriptTransformSupported() {\n    // @ts-ignore\n    return typeof window.RTCRtpScriptTransform !== \"undefined\";\n}\nfunction isInsertableStreamSupported() {\n    return typeof window.RTCRtpSender !== \"undefined\" && // @ts-ignore\n    typeof window.RTCRtpSender.prototype.createEncodedStreams !== \"undefined\";\n}\nfunction isVideoFrame(frame) {\n    return \"type\" in frame;\n}\nfunction importKey(keyBytes_1) {\n    return __awaiter(this, arguments, void 0, function(keyBytes) {\n        let algorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n            name: ENCRYPTION_ALGORITHM\n        };\n        let usage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"encrypt\";\n        let extractable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        return function*() {\n            // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/importKey\n            return crypto.subtle.importKey(\"raw\", keyBytes, algorithm, extractable, usage === \"derive\" ? [\n                \"deriveBits\",\n                \"deriveKey\"\n            ] : [\n                \"encrypt\",\n                \"decrypt\"\n            ]);\n        }();\n    });\n}\nfunction createKeyMaterialFromString(password) {\n    return __awaiter(this, void 0, void 0, function*() {\n        let enc = new TextEncoder();\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", enc.encode(password), {\n            name: \"PBKDF2\"\n        }, false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction createKeyMaterialFromBuffer(cryptoBuffer) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const keyMaterial = yield crypto.subtle.importKey(\"raw\", cryptoBuffer, \"HKDF\", false, [\n            \"deriveBits\",\n            \"deriveKey\"\n        ]);\n        return keyMaterial;\n    });\n}\nfunction getAlgoOptions(algorithmName, salt) {\n    const textEncoder = new TextEncoder();\n    const encodedSalt = textEncoder.encode(salt);\n    switch(algorithmName){\n        case \"HKDF\":\n            return {\n                name: \"HKDF\",\n                salt: encodedSalt,\n                hash: \"SHA-256\",\n                info: new ArrayBuffer(128)\n            };\n        case \"PBKDF2\":\n            {\n                return {\n                    name: \"PBKDF2\",\n                    salt: encodedSalt,\n                    hash: \"SHA-256\",\n                    iterations: 100000\n                };\n            }\n        default:\n            throw new Error(\"algorithm \".concat(algorithmName, \" is currently unsupported\"));\n    }\n}\n/**\n * Derives a set of keys from the master key.\n * See https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.1\n */ function deriveKeys(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveKey#HKDF\n        // https://developer.mozilla.org/en-US/docs/Web/API/HkdfParams\n        const encryptionKey = yield crypto.subtle.deriveKey(algorithmOptions, material, {\n            name: ENCRYPTION_ALGORITHM,\n            length: 128\n        }, false, [\n            \"encrypt\",\n            \"decrypt\"\n        ]);\n        return {\n            material,\n            encryptionKey\n        };\n    });\n}\nfunction createE2EEKey() {\n    return window.crypto.getRandomValues(new Uint8Array(32));\n}\n/**\n * Ratchets a key. See\n * https://tools.ietf.org/html/draft-omara-sframe-00#section-4.3.5.1\n */ function ratchet(material, salt) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const algorithmOptions = getAlgoOptions(material.algorithm.name, salt);\n        // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/deriveBits\n        return crypto.subtle.deriveBits(algorithmOptions, material, 256);\n    });\n}\nfunction needsRbspUnescaping(frameData) {\n    for(var i = 0; i < frameData.length - 3; i++){\n        if (frameData[i] == 0 && frameData[i + 1] == 0 && frameData[i + 2] == 3) return true;\n    }\n    return false;\n}\nfunction parseRbsp(stream) {\n    const dataOut = [];\n    var length = stream.length;\n    for(var i = 0; i < stream.length;){\n        // Be careful about over/underflow here. byte_length_ - 3 can underflow, and\n        // i + 3 can overflow, but byte_length_ - i can't, because i < byte_length_\n        // above, and that expression will produce the number of bytes left in\n        // the stream including the byte at i.\n        if (length - i >= 3 && !stream[i] && !stream[i + 1] && stream[i + 2] == 3) {\n            // Two rbsp bytes.\n            dataOut.push(stream[i++]);\n            dataOut.push(stream[i++]);\n            // Skip the emulation byte.\n            i++;\n        } else {\n            // Single rbsp byte.\n            dataOut.push(stream[i++]);\n        }\n    }\n    return new Uint8Array(dataOut);\n}\nconst kZerosInStartSequence = 2;\nconst kEmulationByte = 3;\nfunction writeRbsp(data_in) {\n    const dataOut = [];\n    var numConsecutiveZeros = 0;\n    for(var i = 0; i < data_in.length; ++i){\n        var byte = data_in[i];\n        if (byte <= kEmulationByte && numConsecutiveZeros >= kZerosInStartSequence) {\n            // Need to escape.\n            dataOut.push(kEmulationByte);\n            numConsecutiveZeros = 0;\n        }\n        dataOut.push(byte);\n        if (byte == 0) {\n            ++numConsecutiveZeros;\n        } else {\n            numConsecutiveZeros = 0;\n        }\n    }\n    return new Uint8Array(dataOut);\n}\n/**\n * @experimental\n */ class BaseKeyProvider extends eventsExports.EventEmitter {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        super();\n        /**\n     * callback being invoked after a ratchet request has been performed on a participant\n     * that surfaces the new key material.\n     * @param material\n     * @param keyIndex\n     */ this.onKeyRatcheted = (material, keyIndex)=>{\n            livekitLogger.debug(\"key ratcheted event received\", {\n                material,\n                keyIndex\n            });\n        };\n        this.keyInfoMap = new Map();\n        this.options = Object.assign(Object.assign({}, KEY_PROVIDER_DEFAULTS), options);\n        this.on(KeyProviderEvent.KeyRatcheted, this.onKeyRatcheted);\n    }\n    /**\n   * callback to invoke once a key has been set for a participant\n   * @param key\n   * @param participantIdentity\n   * @param keyIndex\n   */ onSetEncryptionKey(key, participantIdentity, keyIndex) {\n        const keyInfo = {\n            key,\n            participantIdentity,\n            keyIndex\n        };\n        if (!this.options.sharedKey && !participantIdentity) {\n            throw new Error(\"participant identity needs to be passed for encryption key if sharedKey option is false\");\n        }\n        this.keyInfoMap.set(\"\".concat(participantIdentity !== null && participantIdentity !== void 0 ? participantIdentity : \"shared\", \"-\").concat(keyIndex !== null && keyIndex !== void 0 ? keyIndex : 0), keyInfo);\n        this.emit(KeyProviderEvent.SetKey, keyInfo);\n    }\n    getKeys() {\n        return Array.from(this.keyInfoMap.values());\n    }\n    getOptions() {\n        return this.options;\n    }\n    ratchetKey(participantIdentity, keyIndex) {\n        this.emit(KeyProviderEvent.RatchetRequest, participantIdentity, keyIndex);\n    }\n}\n/**\n * A basic KeyProvider implementation intended for a single shared\n * passphrase between all participants\n * @experimental\n */ class ExternalE2EEKeyProvider extends BaseKeyProvider {\n    constructor(){\n        let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const opts = Object.assign(Object.assign({}, options), {\n            sharedKey: true,\n            // for a shared key provider failing to decrypt for a specific participant\n            // should not mark the key as invalid, so we accept wrong keys forever\n            // and won't try to auto-ratchet\n            ratchetWindowSize: 0,\n            failureTolerance: -1\n        });\n        super(opts);\n    }\n    /**\n   * Accepts a passphrase that's used to create the crypto keys.\n   * When passing in a string, PBKDF2 is used.\n   * When passing in an Array buffer of cryptographically random numbers, HKDF is being used. (recommended)\n   * @param key\n   */ setKey(key) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const derivedKey = typeof key === \"string\" ? yield createKeyMaterialFromString(key) : yield createKeyMaterialFromBuffer(key);\n            this.onSetEncryptionKey(derivedKey);\n        });\n    }\n}\nclass LivekitError extends Error {\n    constructor(code, message){\n        super(message || \"an error has occured\");\n        this.name = \"LiveKitError\";\n        this.code = code;\n    }\n}\nvar ConnectionErrorReason;\n(function(ConnectionErrorReason) {\n    ConnectionErrorReason[ConnectionErrorReason[\"NotAllowed\"] = 0] = \"NotAllowed\";\n    ConnectionErrorReason[ConnectionErrorReason[\"ServerUnreachable\"] = 1] = \"ServerUnreachable\";\n    ConnectionErrorReason[ConnectionErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n    ConnectionErrorReason[ConnectionErrorReason[\"Cancelled\"] = 3] = \"Cancelled\";\n    ConnectionErrorReason[ConnectionErrorReason[\"LeaveRequest\"] = 4] = \"LeaveRequest\";\n})(ConnectionErrorReason || (ConnectionErrorReason = {}));\nclass ConnectionError extends LivekitError {\n    constructor(message, reason, status, context){\n        super(1, message);\n        this.name = \"ConnectionError\";\n        this.status = status;\n        this.reason = reason;\n        this.context = context;\n        this.reasonName = ConnectionErrorReason[reason];\n    }\n}\nclass DeviceUnsupportedError extends LivekitError {\n    constructor(message){\n        super(21, message !== null && message !== void 0 ? message : \"device is unsupported\");\n        this.name = \"DeviceUnsupportedError\";\n    }\n}\nclass TrackInvalidError extends LivekitError {\n    constructor(message){\n        super(20, message !== null && message !== void 0 ? message : \"track is invalid\");\n        this.name = \"TrackInvalidError\";\n    }\n}\nclass UnsupportedServer extends LivekitError {\n    constructor(message){\n        super(10, message !== null && message !== void 0 ? message : \"unsupported server\");\n        this.name = \"UnsupportedServer\";\n    }\n}\nclass UnexpectedConnectionState extends LivekitError {\n    constructor(message){\n        super(12, message !== null && message !== void 0 ? message : \"unexpected connection state\");\n        this.name = \"UnexpectedConnectionState\";\n    }\n}\nclass NegotiationError extends LivekitError {\n    constructor(message){\n        super(13, message !== null && message !== void 0 ? message : \"unable to negotiate\");\n        this.name = \"NegotiationError\";\n    }\n}\nclass PublishDataError extends LivekitError {\n    constructor(message){\n        super(14, message !== null && message !== void 0 ? message : \"unable to publish data\");\n        this.name = \"PublishDataError\";\n    }\n}\nclass PublishTrackError extends LivekitError {\n    constructor(message, status){\n        super(15, message);\n        this.name = \"PublishTrackError\";\n        this.status = status;\n    }\n}\nclass SignalRequestError extends LivekitError {\n    constructor(message, reason){\n        super(15, message);\n        this.reason = reason;\n        this.reasonName = typeof reason === \"string\" ? reason : RequestResponse_Reason[reason];\n    }\n}\nvar MediaDeviceFailure;\n(function(MediaDeviceFailure) {\n    // user rejected permissions\n    MediaDeviceFailure[\"PermissionDenied\"] = \"PermissionDenied\";\n    // device is not available\n    MediaDeviceFailure[\"NotFound\"] = \"NotFound\";\n    // device is in use. On Windows, only a single tab may get access to a device at a time.\n    MediaDeviceFailure[\"DeviceInUse\"] = \"DeviceInUse\";\n    MediaDeviceFailure[\"Other\"] = \"Other\";\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\n(function(MediaDeviceFailure) {\n    function getFailure(error) {\n        if (error && \"name\" in error) {\n            if (error.name === \"NotFoundError\" || error.name === \"DevicesNotFoundError\") {\n                return MediaDeviceFailure.NotFound;\n            }\n            if (error.name === \"NotAllowedError\" || error.name === \"PermissionDeniedError\") {\n                return MediaDeviceFailure.PermissionDenied;\n            }\n            if (error.name === \"NotReadableError\" || error.name === \"TrackStartError\") {\n                return MediaDeviceFailure.DeviceInUse;\n            }\n            return MediaDeviceFailure.Other;\n        }\n    }\n    MediaDeviceFailure.getFailure = getFailure;\n})(MediaDeviceFailure || (MediaDeviceFailure = {}));\nvar CryptorErrorReason;\n(function(CryptorErrorReason) {\n    CryptorErrorReason[CryptorErrorReason[\"InvalidKey\"] = 0] = \"InvalidKey\";\n    CryptorErrorReason[CryptorErrorReason[\"MissingKey\"] = 1] = \"MissingKey\";\n    CryptorErrorReason[CryptorErrorReason[\"InternalError\"] = 2] = \"InternalError\";\n})(CryptorErrorReason || (CryptorErrorReason = {}));\nclass CryptorError extends LivekitError {\n    constructor(message){\n        let reason = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CryptorErrorReason.InternalError;\n        let participantIdentity = arguments.length > 2 ? arguments[2] : undefined;\n        super(40, message);\n        this.reason = reason;\n        this.participantIdentity = participantIdentity;\n    }\n}\n/**\n * Events are the primary way LiveKit notifies your application of changes.\n *\n * The following are events emitted by [[Room]], listen to room events like\n *\n * ```typescript\n * room.on(RoomEvent.TrackPublished, (track, publication, participant) => {})\n * ```\n */ var RoomEvent;\n(function(RoomEvent) {\n    /**\n   * When the connection to the server has been established\n   */ RoomEvent[\"Connected\"] = \"connected\";\n    /**\n   * When the connection to the server has been interrupted and it's attempting\n   * to reconnect.\n   */ RoomEvent[\"Reconnecting\"] = \"reconnecting\";\n    /**\n   * When the signal connection to the server has been interrupted. This isn't noticeable to users most of the time.\n   * It will resolve with a `RoomEvent.Reconnected` once the signal connection has been re-established.\n   * If media fails additionally it an additional `RoomEvent.Reconnecting` will be emitted.\n   */ RoomEvent[\"SignalReconnecting\"] = \"signalReconnecting\";\n    /**\n   * Fires when a reconnection has been successful.\n   */ RoomEvent[\"Reconnected\"] = \"reconnected\";\n    /**\n   * When disconnected from room. This fires when room.disconnect() is called or\n   * when an unrecoverable connection issue had occured.\n   *\n   * DisconnectReason can be used to determine why the participant was disconnected. Notable reasons are\n   * - DUPLICATE_IDENTITY: another client with the same identity has joined the room\n   * - PARTICIPANT_REMOVED: participant was removed by RemoveParticipant API\n   * - ROOM_DELETED: the room has ended via DeleteRoom API\n   *\n   * args: ([[DisconnectReason]])\n   */ RoomEvent[\"Disconnected\"] = \"disconnected\";\n    /**\n   * Whenever the connection state of the room changes\n   *\n   * args: ([[ConnectionState]])\n   */ RoomEvent[\"ConnectionStateChanged\"] = \"connectionStateChanged\";\n    /**\n   * When input or output devices on the machine have changed.\n   */ RoomEvent[\"MediaDevicesChanged\"] = \"mediaDevicesChanged\";\n    /**\n   * When a [[RemoteParticipant]] joins *after* the local\n   * participant. It will not emit events for participants that are already\n   * in the room\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantConnected\"] = \"participantConnected\";\n    /**\n   * When a [[RemoteParticipant]] leaves *after* the local\n   * participant has joined.\n   *\n   * args: ([[RemoteParticipant]])\n   */ RoomEvent[\"ParticipantDisconnected\"] = \"participantDisconnected\";\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * The [[LocalParticipant]] has subscribed to a new track. This event will **always**\n   * fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid, [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[Track]], [[RemoteTrackPublication]], [[RemoteParticipant]])\n   */ RoomEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]], [[Participant]])\n   */ RoomEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]], [[LocalParticipant]])\n   */ RoomEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * When a local audio track is published the SDK checks whether there is complete silence\n   * on that track and emits the LocalAudioSilenceDetected event in that case.\n   * This allows for applications to show UI informing users that they might have to\n   * reset their audio hardware or check for proper device connectivity.\n   */ RoomEvent[\"LocalAudioSilenceDetected\"] = \"localAudioSilenceDetected\";\n    /**\n   * Active speakers changed. List of speakers are ordered by their audio level.\n   * loudest speakers first. This will include the LocalParticipant too.\n   *\n   * Speaker updates are sent only to the publishing participant and their subscribers.\n   *\n   * args: (Array<[[Participant]]>)\n   */ RoomEvent[\"ActiveSpeakersChanged\"] = \"activeSpeakersChanged\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   *\n   * args: (prevMetadata: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ RoomEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes and the participant\n   * args: (changedAttributes: [[Record<string, string]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantAttributesChanged\"] = \"participantAttributesChanged\";\n    /**\n   * Room metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateRoomMetadata is called to change a room's state,\n   * *all*  participants in the room will fire this event.\n   *\n   * args: (string)\n   */ RoomEvent[\"RoomMetadataChanged\"] = \"roomMetadataChanged\";\n    /**\n   * Data received from another participant.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, participant: [[Participant]], kind: [[DataPacket_Kind]], topic?: string)\n   */ RoomEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * SIP DTMF tones received from another participant.\n   *\n   * args: (participant: [[Participant]], dtmf: [[DataPacket_Kind]])\n   */ RoomEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n    /**\n   * Transcription received from a participant's track.\n   * @beta\n   */ RoomEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]], participant: [[Participant]])\n   */ RoomEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed (remote) track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.PermissionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of subscribed tracks have changed its status for the current\n   * participant.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]],\n   *        participant: [[RemoteParticipant]])\n   */ RoomEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    /**\n   * LiveKit will attempt to autoplay all audio tracks when you attach them to\n   * audio elements. However, if that fails, we'll notify you via AudioPlaybackStatusChanged.\n   * `Room.canPlaybackAudio` will indicate if audio playback is permitted.\n   */ RoomEvent[\"AudioPlaybackStatusChanged\"] = \"audioPlaybackChanged\";\n    /**\n   * LiveKit will attempt to autoplay all video tracks when you attach them to\n   * a video element. However, if that fails, we'll notify you via VideoPlaybackStatusChanged.\n   * Calling `room.startVideo()` in a user gesture event handler will resume the video playback.\n   */ RoomEvent[\"VideoPlaybackStatusChanged\"] = \"videoPlaybackChanged\";\n    /**\n   * When we have encountered an error while attempting to create a track.\n   * The errors take place in getUserMedia().\n   * Use MediaDeviceFailure.getFailure(error) to get the reason of failure.\n   * [[LocalParticipant.lastCameraError]] and [[LocalParticipant.lastMicrophoneError]]\n   * will indicate if it had an error while creating the audio or video track respectively.\n   *\n   * args: (error: Error)\n   */ RoomEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]], participant: [[Participant]])\n   */ RoomEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /**\n   * Signal connected, can publish tracks.\n   */ RoomEvent[\"SignalConnected\"] = \"signalConnected\";\n    /**\n   * Recording of a room has started/stopped. Room.isRecording will be updated too.\n   * args: (isRecording: boolean)\n   */ RoomEvent[\"RecordingStatusChanged\"] = \"recordingStatusChanged\";\n    RoomEvent[\"ParticipantEncryptionStatusChanged\"] = \"participantEncryptionStatusChanged\";\n    RoomEvent[\"EncryptionError\"] = \"encryptionError\";\n    /**\n   * Emits whenever the current buffer status of a data channel changes\n   * args: (isLow: boolean, kind: [[DataPacket_Kind]])\n   */ RoomEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    /**\n   * Triggered by a call to room.switchActiveDevice\n   * args: (kind: MediaDeviceKind, deviceId: string)\n   */ RoomEvent[\"ActiveDeviceChanged\"] = \"activeDeviceChanged\";\n    RoomEvent[\"ChatMessage\"] = \"chatMessage\";\n    /**\n   * fired when the first remote participant has subscribed to the localParticipant's track\n   */ RoomEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    /**\n   * fired when the client receives connection metrics from other participants\n   */ RoomEvent[\"MetricsReceived\"] = \"metricsReceived\";\n})(RoomEvent || (RoomEvent = {}));\nvar ParticipantEvent;\n(function(ParticipantEvent) {\n    /**\n   * When a new track is published to room *after* the local\n   * participant has joined. It will not fire for tracks that are already published.\n   *\n   * A track published doesn't mean the participant has subscribed to it. It's\n   * simply reflecting the state of the room.\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackPublished\"] = \"trackPublished\";\n    /**\n   * Successfully subscribed to the [[RemoteParticipant]]'s track.\n   * This event will **always** fire as long as new tracks are ready for use.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackSubscribed\"] = \"trackSubscribed\";\n    /**\n   * Could not subscribe to a track\n   *\n   * args: (track sid)\n   */ ParticipantEvent[\"TrackSubscriptionFailed\"] = \"trackSubscriptionFailed\";\n    /**\n   * A [[RemoteParticipant]] has unpublished a track\n   *\n   * args: ([[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnpublished\"] = \"trackUnpublished\";\n    /**\n   * A subscribed track is no longer available. Clients should listen to this\n   * event and ensure they detach tracks.\n   *\n   * args: ([[RemoteTrack]], [[RemoteTrackPublication]])\n   */ ParticipantEvent[\"TrackUnsubscribed\"] = \"trackUnsubscribed\";\n    /**\n   * A track that was muted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackMuted\"] = \"trackMuted\";\n    /**\n   * A track that was unmuted, fires on both [[RemoteParticipant]]s and [[LocalParticipant]]\n   *\n   * args: ([[TrackPublication]])\n   */ ParticipantEvent[\"TrackUnmuted\"] = \"trackUnmuted\";\n    /**\n   * A local track was published successfully. This event is helpful to know\n   * when to update your local UI with the newly published track.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackPublished\"] = \"localTrackPublished\";\n    /**\n   * A local track was unpublished. This event is helpful to know when to remove\n   * the local track from your UI.\n   *\n   * When a user stops sharing their screen by pressing \"End\" on the browser UI,\n   * this event will also fire.\n   *\n   * args: ([[LocalTrackPublication]])\n   */ ParticipantEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    /**\n   * Participant metadata is a simple way for app-specific state to be pushed to\n   * all users.\n   * When RoomService.UpdateParticipantMetadata is called to change a participant's\n   * state, *all*  participants in the room will fire this event.\n   * To access the current metadata, see [[Participant.metadata]].\n   *\n   * args: (prevMetadata: string)\n   *\n   */ ParticipantEvent[\"ParticipantMetadataChanged\"] = \"participantMetadataChanged\";\n    /**\n   * Participant's display name changed\n   *\n   * args: (name: string, [[Participant]])\n   *\n   */ ParticipantEvent[\"ParticipantNameChanged\"] = \"participantNameChanged\";\n    /**\n   * Data received from this participant as sender.\n   * Data packets provides the ability to use LiveKit to send/receive arbitrary payloads.\n   * All participants in the room will receive the messages sent to the room.\n   *\n   * args: (payload: Uint8Array, kind: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"DataReceived\"] = \"dataReceived\";\n    /**\n   * SIP DTMF tones received from this participant as sender.\n   *\n   * args: (dtmf: [[DataPacket_Kind]])\n   */ ParticipantEvent[\"SipDTMFReceived\"] = \"sipDTMFReceived\";\n    /**\n   * Transcription received from this participant as data source.\n   * @beta\n   */ ParticipantEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * Has speaking status changed for the current participant\n   *\n   * args: (speaking: boolean)\n   */ ParticipantEvent[\"IsSpeakingChanged\"] = \"isSpeakingChanged\";\n    /**\n   * Connection quality was changed for a Participant. It'll receive updates\n   * from the local participant, as well as any [[RemoteParticipant]]s that we are\n   * subscribed to.\n   *\n   * args: (connectionQuality: [[ConnectionQuality]])\n   */ ParticipantEvent[\"ConnectionQualityChanged\"] = \"connectionQualityChanged\";\n    /**\n   * StreamState indicates if a subscribed track has been paused by the SFU\n   * (typically this happens because of subscriber's bandwidth constraints)\n   *\n   * When bandwidth conditions allow, the track will be resumed automatically.\n   * TrackStreamStateChanged will also be emitted when that happens.\n   *\n   * args: (pub: [[RemoteTrackPublication]], streamState: [[Track.StreamState]])\n   */ ParticipantEvent[\"TrackStreamStateChanged\"] = \"trackStreamStateChanged\";\n    /**\n   * One of subscribed tracks have changed its permissions for the current\n   * participant. If permission was revoked, then the track will no longer\n   * be subscribed. If permission was granted, a TrackSubscribed event will\n   * be emitted.\n   *\n   * args: (pub: [[RemoteTrackPublication]],\n   *        status: [[TrackPublication.SubscriptionStatus]])\n   */ ParticipantEvent[\"TrackSubscriptionPermissionChanged\"] = \"trackSubscriptionPermissionChanged\";\n    /**\n   * One of the remote participants publications has changed its subscription status.\n   *\n   */ ParticipantEvent[\"TrackSubscriptionStatusChanged\"] = \"trackSubscriptionStatusChanged\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"MediaDevicesError\"] = \"mediaDevicesError\";\n    // fired only on LocalParticipant\n    /** @internal */ ParticipantEvent[\"AudioStreamAcquired\"] = \"audioStreamAcquired\";\n    /**\n   * A participant's permission has changed.\n   * args: (prevPermissions: [[ParticipantPermission]])\n   */ ParticipantEvent[\"ParticipantPermissionsChanged\"] = \"participantPermissionsChanged\";\n    /** @internal */ ParticipantEvent[\"PCTrackAdded\"] = \"pcTrackAdded\";\n    /**\n   * Participant attributes is an app-specific key value state to be pushed to\n   * all users.\n   * When a participant's attributes changed, this event will be emitted with the changed attributes\n   * args: (changedAttributes: [[Record<string, string]])\n   */ ParticipantEvent[\"AttributesChanged\"] = \"attributesChanged\";\n    /**\n   * fired on local participant only, when the first remote participant has subscribed to the track specified in the payload\n   */ ParticipantEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    /** only emitted on local participant */ ParticipantEvent[\"ChatMessage\"] = \"chatMessage\";\n})(ParticipantEvent || (ParticipantEvent = {}));\n/** @internal */ var EngineEvent;\n(function(EngineEvent) {\n    EngineEvent[\"TransportsCreated\"] = \"transportsCreated\";\n    EngineEvent[\"Connected\"] = \"connected\";\n    EngineEvent[\"Disconnected\"] = \"disconnected\";\n    EngineEvent[\"Resuming\"] = \"resuming\";\n    EngineEvent[\"Resumed\"] = \"resumed\";\n    EngineEvent[\"Restarting\"] = \"restarting\";\n    EngineEvent[\"Restarted\"] = \"restarted\";\n    EngineEvent[\"SignalResumed\"] = \"signalResumed\";\n    EngineEvent[\"SignalRestarted\"] = \"signalRestarted\";\n    EngineEvent[\"Closing\"] = \"closing\";\n    EngineEvent[\"MediaTrackAdded\"] = \"mediaTrackAdded\";\n    EngineEvent[\"ActiveSpeakersUpdate\"] = \"activeSpeakersUpdate\";\n    EngineEvent[\"DataPacketReceived\"] = \"dataPacketReceived\";\n    EngineEvent[\"RTPVideoMapUpdate\"] = \"rtpVideoMapUpdate\";\n    EngineEvent[\"DCBufferStatusChanged\"] = \"dcBufferStatusChanged\";\n    EngineEvent[\"ParticipantUpdate\"] = \"participantUpdate\";\n    EngineEvent[\"RoomUpdate\"] = \"roomUpdate\";\n    EngineEvent[\"SpeakersChanged\"] = \"speakersChanged\";\n    EngineEvent[\"StreamStateChanged\"] = \"streamStateChanged\";\n    EngineEvent[\"ConnectionQualityUpdate\"] = \"connectionQualityUpdate\";\n    EngineEvent[\"SubscriptionError\"] = \"subscriptionError\";\n    EngineEvent[\"SubscriptionPermissionUpdate\"] = \"subscriptionPermissionUpdate\";\n    EngineEvent[\"RemoteMute\"] = \"remoteMute\";\n    EngineEvent[\"SubscribedQualityUpdate\"] = \"subscribedQualityUpdate\";\n    EngineEvent[\"LocalTrackUnpublished\"] = \"localTrackUnpublished\";\n    EngineEvent[\"LocalTrackSubscribed\"] = \"localTrackSubscribed\";\n    EngineEvent[\"Offline\"] = \"offline\";\n    EngineEvent[\"SignalRequestResponse\"] = \"signalRequestResponse\";\n    EngineEvent[\"SignalConnected\"] = \"signalConnected\";\n})(EngineEvent || (EngineEvent = {}));\nvar TrackEvent;\n(function(TrackEvent) {\n    TrackEvent[\"Message\"] = \"message\";\n    TrackEvent[\"Muted\"] = \"muted\";\n    TrackEvent[\"Unmuted\"] = \"unmuted\";\n    /**\n   * Only fires on LocalTracks\n   */ TrackEvent[\"Restarted\"] = \"restarted\";\n    TrackEvent[\"Ended\"] = \"ended\";\n    TrackEvent[\"Subscribed\"] = \"subscribed\";\n    TrackEvent[\"Unsubscribed\"] = \"unsubscribed\";\n    /** @internal */ TrackEvent[\"UpdateSettings\"] = \"updateSettings\";\n    /** @internal */ TrackEvent[\"UpdateSubscription\"] = \"updateSubscription\";\n    /** @internal */ TrackEvent[\"AudioPlaybackStarted\"] = \"audioPlaybackStarted\";\n    /** @internal */ TrackEvent[\"AudioPlaybackFailed\"] = \"audioPlaybackFailed\";\n    /**\n   * @internal\n   * Only fires on LocalAudioTrack instances\n   */ TrackEvent[\"AudioSilenceDetected\"] = \"audioSilenceDetected\";\n    /** @internal */ TrackEvent[\"VisibilityChanged\"] = \"visibilityChanged\";\n    /** @internal */ TrackEvent[\"VideoDimensionsChanged\"] = \"videoDimensionsChanged\";\n    /** @internal */ TrackEvent[\"VideoPlaybackStarted\"] = \"videoPlaybackStarted\";\n    /** @internal */ TrackEvent[\"VideoPlaybackFailed\"] = \"videoPlaybackFailed\";\n    /** @internal */ TrackEvent[\"ElementAttached\"] = \"elementAttached\";\n    /** @internal */ TrackEvent[\"ElementDetached\"] = \"elementDetached\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamPaused\"] = \"upstreamPaused\";\n    /**\n   * @internal\n   * Only fires on LocalTracks\n   */ TrackEvent[\"UpstreamResumed\"] = \"upstreamResumed\";\n    /**\n   * @internal\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionPermissionChanged\"] = \"subscriptionPermissionChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionStatusChanged\"] = \"subscriptionStatusChanged\";\n    /**\n   * Fires on RemoteTrackPublication\n   */ TrackEvent[\"SubscriptionFailed\"] = \"subscriptionFailed\";\n    /**\n   * @internal\n   */ TrackEvent[\"TrackProcessorUpdate\"] = \"trackProcessorUpdate\";\n    /**\n   * @internal\n   */ TrackEvent[\"AudioTrackFeatureUpdate\"] = \"audioTrackFeatureUpdate\";\n    /**\n   * @beta\n   */ TrackEvent[\"TranscriptionReceived\"] = \"transcriptionReceived\";\n    /**\n   * @experimental\n   */ TrackEvent[\"TimeSyncUpdate\"] = \"timeSyncUpdate\";\n})(TrackEvent || (TrackEvent = {}));\nfunction cloneDeep(value) {\n    if (typeof value === \"undefined\") {\n        return value;\n    }\n    if (typeof structuredClone === \"function\") {\n        return structuredClone(value);\n    } else {\n        return JSON.parse(JSON.stringify(value));\n    }\n}\n// tiny, simplified version of https://github.com/lancedikson/bowser/blob/master/src/parser-browsers.js\n// reduced to only differentiate Chrome(ium) based browsers / Firefox / Safari\nconst commonVersionIdentifier = /version\\/(\\d+(\\.?_?\\d+)+)/i;\nlet browserDetails;\n/**\n * @internal\n */ function getBrowser(userAgent) {\n    let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (typeof userAgent === \"undefined\" && typeof navigator === \"undefined\") {\n        return;\n    }\n    const ua = (userAgent !== null && userAgent !== void 0 ? userAgent : navigator.userAgent).toLowerCase();\n    if (browserDetails === undefined || force) {\n        const browser = browsersList.find((_ref)=>{\n            let { test } = _ref;\n            return test.test(ua);\n        });\n        browserDetails = browser === null || browser === void 0 ? void 0 : browser.describe(ua);\n    }\n    return browserDetails;\n}\nconst browsersList = [\n    {\n        test: /firefox|iceweasel|fxios/i,\n        describe (ua) {\n            const browser = {\n                name: \"Firefox\",\n                version: getMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"fxios\") ? \"iOS\" : undefined,\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    },\n    {\n        test: /chrom|crios|crmo/i,\n        describe (ua) {\n            const browser = {\n                name: \"Chrome\",\n                version: getMatch(/(?:chrome|chromium|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i, ua),\n                os: ua.toLowerCase().includes(\"crios\") ? \"iOS\" : undefined,\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    },\n    /* Safari */ {\n        test: /safari|applewebkit/i,\n        describe (ua) {\n            const browser = {\n                name: \"Safari\",\n                version: getMatch(commonVersionIdentifier, ua),\n                os: ua.includes(\"mobile/\") ? \"iOS\" : \"macOS\",\n                osVersion: getOSVersion(ua)\n            };\n            return browser;\n        }\n    }\n];\nfunction getMatch(exp, ua) {\n    let id = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n    const match = ua.match(exp);\n    return match && match.length >= id && match[id] || \"\";\n}\nfunction getOSVersion(ua) {\n    return ua.includes(\"mac os\") ? getMatch(/\\(.+?(\\d+_\\d+(:?_\\d+)?)/, ua, 1).replace(/_/g, \".\") : undefined;\n}\nvar version$1 = \"2.11.3\";\nconst version = version$1;\nconst protocolVersion = 15;\n/**\n * Timers that can be overridden with platform specific implementations\n * that ensure that they are fired. These should be used when it is critical\n * that the timer fires on time.\n */ class CriticalTimers {\n}\nCriticalTimers.setTimeout = function() {\n    return setTimeout(...arguments);\n};\nCriticalTimers.setInterval = // eslint-disable-next-line @typescript-eslint/no-implied-eval\nfunction() {\n    return setInterval(...arguments);\n};\nCriticalTimers.clearTimeout = function() {\n    return clearTimeout(...arguments);\n};\nCriticalTimers.clearInterval = function() {\n    return clearInterval(...arguments);\n};\nconst BACKGROUND_REACTION_DELAY = 5000;\n// keep old audio elements when detached, we would re-use them since on iOS\n// Safari tracks which audio elements have been \"blessed\" by the user.\nconst recycledElements = [];\nvar VideoQuality;\n(function(VideoQuality) {\n    VideoQuality[VideoQuality[\"LOW\"] = 0] = \"LOW\";\n    VideoQuality[VideoQuality[\"MEDIUM\"] = 1] = \"MEDIUM\";\n    VideoQuality[VideoQuality[\"HIGH\"] = 2] = \"HIGH\";\n})(VideoQuality || (VideoQuality = {}));\nclass Track extends eventsExports.EventEmitter {\n    constructor(mediaTrack, kind){\n        let loggerOptions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var _a;\n        super();\n        this.attachedElements = [];\n        this.isMuted = false;\n        /**\n     * indicates current state of stream, it'll indicate `paused` if the track\n     * has been paused by congestion controller\n     */ this.streamState = Track.StreamState.Active;\n        this.isInBackground = false;\n        this._currentBitrate = 0;\n        this.log = livekitLogger;\n        this.appVisibilityChangedListener = ()=>{\n            if (this.backgroundTimeout) {\n                clearTimeout(this.backgroundTimeout);\n            }\n            // delay app visibility update if it goes to hidden\n            // update immediately if it comes back to focus\n            if (document.visibilityState === \"hidden\") {\n                this.backgroundTimeout = setTimeout(()=>this.handleAppVisibilityChanged(), BACKGROUND_REACTION_DELAY);\n            } else {\n                this.handleAppVisibilityChanged();\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Track);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this._mediaStreamTrack = mediaTrack;\n        this._mediaStreamID = mediaTrack.id;\n        this.source = Track.Source.Unknown;\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    /** current receive bits per second */ get currentBitrate() {\n        return this._currentBitrate;\n    }\n    get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /**\n   * @internal\n   * used for keep mediaStream's first id, since it's id might change\n   * if we disable/enable a track\n   */ get mediaStreamID() {\n        return this._mediaStreamID;\n    }\n    attach(element) {\n        let elementType = \"audio\";\n        if (this.kind === Track.Kind.Video) {\n            elementType = \"video\";\n        }\n        if (this.attachedElements.length === 0 && this.kind === Track.Kind.Video) {\n            this.addAppVisibilityListener();\n        }\n        if (!element) {\n            if (elementType === \"audio\") {\n                recycledElements.forEach((e)=>{\n                    if (e.parentElement === null && !element) {\n                        element = e;\n                    }\n                });\n                if (element) {\n                    // remove it from pool\n                    recycledElements.splice(recycledElements.indexOf(element), 1);\n                }\n            }\n            if (!element) {\n                element = document.createElement(elementType);\n            }\n        }\n        if (!this.attachedElements.includes(element)) {\n            this.attachedElements.push(element);\n        }\n        // even if we believe it's already attached to the element, it's possible\n        // the element's srcObject was set to something else out of band.\n        // we'll want to re-attach it in that case\n        attachToElement(this.mediaStreamTrack, element);\n        // handle auto playback failures\n        const allMediaStreamTracks = element.srcObject.getTracks();\n        const hasAudio = allMediaStreamTracks.some((tr)=>tr.kind === \"audio\");\n        // manually play media to detect auto playback status\n        element.play().then(()=>{\n            this.emit(hasAudio ? TrackEvent.AudioPlaybackStarted : TrackEvent.VideoPlaybackStarted);\n        }).catch((e)=>{\n            if (e.name === \"NotAllowedError\") {\n                this.emit(hasAudio ? TrackEvent.AudioPlaybackFailed : TrackEvent.VideoPlaybackFailed, e);\n            } else if (e.name === \"AbortError\") {\n                // commonly triggered by another `play` request, only log for debugging purposes\n                livekitLogger.debug(\"\".concat(hasAudio ? \"audio\" : \"video\", \" playback aborted, likely due to new play request\"));\n            } else {\n                livekitLogger.warn(\"could not playback \".concat(hasAudio ? \"audio\" : \"video\"), e);\n            }\n            // If audio playback isn't allowed make sure we still play back the video\n            if (hasAudio && element && allMediaStreamTracks.some((tr)=>tr.kind === \"video\") && e.name === \"NotAllowedError\") {\n                element.muted = true;\n                element.play().catch(()=>{\n                // catch for Safari, exceeded options at this point to automatically play the media element\n                });\n            }\n        });\n        this.emit(TrackEvent.ElementAttached, element);\n        return element;\n    }\n    detach(element) {\n        try {\n            // detach from a single element\n            if (element) {\n                detachTrack(this.mediaStreamTrack, element);\n                const idx = this.attachedElements.indexOf(element);\n                if (idx >= 0) {\n                    this.attachedElements.splice(idx, 1);\n                    this.recycleElement(element);\n                    this.emit(TrackEvent.ElementDetached, element);\n                }\n                return element;\n            }\n            const detached = [];\n            this.attachedElements.forEach((elm)=>{\n                detachTrack(this.mediaStreamTrack, elm);\n                detached.push(elm);\n                this.recycleElement(elm);\n                this.emit(TrackEvent.ElementDetached, elm);\n            });\n            // remove all tracks\n            this.attachedElements = [];\n            return detached;\n        } finally{\n            if (this.attachedElements.length === 0) {\n                this.removeAppVisibilityListener();\n            }\n        }\n    }\n    stop() {\n        this.stopMonitor();\n        this._mediaStreamTrack.stop();\n    }\n    enable() {\n        this._mediaStreamTrack.enabled = true;\n    }\n    disable() {\n        this._mediaStreamTrack.enabled = false;\n    }\n    /* @internal */ stopMonitor() {\n        if (this.monitorInterval) {\n            clearInterval(this.monitorInterval);\n        }\n        if (this.timeSyncHandle) {\n            cancelAnimationFrame(this.timeSyncHandle);\n        }\n    }\n    /** @internal */ updateLoggerOptions(loggerOptions) {\n        if (loggerOptions.loggerName) {\n            this.log = getLogger(loggerOptions.loggerName);\n        }\n        if (loggerOptions.loggerContextCb) {\n            this.loggerContextCb = loggerOptions.loggerContextCb;\n        }\n    }\n    recycleElement(element) {\n        if (element instanceof HTMLAudioElement) {\n            // we only need to re-use a single element\n            let shouldCache = true;\n            element.pause();\n            recycledElements.forEach((e)=>{\n                if (!e.parentElement) {\n                    shouldCache = false;\n                }\n            });\n            if (shouldCache) {\n                recycledElements.push(element);\n            }\n        }\n    }\n    handleAppVisibilityChanged() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            if (!this.isInBackground && this.kind === Track.Kind.Video) {\n                setTimeout(()=>this.attachedElements.forEach((el)=>el.play().catch(()=>{\n                        /** catch clause necessary for Safari */ })), 0);\n            }\n        });\n    }\n    addAppVisibilityListener() {\n        if (isWeb()) {\n            this.isInBackground = document.visibilityState === \"hidden\";\n            document.addEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        } else {\n            this.isInBackground = false;\n        }\n    }\n    removeAppVisibilityListener() {\n        if (isWeb()) {\n            document.removeEventListener(\"visibilitychange\", this.appVisibilityChangedListener);\n        }\n    }\n}\nfunction attachToElement(track, element) {\n    let mediaStream;\n    if (element.srcObject instanceof MediaStream) {\n        mediaStream = element.srcObject;\n    } else {\n        mediaStream = new MediaStream();\n    }\n    // check if track matches existing track\n    let existingTracks;\n    if (track.kind === \"audio\") {\n        existingTracks = mediaStream.getAudioTracks();\n    } else {\n        existingTracks = mediaStream.getVideoTracks();\n    }\n    if (!existingTracks.includes(track)) {\n        existingTracks.forEach((et)=>{\n            mediaStream.removeTrack(et);\n        });\n        mediaStream.addTrack(track);\n    }\n    if (!isSafari() || !(element instanceof HTMLVideoElement)) {\n        // when in low power mode (applies to both macOS and iOS), Safari will show a play/pause overlay\n        // when a video starts that has the `autoplay` attribute is set.\n        // we work around this by _not_ setting the autoplay attribute on safari and instead call `setTimeout(() => el.play(),0)` further down\n        element.autoplay = true;\n    }\n    // In case there are no audio tracks present on the mediastream, we set the element as muted to ensure autoplay works\n    element.muted = mediaStream.getAudioTracks().length === 0;\n    if (element instanceof HTMLVideoElement) {\n        element.playsInline = true;\n    }\n    // avoid flicker\n    if (element.srcObject !== mediaStream) {\n        element.srcObject = mediaStream;\n        if ((isSafari() || isFireFox()) && element instanceof HTMLVideoElement) {\n            // Firefox also has a timing issue where video doesn't actually get attached unless\n            // performed out-of-band\n            // Safari 15 has a bug where in certain layouts, video element renders\n            // black until the page is resized or other changes take place.\n            // Resetting the src triggers it to render.\n            // https://developer.apple.com/forums/thread/690523\n            setTimeout(()=>{\n                element.srcObject = mediaStream;\n                // Safari 15 sometimes fails to start a video\n                // when the window is backgrounded before the first frame is drawn\n                // manually calling play here seems to fix that\n                element.play().catch(()=>{\n                /** do nothing */ });\n            }, 0);\n        }\n    }\n}\n/** @internal */ function detachTrack(track, element) {\n    if (element.srcObject instanceof MediaStream) {\n        const mediaStream = element.srcObject;\n        mediaStream.removeTrack(track);\n        if (mediaStream.getTracks().length > 0) {\n            element.srcObject = mediaStream;\n        } else {\n            element.srcObject = null;\n        }\n    }\n}\n(function(Track) {\n    let Kind;\n    (function(Kind) {\n        Kind[\"Audio\"] = \"audio\";\n        Kind[\"Video\"] = \"video\";\n        Kind[\"Unknown\"] = \"unknown\";\n    })(Kind = Track.Kind || (Track.Kind = {}));\n    let Source;\n    (function(Source) {\n        Source[\"Camera\"] = \"camera\";\n        Source[\"Microphone\"] = \"microphone\";\n        Source[\"ScreenShare\"] = \"screen_share\";\n        Source[\"ScreenShareAudio\"] = \"screen_share_audio\";\n        Source[\"Unknown\"] = \"unknown\";\n    })(Source = Track.Source || (Track.Source = {}));\n    let StreamState$1;\n    (function(StreamState) {\n        StreamState[\"Active\"] = \"active\";\n        StreamState[\"Paused\"] = \"paused\";\n        StreamState[\"Unknown\"] = \"unknown\";\n    })(StreamState$1 = Track.StreamState || (Track.StreamState = {}));\n    /** @internal */ function kindToProto(k) {\n        switch(k){\n            case Kind.Audio:\n                return TrackType.AUDIO;\n            case Kind.Video:\n                return TrackType.VIDEO;\n            default:\n                // FIXME this was UNRECOGNIZED before\n                return TrackType.DATA;\n        }\n    }\n    Track.kindToProto = kindToProto;\n    /** @internal */ function kindFromProto(t) {\n        switch(t){\n            case TrackType.AUDIO:\n                return Kind.Audio;\n            case TrackType.VIDEO:\n                return Kind.Video;\n            default:\n                return Kind.Unknown;\n        }\n    }\n    Track.kindFromProto = kindFromProto;\n    /** @internal */ function sourceToProto(s) {\n        switch(s){\n            case Source.Camera:\n                return TrackSource.CAMERA;\n            case Source.Microphone:\n                return TrackSource.MICROPHONE;\n            case Source.ScreenShare:\n                return TrackSource.SCREEN_SHARE;\n            case Source.ScreenShareAudio:\n                return TrackSource.SCREEN_SHARE_AUDIO;\n            default:\n                return TrackSource.UNKNOWN;\n        }\n    }\n    Track.sourceToProto = sourceToProto;\n    /** @internal */ function sourceFromProto(s) {\n        switch(s){\n            case TrackSource.CAMERA:\n                return Source.Camera;\n            case TrackSource.MICROPHONE:\n                return Source.Microphone;\n            case TrackSource.SCREEN_SHARE:\n                return Source.ScreenShare;\n            case TrackSource.SCREEN_SHARE_AUDIO:\n                return Source.ScreenShareAudio;\n            default:\n                return Source.Unknown;\n        }\n    }\n    Track.sourceFromProto = sourceFromProto;\n    /** @internal */ function streamStateFromProto(s) {\n        switch(s){\n            case StreamState.ACTIVE:\n                return StreamState$1.Active;\n            case StreamState.PAUSED:\n                return StreamState$1.Paused;\n            default:\n                return StreamState$1.Unknown;\n        }\n    }\n    Track.streamStateFromProto = streamStateFromProto;\n})(Track || (Track = {}));\nclass VideoPreset {\n    constructor(widthOrOptions, height, maxBitrate, maxFramerate, priority){\n        if (typeof widthOrOptions === \"object\") {\n            this.width = widthOrOptions.width;\n            this.height = widthOrOptions.height;\n            this.aspectRatio = widthOrOptions.aspectRatio;\n            this.encoding = {\n                maxBitrate: widthOrOptions.maxBitrate,\n                maxFramerate: widthOrOptions.maxFramerate,\n                priority: widthOrOptions.priority\n            };\n        } else if (height !== undefined && maxBitrate !== undefined) {\n            this.width = widthOrOptions;\n            this.height = height;\n            this.aspectRatio = widthOrOptions / height;\n            this.encoding = {\n                maxBitrate,\n                maxFramerate,\n                priority\n            };\n        } else {\n            throw new TypeError(\"Unsupported options: provide at least width, height and maxBitrate\");\n        }\n    }\n    get resolution() {\n        return {\n            width: this.width,\n            height: this.height,\n            frameRate: this.encoding.maxFramerate,\n            aspectRatio: this.aspectRatio\n        };\n    }\n}\nconst backupCodecs = [\n    \"vp8\",\n    \"h264\"\n];\nconst videoCodecs = [\n    \"vp8\",\n    \"h264\",\n    \"vp9\",\n    \"av1\"\n];\nfunction isBackupCodec(codec) {\n    return !!backupCodecs.find((backup)=>backup === codec);\n}\nvar BackupCodecPolicy;\n(function(BackupCodecPolicy) {\n    // codec regression is preferred, the sfu will try to regress codec if possible but not guaranteed\n    BackupCodecPolicy[BackupCodecPolicy[\"PREFER_REGRESSION\"] = 0] = \"PREFER_REGRESSION\";\n    // multi-codec simulcast, publish both primary and backup codec at the same time\n    BackupCodecPolicy[BackupCodecPolicy[\"SIMULCAST\"] = 1] = \"SIMULCAST\";\n    // always use backup codec only\n    BackupCodecPolicy[BackupCodecPolicy[\"REGRESSION\"] = 2] = \"REGRESSION\";\n})(BackupCodecPolicy || (BackupCodecPolicy = {}));\nvar AudioPresets;\n(function(AudioPresets) {\n    AudioPresets.telephone = {\n        maxBitrate: 12000\n    };\n    AudioPresets.speech = {\n        maxBitrate: 24000\n    };\n    AudioPresets.music = {\n        maxBitrate: 48000\n    };\n    AudioPresets.musicStereo = {\n        maxBitrate: 64000\n    };\n    AudioPresets.musicHighQuality = {\n        maxBitrate: 96000\n    };\n    AudioPresets.musicHighQualityStereo = {\n        maxBitrate: 128000\n    };\n})(AudioPresets || (AudioPresets = {}));\n/**\n * Sane presets for video resolution/encoding\n */ const VideoPresets = {\n    h90: new VideoPreset(160, 90, 90000, 20),\n    h180: new VideoPreset(320, 180, 160000, 20),\n    h216: new VideoPreset(384, 216, 180000, 20),\n    h360: new VideoPreset(640, 360, 450000, 20),\n    h540: new VideoPreset(960, 540, 800000, 25),\n    h720: new VideoPreset(1280, 720, 1700000, 30),\n    h1080: new VideoPreset(1920, 1080, 3000000, 30),\n    h1440: new VideoPreset(2560, 1440, 5000000, 30),\n    h2160: new VideoPreset(3840, 2160, 8000000, 30)\n};\n/**\n * Four by three presets\n */ const VideoPresets43 = {\n    h120: new VideoPreset(160, 120, 70000, 20),\n    h180: new VideoPreset(240, 180, 125000, 20),\n    h240: new VideoPreset(320, 240, 140000, 20),\n    h360: new VideoPreset(480, 360, 330000, 20),\n    h480: new VideoPreset(640, 480, 500000, 20),\n    h540: new VideoPreset(720, 540, 600000, 25),\n    h720: new VideoPreset(960, 720, 1300000, 30),\n    h1080: new VideoPreset(1440, 1080, 2300000, 30),\n    h1440: new VideoPreset(1920, 1440, 3800000, 30)\n};\nconst ScreenSharePresets = {\n    h360fps3: new VideoPreset(640, 360, 200000, 3, \"medium\"),\n    h360fps15: new VideoPreset(640, 360, 400000, 15, \"medium\"),\n    h720fps5: new VideoPreset(1280, 720, 800000, 5, \"medium\"),\n    h720fps15: new VideoPreset(1280, 720, 1500000, 15, \"medium\"),\n    h720fps30: new VideoPreset(1280, 720, 2000000, 30, \"medium\"),\n    h1080fps15: new VideoPreset(1920, 1080, 2500000, 15, \"medium\"),\n    h1080fps30: new VideoPreset(1920, 1080, 5000000, 30, \"medium\"),\n    // original resolution, without resizing\n    original: new VideoPreset(0, 0, 7000000, 30, \"medium\")\n};\nconst separator = \"|\";\nconst ddExtensionURI = \"https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension\";\nfunction unpackStreamId(packed) {\n    const parts = packed.split(separator);\n    if (parts.length > 1) {\n        return [\n            parts[0],\n            packed.substr(parts[0].length + 1)\n        ];\n    }\n    return [\n        packed,\n        \"\"\n    ];\n}\nfunction sleep(duration) {\n    return __awaiter(this, void 0, void 0, function*() {\n        return new Promise((resolve)=>CriticalTimers.setTimeout(resolve, duration));\n    });\n}\n/** @internal */ function supportsTransceiver() {\n    return \"addTransceiver\" in RTCPeerConnection.prototype;\n}\n/** @internal */ function supportsAddTrack() {\n    return \"addTrack\" in RTCPeerConnection.prototype;\n}\nfunction supportsAdaptiveStream() {\n    return typeof ResizeObserver !== undefined && typeof IntersectionObserver !== undefined;\n}\nfunction supportsDynacast() {\n    return supportsTransceiver();\n}\nfunction supportsAV1() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isSafari()) {\n        // Safari 17 on iPhone14 reports AV1 capability, but does not actually support it\n        return false;\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasAV1 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/AV1\") {\n                hasAV1 = true;\n                break;\n            }\n        }\n    }\n    return hasAV1;\n}\nfunction supportsVP9() {\n    if (!(\"getCapabilities\" in RTCRtpSender)) {\n        return false;\n    }\n    if (isFireFox()) {\n        // technically speaking FireFox supports VP9, but SVC publishing is broken\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1633876\n        return false;\n    }\n    if (isSafari()) {\n        const browser = getBrowser();\n        if ((browser === null || browser === void 0 ? void 0 : browser.version) && compareVersions(browser.version, \"16\") < 0) {\n            // Safari 16 and below does not support VP9\n            return false;\n        }\n    }\n    const capabilities = RTCRtpSender.getCapabilities(\"video\");\n    let hasVP9 = false;\n    if (capabilities) {\n        for (const codec of capabilities.codecs){\n            if (codec.mimeType === \"video/VP9\") {\n                hasVP9 = true;\n                break;\n            }\n        }\n    }\n    return hasVP9;\n}\nfunction isSVCCodec(codec) {\n    return codec === \"av1\" || codec === \"vp9\";\n}\nfunction supportsSetSinkId(elm) {\n    if (!document) {\n        return false;\n    }\n    if (!elm) {\n        elm = document.createElement(\"audio\");\n    }\n    return \"setSinkId\" in elm;\n}\nfunction isBrowserSupported() {\n    if (typeof RTCPeerConnection === \"undefined\") {\n        return false;\n    }\n    return supportsTransceiver() || supportsAddTrack();\n}\nfunction isFireFox() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Firefox\";\n}\nfunction isSafari() {\n    var _a;\n    return ((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.name) === \"Safari\";\n}\nfunction isSafari17() {\n    const b = getBrowser();\n    return (b === null || b === void 0 ? void 0 : b.name) === \"Safari\" && b.version.startsWith(\"17.\");\n}\nfunction isMobile() {\n    var _a, _b;\n    if (!isWeb()) return false;\n    return(// @ts-expect-error `userAgentData` is not yet part of typescript\n    (_b = (_a = navigator.userAgentData) === null || _a === void 0 ? void 0 : _a.mobile) !== null && _b !== void 0 ? _b : /Tablet|iPad|Mobile|Android|BlackBerry/.test(navigator.userAgent));\n}\nfunction isE2EESimulcastSupported() {\n    const browser = getBrowser();\n    const supportedSafariVersion = \"17.2\"; // see https://bugs.webkit.org/show_bug.cgi?id=257803\n    if (browser) {\n        if (browser.name !== \"Safari\" && browser.os !== \"iOS\") {\n            return true;\n        } else if (browser.os === \"iOS\" && browser.osVersion && compareVersions(supportedSafariVersion, browser.osVersion) >= 0) {\n            return true;\n        } else if (browser.name === \"Safari\" && compareVersions(supportedSafariVersion, browser.version) >= 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\nfunction isWeb() {\n    return typeof document !== \"undefined\";\n}\nfunction isReactNative() {\n    // navigator.product is deprecated on browsers, but will be set appropriately for react-native.\n    return navigator.product == \"ReactNative\";\n}\nfunction isCloud(serverUrl) {\n    return serverUrl.hostname.endsWith(\".livekit.cloud\") || serverUrl.hostname.endsWith(\".livekit.run\");\n}\nfunction getLKReactNativeInfo() {\n    // global defined only for ReactNative.\n    // @ts-ignore\n    if (global && global.LiveKitReactNativeGlobal) {\n        // @ts-ignore\n        return global.LiveKitReactNativeGlobal;\n    }\n    return undefined;\n}\nfunction getReactNativeOs() {\n    if (!isReactNative()) {\n        return undefined;\n    }\n    let info = getLKReactNativeInfo();\n    if (info) {\n        return info.platform;\n    }\n    return undefined;\n}\nfunction getDevicePixelRatio() {\n    if (isWeb()) {\n        return window.devicePixelRatio;\n    }\n    if (isReactNative()) {\n        let info = getLKReactNativeInfo();\n        if (info) {\n            return info.devicePixelRatio;\n        }\n    }\n    return 1;\n}\nfunction compareVersions(v1, v2) {\n    const parts1 = v1.split(\".\");\n    const parts2 = v2.split(\".\");\n    const k = Math.min(parts1.length, parts2.length);\n    for(let i = 0; i < k; ++i){\n        const p1 = parseInt(parts1[i], 10);\n        const p2 = parseInt(parts2[i], 10);\n        if (p1 > p2) return 1;\n        if (p1 < p2) return -1;\n        if (i === k - 1 && p1 === p2) return 0;\n    }\n    if (v1 === \"\" && v2 !== \"\") {\n        return -1;\n    } else if (v2 === \"\") {\n        return 1;\n    }\n    return parts1.length == parts2.length ? 0 : parts1.length < parts2.length ? -1 : 1;\n}\nfunction roDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleResize(entry);\n    }\n}\nfunction ioDispatchCallback(entries) {\n    for (const entry of entries){\n        entry.target.handleVisibilityChanged(entry);\n    }\n}\nlet resizeObserver = null;\nconst getResizeObserver = ()=>{\n    if (!resizeObserver) resizeObserver = new ResizeObserver(roDispatchCallback);\n    return resizeObserver;\n};\nlet intersectionObserver = null;\nconst getIntersectionObserver = ()=>{\n    if (!intersectionObserver) {\n        intersectionObserver = new IntersectionObserver(ioDispatchCallback, {\n            root: null,\n            rootMargin: \"0px\"\n        });\n    }\n    return intersectionObserver;\n};\nfunction getClientInfo() {\n    var _a;\n    const info = new ClientInfo({\n        sdk: ClientInfo_SDK.JS,\n        protocol: protocolVersion,\n        version\n    });\n    if (isReactNative()) {\n        info.os = (_a = getReactNativeOs()) !== null && _a !== void 0 ? _a : \"\";\n    }\n    return info;\n}\nlet emptyVideoStreamTrack;\nfunction getEmptyVideoStreamTrack() {\n    if (!emptyVideoStreamTrack) {\n        emptyVideoStreamTrack = createDummyVideoStreamTrack();\n    }\n    return emptyVideoStreamTrack.clone();\n}\nfunction createDummyVideoStreamTrack() {\n    let width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 16;\n    let height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;\n    let enabled = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let paintContent = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    const canvas = document.createElement(\"canvas\");\n    // the canvas size is set to 16 by default, because electron apps seem to fail with smaller values\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext(\"2d\");\n    ctx === null || ctx === void 0 ? void 0 : ctx.fillRect(0, 0, canvas.width, canvas.height);\n    if (paintContent && ctx) {\n        ctx.beginPath();\n        ctx.arc(width / 2, height / 2, 50, 0, Math.PI * 2, true);\n        ctx.closePath();\n        ctx.fillStyle = \"grey\";\n        ctx.fill();\n    }\n    // @ts-ignore\n    const dummyStream = canvas.captureStream();\n    const [dummyTrack] = dummyStream.getTracks();\n    if (!dummyTrack) {\n        throw Error(\"Could not get empty media stream video track\");\n    }\n    dummyTrack.enabled = enabled;\n    return dummyTrack;\n}\nlet emptyAudioStreamTrack;\nfunction getEmptyAudioStreamTrack() {\n    if (!emptyAudioStreamTrack) {\n        // implementation adapted from https://blog.mozilla.org/webrtc/warm-up-with-replacetrack/\n        const ctx = new AudioContext();\n        const oscillator = ctx.createOscillator();\n        const gain = ctx.createGain();\n        gain.gain.setValueAtTime(0, 0);\n        const dst = ctx.createMediaStreamDestination();\n        oscillator.connect(gain);\n        gain.connect(dst);\n        oscillator.start();\n        [emptyAudioStreamTrack] = dst.stream.getAudioTracks();\n        if (!emptyAudioStreamTrack) {\n            throw Error(\"Could not get empty media stream audio track\");\n        }\n        emptyAudioStreamTrack.enabled = false;\n    }\n    return emptyAudioStreamTrack.clone();\n}\nclass Future {\n    constructor(futureBase, onFinally){\n        this.onFinally = onFinally;\n        this.promise = new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                this.resolve = resolve;\n                this.reject = reject;\n                if (futureBase) {\n                    yield futureBase(resolve, reject);\n                }\n            })).finally(()=>{\n            var _a;\n            return (_a = this.onFinally) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\n/**\n * Creates and returns an analyser web audio node that is attached to the provided track.\n * Additionally returns a convenience method `calculateVolume` to perform instant volume readings on that track.\n * Call the returned `cleanup` function to close the audioContext that has been created for the instance of this helper\n */ function createAudioAnalyser(track, options) {\n    const opts = Object.assign({\n        cloneTrack: false,\n        fftSize: 2048,\n        smoothingTimeConstant: 0.8,\n        minDecibels: -100,\n        maxDecibels: -80\n    }, options);\n    const audioContext = getNewAudioContext();\n    if (!audioContext) {\n        throw new Error(\"Audio Context not supported on this browser\");\n    }\n    const streamTrack = opts.cloneTrack ? track.mediaStreamTrack.clone() : track.mediaStreamTrack;\n    const mediaStreamSource = audioContext.createMediaStreamSource(new MediaStream([\n        streamTrack\n    ]));\n    const analyser = audioContext.createAnalyser();\n    analyser.minDecibels = opts.minDecibels;\n    analyser.maxDecibels = opts.maxDecibels;\n    analyser.fftSize = opts.fftSize;\n    analyser.smoothingTimeConstant = opts.smoothingTimeConstant;\n    mediaStreamSource.connect(analyser);\n    const dataArray = new Uint8Array(analyser.frequencyBinCount);\n    /**\n   * Calculates the current volume of the track in the range from 0 to 1\n   */ const calculateVolume = ()=>{\n        analyser.getByteFrequencyData(dataArray);\n        let sum = 0;\n        for (const amplitude of dataArray){\n            sum += Math.pow(amplitude / 255, 2);\n        }\n        const volume = Math.sqrt(sum / dataArray.length);\n        return volume;\n    };\n    const cleanup = ()=>__awaiter(this, void 0, void 0, function*() {\n            yield audioContext.close();\n            if (opts.cloneTrack) {\n                streamTrack.stop();\n            }\n        });\n    return {\n        calculateVolume,\n        analyser,\n        cleanup\n    };\n}\nfunction isVideoCodec(maybeCodec) {\n    return videoCodecs.includes(maybeCodec);\n}\nfunction unwrapConstraint(constraint) {\n    if (typeof constraint === \"string\" || typeof constraint === \"number\") {\n        return constraint;\n    }\n    if (Array.isArray(constraint)) {\n        return constraint[0];\n    }\n    if (constraint.exact) {\n        if (Array.isArray(constraint.exact)) {\n            return constraint.exact[0];\n        }\n        return constraint.exact;\n    }\n    if (constraint.ideal) {\n        if (Array.isArray(constraint.ideal)) {\n            return constraint.ideal[0];\n        }\n        return constraint.ideal;\n    }\n    throw Error(\"could not unwrap constraint\");\n}\nfunction toWebsocketUrl(url) {\n    if (url.startsWith(\"http\")) {\n        return url.replace(/^(http)/, \"ws\");\n    }\n    return url;\n}\nfunction toHttpUrl(url) {\n    if (url.startsWith(\"ws\")) {\n        return url.replace(/^(ws)/, \"http\");\n    }\n    return url;\n}\nfunction extractTranscriptionSegments(transcription, firstReceivedTimesMap) {\n    return transcription.segments.map((_ref)=>{\n        let { id, text, language, startTime, endTime, final } = _ref;\n        var _a;\n        const firstReceivedTime = (_a = firstReceivedTimesMap.get(id)) !== null && _a !== void 0 ? _a : Date.now();\n        const lastReceivedTime = Date.now();\n        if (final) {\n            firstReceivedTimesMap.delete(id);\n        } else {\n            firstReceivedTimesMap.set(id, firstReceivedTime);\n        }\n        return {\n            id,\n            text,\n            startTime: Number.parseInt(startTime.toString()),\n            endTime: Number.parseInt(endTime.toString()),\n            final,\n            language,\n            firstReceivedTime,\n            lastReceivedTime\n        };\n    });\n}\nfunction extractChatMessage(msg) {\n    const { id, timestamp, message, editTimestamp } = msg;\n    return {\n        id,\n        timestamp: Number.parseInt(timestamp.toString()),\n        editTimestamp: editTimestamp ? Number.parseInt(editTimestamp.toString()) : undefined,\n        message\n    };\n}\nfunction getDisconnectReasonFromConnectionError(e) {\n    switch(e.reason){\n        case ConnectionErrorReason.LeaveRequest:\n            return e.context;\n        case ConnectionErrorReason.Cancelled:\n            return DisconnectReason.CLIENT_INITIATED;\n        case ConnectionErrorReason.NotAllowed:\n            return DisconnectReason.USER_REJECTED;\n        case ConnectionErrorReason.ServerUnreachable:\n            return DisconnectReason.JOIN_FAILURE;\n        default:\n            return DisconnectReason.UNKNOWN_REASON;\n    }\n}\n/** convert bigints to numbers preserving undefined values */ function bigIntToNumber(value) {\n    return value !== undefined ? Number(value) : undefined;\n}\n/** convert numbers to bigints preserving undefined values */ function numberToBigInt(value) {\n    return value !== undefined ? BigInt(value) : undefined;\n}\nfunction isLocalTrack(track) {\n    return !!track && !(track instanceof MediaStreamTrack) && track.isLocal;\n}\nfunction isAudioTrack(track) {\n    return !!track && track.kind == Track.Kind.Audio;\n}\nfunction isVideoTrack(track) {\n    return !!track && track.kind == Track.Kind.Video;\n}\nfunction isLocalVideoTrack(track) {\n    return isLocalTrack(track) && isVideoTrack(track);\n}\nfunction isLocalAudioTrack(track) {\n    return isLocalTrack(track) && isAudioTrack(track);\n}\nfunction isRemoteTrack(track) {\n    return !!track && !track.isLocal;\n}\nfunction isRemotePub(pub) {\n    return !!pub && !pub.isLocal;\n}\nfunction isRemoteVideoTrack(track) {\n    return isRemoteTrack(track) && isVideoTrack(track);\n}\nfunction isLocalParticipant(p) {\n    return p.isLocal;\n}\nfunction isRemoteParticipant(p) {\n    return !p.isLocal;\n}\nfunction splitUtf8(s, n) {\n    // adapted from https://stackoverflow.com/a/6043797\n    const result = [];\n    let encoded = new TextEncoder().encode(s);\n    while(encoded.length > n){\n        let k = n;\n        while(k > 0){\n            const byte = encoded[k];\n            if (byte !== undefined && (byte & 0xc0) !== 0x80) {\n                break;\n            }\n            k--;\n        }\n        result.push(encoded.slice(0, k));\n        encoded = encoded.slice(k);\n    }\n    if (encoded.length > 0) {\n        result.push(encoded);\n    }\n    return result;\n}\nfunction mergeDefaultOptions(options, audioDefaults, videoDefaults) {\n    var _a, _b;\n    var _c, _d;\n    const { optionsWithoutProcessor, audioProcessor, videoProcessor } = extractProcessorsFromOptions(options !== null && options !== void 0 ? options : {});\n    const defaultAudioProcessor = audioDefaults === null || audioDefaults === void 0 ? void 0 : audioDefaults.processor;\n    const defaultVideoProcessor = videoDefaults === null || videoDefaults === void 0 ? void 0 : videoDefaults.processor;\n    const clonedOptions = optionsWithoutProcessor !== null && optionsWithoutProcessor !== void 0 ? optionsWithoutProcessor : {};\n    if (clonedOptions.audio === true) clonedOptions.audio = {};\n    if (clonedOptions.video === true) clonedOptions.video = {};\n    // use defaults\n    if (clonedOptions.audio) {\n        mergeObjectWithoutOverwriting(clonedOptions.audio, audioDefaults);\n        (_a = (_c = clonedOptions.audio).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n            ideal: \"default\"\n        };\n        if (audioProcessor || defaultAudioProcessor) {\n            clonedOptions.audio.processor = audioProcessor !== null && audioProcessor !== void 0 ? audioProcessor : defaultAudioProcessor;\n        }\n    }\n    if (clonedOptions.video) {\n        mergeObjectWithoutOverwriting(clonedOptions.video, videoDefaults);\n        (_b = (_d = clonedOptions.video).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n            ideal: \"default\"\n        };\n        if (videoProcessor || defaultVideoProcessor) {\n            clonedOptions.video.processor = videoProcessor !== null && videoProcessor !== void 0 ? videoProcessor : defaultVideoProcessor;\n        }\n    }\n    return clonedOptions;\n}\nfunction mergeObjectWithoutOverwriting(mainObject, objectToMerge) {\n    Object.keys(objectToMerge).forEach((key)=>{\n        if (mainObject[key] === undefined) mainObject[key] = objectToMerge[key];\n    });\n    return mainObject;\n}\nfunction constraintsForOptions(options) {\n    var _a, _b;\n    var _c, _d;\n    const constraints = {};\n    if (options.video) {\n        // default video options\n        if (typeof options.video === \"object\") {\n            const videoOptions = {};\n            const target = videoOptions;\n            const source = options.video;\n            Object.keys(source).forEach((key)=>{\n                switch(key){\n                    case \"resolution\":\n                        // flatten VideoResolution fields\n                        mergeObjectWithoutOverwriting(target, source.resolution);\n                        break;\n                    default:\n                        target[key] = source[key];\n                }\n            });\n            constraints.video = videoOptions;\n            (_a = (_c = constraints.video).deviceId) !== null && _a !== void 0 ? _a : _c.deviceId = {\n                ideal: \"default\"\n            };\n        } else {\n            constraints.video = options.video ? {\n                deviceId: {\n                    ideal: \"default\"\n                }\n            } : false;\n        }\n    } else {\n        constraints.video = false;\n    }\n    if (options.audio) {\n        if (typeof options.audio === \"object\") {\n            constraints.audio = options.audio;\n            (_b = (_d = constraints.audio).deviceId) !== null && _b !== void 0 ? _b : _d.deviceId = {\n                ideal: \"default\"\n            };\n        } else {\n            constraints.audio = {\n                deviceId: {\n                    ideal: \"default\"\n                }\n            };\n        }\n    } else {\n        constraints.audio = false;\n    }\n    return constraints;\n}\n/**\n * This function detects silence on a given [[Track]] instance.\n * Returns true if the track seems to be entirely silent.\n */ function detectSilence(track_1) {\n    return __awaiter(this, arguments, void 0, function(track) {\n        let timeOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;\n        return function*() {\n            const ctx = getNewAudioContext();\n            if (ctx) {\n                const analyser = ctx.createAnalyser();\n                analyser.fftSize = 2048;\n                const bufferLength = analyser.frequencyBinCount;\n                const dataArray = new Uint8Array(bufferLength);\n                const source = ctx.createMediaStreamSource(new MediaStream([\n                    track.mediaStreamTrack\n                ]));\n                source.connect(analyser);\n                yield sleep(timeOffset);\n                analyser.getByteTimeDomainData(dataArray);\n                const someNoise = dataArray.some((sample)=>sample !== 128 && sample !== 0);\n                ctx.close();\n                return !someNoise;\n            }\n            return false;\n        }();\n    });\n}\n/**\n * @internal\n */ function getNewAudioContext() {\n    var _a;\n    const AudioContext1 = // @ts-ignore\n     false && (0);\n    if (AudioContext1) {\n        const audioContext = new AudioContext1({\n            latencyHint: \"interactive\"\n        });\n        // If the audio context is suspended, we need to resume it when the user clicks on the page\n        if (audioContext.state === \"suspended\" && \"undefined\" !== \"undefined\" && (0)) {}\n        return audioContext;\n    }\n}\n/**\n * @internal\n */ function sourceToKind(source) {\n    if (source === Track.Source.Microphone) {\n        return \"audioinput\";\n    } else if (source === Track.Source.Camera) {\n        return \"videoinput\";\n    } else {\n        return undefined;\n    }\n}\n/**\n * @internal\n */ function screenCaptureToDisplayMediaStreamOptions(options) {\n    var _a, _b;\n    let videoConstraints = (_a = options.video) !== null && _a !== void 0 ? _a : true;\n    // treat 0 as uncapped\n    if (options.resolution && options.resolution.width > 0 && options.resolution.height > 0) {\n        videoConstraints = typeof videoConstraints === \"boolean\" ? {} : videoConstraints;\n        if (isSafari()) {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    max: options.resolution.width\n                },\n                height: {\n                    max: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        } else {\n            videoConstraints = Object.assign(Object.assign({}, videoConstraints), {\n                width: {\n                    ideal: options.resolution.width\n                },\n                height: {\n                    ideal: options.resolution.height\n                },\n                frameRate: options.resolution.frameRate\n            });\n        }\n    }\n    return {\n        audio: (_b = options.audio) !== null && _b !== void 0 ? _b : false,\n        video: videoConstraints,\n        // @ts-expect-error support for experimental display media features\n        controller: options.controller,\n        selfBrowserSurface: options.selfBrowserSurface,\n        surfaceSwitching: options.surfaceSwitching,\n        systemAudio: options.systemAudio,\n        preferCurrentTab: options.preferCurrentTab\n    };\n}\nfunction mimeTypeToVideoCodecString(mimeType) {\n    return mimeType.split(\"/\")[1].toLowerCase();\n}\nfunction getTrackPublicationInfo(tracks) {\n    const infos = [];\n    tracks.forEach((track)=>{\n        if (track.track !== undefined) {\n            infos.push(new TrackPublishedResponse({\n                cid: track.track.mediaStreamID,\n                track: track.trackInfo\n            }));\n        }\n    });\n    return infos;\n}\nfunction getLogContextFromTrack(track) {\n    if (\"mediaStreamTrack\" in track) {\n        return {\n            trackID: track.sid,\n            source: track.source,\n            muted: track.isMuted,\n            enabled: track.mediaStreamTrack.enabled,\n            kind: track.kind,\n            streamID: track.mediaStreamID,\n            streamTrackID: track.mediaStreamTrack.id\n        };\n    } else {\n        return {\n            trackID: track.trackSid,\n            enabled: track.isEnabled,\n            muted: track.isMuted,\n            trackInfo: Object.assign({\n                mimeType: track.mimeType,\n                name: track.trackName,\n                encrypted: track.isEncrypted,\n                kind: track.kind,\n                source: track.source\n            }, track.track ? getLogContextFromTrack(track.track) : {})\n        };\n    }\n}\nfunction supportsSynchronizationSources() {\n    return typeof RTCRtpReceiver !== \"undefined\" && \"getSynchronizationSources\" in RTCRtpReceiver;\n}\nfunction diffAttributes(oldValues, newValues) {\n    var _a;\n    if (oldValues === undefined) {\n        oldValues = {};\n    }\n    if (newValues === undefined) {\n        newValues = {};\n    }\n    const allKeys = [\n        ...Object.keys(newValues),\n        ...Object.keys(oldValues)\n    ];\n    const diff = {};\n    for (const key of allKeys){\n        if (oldValues[key] !== newValues[key]) {\n            diff[key] = (_a = newValues[key]) !== null && _a !== void 0 ? _a : \"\";\n        }\n    }\n    return diff;\n}\n/** @internal */ function extractProcessorsFromOptions(options) {\n    const newOptions = Object.assign({}, options);\n    let audioProcessor;\n    let videoProcessor;\n    if (typeof newOptions.audio === \"object\" && newOptions.audio.processor) {\n        audioProcessor = newOptions.audio.processor;\n        newOptions.audio = Object.assign(Object.assign({}, newOptions.audio), {\n            processor: undefined\n        });\n    }\n    if (typeof newOptions.video === \"object\" && newOptions.video.processor) {\n        videoProcessor = newOptions.video.processor;\n        newOptions.video = Object.assign(Object.assign({}, newOptions.video), {\n            processor: undefined\n        });\n    }\n    return {\n        audioProcessor,\n        videoProcessor,\n        optionsWithoutProcessor: cloneDeep(newOptions)\n    };\n}\nfunction getTrackSourceFromProto(source) {\n    switch(source){\n        case TrackSource.CAMERA:\n            return Track.Source.Camera;\n        case TrackSource.MICROPHONE:\n            return Track.Source.Microphone;\n        case TrackSource.SCREEN_SHARE:\n            return Track.Source.ScreenShare;\n        case TrackSource.SCREEN_SHARE_AUDIO:\n            return Track.Source.ScreenShareAudio;\n        default:\n            return Track.Source.Unknown;\n    }\n}\n/**\n * @experimental\n */ class E2EEManager extends eventsExports.EventEmitter {\n    constructor(options){\n        super();\n        this.onWorkerMessage = (ev)=>{\n            var _a, _b;\n            const { kind, data } = ev.data;\n            switch(kind){\n                case \"error\":\n                    livekitLogger.error(data.error.message);\n                    this.emit(EncryptionEvent.EncryptionError, data.error);\n                    break;\n                case \"initAck\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    break;\n                case \"enable\":\n                    if (data.enabled) {\n                        this.keyProvider.getKeys().forEach((keyInfo)=>{\n                            this.postKey(keyInfo);\n                        });\n                    }\n                    if (this.encryptionEnabled !== data.enabled && data.participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, this.room.localParticipant);\n                        this.encryptionEnabled = data.enabled;\n                    } else if (data.participantIdentity) {\n                        const participant = (_b = this.room) === null || _b === void 0 ? void 0 : _b.getParticipantByIdentity(data.participantIdentity);\n                        if (!participant) {\n                            throw TypeError(\"couldn't set encryption status, participant not found\".concat(data.participantIdentity));\n                        }\n                        this.emit(EncryptionEvent.ParticipantEncryptionStatusChanged, data.enabled, participant);\n                    }\n                    break;\n                case \"ratchetKey\":\n                    this.keyProvider.emit(KeyProviderEvent.KeyRatcheted, data.material, data.keyIndex);\n                    break;\n            }\n        };\n        this.onWorkerError = (ev)=>{\n            livekitLogger.error(\"e2ee worker encountered an error:\", {\n                error: ev.error\n            });\n            this.emit(EncryptionEvent.EncryptionError, ev.error);\n        };\n        this.keyProvider = options.keyProvider;\n        this.worker = options.worker;\n        this.encryptionEnabled = false;\n    }\n    /**\n   * @internal\n   */ setup(room) {\n        if (!isE2EESupported()) {\n            throw new DeviceUnsupportedError(\"tried to setup end-to-end encryption on an unsupported browser\");\n        }\n        livekitLogger.info(\"setting up e2ee\");\n        if (room !== this.room) {\n            this.room = room;\n            this.setupEventListeners(room, this.keyProvider);\n            // this.worker = new Worker('');\n            const msg = {\n                kind: \"init\",\n                data: {\n                    keyProviderOptions: this.keyProvider.getOptions(),\n                    loglevel: workerLogger.getLevel()\n                }\n            };\n            if (this.worker) {\n                livekitLogger.info(\"initializing worker\", {\n                    worker: this.worker\n                });\n                this.worker.onmessage = this.onWorkerMessage;\n                this.worker.onerror = this.onWorkerError;\n                this.worker.postMessage(msg);\n            }\n        }\n    }\n    /**\n   * @internal\n   */ setParticipantCryptorEnabled(enabled, participantIdentity) {\n        livekitLogger.debug(\"set e2ee to \".concat(enabled, \" for participant \").concat(participantIdentity));\n        this.postEnable(enabled, participantIdentity);\n    }\n    /**\n   * @internal\n   */ setSifTrailer(trailer) {\n        if (!trailer || trailer.length === 0) {\n            livekitLogger.warn(\"ignoring server sent trailer as it's empty\");\n        } else {\n            this.postSifTrailer(trailer);\n        }\n    }\n    setupEngine(engine) {\n        engine.on(EngineEvent.RTPVideoMapUpdate, (rtpMap)=>{\n            this.postRTPMap(rtpMap);\n        });\n    }\n    setupEventListeners(room, keyProvider) {\n        room.on(RoomEvent.TrackPublished, (pub, participant)=>this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity));\n        room.on(RoomEvent.ConnectionStateChanged, (state)=>{\n            if (state === ConnectionState.Connected) {\n                room.remoteParticipants.forEach((participant)=>{\n                    participant.trackPublications.forEach((pub)=>{\n                        this.setParticipantCryptorEnabled(pub.trackInfo.encryption !== Encryption_Type.NONE, participant.identity);\n                    });\n                });\n            }\n        }).on(RoomEvent.TrackUnsubscribed, (track, _, participant)=>{\n            var _a;\n            const msg = {\n                kind: \"removeTransform\",\n                data: {\n                    participantIdentity: participant.identity,\n                    trackId: track.mediaStreamID\n                }\n            };\n            (_a = this.worker) === null || _a === void 0 ? void 0 : _a.postMessage(msg);\n        }).on(RoomEvent.TrackSubscribed, (track, pub, participant)=>{\n            this.setupE2EEReceiver(track, participant.identity, pub.trackInfo);\n        }).on(RoomEvent.SignalConnected, ()=>{\n            if (!this.room) {\n                throw new TypeError(\"expected room to be present on signal connect\");\n            }\n            keyProvider.getKeys().forEach((keyInfo)=>{\n                this.postKey(keyInfo);\n            });\n            this.setParticipantCryptorEnabled(this.room.localParticipant.isE2EEEnabled, this.room.localParticipant.identity);\n        });\n        room.localParticipant.on(ParticipantEvent.LocalTrackPublished, (publication)=>__awaiter(this, void 0, void 0, function*() {\n                this.setupE2EESender(publication.track, publication.track.sender);\n            }));\n        keyProvider.on(KeyProviderEvent.SetKey, (keyInfo)=>this.postKey(keyInfo)).on(KeyProviderEvent.RatchetRequest, (participantId, keyIndex)=>this.postRatchetRequest(participantId, keyIndex, keyProvider.getOptions().allowKeyExtraction));\n    }\n    postRatchetRequest(participantIdentity, keyIndex, extractable) {\n        if (!this.worker) {\n            throw Error(\"could not ratchet key, worker is missing\");\n        }\n        const msg = {\n            kind: \"ratchetRequest\",\n            data: {\n                participantIdentity: participantIdentity,\n                keyIndex,\n                extractable\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postKey(_ref) {\n        let { key, participantIdentity, keyIndex } = _ref;\n        var _a;\n        if (!this.worker) {\n            throw Error(\"could not set key, worker is missing\");\n        }\n        const msg = {\n            kind: \"setKey\",\n            data: {\n                participantIdentity: participantIdentity,\n                isPublisher: participantIdentity === ((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity),\n                key,\n                keyIndex\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postEnable(enabled, participantIdentity) {\n        if (this.worker) {\n            const enableMsg = {\n                kind: \"enable\",\n                data: {\n                    enabled,\n                    participantIdentity\n                }\n            };\n            this.worker.postMessage(enableMsg);\n        } else {\n            throw new ReferenceError(\"failed to enable e2ee, worker is not ready\");\n        }\n    }\n    postRTPMap(map) {\n        var _a;\n        if (!this.worker) {\n            throw TypeError(\"could not post rtp map, worker is missing\");\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity)) {\n            throw TypeError(\"could not post rtp map, local participant identity is missing\");\n        }\n        const msg = {\n            kind: \"setRTPMap\",\n            data: {\n                map,\n                participantIdentity: this.room.localParticipant.identity\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    postSifTrailer(trailer) {\n        if (!this.worker) {\n            throw Error(\"could not post SIF trailer, worker is missing\");\n        }\n        const msg = {\n            kind: \"setSifTrailer\",\n            data: {\n                trailer\n            }\n        };\n        this.worker.postMessage(msg);\n    }\n    setupE2EEReceiver(track, remoteId, trackInfo) {\n        if (!track.receiver) {\n            return;\n        }\n        if (!(trackInfo === null || trackInfo === void 0 ? void 0 : trackInfo.mimeType) || trackInfo.mimeType === \"\") {\n            throw new TypeError(\"MimeType missing from trackInfo, cannot set up E2EE cryptor\");\n        }\n        this.handleReceiver(track.receiver, track.mediaStreamID, remoteId, track.kind === \"video\" ? mimeTypeToVideoCodecString(trackInfo.mimeType) : undefined);\n    }\n    setupE2EESender(track, sender) {\n        if (!isLocalTrack(track) || !sender) {\n            if (!sender) livekitLogger.warn(\"early return because sender is not ready\");\n            return;\n        }\n        this.handleSender(sender, track.mediaStreamID, undefined);\n    }\n    /**\n   * Handles the given {@code RTCRtpReceiver} by creating a {@code TransformStream} which will inject\n   * a frame decoder.\n   *\n   */ handleReceiver(receiver, trackId, participantIdentity, codec) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.worker) {\n                return;\n            }\n            if (isScriptTransformSupported()) {\n                const options = {\n                    kind: \"decode\",\n                    participantIdentity,\n                    trackId,\n                    codec\n                };\n                // @ts-ignore\n                receiver.transform = new RTCRtpScriptTransform(this.worker, options);\n            } else {\n                if (E2EE_FLAG in receiver && codec) {\n                    // only update codec\n                    const msg = {\n                        kind: \"updateCodec\",\n                        data: {\n                            trackId,\n                            codec,\n                            participantIdentity: participantIdentity\n                        }\n                    };\n                    this.worker.postMessage(msg);\n                    return;\n                }\n                // @ts-ignore\n                let writable = receiver.writableStream;\n                // @ts-ignore\n                let readable = receiver.readableStream;\n                if (!writable || !readable) {\n                    // @ts-ignore\n                    const receiverStreams = receiver.createEncodedStreams();\n                    // @ts-ignore\n                    receiver.writableStream = receiverStreams.writable;\n                    writable = receiverStreams.writable;\n                    // @ts-ignore\n                    receiver.readableStream = receiverStreams.readable;\n                    readable = receiverStreams.readable;\n                }\n                const msg = {\n                    kind: \"decode\",\n                    data: {\n                        readableStream: readable,\n                        writableStream: writable,\n                        trackId: trackId,\n                        codec,\n                        participantIdentity: participantIdentity\n                    }\n                };\n                this.worker.postMessage(msg, [\n                    readable,\n                    writable\n                ]);\n            }\n            // @ts-ignore\n            receiver[E2EE_FLAG] = true;\n        });\n    }\n    /**\n   * Handles the given {@code RTCRtpSender} by creating a {@code TransformStream} which will inject\n   * a frame encoder.\n   *\n   */ handleSender(sender, trackId, codec) {\n        var _a;\n        if (E2EE_FLAG in sender || !this.worker) {\n            return;\n        }\n        if (!((_a = this.room) === null || _a === void 0 ? void 0 : _a.localParticipant.identity) || this.room.localParticipant.identity === \"\") {\n            throw TypeError(\"local identity needs to be known in order to set up encrypted sender\");\n        }\n        if (isScriptTransformSupported()) {\n            livekitLogger.info(\"initialize script transform\");\n            const options = {\n                kind: \"encode\",\n                participantIdentity: this.room.localParticipant.identity,\n                trackId,\n                codec\n            };\n            // @ts-ignore\n            sender.transform = new RTCRtpScriptTransform(this.worker, options);\n        } else {\n            livekitLogger.info(\"initialize encoded streams\");\n            // @ts-ignore\n            const senderStreams = sender.createEncodedStreams();\n            const msg = {\n                kind: \"encode\",\n                data: {\n                    readableStream: senderStreams.readable,\n                    writableStream: senderStreams.writable,\n                    codec,\n                    trackId,\n                    participantIdentity: this.room.localParticipant.identity\n                }\n            };\n            this.worker.postMessage(msg, [\n                senderStreams.readable,\n                senderStreams.writable\n            ]);\n        }\n        // @ts-ignore\n        sender[E2EE_FLAG] = true;\n    }\n}\nconst defaultId = \"default\";\nclass DeviceManager {\n    constructor(){\n        this._previousDevices = [];\n    }\n    static getInstance() {\n        if (this.instance === undefined) {\n            this.instance = new DeviceManager();\n        }\n        return this.instance;\n    }\n    get previousDevices() {\n        return this._previousDevices;\n    }\n    getDevices(kind_1) {\n        return __awaiter(this, arguments, void 0, function(kind) {\n            var _this = this;\n            let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a;\n                if (((_a = DeviceManager.userMediaPromiseMap) === null || _a === void 0 ? void 0 : _a.size) > 0) {\n                    livekitLogger.debug(\"awaiting getUserMedia promise\");\n                    try {\n                        if (kind) {\n                            yield DeviceManager.userMediaPromiseMap.get(kind);\n                        } else {\n                            yield Promise.all(DeviceManager.userMediaPromiseMap.values());\n                        }\n                    } catch (e) {\n                        livekitLogger.warn(\"error waiting for media permissons\");\n                    }\n                }\n                let devices = yield navigator.mediaDevices.enumerateDevices();\n                if (requestPermissions && // for safari we need to skip this check, as otherwise it will re-acquire user media and fail on iOS https://bugs.webkit.org/show_bug.cgi?id=179363\n                !(isSafari() && _this.hasDeviceInUse(kind))) {\n                    const isDummyDeviceOrEmpty = devices.filter((d)=>d.kind === kind).length === 0 || devices.some((device)=>{\n                        const noLabel = device.label === \"\";\n                        const isRelevant = kind ? device.kind === kind : true;\n                        return noLabel && isRelevant;\n                    });\n                    if (isDummyDeviceOrEmpty) {\n                        const permissionsToAcquire = {\n                            video: kind !== \"audioinput\" && kind !== \"audiooutput\",\n                            audio: kind !== \"videoinput\" && {\n                                deviceId: {\n                                    ideal: \"default\"\n                                }\n                            }\n                        };\n                        const stream = yield navigator.mediaDevices.getUserMedia(permissionsToAcquire);\n                        devices = yield navigator.mediaDevices.enumerateDevices();\n                        stream.getTracks().forEach((track)=>{\n                            track.stop();\n                        });\n                    }\n                }\n                _this._previousDevices = devices;\n                if (kind) {\n                    devices = devices.filter((device)=>device.kind === kind);\n                }\n                return devices;\n            }();\n        });\n    }\n    normalizeDeviceId(kind, deviceId, groupId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (deviceId !== defaultId) {\n                return deviceId;\n            }\n            // resolve actual device id if it's 'default': Chrome returns it when no\n            // device has been chosen\n            const devices = yield this.getDevices(kind);\n            const defaultDevice = devices.find((d)=>d.deviceId === defaultId);\n            if (!defaultDevice) {\n                livekitLogger.warn(\"could not reliably determine default device\");\n                return undefined;\n            }\n            const device = devices.find((d)=>d.deviceId !== defaultId && d.groupId === (groupId !== null && groupId !== void 0 ? groupId : defaultDevice.groupId));\n            if (!device) {\n                livekitLogger.warn(\"could not reliably determine default device\");\n                return undefined;\n            }\n            return device === null || device === void 0 ? void 0 : device.deviceId;\n        });\n    }\n    hasDeviceInUse(kind) {\n        return kind ? DeviceManager.userMediaPromiseMap.has(kind) : DeviceManager.userMediaPromiseMap.size > 0;\n    }\n}\nDeviceManager.mediaDeviceKinds = [\n    \"audioinput\",\n    \"audiooutput\",\n    \"videoinput\"\n];\nDeviceManager.userMediaPromiseMap = new Map();\nvar QueueTaskStatus;\n(function(QueueTaskStatus) {\n    QueueTaskStatus[QueueTaskStatus[\"WAITING\"] = 0] = \"WAITING\";\n    QueueTaskStatus[QueueTaskStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    QueueTaskStatus[QueueTaskStatus[\"COMPLETED\"] = 2] = \"COMPLETED\";\n})(QueueTaskStatus || (QueueTaskStatus = {}));\nclass AsyncQueue {\n    constructor(){\n        this.pendingTasks = new Map();\n        this.taskMutex = new _();\n        this.nextTaskIndex = 0;\n    }\n    run(task) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const taskInfo = {\n                id: this.nextTaskIndex++,\n                enqueuedAt: Date.now(),\n                status: QueueTaskStatus.WAITING\n            };\n            this.pendingTasks.set(taskInfo.id, taskInfo);\n            const unlock = yield this.taskMutex.lock();\n            try {\n                taskInfo.executedAt = Date.now();\n                taskInfo.status = QueueTaskStatus.RUNNING;\n                return yield task();\n            } finally{\n                taskInfo.status = QueueTaskStatus.COMPLETED;\n                this.pendingTasks.delete(taskInfo.id);\n                unlock();\n            }\n        });\n    }\n    flush() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.run(()=>__awaiter(this, void 0, void 0, function*() {}));\n        });\n    }\n    snapshot() {\n        return Array.from(this.pendingTasks.values());\n    }\n}\nfunction createRtcUrl(url, searchParams) {\n    const urlObj = new URL(toWebsocketUrl(url));\n    searchParams.forEach((value, key)=>{\n        urlObj.searchParams.set(key, value);\n    });\n    return appendUrlPath(urlObj, \"rtc\");\n}\nfunction createValidateUrl(rtcWsUrl) {\n    const urlObj = new URL(toHttpUrl(rtcWsUrl));\n    return appendUrlPath(urlObj, \"validate\");\n}\nfunction ensureTrailingSlash(path) {\n    return path.endsWith(\"/\") ? path : \"\".concat(path, \"/\");\n}\nfunction appendUrlPath(urlObj, path) {\n    urlObj.pathname = \"\".concat(ensureTrailingSlash(urlObj.pathname)).concat(path);\n    return urlObj.toString();\n}\nconst passThroughQueueSignals = [\n    \"syncState\",\n    \"trickle\",\n    \"offer\",\n    \"answer\",\n    \"simulate\",\n    \"leave\"\n];\nfunction canPassThroughQueue(req) {\n    const canPass = passThroughQueueSignals.indexOf(req.case) >= 0;\n    livekitLogger.trace(\"request allowed to bypass queue:\", {\n        canPass,\n        req\n    });\n    return canPass;\n}\nvar SignalConnectionState;\n(function(SignalConnectionState) {\n    SignalConnectionState[SignalConnectionState[\"CONNECTING\"] = 0] = \"CONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"CONNECTED\"] = 1] = \"CONNECTED\";\n    SignalConnectionState[SignalConnectionState[\"RECONNECTING\"] = 2] = \"RECONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTING\"] = 3] = \"DISCONNECTING\";\n    SignalConnectionState[SignalConnectionState[\"DISCONNECTED\"] = 4] = \"DISCONNECTED\";\n})(SignalConnectionState || (SignalConnectionState = {}));\n/** @internal */ class SignalClient {\n    get currentState() {\n        return this.state;\n    }\n    get isDisconnected() {\n        return this.state === SignalConnectionState.DISCONNECTING || this.state === SignalConnectionState.DISCONNECTED;\n    }\n    get isEstablishingConnection() {\n        return this.state === SignalConnectionState.CONNECTING || this.state === SignalConnectionState.RECONNECTING;\n    }\n    getNextRequestId() {\n        this._requestId += 1;\n        return this._requestId;\n    }\n    constructor(){\n        let useJSON = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        /** signal rtt in milliseconds */ this.rtt = 0;\n        this.state = SignalConnectionState.DISCONNECTED;\n        this.log = livekitLogger;\n        this._requestId = 0;\n        /** @internal */ this.resetCallbacks = ()=>{\n            this.onAnswer = undefined;\n            this.onLeave = undefined;\n            this.onLocalTrackPublished = undefined;\n            this.onLocalTrackUnpublished = undefined;\n            this.onNegotiateRequested = undefined;\n            this.onOffer = undefined;\n            this.onRemoteMuteChanged = undefined;\n            this.onSubscribedQualityUpdate = undefined;\n            this.onTokenRefresh = undefined;\n            this.onTrickle = undefined;\n            this.onClose = undefined;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Signal);\n        this.loggerContextCb = loggerOptions.loggerContextCb;\n        this.useJSON = useJSON;\n        this.requestQueue = new AsyncQueue();\n        this.queuedRequests = [];\n        this.closingLock = new _();\n        this.connectionLock = new _();\n        this.state = SignalConnectionState.DISCONNECTED;\n    }\n    get logContext() {\n        var _a, _b;\n        return (_b = (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)) !== null && _b !== void 0 ? _b : {};\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // during a full reconnect, we'd want to start the sequence even if currently\n            // connected\n            this.state = SignalConnectionState.CONNECTING;\n            this.options = opts;\n            const res = yield this.connect(url, token, opts, abortSignal);\n            return res;\n        });\n    }\n    reconnect(url, token, sid, reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.options) {\n                this.log.warn(\"attempted to reconnect without signal options being set, ignoring\", this.logContext);\n                return;\n            }\n            this.state = SignalConnectionState.RECONNECTING;\n            // clear ping interval and restart it once reconnected\n            this.clearPingInterval();\n            const res = yield this.connect(url, token, Object.assign(Object.assign({}, this.options), {\n                reconnect: true,\n                sid,\n                reconnectReason: reason\n            }));\n            return res;\n        });\n    }\n    connect(url, token, opts, abortSignal) {\n        this.connectOptions = opts;\n        const clientInfo = getClientInfo();\n        const params = createConnectionParams(token, clientInfo, opts);\n        const rtcUrl = createRtcUrl(url, params);\n        const validateUrl = createValidateUrl(rtcUrl);\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                const unlock = yield this.connectionLock.lock();\n                try {\n                    const abortHandler = ()=>__awaiter(this, void 0, void 0, function*() {\n                            this.close();\n                            clearTimeout(wsTimeout);\n                            reject(new ConnectionError(\"room connection has been cancelled (signal)\", ConnectionErrorReason.Cancelled));\n                        });\n                    const wsTimeout = setTimeout(()=>{\n                        this.close();\n                        reject(new ConnectionError(\"room connection has timed out (signal)\", ConnectionErrorReason.ServerUnreachable));\n                    }, opts.websocketTimeout);\n                    if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {\n                        abortHandler();\n                    }\n                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.addEventListener(\"abort\", abortHandler);\n                    const redactedUrl = new URL(rtcUrl);\n                    if (redactedUrl.searchParams.has(\"access_token\")) {\n                        redactedUrl.searchParams.set(\"access_token\", \"<redacted>\");\n                    }\n                    this.log.debug(\"connecting to \".concat(redactedUrl), Object.assign({\n                        reconnect: opts.reconnect,\n                        reconnectReason: opts.reconnectReason\n                    }, this.logContext));\n                    if (this.ws) {\n                        yield this.close(false);\n                    }\n                    this.ws = new WebSocket(rtcUrl);\n                    this.ws.binaryType = \"arraybuffer\";\n                    this.ws.onopen = ()=>{\n                        clearTimeout(wsTimeout);\n                    };\n                    this.ws.onerror = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                this.state = SignalConnectionState.DISCONNECTED;\n                                clearTimeout(wsTimeout);\n                                try {\n                                    const resp = yield fetch(validateUrl);\n                                    if (resp.status.toFixed(0).startsWith(\"4\")) {\n                                        const msg = yield resp.text();\n                                        reject(new ConnectionError(msg, ConnectionErrorReason.NotAllowed, resp.status));\n                                    } else {\n                                        reject(new ConnectionError(\"Encountered unknown websocket error during connection: \".concat(ev.toString()), ConnectionErrorReason.InternalError, resp.status));\n                                    }\n                                } catch (e) {\n                                    reject(new ConnectionError(e instanceof Error ? e.message : \"server was not reachable\", ConnectionErrorReason.ServerUnreachable));\n                                }\n                                return;\n                            }\n                            // other errors, handle\n                            this.handleWSError(ev);\n                        });\n                    this.ws.onmessage = (ev)=>__awaiter(this, void 0, void 0, function*() {\n                            var _a, _b, _c;\n                            // not considered connected until JoinResponse is received\n                            let resp;\n                            if (typeof ev.data === \"string\") {\n                                const json = JSON.parse(ev.data);\n                                resp = SignalResponse.fromJson(json, {\n                                    ignoreUnknownFields: true\n                                });\n                            } else if (ev.data instanceof ArrayBuffer) {\n                                resp = SignalResponse.fromBinary(new Uint8Array(ev.data));\n                            } else {\n                                this.log.error(\"could not decode websocket message: \".concat(typeof ev.data), this.logContext);\n                                return;\n                            }\n                            if (this.state !== SignalConnectionState.CONNECTED) {\n                                let shouldProcessMessage = false;\n                                // handle join message only\n                                if (((_a = resp.message) === null || _a === void 0 ? void 0 : _a.case) === \"join\") {\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.pingTimeoutDuration = resp.message.value.pingTimeout;\n                                    this.pingIntervalDuration = resp.message.value.pingInterval;\n                                    if (this.pingTimeoutDuration && this.pingTimeoutDuration > 0) {\n                                        this.log.debug(\"ping config\", Object.assign(Object.assign({}, this.logContext), {\n                                            timeout: this.pingTimeoutDuration,\n                                            interval: this.pingIntervalDuration\n                                        }));\n                                        this.startPingInterval();\n                                    }\n                                    resolve(resp.message.value);\n                                } else if (this.state === SignalConnectionState.RECONNECTING && resp.message.case !== \"leave\") {\n                                    // in reconnecting, any message received means signal reconnected\n                                    this.state = SignalConnectionState.CONNECTED;\n                                    abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.removeEventListener(\"abort\", abortHandler);\n                                    this.startPingInterval();\n                                    if (((_b = resp.message) === null || _b === void 0 ? void 0 : _b.case) === \"reconnect\") {\n                                        resolve(resp.message.value);\n                                    } else {\n                                        this.log.debug(\"declaring signal reconnected without reconnect response received\", this.logContext);\n                                        resolve(undefined);\n                                        shouldProcessMessage = true;\n                                    }\n                                } else if (this.isEstablishingConnection && resp.message.case === \"leave\") {\n                                    reject(new ConnectionError(\"Received leave request while trying to (re)connect\", ConnectionErrorReason.LeaveRequest, undefined, resp.message.value.reason));\n                                } else if (!opts.reconnect) {\n                                    // non-reconnect case, should receive join response first\n                                    reject(new ConnectionError(\"did not receive join response, got \".concat((_c = resp.message) === null || _c === void 0 ? void 0 : _c.case, \" instead\"), ConnectionErrorReason.InternalError));\n                                }\n                                if (!shouldProcessMessage) {\n                                    return;\n                                }\n                            }\n                            if (this.signalLatency) {\n                                yield sleep(this.signalLatency);\n                            }\n                            this.handleSignalResponse(resp);\n                        });\n                    this.ws.onclose = (ev)=>{\n                        if (this.isEstablishingConnection) {\n                            reject(new ConnectionError(\"Websocket got closed during a (re)connection attempt\", ConnectionErrorReason.InternalError));\n                        }\n                        this.log.warn(\"websocket closed\", Object.assign(Object.assign({}, this.logContext), {\n                            reason: ev.reason,\n                            code: ev.code,\n                            wasClean: ev.wasClean,\n                            state: this.state\n                        }));\n                        this.handleOnClose(ev.reason);\n                    };\n                } finally{\n                    unlock();\n                }\n            }));\n    }\n    close() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this = this;\n            let updateState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                const unlock = yield _this.closingLock.lock();\n                try {\n                    _this.clearPingInterval();\n                    if (updateState) {\n                        _this.state = SignalConnectionState.DISCONNECTING;\n                    }\n                    if (_this.ws) {\n                        _this.ws.onmessage = null;\n                        _this.ws.onopen = null;\n                        _this.ws.onclose = null;\n                        // calling `ws.close()` only starts the closing handshake (CLOSING state), prefer to wait until state is actually CLOSED\n                        const closePromise = new Promise((resolve)=>{\n                            if (_this.ws) {\n                                _this.ws.onclose = ()=>{\n                                    resolve();\n                                };\n                            } else {\n                                resolve();\n                            }\n                        });\n                        if (_this.ws.readyState < _this.ws.CLOSING) {\n                            _this.ws.close();\n                            // 250ms grace period for ws to close gracefully\n                            yield Promise.race([\n                                closePromise,\n                                sleep(250)\n                            ]);\n                        }\n                        _this.ws = undefined;\n                    }\n                } finally{\n                    if (updateState) {\n                        _this.state = SignalConnectionState.DISCONNECTED;\n                    }\n                    unlock();\n                }\n            }();\n        });\n    }\n    // initial offer after joining\n    sendOffer(offer) {\n        this.log.debug(\"sending offer\", Object.assign(Object.assign({}, this.logContext), {\n            offerSdp: offer.sdp\n        }));\n        this.sendRequest({\n            case: \"offer\",\n            value: toProtoSessionDescription(offer)\n        });\n    }\n    // answer a server-initiated offer\n    sendAnswer(answer) {\n        this.log.debug(\"sending answer\", Object.assign(Object.assign({}, this.logContext), {\n            answerSdp: answer.sdp\n        }));\n        return this.sendRequest({\n            case: \"answer\",\n            value: toProtoSessionDescription(answer)\n        });\n    }\n    sendIceCandidate(candidate, target) {\n        this.log.debug(\"sending ice candidate\", Object.assign(Object.assign({}, this.logContext), {\n            candidate\n        }));\n        return this.sendRequest({\n            case: \"trickle\",\n            value: new TrickleRequest({\n                candidateInit: JSON.stringify(candidate),\n                target\n            })\n        });\n    }\n    sendMuteTrack(trackSid, muted) {\n        return this.sendRequest({\n            case: \"mute\",\n            value: new MuteTrackRequest({\n                sid: trackSid,\n                muted\n            })\n        });\n    }\n    sendAddTrack(req) {\n        return this.sendRequest({\n            case: \"addTrack\",\n            value: req\n        });\n    }\n    sendUpdateLocalMetadata(metadata_1, name_1) {\n        return __awaiter(this, arguments, void 0, function(metadata, name) {\n            var _this2 = this;\n            let attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n            return function*() {\n                const requestId = _this2.getNextRequestId();\n                yield _this2.sendRequest({\n                    case: \"updateMetadata\",\n                    value: new UpdateParticipantMetadata({\n                        requestId,\n                        metadata,\n                        name,\n                        attributes\n                    })\n                });\n                return requestId;\n            }();\n        });\n    }\n    sendUpdateTrackSettings(settings) {\n        this.sendRequest({\n            case: \"trackSetting\",\n            value: settings\n        });\n    }\n    sendUpdateSubscription(sub) {\n        return this.sendRequest({\n            case: \"subscription\",\n            value: sub\n        });\n    }\n    sendSyncState(sync) {\n        return this.sendRequest({\n            case: \"syncState\",\n            value: sync\n        });\n    }\n    sendUpdateVideoLayers(trackSid, layers) {\n        return this.sendRequest({\n            case: \"updateLayers\",\n            value: new UpdateVideoLayers({\n                trackSid,\n                layers\n            })\n        });\n    }\n    sendUpdateSubscriptionPermissions(allParticipants, trackPermissions) {\n        return this.sendRequest({\n            case: \"subscriptionPermission\",\n            value: new SubscriptionPermission({\n                allParticipants,\n                trackPermissions\n            })\n        });\n    }\n    sendSimulateScenario(scenario) {\n        return this.sendRequest({\n            case: \"simulate\",\n            value: scenario\n        });\n    }\n    sendPing() {\n        /** send both of ping and pingReq for compatibility to old and new server */ return Promise.all([\n            this.sendRequest({\n                case: \"ping\",\n                value: protoInt64.parse(Date.now())\n            }),\n            this.sendRequest({\n                case: \"pingReq\",\n                value: new Ping({\n                    timestamp: protoInt64.parse(Date.now()),\n                    rtt: protoInt64.parse(this.rtt)\n                })\n            })\n        ]);\n    }\n    sendUpdateLocalAudioTrack(trackSid, features) {\n        return this.sendRequest({\n            case: \"updateAudioTrack\",\n            value: new UpdateLocalAudioTrack({\n                trackSid,\n                features\n            })\n        });\n    }\n    sendLeave() {\n        return this.sendRequest({\n            case: \"leave\",\n            value: new LeaveRequest({\n                reason: DisconnectReason.CLIENT_INITIATED,\n                // server doesn't process this field, keeping it here to indicate the intent of a full disconnect\n                action: LeaveRequest_Action.DISCONNECT\n            })\n        });\n    }\n    sendRequest(message_1) {\n        return __awaiter(this, arguments, void 0, function(message) {\n            var _this3 = this;\n            let fromQueue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n            return function*() {\n                // capture all requests while reconnecting and put them in a queue\n                // unless the request originates from the queue, then don't enqueue again\n                const canQueue = !fromQueue && !canPassThroughQueue(message);\n                if (canQueue && _this3.state === SignalConnectionState.RECONNECTING) {\n                    _this3.queuedRequests.push(()=>__awaiter(_this3, void 0, void 0, function*() {\n                            yield this.sendRequest(message, true);\n                        }));\n                    return;\n                }\n                // make sure previously queued requests are being sent first\n                if (!fromQueue) {\n                    yield _this3.requestQueue.flush();\n                }\n                if (_this3.signalLatency) {\n                    yield sleep(_this3.signalLatency);\n                }\n                if (!_this3.ws || _this3.ws.readyState !== _this3.ws.OPEN) {\n                    _this3.log.error(\"cannot send signal request before connected, type: \".concat(message === null || message === void 0 ? void 0 : message.case), _this3.logContext);\n                    return;\n                }\n                const req = new SignalRequest({\n                    message\n                });\n                try {\n                    if (_this3.useJSON) {\n                        _this3.ws.send(req.toJsonString());\n                    } else {\n                        _this3.ws.send(req.toBinary());\n                    }\n                } catch (e) {\n                    _this3.log.error(\"error sending signal message\", Object.assign(Object.assign({}, _this3.logContext), {\n                        error: e\n                    }));\n                }\n            }();\n        });\n    }\n    handleSignalResponse(res) {\n        var _a, _b;\n        const msg = res.message;\n        if (msg == undefined) {\n            this.log.debug(\"received unsupported message\", this.logContext);\n            return;\n        }\n        let pingHandled = false;\n        if (msg.case === \"answer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onAnswer) {\n                this.onAnswer(sd);\n            }\n        } else if (msg.case === \"offer\") {\n            const sd = fromProtoSessionDescription(msg.value);\n            if (this.onOffer) {\n                this.onOffer(sd);\n            }\n        } else if (msg.case === \"trickle\") {\n            const candidate = JSON.parse(msg.value.candidateInit);\n            if (this.onTrickle) {\n                this.onTrickle(candidate, msg.value.target);\n            }\n        } else if (msg.case === \"update\") {\n            if (this.onParticipantUpdate) {\n                this.onParticipantUpdate((_a = msg.value.participants) !== null && _a !== void 0 ? _a : []);\n            }\n        } else if (msg.case === \"trackPublished\") {\n            if (this.onLocalTrackPublished) {\n                this.onLocalTrackPublished(msg.value);\n            }\n        } else if (msg.case === \"speakersChanged\") {\n            if (this.onSpeakersChanged) {\n                this.onSpeakersChanged((_b = msg.value.speakers) !== null && _b !== void 0 ? _b : []);\n            }\n        } else if (msg.case === \"leave\") {\n            if (this.onLeave) {\n                this.onLeave(msg.value);\n            }\n        } else if (msg.case === \"mute\") {\n            if (this.onRemoteMuteChanged) {\n                this.onRemoteMuteChanged(msg.value.sid, msg.value.muted);\n            }\n        } else if (msg.case === \"roomUpdate\") {\n            if (this.onRoomUpdate && msg.value.room) {\n                this.onRoomUpdate(msg.value.room);\n            }\n        } else if (msg.case === \"connectionQuality\") {\n            if (this.onConnectionQuality) {\n                this.onConnectionQuality(msg.value);\n            }\n        } else if (msg.case === \"streamStateUpdate\") {\n            if (this.onStreamStateUpdate) {\n                this.onStreamStateUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscribedQualityUpdate\") {\n            if (this.onSubscribedQualityUpdate) {\n                this.onSubscribedQualityUpdate(msg.value);\n            }\n        } else if (msg.case === \"subscriptionPermissionUpdate\") {\n            if (this.onSubscriptionPermissionUpdate) {\n                this.onSubscriptionPermissionUpdate(msg.value);\n            }\n        } else if (msg.case === \"refreshToken\") {\n            if (this.onTokenRefresh) {\n                this.onTokenRefresh(msg.value);\n            }\n        } else if (msg.case === \"trackUnpublished\") {\n            if (this.onLocalTrackUnpublished) {\n                this.onLocalTrackUnpublished(msg.value);\n            }\n        } else if (msg.case === \"subscriptionResponse\") {\n            if (this.onSubscriptionError) {\n                this.onSubscriptionError(msg.value);\n            }\n        } else if (msg.case === \"pong\") ;\n        else if (msg.case === \"pongResp\") {\n            this.rtt = Date.now() - Number.parseInt(msg.value.lastPingTimestamp.toString());\n            this.resetPingTimeout();\n            pingHandled = true;\n        } else if (msg.case === \"requestResponse\") {\n            if (this.onRequestResponse) {\n                this.onRequestResponse(msg.value);\n            }\n        } else if (msg.case === \"trackSubscribed\") {\n            if (this.onLocalTrackSubscribed) {\n                this.onLocalTrackSubscribed(msg.value.trackSid);\n            }\n        } else {\n            this.log.debug(\"unsupported message\", Object.assign(Object.assign({}, this.logContext), {\n                msgCase: msg.case\n            }));\n        }\n        if (!pingHandled) {\n            this.resetPingTimeout();\n        }\n    }\n    setReconnected() {\n        while(this.queuedRequests.length > 0){\n            const req = this.queuedRequests.shift();\n            if (req) {\n                this.requestQueue.run(req);\n            }\n        }\n    }\n    handleOnClose(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === SignalConnectionState.DISCONNECTED) return;\n            const onCloseCallback = this.onClose;\n            yield this.close();\n            this.log.debug(\"websocket connection closed: \".concat(reason), Object.assign(Object.assign({}, this.logContext), {\n                reason\n            }));\n            if (onCloseCallback) {\n                onCloseCallback(reason);\n            }\n        });\n    }\n    handleWSError(ev) {\n        this.log.error(\"websocket error\", Object.assign(Object.assign({}, this.logContext), {\n            error: ev\n        }));\n    }\n    /**\n   * Resets the ping timeout and starts a new timeout.\n   * Call this after receiving a pong message\n   */ resetPingTimeout() {\n        this.clearPingTimeout();\n        if (!this.pingTimeoutDuration) {\n            this.log.warn(\"ping timeout duration not set\", this.logContext);\n            return;\n        }\n        this.pingTimeout = CriticalTimers.setTimeout(()=>{\n            this.log.warn(\"ping timeout triggered. last pong received at: \".concat(new Date(Date.now() - this.pingTimeoutDuration * 1000).toUTCString()), this.logContext);\n            this.handleOnClose(\"ping timeout\");\n        }, this.pingTimeoutDuration * 1000);\n    }\n    /**\n   * Clears ping timeout (does not start a new timeout)\n   */ clearPingTimeout() {\n        if (this.pingTimeout) {\n            CriticalTimers.clearTimeout(this.pingTimeout);\n        }\n    }\n    startPingInterval() {\n        this.clearPingInterval();\n        this.resetPingTimeout();\n        if (!this.pingIntervalDuration) {\n            this.log.warn(\"ping interval duration not set\", this.logContext);\n            return;\n        }\n        this.log.debug(\"start ping interval\", this.logContext);\n        this.pingInterval = CriticalTimers.setInterval(()=>{\n            this.sendPing();\n        }, this.pingIntervalDuration * 1000);\n    }\n    clearPingInterval() {\n        this.log.debug(\"clearing ping interval\", this.logContext);\n        this.clearPingTimeout();\n        if (this.pingInterval) {\n            CriticalTimers.clearInterval(this.pingInterval);\n        }\n    }\n}\nfunction fromProtoSessionDescription(sd) {\n    const rsd = {\n        type: \"offer\",\n        sdp: sd.sdp\n    };\n    switch(sd.type){\n        case \"answer\":\n        case \"offer\":\n        case \"pranswer\":\n        case \"rollback\":\n            rsd.type = sd.type;\n            break;\n    }\n    return rsd;\n}\nfunction toProtoSessionDescription(rsd) {\n    const sd = new SessionDescription({\n        sdp: rsd.sdp,\n        type: rsd.type\n    });\n    return sd;\n}\nfunction createConnectionParams(token, info, opts) {\n    var _a;\n    const params = new URLSearchParams();\n    params.set(\"access_token\", token);\n    // opts\n    if (opts.reconnect) {\n        params.set(\"reconnect\", \"1\");\n        if (opts.sid) {\n            params.set(\"sid\", opts.sid);\n        }\n    }\n    params.set(\"auto_subscribe\", opts.autoSubscribe ? \"1\" : \"0\");\n    // ClientInfo\n    params.set(\"sdk\", isReactNative() ? \"reactnative\" : \"js\");\n    params.set(\"version\", info.version);\n    params.set(\"protocol\", info.protocol.toString());\n    if (info.deviceModel) {\n        params.set(\"device_model\", info.deviceModel);\n    }\n    if (info.os) {\n        params.set(\"os\", info.os);\n    }\n    if (info.osVersion) {\n        params.set(\"os_version\", info.osVersion);\n    }\n    if (info.browser) {\n        params.set(\"browser\", info.browser);\n    }\n    if (info.browserVersion) {\n        params.set(\"browser_version\", info.browserVersion);\n    }\n    if (opts.adaptiveStream) {\n        params.set(\"adaptive_stream\", \"1\");\n    }\n    if (opts.reconnectReason) {\n        params.set(\"reconnect_reason\", opts.reconnectReason.toString());\n    }\n    // @ts-ignore\n    if ((_a = navigator.connection) === null || _a === void 0 ? void 0 : _a.type) {\n        // @ts-ignore\n        params.set(\"network\", navigator.connection.type);\n    }\n    return params;\n}\nvar lib = {};\nvar parser = {};\nvar grammar = {\n    exports: {}\n};\nvar hasRequiredGrammar;\nfunction requireGrammar() {\n    if (hasRequiredGrammar) return grammar.exports;\n    hasRequiredGrammar = 1;\n    var grammar$1 = grammar.exports = {\n        v: [\n            {\n                name: \"version\",\n                reg: /^(\\d*)$/\n            }\n        ],\n        o: [\n            {\n                // o=- 20518 0 IN IP4 203.0.113.1\n                // NB: sessionId will be a String in most cases because it is huge\n                name: \"origin\",\n                reg: /^(\\S*) (\\d*) (\\d*) (\\S*) IP(\\d) (\\S*)/,\n                names: [\n                    \"username\",\n                    \"sessionId\",\n                    \"sessionVersion\",\n                    \"netType\",\n                    \"ipVer\",\n                    \"address\"\n                ],\n                format: \"%s %s %d %s IP%d %s\"\n            }\n        ],\n        // default parsing of these only (though some of these feel outdated)\n        s: [\n            {\n                name: \"name\"\n            }\n        ],\n        i: [\n            {\n                name: \"description\"\n            }\n        ],\n        u: [\n            {\n                name: \"uri\"\n            }\n        ],\n        e: [\n            {\n                name: \"email\"\n            }\n        ],\n        p: [\n            {\n                name: \"phone\"\n            }\n        ],\n        z: [\n            {\n                name: \"timezones\"\n            }\n        ],\n        // TODO: this one can actually be parsed properly...\n        r: [\n            {\n                name: \"repeats\"\n            }\n        ],\n        // TODO: this one can also be parsed properly\n        // k: [{}], // outdated thing ignored\n        t: [\n            {\n                // t=0 0\n                name: \"timing\",\n                reg: /^(\\d*) (\\d*)/,\n                names: [\n                    \"start\",\n                    \"stop\"\n                ],\n                format: \"%d %d\"\n            }\n        ],\n        c: [\n            {\n                // c=IN IP4 10.47.197.26\n                name: \"connection\",\n                reg: /^IN IP(\\d) (\\S*)/,\n                names: [\n                    \"version\",\n                    \"ip\"\n                ],\n                format: \"IN IP%d %s\"\n            }\n        ],\n        b: [\n            {\n                // b=AS:4000\n                push: \"bandwidth\",\n                reg: /^(TIAS|AS|CT|RR|RS):(\\d*)/,\n                names: [\n                    \"type\",\n                    \"limit\"\n                ],\n                format: \"%s:%s\"\n            }\n        ],\n        m: [\n            {\n                // m=video 51744 RTP/AVP 126 97 98 34 31\n                // NB: special - pushes to session\n                // TODO: rtp/fmtp should be filtered by the payloads found here?\n                reg: /^(\\w*) (\\d*) ([\\w/]*)(?: (.*))?/,\n                names: [\n                    \"type\",\n                    \"port\",\n                    \"protocol\",\n                    \"payloads\"\n                ],\n                format: \"%s %d %s %s\"\n            }\n        ],\n        a: [\n            {\n                // a=rtpmap:110 opus/48000/2\n                push: \"rtp\",\n                reg: /^rtpmap:(\\d*) ([\\w\\-.]*)(?:\\s*\\/(\\d*)(?:\\s*\\/(\\S*))?)?/,\n                names: [\n                    \"payload\",\n                    \"codec\",\n                    \"rate\",\n                    \"encoding\"\n                ],\n                format: function(o) {\n                    return o.encoding ? \"rtpmap:%d %s/%s/%s\" : o.rate ? \"rtpmap:%d %s/%s\" : \"rtpmap:%d %s\";\n                }\n            },\n            {\n                // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000\n                // a=fmtp:111 minptime=10; useinbandfec=1\n                push: \"fmtp\",\n                reg: /^fmtp:(\\d*) ([\\S| ]*)/,\n                names: [\n                    \"payload\",\n                    \"config\"\n                ],\n                format: \"fmtp:%d %s\"\n            },\n            {\n                // a=control:streamid=0\n                name: \"control\",\n                reg: /^control:(.*)/,\n                format: \"control:%s\"\n            },\n            {\n                // a=rtcp:65179 IN IP4 193.84.77.194\n                name: \"rtcp\",\n                reg: /^rtcp:(\\d*)(?: (\\S*) IP(\\d) (\\S*))?/,\n                names: [\n                    \"port\",\n                    \"netType\",\n                    \"ipVer\",\n                    \"address\"\n                ],\n                format: function(o) {\n                    return o.address != null ? \"rtcp:%d %s IP%d %s\" : \"rtcp:%d\";\n                }\n            },\n            {\n                // a=rtcp-fb:98 trr-int 100\n                push: \"rtcpFbTrrInt\",\n                reg: /^rtcp-fb:(\\*|\\d*) trr-int (\\d*)/,\n                names: [\n                    \"payload\",\n                    \"value\"\n                ],\n                format: \"rtcp-fb:%s trr-int %d\"\n            },\n            {\n                // a=rtcp-fb:98 nack rpsi\n                push: \"rtcpFb\",\n                reg: /^rtcp-fb:(\\*|\\d*) ([\\w-_]*)(?: ([\\w-_]*))?/,\n                names: [\n                    \"payload\",\n                    \"type\",\n                    \"subtype\"\n                ],\n                format: function(o) {\n                    return o.subtype != null ? \"rtcp-fb:%s %s %s\" : \"rtcp-fb:%s %s\";\n                }\n            },\n            {\n                // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset\n                // a=extmap:1/recvonly URI-gps-string\n                // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24\n                push: \"ext\",\n                reg: /^extmap:(\\d+)(?:\\/(\\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"value\",\n                    \"direction\",\n                    \"encrypt-uri\",\n                    \"uri\",\n                    \"config\"\n                ],\n                format: function(o) {\n                    return \"extmap:%d\" + (o.direction ? \"/%s\" : \"%v\") + (o[\"encrypt-uri\"] ? \" %s\" : \"%v\") + \" %s\" + (o.config ? \" %s\" : \"\");\n                }\n            },\n            {\n                // a=extmap-allow-mixed\n                name: \"extmapAllowMixed\",\n                reg: /^(extmap-allow-mixed)/\n            },\n            {\n                // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32\n                push: \"crypto\",\n                reg: /^crypto:(\\d*) ([\\w_]*) (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"id\",\n                    \"suite\",\n                    \"config\",\n                    \"sessionConfig\"\n                ],\n                format: function(o) {\n                    return o.sessionConfig != null ? \"crypto:%d %s %s %s\" : \"crypto:%d %s %s\";\n                }\n            },\n            {\n                // a=setup:actpass\n                name: \"setup\",\n                reg: /^setup:(\\w*)/,\n                format: \"setup:%s\"\n            },\n            {\n                // a=connection:new\n                name: \"connectionType\",\n                reg: /^connection:(new|existing)/,\n                format: \"connection:%s\"\n            },\n            {\n                // a=mid:1\n                name: \"mid\",\n                reg: /^mid:([^\\s]*)/,\n                format: \"mid:%s\"\n            },\n            {\n                // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a\n                name: \"msid\",\n                reg: /^msid:(.*)/,\n                format: \"msid:%s\"\n            },\n            {\n                // a=ptime:20\n                name: \"ptime\",\n                reg: /^ptime:(\\d*(?:\\.\\d*)*)/,\n                format: \"ptime:%d\"\n            },\n            {\n                // a=maxptime:60\n                name: \"maxptime\",\n                reg: /^maxptime:(\\d*(?:\\.\\d*)*)/,\n                format: \"maxptime:%d\"\n            },\n            {\n                // a=sendrecv\n                name: \"direction\",\n                reg: /^(sendrecv|recvonly|sendonly|inactive)/\n            },\n            {\n                // a=ice-lite\n                name: \"icelite\",\n                reg: /^(ice-lite)/\n            },\n            {\n                // a=ice-ufrag:F7gI\n                name: \"iceUfrag\",\n                reg: /^ice-ufrag:(\\S*)/,\n                format: \"ice-ufrag:%s\"\n            },\n            {\n                // a=ice-pwd:x9cml/YzichV2+XlhiMu8g\n                name: \"icePwd\",\n                reg: /^ice-pwd:(\\S*)/,\n                format: \"ice-pwd:%s\"\n            },\n            {\n                // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33\n                name: \"fingerprint\",\n                reg: /^fingerprint:(\\S*) (\\S*)/,\n                names: [\n                    \"type\",\n                    \"hash\"\n                ],\n                format: \"fingerprint:%s %s\"\n            },\n            {\n                // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host\n                // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10\n                // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10\n                // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10\n                // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10\n                push: \"candidates\",\n                reg: /^candidate:(\\S*) (\\d*) (\\S*) (\\d*) (\\S*) (\\d*) typ (\\S*)(?: raddr (\\S*) rport (\\d*))?(?: tcptype (\\S*))?(?: generation (\\d*))?(?: network-id (\\d*))?(?: network-cost (\\d*))?/,\n                names: [\n                    \"foundation\",\n                    \"component\",\n                    \"transport\",\n                    \"priority\",\n                    \"ip\",\n                    \"port\",\n                    \"type\",\n                    \"raddr\",\n                    \"rport\",\n                    \"tcptype\",\n                    \"generation\",\n                    \"network-id\",\n                    \"network-cost\"\n                ],\n                format: function(o) {\n                    var str = \"candidate:%s %d %s %d %s %d typ %s\";\n                    str += o.raddr != null ? \" raddr %s rport %d\" : \"%v%v\";\n                    // NB: candidate has three optional chunks, so %void middles one if it's missing\n                    str += o.tcptype != null ? \" tcptype %s\" : \"%v\";\n                    if (o.generation != null) {\n                        str += \" generation %d\";\n                    }\n                    str += o[\"network-id\"] != null ? \" network-id %d\" : \"%v\";\n                    str += o[\"network-cost\"] != null ? \" network-cost %d\" : \"%v\";\n                    return str;\n                }\n            },\n            {\n                // a=end-of-candidates (keep after the candidates line for readability)\n                name: \"endOfCandidates\",\n                reg: /^(end-of-candidates)/\n            },\n            {\n                // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...\n                name: \"remoteCandidates\",\n                reg: /^remote-candidates:(.*)/,\n                format: \"remote-candidates:%s\"\n            },\n            {\n                // a=ice-options:google-ice\n                name: \"iceOptions\",\n                reg: /^ice-options:(\\S*)/,\n                format: \"ice-options:%s\"\n            },\n            {\n                // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1\n                push: \"ssrcs\",\n                reg: /^ssrc:(\\d*) ([\\w_-]*)(?::(.*))?/,\n                names: [\n                    \"id\",\n                    \"attribute\",\n                    \"value\"\n                ],\n                format: function(o) {\n                    var str = \"ssrc:%d\";\n                    if (o.attribute != null) {\n                        str += \" %s\";\n                        if (o.value != null) {\n                            str += \":%s\";\n                        }\n                    }\n                    return str;\n                }\n            },\n            {\n                // a=ssrc-group:FEC 1 2\n                // a=ssrc-group:FEC-FR 3004364195 1080772241\n                push: \"ssrcGroups\",\n                // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E\n                reg: /^ssrc-group:([\\x21\\x23\\x24\\x25\\x26\\x27\\x2A\\x2B\\x2D\\x2E\\w]*) (.*)/,\n                names: [\n                    \"semantics\",\n                    \"ssrcs\"\n                ],\n                format: \"ssrc-group:%s %s\"\n            },\n            {\n                // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV\n                name: \"msidSemantic\",\n                reg: /^msid-semantic:\\s?(\\w*) (\\S*)/,\n                names: [\n                    \"semantic\",\n                    \"token\"\n                ],\n                format: \"msid-semantic: %s %s\" // space after ':' is not accidental\n            },\n            {\n                // a=group:BUNDLE audio video\n                push: \"groups\",\n                reg: /^group:(\\w*) (.*)/,\n                names: [\n                    \"type\",\n                    \"mids\"\n                ],\n                format: \"group:%s %s\"\n            },\n            {\n                // a=rtcp-mux\n                name: \"rtcpMux\",\n                reg: /^(rtcp-mux)/\n            },\n            {\n                // a=rtcp-rsize\n                name: \"rtcpRsize\",\n                reg: /^(rtcp-rsize)/\n            },\n            {\n                // a=sctpmap:5000 webrtc-datachannel 1024\n                name: \"sctpmap\",\n                reg: /^sctpmap:([\\w_/]*) (\\S*)(?: (\\S*))?/,\n                names: [\n                    \"sctpmapNumber\",\n                    \"app\",\n                    \"maxMessageSize\"\n                ],\n                format: function(o) {\n                    return o.maxMessageSize != null ? \"sctpmap:%s %s %s\" : \"sctpmap:%s %s\";\n                }\n            },\n            {\n                // a=x-google-flag:conference\n                name: \"xGoogleFlag\",\n                reg: /^x-google-flag:([^\\s]*)/,\n                format: \"x-google-flag:%s\"\n            },\n            {\n                // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0\n                push: \"rids\",\n                reg: /^rid:([\\d\\w]+) (\\w+)(?: ([\\S| ]*))?/,\n                names: [\n                    \"id\",\n                    \"direction\",\n                    \"params\"\n                ],\n                format: function(o) {\n                    return o.params ? \"rid:%s %s %s\" : \"rid:%s %s\";\n                }\n            },\n            {\n                // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]\n                // a=imageattr:* send [x=800,y=640] recv *\n                // a=imageattr:100 recv [x=320,y=240]\n                push: \"imageattrs\",\n                reg: new RegExp(// a=imageattr:97\n                \"^imageattr:(\\\\d+|\\\\*)\" + // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]\n                \"[\\\\s\\\\t]+(send|recv)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*)\" + // recv [x=330,y=250]\n                \"(?:[\\\\s\\\\t]+(recv|send)[\\\\s\\\\t]+(\\\\*|\\\\[\\\\S+\\\\](?:[\\\\s\\\\t]+\\\\[\\\\S+\\\\])*))?\"),\n                names: [\n                    \"pt\",\n                    \"dir1\",\n                    \"attrs1\",\n                    \"dir2\",\n                    \"attrs2\"\n                ],\n                format: function(o) {\n                    return \"imageattr:%s %s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n                }\n            },\n            {\n                // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8\n                // a=simulcast:recv 1;4,5 send 6;7\n                name: \"simulcast\",\n                reg: new RegExp(// a=simulcast:\n                \"^simulcast:\" + // send 1,2,3;~4,~5\n                \"(send|recv) ([a-zA-Z0-9\\\\-_~;,]+)\" + // space + recv 6;~7,~8\n                \"(?:\\\\s?(send|recv) ([a-zA-Z0-9\\\\-_~;,]+))?\" + // end\n                \"$\"),\n                names: [\n                    \"dir1\",\n                    \"list1\",\n                    \"dir2\",\n                    \"list2\"\n                ],\n                format: function(o) {\n                    return \"simulcast:%s %s\" + (o.dir2 ? \" %s %s\" : \"\");\n                }\n            },\n            {\n                // old simulcast draft 03 (implemented by Firefox)\n                //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03\n                // a=simulcast: recv pt=97;98 send pt=97\n                // a=simulcast: send rid=5;6;7 paused=6,7\n                name: \"simulcast_03\",\n                reg: /^simulcast:[\\s\\t]+([\\S+\\s\\t]+)$/,\n                names: [\n                    \"value\"\n                ],\n                format: \"simulcast: %s\"\n            },\n            {\n                // a=framerate:25\n                // a=framerate:29.97\n                name: \"framerate\",\n                reg: /^framerate:(\\d+(?:$|\\.\\d+))/,\n                format: \"framerate:%s\"\n            },\n            {\n                // RFC4570\n                // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5\n                name: \"sourceFilter\",\n                reg: /^source-filter: *(excl|incl) (\\S*) (IP4|IP6|\\*) (\\S*) (.*)/,\n                names: [\n                    \"filterMode\",\n                    \"netType\",\n                    \"addressTypes\",\n                    \"destAddress\",\n                    \"srcList\"\n                ],\n                format: \"source-filter: %s %s %s %s %s\"\n            },\n            {\n                // a=bundle-only\n                name: \"bundleOnly\",\n                reg: /^(bundle-only)/\n            },\n            {\n                // a=label:1\n                name: \"label\",\n                reg: /^label:(.+)/,\n                format: \"label:%s\"\n            },\n            {\n                // RFC version 26 for SCTP over DTLS\n                // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5\n                name: \"sctpPort\",\n                reg: /^sctp-port:(\\d+)$/,\n                format: \"sctp-port:%s\"\n            },\n            {\n                // RFC version 26 for SCTP over DTLS\n                // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6\n                name: \"maxMessageSize\",\n                reg: /^max-message-size:(\\d+)$/,\n                format: \"max-message-size:%s\"\n            },\n            {\n                // RFC7273\n                // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37\n                push: \"tsRefClocks\",\n                reg: /^ts-refclk:([^\\s=]*)(?:=(\\S*))?/,\n                names: [\n                    \"clksrc\",\n                    \"clksrcExt\"\n                ],\n                format: function(o) {\n                    return \"ts-refclk:%s\" + (o.clksrcExt != null ? \"=%s\" : \"\");\n                }\n            },\n            {\n                // RFC7273\n                // a=mediaclk:direct=963214424\n                name: \"mediaClk\",\n                reg: /^mediaclk:(?:id=(\\S*))? *([^\\s=]*)(?:=(\\S*))?(?: *rate=(\\d+)\\/(\\d+))?/,\n                names: [\n                    \"id\",\n                    \"mediaClockName\",\n                    \"mediaClockValue\",\n                    \"rateNumerator\",\n                    \"rateDenominator\"\n                ],\n                format: function(o) {\n                    var str = \"mediaclk:\";\n                    str += o.id != null ? \"id=%s %s\" : \"%v%s\";\n                    str += o.mediaClockValue != null ? \"=%s\" : \"\";\n                    str += o.rateNumerator != null ? \" rate=%s\" : \"\";\n                    str += o.rateDenominator != null ? \"/%s\" : \"\";\n                    return str;\n                }\n            },\n            {\n                // a=keywds:keywords\n                name: \"keywords\",\n                reg: /^keywds:(.+)$/,\n                format: \"keywds:%s\"\n            },\n            {\n                // a=content:main\n                name: \"content\",\n                reg: /^content:(.+)/,\n                format: \"content:%s\"\n            },\n            // BFCP https://tools.ietf.org/html/rfc4583\n            {\n                // a=floorctrl:c-s\n                name: \"bfcpFloorCtrl\",\n                reg: /^floorctrl:(c-only|s-only|c-s)/,\n                format: \"floorctrl:%s\"\n            },\n            {\n                // a=confid:1\n                name: \"bfcpConfId\",\n                reg: /^confid:(\\d+)/,\n                format: \"confid:%s\"\n            },\n            {\n                // a=userid:1\n                name: \"bfcpUserId\",\n                reg: /^userid:(\\d+)/,\n                format: \"userid:%s\"\n            },\n            {\n                // a=floorid:1\n                name: \"bfcpFloorId\",\n                reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,\n                names: [\n                    \"id\",\n                    \"mStream\"\n                ],\n                format: \"floorid:%s mstrm:%s\"\n            },\n            {\n                // any a= that we don't understand is kept verbatim on media.invalid\n                push: \"invalid\",\n                names: [\n                    \"value\"\n                ]\n            }\n        ]\n    };\n    // set sensible defaults to avoid polluting the grammar with boring details\n    Object.keys(grammar$1).forEach(function(key) {\n        var objs = grammar$1[key];\n        objs.forEach(function(obj) {\n            if (!obj.reg) {\n                obj.reg = /(.*)/;\n            }\n            if (!obj.format) {\n                obj.format = \"%s\";\n            }\n        });\n    });\n    return grammar.exports;\n}\nvar hasRequiredParser;\nfunction requireParser() {\n    if (hasRequiredParser) return parser;\n    hasRequiredParser = 1;\n    (function(exports) {\n        var toIntIfInt = function(v) {\n            return String(Number(v)) === v ? Number(v) : v;\n        };\n        var attachProperties = function(match, location, names, rawName) {\n            if (rawName && !names) {\n                location[rawName] = toIntIfInt(match[1]);\n            } else {\n                for(var i = 0; i < names.length; i += 1){\n                    if (match[i + 1] != null) {\n                        location[names[i]] = toIntIfInt(match[i + 1]);\n                    }\n                }\n            }\n        };\n        var parseReg = function(obj, location, content) {\n            var needsBlank = obj.name && obj.names;\n            if (obj.push && !location[obj.push]) {\n                location[obj.push] = [];\n            } else if (needsBlank && !location[obj.name]) {\n                location[obj.name] = {};\n            }\n            var keyLocation = obj.push ? {} : // blank object that will be pushed\n            needsBlank ? location[obj.name] : location; // otherwise, named location or root\n            attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);\n            if (obj.push) {\n                location[obj.push].push(keyLocation);\n            }\n        };\n        var grammar = requireGrammar();\n        var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);\n        exports.parse = function(sdp) {\n            var session = {}, media = [], location = session; // points at where properties go under (one of the above)\n            // parse lines we understand\n            sdp.split(/(\\r\\n|\\r|\\n)/).filter(validLine).forEach(function(l) {\n                var type = l[0];\n                var content = l.slice(2);\n                if (type === \"m\") {\n                    media.push({\n                        rtp: [],\n                        fmtp: []\n                    });\n                    location = media[media.length - 1]; // point at latest media line\n                }\n                for(var j = 0; j < (grammar[type] || []).length; j += 1){\n                    var obj = grammar[type][j];\n                    if (obj.reg.test(content)) {\n                        return parseReg(obj, location, content);\n                    }\n                }\n            });\n            session.media = media; // link it up\n            return session;\n        };\n        var paramReducer = function(acc, expr) {\n            var s = expr.split(/=(.+)/, 2);\n            if (s.length === 2) {\n                acc[s[0]] = toIntIfInt(s[1]);\n            } else if (s.length === 1 && expr.length > 1) {\n                acc[s[0]] = undefined;\n            }\n            return acc;\n        };\n        exports.parseParams = function(str) {\n            return str.split(/;\\s?/).reduce(paramReducer, {});\n        };\n        // For backward compatibility - alias will be removed in 3.0.0\n        exports.parseFmtpConfig = exports.parseParams;\n        exports.parsePayloads = function(str) {\n            return str.toString().split(\" \").map(Number);\n        };\n        exports.parseRemoteCandidates = function(str) {\n            var candidates = [];\n            var parts = str.split(\" \").map(toIntIfInt);\n            for(var i = 0; i < parts.length; i += 3){\n                candidates.push({\n                    component: parts[i],\n                    ip: parts[i + 1],\n                    port: parts[i + 2]\n                });\n            }\n            return candidates;\n        };\n        exports.parseImageAttributes = function(str) {\n            return str.split(\" \").map(function(item) {\n                return item.substring(1, item.length - 1).split(\",\").reduce(paramReducer, {});\n            });\n        };\n        exports.parseSimulcastStreamList = function(str) {\n            return str.split(\";\").map(function(stream) {\n                return stream.split(\",\").map(function(format) {\n                    var scid, paused = false;\n                    if (format[0] !== \"~\") {\n                        scid = toIntIfInt(format);\n                    } else {\n                        scid = toIntIfInt(format.substring(1, format.length));\n                        paused = true;\n                    }\n                    return {\n                        scid: scid,\n                        paused: paused\n                    };\n                });\n            });\n        };\n    })(parser);\n    return parser;\n}\nvar writer;\nvar hasRequiredWriter;\nfunction requireWriter() {\n    if (hasRequiredWriter) return writer;\n    hasRequiredWriter = 1;\n    var grammar = requireGrammar();\n    // customized util.format - discards excess arguments and can void middle ones\n    var formatRegExp = /%[sdv%]/g;\n    var format = function(formatStr) {\n        var i = 1;\n        var args = arguments;\n        var len = args.length;\n        return formatStr.replace(formatRegExp, function(x) {\n            if (i >= len) {\n                return x; // missing argument\n            }\n            var arg = args[i];\n            i += 1;\n            switch(x){\n                case \"%%\":\n                    return \"%\";\n                case \"%s\":\n                    return String(arg);\n                case \"%d\":\n                    return Number(arg);\n                case \"%v\":\n                    return \"\";\n            }\n        });\n    // NB: we discard excess arguments - they are typically undefined from makeLine\n    };\n    var makeLine = function(type, obj, location) {\n        var str = obj.format instanceof Function ? obj.format(obj.push ? location : location[obj.name]) : obj.format;\n        var args = [\n            type + \"=\" + str\n        ];\n        if (obj.names) {\n            for(var i = 0; i < obj.names.length; i += 1){\n                var n = obj.names[i];\n                if (obj.name) {\n                    args.push(location[obj.name][n]);\n                } else {\n                    // for mLine and push attributes\n                    args.push(location[obj.names[i]]);\n                }\n            }\n        } else {\n            args.push(location[obj.name]);\n        }\n        return format.apply(null, args);\n    };\n    // RFC specified order\n    // TODO: extend this with all the rest\n    var defaultOuterOrder = [\n        \"v\",\n        \"o\",\n        \"s\",\n        \"i\",\n        \"u\",\n        \"e\",\n        \"p\",\n        \"c\",\n        \"b\",\n        \"t\",\n        \"r\",\n        \"z\",\n        \"a\"\n    ];\n    var defaultInnerOrder = [\n        \"i\",\n        \"c\",\n        \"b\",\n        \"a\"\n    ];\n    writer = function(session, opts) {\n        opts = opts || {};\n        // ensure certain properties exist\n        if (session.version == null) {\n            session.version = 0; // 'v=0' must be there (only defined version atm)\n        }\n        if (session.name == null) {\n            session.name = \" \"; // 's= ' must be there if no meaningful name set\n        }\n        session.media.forEach(function(mLine) {\n            if (mLine.payloads == null) {\n                mLine.payloads = \"\";\n            }\n        });\n        var outerOrder = opts.outerOrder || defaultOuterOrder;\n        var innerOrder = opts.innerOrder || defaultInnerOrder;\n        var sdp = [];\n        // loop through outerOrder for matching properties on session\n        outerOrder.forEach(function(type) {\n            grammar[type].forEach(function(obj) {\n                if (obj.name in session && session[obj.name] != null) {\n                    sdp.push(makeLine(type, obj, session));\n                } else if (obj.push in session && session[obj.push] != null) {\n                    session[obj.push].forEach(function(el) {\n                        sdp.push(makeLine(type, obj, el));\n                    });\n                }\n            });\n        });\n        // then for each media line, follow the innerOrder\n        session.media.forEach(function(mLine) {\n            sdp.push(makeLine(\"m\", grammar.m[0], mLine));\n            innerOrder.forEach(function(type) {\n                grammar[type].forEach(function(obj) {\n                    if (obj.name in mLine && mLine[obj.name] != null) {\n                        sdp.push(makeLine(type, obj, mLine));\n                    } else if (obj.push in mLine && mLine[obj.push] != null) {\n                        mLine[obj.push].forEach(function(el) {\n                            sdp.push(makeLine(type, obj, el));\n                        });\n                    }\n                });\n            });\n        });\n        return sdp.join(\"\\r\\n\") + \"\\r\\n\";\n    };\n    return writer;\n}\nvar hasRequiredLib;\nfunction requireLib() {\n    if (hasRequiredLib) return lib;\n    hasRequiredLib = 1;\n    var parser = requireParser();\n    var writer = requireWriter();\n    var grammar = requireGrammar();\n    lib.grammar = grammar;\n    lib.write = writer;\n    lib.parse = parser.parse;\n    lib.parseParams = parser.parseParams;\n    lib.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\n    lib.parsePayloads = parser.parsePayloads;\n    lib.parseRemoteCandidates = parser.parseRemoteCandidates;\n    lib.parseImageAttributes = parser.parseImageAttributes;\n    lib.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n    return lib;\n}\nvar libExports = requireLib();\nfunction r(r, e, n) {\n    var i, t, o;\n    void 0 === e && (e = 50), void 0 === n && (n = {});\n    var a = null != (i = n.isImmediate) && i, u = null != (t = n.callback) && t, c = n.maxWait, v = Date.now(), l = [];\n    function f() {\n        if (void 0 !== c) {\n            var r = Date.now() - v;\n            if (r + e >= c) return c - r;\n        }\n        return e;\n    }\n    var d = function() {\n        var e = [].slice.call(arguments), n = this;\n        return new Promise(function(i, t) {\n            var c = a && void 0 === o;\n            if (void 0 !== o && clearTimeout(o), o = setTimeout(function() {\n                if (o = void 0, v = Date.now(), !a) {\n                    var i = r.apply(n, e);\n                    u && u(i), l.forEach(function(r) {\n                        return (0, r.resolve)(i);\n                    }), l = [];\n                }\n            }, f()), c) {\n                var d = r.apply(n, e);\n                return u && u(d), i(d);\n            }\n            l.push({\n                resolve: i,\n                reject: t\n            });\n        });\n    };\n    return d.cancel = function(r) {\n        void 0 !== o && clearTimeout(o), l.forEach(function(e) {\n            return (0, e.reject)(r);\n        }), l = [];\n    }, d;\n}\n/* The svc codec (av1/vp9) would use a very low bitrate at the begining and\nincrease slowly by the bandwidth estimator until it reach the target bitrate. The\nprocess commonly cost more than 10 seconds cause subscriber will get blur video at\nthe first few seconds. So we use a 70% of target bitrate here as the start bitrate to\neliminate this issue.\n*/ const startBitrateForSVC = 0.7;\nconst debounceInterval = 20;\nconst PCEvents = {\n    NegotiationStarted: \"negotiationStarted\",\n    NegotiationComplete: \"negotiationComplete\",\n    RTPVideoPayloadTypes: \"rtpVideoPayloadTypes\"\n};\n/** @internal */ class PCTransport extends eventsExports.EventEmitter {\n    get pc() {\n        if (!this._pc) {\n            this._pc = this.createPC();\n        }\n        return this._pc;\n    }\n    constructor(config){\n        let loggerOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var _a;\n        super();\n        this.log = livekitLogger;\n        this.ddExtID = 0;\n        this.pendingCandidates = [];\n        this.restartingIce = false;\n        this.renegotiate = false;\n        this.trackBitrates = [];\n        this.remoteStereoMids = [];\n        this.remoteNackMids = [];\n        // debounced negotiate interface\n        this.negotiate = r((onError)=>__awaiter(this, void 0, void 0, function*() {\n                this.emit(PCEvents.NegotiationStarted);\n                try {\n                    yield this.createAndSendOffer();\n                } catch (e) {\n                    if (onError) {\n                        onError(e);\n                    } else {\n                        throw e;\n                    }\n                }\n            }), debounceInterval);\n        this.close = ()=>{\n            if (!this._pc) {\n                return;\n            }\n            this._pc.close();\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc.onicegatheringstatechange = null;\n            this._pc.ondatachannel = null;\n            this._pc.onnegotiationneeded = null;\n            this._pc.onsignalingstatechange = null;\n            this._pc.onicecandidate = null;\n            this._pc.ondatachannel = null;\n            this._pc.ontrack = null;\n            this._pc.onconnectionstatechange = null;\n            this._pc.oniceconnectionstatechange = null;\n            this._pc = null;\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCTransport);\n        this.loggerOptions = loggerOptions;\n        this.config = config;\n        this._pc = this.createPC();\n    }\n    createPC() {\n        const pc = new RTCPeerConnection(this.config);\n        pc.onicecandidate = (ev)=>{\n            var _a;\n            if (!ev.candidate) return;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, ev.candidate);\n        };\n        pc.onicecandidateerror = (ev)=>{\n            var _a;\n            (_a = this.onIceCandidateError) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.oniceconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onIceConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.iceConnectionState);\n        };\n        pc.onsignalingstatechange = ()=>{\n            var _a;\n            (_a = this.onSignalingStatechange) === null || _a === void 0 ? void 0 : _a.call(this, pc.signalingState);\n        };\n        pc.onconnectionstatechange = ()=>{\n            var _a;\n            (_a = this.onConnectionStateChange) === null || _a === void 0 ? void 0 : _a.call(this, pc.connectionState);\n        };\n        pc.ondatachannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        pc.ontrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        return pc;\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isICEConnected() {\n        return this._pc !== null && (this.pc.iceConnectionState === \"connected\" || this.pc.iceConnectionState === \"completed\");\n    }\n    addIceCandidate(candidate) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pc.remoteDescription && !this.restartingIce) {\n                return this.pc.addIceCandidate(candidate);\n            }\n            this.pendingCandidates.push(candidate);\n        });\n    }\n    setRemoteDescription(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            let mungedSDP = undefined;\n            if (sd.type === \"offer\") {\n                let { stereoMids, nackMids } = extractStereoAndNackAudioFromOffer(sd);\n                this.remoteStereoMids = stereoMids;\n                this.remoteNackMids = nackMids;\n            } else if (sd.type === \"answer\") {\n                const sdpParsed = libExports.parse((_a = sd.sdp) !== null && _a !== void 0 ? _a : \"\");\n                sdpParsed.media.forEach((media)=>{\n                    if (media.type === \"audio\") {\n                        // mung sdp for opus bitrate settings\n                        this.trackBitrates.some((trackbr)=>{\n                            if (!trackbr.transceiver || media.mid != trackbr.transceiver.mid) {\n                                return false;\n                            }\n                            let codecPayload = 0;\n                            media.rtp.some((rtp)=>{\n                                if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                    codecPayload = rtp.payload;\n                                    return true;\n                                }\n                                return false;\n                            });\n                            if (codecPayload === 0) {\n                                return true;\n                            }\n                            let fmtpFound = false;\n                            for (const fmtp of media.fmtp){\n                                if (fmtp.payload === codecPayload) {\n                                    fmtp.config = fmtp.config.split(\";\").filter((attr)=>!attr.includes(\"maxaveragebitrate\")).join(\";\");\n                                    if (trackbr.maxbr > 0) {\n                                        fmtp.config += \";maxaveragebitrate=\".concat(trackbr.maxbr * 1000);\n                                    }\n                                    fmtpFound = true;\n                                    break;\n                                }\n                            }\n                            if (!fmtpFound) {\n                                if (trackbr.maxbr > 0) {\n                                    media.fmtp.push({\n                                        payload: codecPayload,\n                                        config: \"maxaveragebitrate=\".concat(trackbr.maxbr * 1000)\n                                    });\n                                }\n                            }\n                            return true;\n                        });\n                    }\n                });\n                mungedSDP = libExports.write(sdpParsed);\n            }\n            yield this.setMungedSDP(sd, mungedSDP, true);\n            this.pendingCandidates.forEach((candidate)=>{\n                this.pc.addIceCandidate(candidate);\n            });\n            this.pendingCandidates = [];\n            this.restartingIce = false;\n            if (this.renegotiate) {\n                this.renegotiate = false;\n                yield this.createAndSendOffer();\n            } else if (sd.type === \"answer\") {\n                this.emit(PCEvents.NegotiationComplete);\n                if (sd.sdp) {\n                    const sdpParsed = libExports.parse(sd.sdp);\n                    sdpParsed.media.forEach((media)=>{\n                        if (media.type === \"video\") {\n                            this.emit(PCEvents.RTPVideoPayloadTypes, media.rtp);\n                        }\n                    });\n                }\n            }\n        });\n    }\n    createAndSendOffer(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (this.onOffer === undefined) {\n                return;\n            }\n            if (options === null || options === void 0 ? void 0 : options.iceRestart) {\n                this.log.debug(\"restarting ICE\", this.logContext);\n                this.restartingIce = true;\n            }\n            if (this._pc && this._pc.signalingState === \"have-local-offer\") {\n                // we're waiting for the peer to accept our offer, so we'll just wait\n                // the only exception to this is when ICE restart is needed\n                const currentSD = this._pc.remoteDescription;\n                if ((options === null || options === void 0 ? void 0 : options.iceRestart) && currentSD) {\n                    // TODO: handle when ICE restart is needed but we don't have a remote description\n                    // the best thing to do is to recreate the peerconnection\n                    yield this._pc.setRemoteDescription(currentSD);\n                } else {\n                    this.renegotiate = true;\n                    return;\n                }\n            } else if (!this._pc || this._pc.signalingState === \"closed\") {\n                this.log.warn(\"could not createOffer with closed peer connection\", this.logContext);\n                return;\n            }\n            // actually negotiate\n            this.log.debug(\"starting to negotiate\", this.logContext);\n            const offer = yield this.pc.createOffer(options);\n            this.log.debug(\"original offer\", Object.assign({\n                sdp: offer.sdp\n            }, this.logContext));\n            const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                ensureIPAddrMatchVersion(media);\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, [], []);\n                } else if (media.type === \"video\") {\n                    this.trackBitrates.some((trackbr)=>{\n                        if (!media.msid || !trackbr.cid || !media.msid.includes(trackbr.cid)) {\n                            return false;\n                        }\n                        let codecPayload = 0;\n                        media.rtp.some((rtp)=>{\n                            if (rtp.codec.toUpperCase() === trackbr.codec.toUpperCase()) {\n                                codecPayload = rtp.payload;\n                                return true;\n                            }\n                            return false;\n                        });\n                        if (codecPayload === 0) {\n                            return true;\n                        }\n                        if (isSVCCodec(trackbr.codec)) {\n                            this.ensureVideoDDExtensionForSVC(media, sdpParsed);\n                        }\n                        // TODO: av1 slow starting issue already fixed in chrome 124, clean this after some versions\n                        // mung sdp for av1 bitrate setting that can't apply by sendEncoding\n                        if (trackbr.codec !== \"av1\") {\n                            return true;\n                        }\n                        const startBitrate = Math.round(trackbr.maxbr * startBitrateForSVC);\n                        for (const fmtp of media.fmtp){\n                            if (fmtp.payload === codecPayload) {\n                                // if another track's fmtp already is set, we cannot override the bitrate\n                                // this has the unfortunate consequence of being forced to use the\n                                // initial track's bitrate for all tracks\n                                if (!fmtp.config.includes(\"x-google-start-bitrate\")) {\n                                    fmtp.config += \";x-google-start-bitrate=\".concat(startBitrate);\n                                }\n                                break;\n                            }\n                        }\n                        return true;\n                    });\n                }\n            });\n            yield this.setMungedSDP(offer, libExports.write(sdpParsed));\n            this.onOffer(offer);\n        });\n    }\n    createAndSetAnswer() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const answer = yield this.pc.createAnswer();\n            const sdpParsed = libExports.parse((_a = answer.sdp) !== null && _a !== void 0 ? _a : \"\");\n            sdpParsed.media.forEach((media)=>{\n                ensureIPAddrMatchVersion(media);\n                if (media.type === \"audio\") {\n                    ensureAudioNackAndStereo(media, this.remoteStereoMids, this.remoteNackMids);\n                }\n            });\n            yield this.setMungedSDP(answer, libExports.write(sdpParsed));\n            return answer;\n        });\n    }\n    createDataChannel(label, dataChannelDict) {\n        return this.pc.createDataChannel(label, dataChannelDict);\n    }\n    addTransceiver(mediaStreamTrack, transceiverInit) {\n        return this.pc.addTransceiver(mediaStreamTrack, transceiverInit);\n    }\n    addTrack(track) {\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot add track\");\n        }\n        return this._pc.addTrack(track);\n    }\n    setTrackCodecBitrate(info) {\n        this.trackBitrates.push(info);\n    }\n    setConfiguration(rtcConfig) {\n        var _a;\n        if (!this._pc) {\n            throw new UnexpectedConnectionState(\"PC closed, cannot configure\");\n        }\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.setConfiguration(rtcConfig);\n    }\n    canRemoveTrack() {\n        var _a;\n        return !!((_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack);\n    }\n    removeTrack(sender) {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.removeTrack(sender);\n    }\n    getConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.connectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getICEConnectionState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getSignallingState() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.signalingState) !== null && _b !== void 0 ? _b : \"closed\";\n    }\n    getTransceivers() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getTransceivers()) !== null && _b !== void 0 ? _b : [];\n    }\n    getSenders() {\n        var _a, _b;\n        return (_b = (_a = this._pc) === null || _a === void 0 ? void 0 : _a.getSenders()) !== null && _b !== void 0 ? _b : [];\n    }\n    getLocalDescription() {\n        var _a;\n        return (_a = this._pc) === null || _a === void 0 ? void 0 : _a.localDescription;\n    }\n    getRemoteDescription() {\n        var _a;\n        return (_a = this.pc) === null || _a === void 0 ? void 0 : _a.remoteDescription;\n    }\n    getStats() {\n        return this.pc.getStats();\n    }\n    getConnectedAddress() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!this._pc) {\n                return;\n            }\n            let selectedCandidatePairId = \"\";\n            const candidatePairs = new Map();\n            // id -> candidate ip\n            const candidates = new Map();\n            const stats = yield this._pc.getStats();\n            stats.forEach((v)=>{\n                switch(v.type){\n                    case \"transport\":\n                        selectedCandidatePairId = v.selectedCandidatePairId;\n                        break;\n                    case \"candidate-pair\":\n                        if (selectedCandidatePairId === \"\" && v.selected) {\n                            selectedCandidatePairId = v.id;\n                        }\n                        candidatePairs.set(v.id, v);\n                        break;\n                    case \"remote-candidate\":\n                        candidates.set(v.id, \"\".concat(v.address, \":\").concat(v.port));\n                        break;\n                }\n            });\n            if (selectedCandidatePairId === \"\") {\n                return undefined;\n            }\n            const selectedID = (_a = candidatePairs.get(selectedCandidatePairId)) === null || _a === void 0 ? void 0 : _a.remoteCandidateId;\n            if (selectedID === undefined) {\n                return undefined;\n            }\n            return candidates.get(selectedID);\n        });\n    }\n    setMungedSDP(sd, munged, remote) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (munged) {\n                const originalSdp = sd.sdp;\n                sd.sdp = munged;\n                try {\n                    this.log.debug(\"setting munged \".concat(remote ? \"remote\" : \"local\", \" description\"), this.logContext);\n                    if (remote) {\n                        yield this.pc.setRemoteDescription(sd);\n                    } else {\n                        yield this.pc.setLocalDescription(sd);\n                    }\n                    return;\n                } catch (e) {\n                    this.log.warn(\"not able to set \".concat(sd.type, \", falling back to unmodified sdp\"), Object.assign(Object.assign({}, this.logContext), {\n                        error: e,\n                        sdp: munged\n                    }));\n                    sd.sdp = originalSdp;\n                }\n            }\n            try {\n                if (remote) {\n                    yield this.pc.setRemoteDescription(sd);\n                } else {\n                    yield this.pc.setLocalDescription(sd);\n                }\n            } catch (e) {\n                let msg = \"unknown error\";\n                if (e instanceof Error) {\n                    msg = e.message;\n                } else if (typeof e === \"string\") {\n                    msg = e;\n                }\n                const fields = {\n                    error: msg,\n                    sdp: sd.sdp\n                };\n                if (!remote && this.pc.remoteDescription) {\n                    fields.remoteSdp = this.pc.remoteDescription;\n                }\n                this.log.error(\"unable to set \".concat(sd.type), Object.assign(Object.assign({}, this.logContext), {\n                    fields\n                }));\n                throw new NegotiationError(msg);\n            }\n        });\n    }\n    ensureVideoDDExtensionForSVC(media, sdp) {\n        var _a, _b;\n        const ddFound = (_a = media.ext) === null || _a === void 0 ? void 0 : _a.some((ext)=>{\n            if (ext.uri === ddExtensionURI) {\n                return true;\n            }\n            return false;\n        });\n        if (!ddFound) {\n            if (this.ddExtID === 0) {\n                let maxID = 0;\n                sdp.media.forEach((m)=>{\n                    var _a;\n                    if (m.type !== \"video\") {\n                        return;\n                    }\n                    (_a = m.ext) === null || _a === void 0 ? void 0 : _a.forEach((ext)=>{\n                        if (ext.value > maxID) {\n                            maxID = ext.value;\n                        }\n                    });\n                });\n                this.ddExtID = maxID + 1;\n            }\n            (_b = media.ext) === null || _b === void 0 ? void 0 : _b.push({\n                value: this.ddExtID,\n                uri: ddExtensionURI\n            });\n        }\n    }\n}\nfunction ensureAudioNackAndStereo(media, stereoMids, nackMids) {\n    // found opus codec to add nack fb\n    let opusPayload = 0;\n    media.rtp.some((rtp)=>{\n        if (rtp.codec === \"opus\") {\n            opusPayload = rtp.payload;\n            return true;\n        }\n        return false;\n    });\n    // add nack rtcpfb if not exist\n    if (opusPayload > 0) {\n        if (!media.rtcpFb) {\n            media.rtcpFb = [];\n        }\n        if (nackMids.includes(media.mid) && !media.rtcpFb.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n            media.rtcpFb.push({\n                payload: opusPayload,\n                type: \"nack\"\n            });\n        }\n        if (stereoMids.includes(media.mid)) {\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (!fmtp.config.includes(\"stereo=1\")) {\n                        fmtp.config += \";stereo=1\";\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    }\n}\nfunction extractStereoAndNackAudioFromOffer(offer) {\n    var _a;\n    const stereoMids = [];\n    const nackMids = [];\n    const sdpParsed = libExports.parse((_a = offer.sdp) !== null && _a !== void 0 ? _a : \"\");\n    let opusPayload = 0;\n    sdpParsed.media.forEach((media)=>{\n        var _a;\n        if (media.type === \"audio\") {\n            media.rtp.some((rtp)=>{\n                if (rtp.codec === \"opus\") {\n                    opusPayload = rtp.payload;\n                    return true;\n                }\n                return false;\n            });\n            if ((_a = media.rtcpFb) === null || _a === void 0 ? void 0 : _a.some((fb)=>fb.payload === opusPayload && fb.type === \"nack\")) {\n                nackMids.push(media.mid);\n            }\n            media.fmtp.some((fmtp)=>{\n                if (fmtp.payload === opusPayload) {\n                    if (fmtp.config.includes(\"sprop-stereo=1\")) {\n                        stereoMids.push(media.mid);\n                    }\n                    return true;\n                }\n                return false;\n            });\n        }\n    });\n    return {\n        stereoMids,\n        nackMids\n    };\n}\nfunction ensureIPAddrMatchVersion(media) {\n    // Chrome could generate sdp with c = IN IP4 <ipv6 addr>\n    // in edge case and return error when set sdp.This is not a\n    // sdk error but correct it if the issue detected.\n    if (media.connection) {\n        const isV6 = media.connection.ip.indexOf(\":\") >= 0;\n        if (media.connection.version === 4 && isV6 || media.connection.version === 6 && !isV6) {\n            // fallback to dummy address\n            media.connection.ip = \"0.0.0.0\";\n            media.connection.version = 4;\n        }\n    }\n}\nconst defaultVideoCodec = \"vp8\";\nconst publishDefaults = {\n    audioPreset: AudioPresets.music,\n    dtx: true,\n    red: true,\n    forceStereo: false,\n    simulcast: true,\n    screenShareEncoding: ScreenSharePresets.h1080fps15.encoding,\n    stopMicTrackOnMute: false,\n    videoCodec: defaultVideoCodec,\n    backupCodec: true\n};\nconst audioDefaults = {\n    deviceId: {\n        ideal: \"default\"\n    },\n    autoGainControl: true,\n    echoCancellation: true,\n    noiseSuppression: true,\n    voiceIsolation: true\n};\nconst videoDefaults = {\n    deviceId: {\n        ideal: \"default\"\n    },\n    resolution: VideoPresets.h720.resolution\n};\nconst roomOptionDefaults = {\n    adaptiveStream: false,\n    dynacast: false,\n    stopLocalTrackOnUnpublish: true,\n    reconnectPolicy: new DefaultReconnectPolicy(),\n    disconnectOnPageLeave: true,\n    webAudioMix: false\n};\nconst roomConnectOptionDefaults = {\n    autoSubscribe: true,\n    maxRetries: 1,\n    peerConnectionTimeout: 15000,\n    websocketTimeout: 15000\n};\nvar PCTransportState;\n(function(PCTransportState) {\n    PCTransportState[PCTransportState[\"NEW\"] = 0] = \"NEW\";\n    PCTransportState[PCTransportState[\"CONNECTING\"] = 1] = \"CONNECTING\";\n    PCTransportState[PCTransportState[\"CONNECTED\"] = 2] = \"CONNECTED\";\n    PCTransportState[PCTransportState[\"FAILED\"] = 3] = \"FAILED\";\n    PCTransportState[PCTransportState[\"CLOSING\"] = 4] = \"CLOSING\";\n    PCTransportState[PCTransportState[\"CLOSED\"] = 5] = \"CLOSED\";\n})(PCTransportState || (PCTransportState = {}));\nclass PCTransportManager {\n    get needsPublisher() {\n        return this.isPublisherConnectionRequired;\n    }\n    get needsSubscriber() {\n        return this.isSubscriberConnectionRequired;\n    }\n    get currentState() {\n        return this.state;\n    }\n    constructor(rtcConfig, subscriberPrimary, loggerOptions){\n        var _a;\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.log = livekitLogger;\n        this.updateState = ()=>{\n            var _a;\n            const previousState = this.state;\n            const connectionStates = this.requiredTransports.map((tr)=>tr.getConnectionState());\n            if (connectionStates.every((st)=>st === \"connected\")) {\n                this.state = PCTransportState.CONNECTED;\n            } else if (connectionStates.some((st)=>st === \"failed\")) {\n                this.state = PCTransportState.FAILED;\n            } else if (connectionStates.some((st)=>st === \"connecting\")) {\n                this.state = PCTransportState.CONNECTING;\n            } else if (connectionStates.every((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSED;\n            } else if (connectionStates.some((st)=>st === \"closed\")) {\n                this.state = PCTransportState.CLOSING;\n            } else if (connectionStates.every((st)=>st === \"new\")) {\n                this.state = PCTransportState.NEW;\n            }\n            if (previousState !== this.state) {\n                this.log.debug(\"pc state change: from \".concat(PCTransportState[previousState], \" to \").concat(PCTransportState[this.state]), this.logContext);\n                (_a = this.onStateChange) === null || _a === void 0 ? void 0 : _a.call(this, this.state, this.publisher.getConnectionState(), this.subscriber.getConnectionState());\n            }\n        };\n        this.log = getLogger((_a = loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.PCManager);\n        this.loggerOptions = loggerOptions;\n        this.isPublisherConnectionRequired = !subscriberPrimary;\n        this.isSubscriberConnectionRequired = subscriberPrimary;\n        this.publisher = new PCTransport(rtcConfig, loggerOptions);\n        this.subscriber = new PCTransport(rtcConfig, loggerOptions);\n        this.publisher.onConnectionStateChange = this.updateState;\n        this.subscriber.onConnectionStateChange = this.updateState;\n        this.publisher.onIceConnectionStateChange = this.updateState;\n        this.subscriber.onIceConnectionStateChange = this.updateState;\n        this.publisher.onSignalingStatechange = this.updateState;\n        this.subscriber.onSignalingStatechange = this.updateState;\n        this.publisher.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.PUBLISHER);\n        };\n        this.subscriber.onIceCandidate = (candidate)=>{\n            var _a;\n            (_a = this.onIceCandidate) === null || _a === void 0 ? void 0 : _a.call(this, candidate, SignalTarget.SUBSCRIBER);\n        };\n        // in subscriber primary mode, server side opens sub data channels.\n        this.subscriber.onDataChannel = (ev)=>{\n            var _a;\n            (_a = this.onDataChannel) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.subscriber.onTrack = (ev)=>{\n            var _a;\n            (_a = this.onTrack) === null || _a === void 0 ? void 0 : _a.call(this, ev);\n        };\n        this.publisher.onOffer = (offer)=>{\n            var _a;\n            (_a = this.onPublisherOffer) === null || _a === void 0 ? void 0 : _a.call(this, offer);\n        };\n        this.state = PCTransportState.NEW;\n        this.connectionLock = new _();\n        this.remoteOfferLock = new _();\n    }\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions).loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    requirePublisher() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isPublisherConnectionRequired = require;\n        this.updateState();\n    }\n    requireSubscriber() {\n        let require = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        this.isSubscriberConnectionRequired = require;\n        this.updateState();\n    }\n    createAndSendPublisherOffer(options) {\n        return this.publisher.createAndSendOffer(options);\n    }\n    setPublisherAnswer(sd) {\n        return this.publisher.setRemoteDescription(sd);\n    }\n    removeTrack(sender) {\n        return this.publisher.removeTrack(sender);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.publisher && this.publisher.getSignallingState() !== \"closed\") {\n                const publisher = this.publisher;\n                for (const sender of publisher.getSenders()){\n                    try {\n                        // TODO: react-native-webrtc doesn't have removeTrack yet.\n                        if (publisher.canRemoveTrack()) {\n                            publisher.removeTrack(sender);\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not removeTrack\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    }\n                }\n            }\n            yield Promise.all([\n                this.publisher.close(),\n                this.subscriber.close()\n            ]);\n            this.updateState();\n        });\n    }\n    triggerIceRestart() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.subscriber.restartingIce = true;\n            // only restart publisher if it's needed\n            if (this.needsPublisher) {\n                yield this.createAndSendPublisherOffer({\n                    iceRestart: true\n                });\n            }\n        });\n    }\n    addIceCandidate(candidate, target) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (target === SignalTarget.PUBLISHER) {\n                yield this.publisher.addIceCandidate(candidate);\n            } else {\n                yield this.subscriber.addIceCandidate(candidate);\n            }\n        });\n    }\n    createSubscriberAnswerFromOffer(sd) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"received server offer\", Object.assign(Object.assign({}, this.logContext), {\n                RTCSdpType: sd.type,\n                sdp: sd.sdp,\n                signalingState: this.subscriber.getSignallingState().toString()\n            }));\n            const unlock = yield this.remoteOfferLock.lock();\n            try {\n                yield this.subscriber.setRemoteDescription(sd);\n                // answer the offer\n                const answer = yield this.subscriber.createAndSetAnswer();\n                return answer;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    updateConfiguration(config, iceRestart) {\n        this.publisher.setConfiguration(config);\n        this.subscriber.setConfiguration(config);\n        if (iceRestart) {\n            this.triggerIceRestart();\n        }\n    }\n    ensurePCTransportConnection(abortController, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.connectionLock.lock();\n            try {\n                if (this.isPublisherConnectionRequired && this.publisher.getConnectionState() !== \"connected\" && this.publisher.getConnectionState() !== \"connecting\") {\n                    this.log.debug(\"negotiation required, start negotiating\", this.logContext);\n                    this.publisher.negotiate();\n                }\n                yield Promise.all((_a = this.requiredTransports) === null || _a === void 0 ? void 0 : _a.map((transport)=>this.ensureTransportConnected(transport, abortController, timeout)));\n            } finally{\n                unlock();\n            }\n        });\n    }\n    negotiate(abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    const negotiationTimeout = setTimeout(()=>{\n                        reject(\"negotiation timed out\");\n                    }, this.peerConnectionTimeout);\n                    const abortHandler = ()=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(\"negotiation aborted\");\n                    };\n                    abortController.signal.addEventListener(\"abort\", abortHandler);\n                    this.publisher.once(PCEvents.NegotiationStarted, ()=>{\n                        if (abortController.signal.aborted) {\n                            return;\n                        }\n                        this.publisher.once(PCEvents.NegotiationComplete, ()=>{\n                            clearTimeout(negotiationTimeout);\n                            resolve();\n                        });\n                    });\n                    yield this.publisher.negotiate((e)=>{\n                        clearTimeout(negotiationTimeout);\n                        reject(e);\n                    });\n                }));\n        });\n    }\n    addPublisherTransceiver(track, transceiverInit) {\n        return this.publisher.addTransceiver(track, transceiverInit);\n    }\n    addPublisherTrack(track) {\n        return this.publisher.addTrack(track);\n    }\n    createPublisherDataChannel(label, dataChannelDict) {\n        return this.publisher.createDataChannel(label, dataChannelDict);\n    }\n    /**\n   * Returns the first required transport's address if no explicit target is specified\n   */ getConnectedAddress(target) {\n        if (target === SignalTarget.PUBLISHER) {\n            return this.publisher.getConnectedAddress();\n        } else if (target === SignalTarget.SUBSCRIBER) {\n            return this.publisher.getConnectedAddress();\n        }\n        return this.requiredTransports[0].getConnectedAddress();\n    }\n    get requiredTransports() {\n        const transports = [];\n        if (this.isPublisherConnectionRequired) {\n            transports.push(this.publisher);\n        }\n        if (this.isSubscriberConnectionRequired) {\n            transports.push(this.subscriber);\n        }\n        return transports;\n    }\n    ensureTransportConnected(pcTransport_1, abortController_1) {\n        return __awaiter(this, arguments, void 0, function(pcTransport, abortController) {\n            var _this = this;\n            let timeout = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.peerConnectionTimeout;\n            return function*() {\n                const connectionState = pcTransport.getConnectionState();\n                if (connectionState === \"connected\") {\n                    return;\n                }\n                return new Promise((resolve, reject)=>__awaiter(_this, void 0, void 0, function*() {\n                        const abortHandler = ()=>{\n                            this.log.warn(\"abort transport connection\", this.logContext);\n                            CriticalTimers.clearTimeout(connectTimeout);\n                            reject(new ConnectionError(\"room connection has been cancelled\", ConnectionErrorReason.Cancelled));\n                        };\n                        if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                            abortHandler();\n                        }\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.addEventListener(\"abort\", abortHandler);\n                        const connectTimeout = CriticalTimers.setTimeout(()=>{\n                            abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                            reject(new ConnectionError(\"could not establish pc connection\", ConnectionErrorReason.InternalError));\n                        }, timeout);\n                        while(this.state !== PCTransportState.CONNECTED){\n                            yield sleep(50); // FIXME we shouldn't rely on `sleep` in the connection paths, as it invokes `setTimeout` which can be drastically throttled by browser implementations\n                            if (abortController === null || abortController === void 0 ? void 0 : abortController.signal.aborted) {\n                                reject(new ConnectionError(\"room connection has been cancelled\", ConnectionErrorReason.Cancelled));\n                                return;\n                            }\n                        }\n                        CriticalTimers.clearTimeout(connectTimeout);\n                        abortController === null || abortController === void 0 ? void 0 : abortController.signal.removeEventListener(\"abort\", abortHandler);\n                        resolve();\n                    }));\n            }();\n        });\n    }\n}\n// SPDX-FileCopyrightText: 2024 LiveKit, Inc.\n//\n// SPDX-License-Identifier: Apache-2.0\n/**\n * Specialized error handling for RPC methods.\n *\n * Instances of this type, when thrown in a method handler, will have their `message`\n * serialized and sent across the wire. The sender will receive an equivalent error on the other side.\n *\n * Built-in types are included but developers may use any string, with a max length of 256 bytes.\n */ class RpcError extends Error {\n    /**\n   * Creates an error object with the given code and message, plus an optional data payload.\n   *\n   * If thrown in an RPC method handler, the error will be sent back to the caller.\n   *\n   * Error codes 1001-1999 are reserved for built-in errors (see RpcError.ErrorCode for their meanings).\n   */ constructor(code, message, data){\n        super(message);\n        this.code = code;\n        this.message = truncateBytes(message, RpcError.MAX_MESSAGE_BYTES);\n        this.data = data ? truncateBytes(data, RpcError.MAX_DATA_BYTES) : undefined;\n    }\n    /**\n   * @internal\n   */ static fromProto(proto) {\n        return new RpcError(proto.code, proto.message, proto.data);\n    }\n    /**\n   * @internal\n   */ toProto() {\n        return new RpcError$1({\n            code: this.code,\n            message: this.message,\n            data: this.data\n        });\n    }\n    /**\n   * Creates an error object from the code, with an auto-populated message.\n   *\n   * @internal\n   */ static builtIn(key, data) {\n        return new RpcError(RpcError.ErrorCode[key], RpcError.ErrorMessage[key], data);\n    }\n}\nRpcError.MAX_MESSAGE_BYTES = 256;\nRpcError.MAX_DATA_BYTES = 15360; // 15 KB\nRpcError.ErrorCode = {\n    APPLICATION_ERROR: 1500,\n    CONNECTION_TIMEOUT: 1501,\n    RESPONSE_TIMEOUT: 1502,\n    RECIPIENT_DISCONNECTED: 1503,\n    RESPONSE_PAYLOAD_TOO_LARGE: 1504,\n    SEND_FAILED: 1505,\n    UNSUPPORTED_METHOD: 1400,\n    RECIPIENT_NOT_FOUND: 1401,\n    REQUEST_PAYLOAD_TOO_LARGE: 1402,\n    UNSUPPORTED_SERVER: 1403,\n    UNSUPPORTED_VERSION: 1404\n};\n/**\n * @internal\n */ RpcError.ErrorMessage = {\n    APPLICATION_ERROR: \"Application error in method handler\",\n    CONNECTION_TIMEOUT: \"Connection timeout\",\n    RESPONSE_TIMEOUT: \"Response timeout\",\n    RECIPIENT_DISCONNECTED: \"Recipient disconnected\",\n    RESPONSE_PAYLOAD_TOO_LARGE: \"Response payload too large\",\n    SEND_FAILED: \"Failed to send\",\n    UNSUPPORTED_METHOD: \"Method not supported at destination\",\n    RECIPIENT_NOT_FOUND: \"Recipient not found\",\n    REQUEST_PAYLOAD_TOO_LARGE: \"Request payload too large\",\n    UNSUPPORTED_SERVER: \"RPC not supported by server\",\n    UNSUPPORTED_VERSION: \"Unsupported RPC version\"\n};\n/*\n * Maximum payload size for RPC requests and responses. If a payload exceeds this size,\n * the RPC call will fail with a REQUEST_PAYLOAD_TOO_LARGE(1402) or RESPONSE_PAYLOAD_TOO_LARGE(1504) error.\n */ const MAX_PAYLOAD_BYTES = 15360; // 15 KB\n/**\n * @internal\n */ function byteLength(str) {\n    const encoder = new TextEncoder();\n    return encoder.encode(str).length;\n}\n/**\n * @internal\n */ function truncateBytes(str, maxBytes) {\n    if (byteLength(str) <= maxBytes) {\n        return str;\n    }\n    let low = 0;\n    let high = str.length;\n    const encoder = new TextEncoder();\n    while(low < high){\n        const mid = Math.floor((low + high + 1) / 2);\n        if (encoder.encode(str.slice(0, mid)).length <= maxBytes) {\n            low = mid;\n        } else {\n            high = mid - 1;\n        }\n    }\n    return str.slice(0, low);\n}\nconst monitorFrequency = 2000;\nfunction computeBitrate(currentStats, prevStats) {\n    if (!prevStats) {\n        return 0;\n    }\n    let bytesNow;\n    let bytesPrev;\n    if (\"bytesReceived\" in currentStats) {\n        bytesNow = currentStats.bytesReceived;\n        bytesPrev = prevStats.bytesReceived;\n    } else if (\"bytesSent\" in currentStats) {\n        bytesNow = currentStats.bytesSent;\n        bytesPrev = prevStats.bytesSent;\n    }\n    if (bytesNow === undefined || bytesPrev === undefined || currentStats.timestamp === undefined || prevStats.timestamp === undefined) {\n        return 0;\n    }\n    return (bytesNow - bytesPrev) * 8 * 1000 / (currentStats.timestamp - prevStats.timestamp);\n}\nconst defaultDimensionsTimeout = 1000;\nclass LocalTrack extends Track {\n    /** @internal */ get sender() {\n        return this._sender;\n    }\n    /** @internal */ set sender(sender) {\n        this._sender = sender;\n    }\n    get constraints() {\n        return this._constraints;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param kind\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, kind, constraints){\n        let userProvidedTrack = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, kind, loggerOptions);\n        this.manuallyStopped = false;\n        this._isUpstreamPaused = false;\n        this.handleTrackMuteEvent = ()=>this.debouncedTrackMuteHandler().catch(()=>this.log.debug(\"track mute bounce got cancelled by an unmute event\", this.logContext));\n        this.debouncedTrackMuteHandler = r(()=>__awaiter(this, void 0, void 0, function*() {\n                yield this.pauseUpstream();\n            }), 5000);\n        this.handleTrackUnmuteEvent = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.debouncedTrackMuteHandler.cancel(\"unmute\");\n                yield this.resumeUpstream();\n            });\n        this.handleEnded = ()=>{\n            if (this.isInBackground) {\n                this.reacquireTrack = true;\n            }\n            this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n            this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            this.emit(TrackEvent.Ended, this);\n        };\n        this.reacquireTrack = false;\n        this.providedByUser = userProvidedTrack;\n        this.muteLock = new _();\n        this.pauseUpstreamLock = new _();\n        this.processorLock = new _();\n        this.restartLock = new _();\n        this.setMediaStreamTrack(mediaTrack, true);\n        // added to satisfy TS compiler, constraints are synced with MediaStreamTrack\n        this._constraints = mediaTrack.getConstraints();\n        if (constraints) {\n            this._constraints = constraints;\n        }\n    }\n    get id() {\n        return this._mediaStreamTrack.id;\n    }\n    get dimensions() {\n        if (this.kind !== Track.Kind.Video) {\n            return undefined;\n        }\n        const { width, height } = this._mediaStreamTrack.getSettings();\n        if (width && height) {\n            return {\n                width,\n                height\n            };\n        }\n        return undefined;\n    }\n    get isUpstreamPaused() {\n        return this._isUpstreamPaused;\n    }\n    get isUserProvided() {\n        return this.providedByUser;\n    }\n    get mediaStreamTrack() {\n        var _a, _b;\n        return (_b = (_a = this.processor) === null || _a === void 0 ? void 0 : _a.processedTrack) !== null && _b !== void 0 ? _b : this._mediaStreamTrack;\n    }\n    get isLocal() {\n        return true;\n    }\n    /**\n   * @internal\n   * returns mediaStreamTrack settings of the capturing mediastreamtrack source - ignoring processors\n   */ getSourceTrackSettings() {\n        return this._mediaStreamTrack.getSettings();\n    }\n    setMediaStreamTrack(newTrack, force) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (newTrack === this._mediaStreamTrack && !force) {\n                return;\n            }\n            if (this._mediaStreamTrack) {\n                // detach\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this._mediaStreamTrack, el);\n                });\n                this.debouncedTrackMuteHandler.cancel(\"new-track\");\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n                this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n            }\n            this.mediaStream = new MediaStream([\n                newTrack\n            ]);\n            if (newTrack) {\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                // when underlying track emits mute, it indicates that the device is unable\n                // to produce media. In this case we'll need to signal with remote that\n                // the track is \"muted\"\n                // note this is different from LocalTrack.mute because we do not want to\n                // touch MediaStreamTrack.enabled\n                newTrack.addEventListener(\"mute\", this.handleTrackMuteEvent);\n                newTrack.addEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n                this._constraints = newTrack.getConstraints();\n            }\n            let processedTrack;\n            if (this.processor && newTrack) {\n                const unlock = yield this.processorLock.lock();\n                try {\n                    this.log.debug(\"restarting processor\", this.logContext);\n                    if (this.kind === \"unknown\") {\n                        throw TypeError(\"cannot set processor on track of unknown kind\");\n                    }\n                    if (this.processorElement) {\n                        attachToElement(newTrack, this.processorElement);\n                        // ensure the processorElement itself stays muted\n                        this.processorElement.muted = true;\n                    }\n                    yield this.processor.restart({\n                        track: newTrack,\n                        kind: this.kind,\n                        element: this.processorElement\n                    });\n                    processedTrack = this.processor.processedTrack;\n                } finally{\n                    unlock();\n                }\n            }\n            if (this.sender && ((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                yield this.sender.replaceTrack(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack);\n            }\n            // if `newTrack` is different from the existing track, stop the\n            // older track just before replacing it\n            if (!this.providedByUser && this._mediaStreamTrack !== newTrack) {\n                this._mediaStreamTrack.stop();\n            }\n            this._mediaStreamTrack = newTrack;\n            if (newTrack) {\n                // sync muted state with the enabled state of the newly provided track\n                this._mediaStreamTrack.enabled = !this.isMuted;\n                // when a valid track is replace, we'd want to start producing\n                yield this.resumeUpstream();\n                this.attachedElements.forEach((el)=>{\n                    attachToElement(processedTrack !== null && processedTrack !== void 0 ? processedTrack : newTrack, el);\n                });\n            }\n        });\n    }\n    waitForDimensions() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this = this;\n            let timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultDimensionsTimeout;\n            return function*() {\n                var _a;\n                if (_this.kind === Track.Kind.Audio) {\n                    throw new Error(\"cannot get dimensions for audio tracks\");\n                }\n                if (((_a = getBrowser()) === null || _a === void 0 ? void 0 : _a.os) === \"iOS\") {\n                    // browsers report wrong initial resolution on iOS.\n                    // when slightly delaying the call to .getSettings(), the correct resolution is being reported\n                    yield sleep(10);\n                }\n                const started = Date.now();\n                while(Date.now() - started < timeout){\n                    const dims = _this.dimensions;\n                    if (dims) {\n                        return dims;\n                    }\n                    yield sleep(50);\n                }\n                throw new TrackInvalidError(\"unable to get track dimensions after timeout\");\n            }();\n        });\n    }\n    setDeviceId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._constraints.deviceId === deviceId && this._mediaStreamTrack.getSettings().deviceId === unwrapConstraint(deviceId)) {\n                return true;\n            }\n            this._constraints.deviceId = deviceId;\n            // when track is muted, underlying media stream track is stopped and\n            // will be restarted later\n            if (this.isMuted) {\n                return true;\n            }\n            yield this.restartTrack();\n            return unwrapConstraint(deviceId) === this._mediaStreamTrack.getSettings().deviceId;\n        });\n    }\n    /**\n   * @returns DeviceID of the device that is currently being used for this track\n   */ getDeviceId() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this2 = this;\n            let normalize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                // screen share doesn't have a usable device id\n                if (_this2.source === Track.Source.ScreenShare) {\n                    return;\n                }\n                const { deviceId, groupId } = _this2._mediaStreamTrack.getSettings();\n                const kind = _this2.kind === Track.Kind.Audio ? \"audioinput\" : \"videoinput\";\n                return normalize ? DeviceManager.getInstance().normalizeDeviceId(kind, deviceId, groupId) : deviceId;\n            }();\n        });\n    }\n    mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(true);\n            return this;\n        });\n    }\n    unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.setTrackMuted(false);\n            return this;\n        });\n    }\n    replaceTrack(track, userProvidedOrOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.sender) {\n                throw new TrackInvalidError(\"unable to replace an unpublished track\");\n            }\n            let userProvidedTrack;\n            let stopProcessor;\n            if (typeof userProvidedOrOptions === \"boolean\") {\n                userProvidedTrack = userProvidedOrOptions;\n            } else if (userProvidedOrOptions !== undefined) {\n                userProvidedTrack = userProvidedOrOptions.userProvidedTrack;\n                stopProcessor = userProvidedOrOptions.stopProcessor;\n            }\n            this.providedByUser = userProvidedTrack !== null && userProvidedTrack !== void 0 ? userProvidedTrack : true;\n            this.log.debug(\"replace MediaStreamTrack\", this.logContext);\n            yield this.setMediaStreamTrack(track);\n            // this must be synced *after* setting mediaStreamTrack above, since it relies\n            // on the previous state in order to cleanup\n            if (stopProcessor && this.processor) {\n                yield this.stopProcessor();\n            }\n            return this;\n        });\n    }\n    restart(constraints) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.manuallyStopped = false;\n            const unlock = yield this.restartLock.lock();\n            try {\n                if (!constraints) {\n                    constraints = this._constraints;\n                }\n                const { deviceId, facingMode } = constraints, otherConstraints = __rest(constraints, [\n                    \"deviceId\",\n                    \"facingMode\"\n                ]);\n                this.log.debug(\"restarting track with constraints\", Object.assign(Object.assign({}, this.logContext), {\n                    constraints\n                }));\n                const streamConstraints = {\n                    audio: false,\n                    video: false\n                };\n                if (this.kind === Track.Kind.Video) {\n                    streamConstraints.video = deviceId || facingMode ? {\n                        deviceId,\n                        facingMode\n                    } : true;\n                } else {\n                    streamConstraints.audio = deviceId ? {\n                        deviceId\n                    } : true;\n                }\n                // these steps are duplicated from setMediaStreamTrack because we must stop\n                // the previous tracks before new tracks can be acquired\n                this.attachedElements.forEach((el)=>{\n                    detachTrack(this.mediaStreamTrack, el);\n                });\n                this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n                // on Safari, the old audio track must be stopped before attempting to acquire\n                // the new track, otherwise the new track will stop with\n                // 'A MediaStreamTrack ended due to a capture failure`\n                this._mediaStreamTrack.stop();\n                // create new track and attach\n                const mediaStream = yield navigator.mediaDevices.getUserMedia(streamConstraints);\n                const newTrack = mediaStream.getTracks()[0];\n                yield newTrack.applyConstraints(otherConstraints);\n                newTrack.addEventListener(\"ended\", this.handleEnded);\n                this.log.debug(\"re-acquired MediaStreamTrack\", this.logContext);\n                yield this.setMediaStreamTrack(newTrack);\n                this._constraints = constraints;\n                this.emit(TrackEvent.Restarted, this);\n                if (this.manuallyStopped) {\n                    this.log.warn(\"track was stopped during a restart, stopping restarted track\", this.logContext);\n                    this.stop();\n                }\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        this.log.debug(\"setting \".concat(this.kind, \" track \").concat(muted ? \"muted\" : \"unmuted\"), this.logContext);\n        if (this.isMuted === muted && this._mediaStreamTrack.enabled !== muted) {\n            return;\n        }\n        this.isMuted = muted;\n        this._mediaStreamTrack.enabled = !muted;\n        this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n    }\n    get needsReAcquisition() {\n        return this._mediaStreamTrack.readyState !== \"live\" || this._mediaStreamTrack.muted || !this._mediaStreamTrack.enabled || this.reacquireTrack;\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            this.log.debug(\"visibility changed, is in Background: \".concat(this.isInBackground), this.logContext);\n            if (!this.isInBackground && this.needsReAcquisition && !this.isUserProvided && !this.isMuted) {\n                this.log.debug(\"track needs to be reacquired, restarting \".concat(this.source), this.logContext);\n                yield this.restart();\n                this.reacquireTrack = false;\n            }\n        });\n    }\n    stop() {\n        var _a;\n        this.manuallyStopped = true;\n        super.stop();\n        this._mediaStreamTrack.removeEventListener(\"ended\", this.handleEnded);\n        this._mediaStreamTrack.removeEventListener(\"mute\", this.handleTrackMuteEvent);\n        this._mediaStreamTrack.removeEventListener(\"unmute\", this.handleTrackUnmuteEvent);\n        (_a = this.processor) === null || _a === void 0 ? void 0 : _a.destroy();\n        this.processor = undefined;\n    }\n    /**\n   * pauses publishing to the server without disabling the local MediaStreamTrack\n   * this is used to display a user's own video locally while pausing publishing to\n   * the server.\n   * this API is unsupported on Safari < 12 due to a bug\n   **/ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === true) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to pause upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = true;\n                this.emit(TrackEvent.UpstreamPaused, this);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Safari\" && compareVersions(browser.version, \"12.0\") < 0) {\n                    // https://bugs.webkit.org/show_bug.cgi?id=184911\n                    throw new DeviceUnsupportedError(\"pauseUpstream is not supported on Safari < 12.\");\n                }\n                if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                    yield this.sender.replaceTrack(null);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.pauseUpstreamLock.lock();\n            try {\n                if (this._isUpstreamPaused === false) {\n                    return;\n                }\n                if (!this.sender) {\n                    this.log.warn(\"unable to resume upstream for an unpublished track\", this.logContext);\n                    return;\n                }\n                this._isUpstreamPaused = false;\n                this.emit(TrackEvent.UpstreamResumed, this);\n                if (((_a = this.sender.transport) === null || _a === void 0 ? void 0 : _a.state) !== \"closed\") {\n                    // this operation is noop if mediastreamtrack is already being sent\n                    yield this.sender.replaceTrack(this.mediaStreamTrack);\n                }\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * Gets the RTCStatsReport for the LocalTrack's underlying RTCRtpSender\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.sender.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Sets a processor on this track.\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   *\n   * @param processor\n   * @param showProcessedStreamLocally\n   * @returns\n   */ setProcessor(processor_1) {\n        return __awaiter(this, arguments, void 0, function(processor) {\n            var _this3 = this;\n            let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a;\n                const unlock = yield _this3.processorLock.lock();\n                try {\n                    _this3.log.debug(\"setting up processor\", _this3.logContext);\n                    const processorElement = document.createElement(_this3.kind);\n                    const processorOptions = {\n                        kind: _this3.kind,\n                        track: _this3._mediaStreamTrack,\n                        element: processorElement,\n                        audioContext: _this3.audioContext\n                    };\n                    yield processor.init(processorOptions);\n                    _this3.log.debug(\"processor initialized\", _this3.logContext);\n                    if (_this3.processor) {\n                        yield _this3.stopProcessor();\n                    }\n                    if (_this3.kind === \"unknown\") {\n                        throw TypeError(\"cannot set processor on track of unknown kind\");\n                    }\n                    attachToElement(_this3._mediaStreamTrack, processorElement);\n                    processorElement.muted = true;\n                    processorElement.play().catch((error)=>_this3.log.error(\"failed to play processor element\", Object.assign(Object.assign({}, _this3.logContext), {\n                            error\n                        })));\n                    _this3.processor = processor;\n                    _this3.processorElement = processorElement;\n                    if (_this3.processor.processedTrack) {\n                        for (const el of _this3.attachedElements){\n                            if (el !== _this3.processorElement && showProcessedStreamLocally) {\n                                detachTrack(_this3._mediaStreamTrack, el);\n                                attachToElement(_this3.processor.processedTrack, el);\n                            }\n                        }\n                        yield (_a = _this3.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(_this3.processor.processedTrack);\n                    }\n                    _this3.emit(TrackEvent.TrackProcessorUpdate, _this3.processor);\n                } finally{\n                    unlock();\n                }\n            }();\n        });\n    }\n    getProcessor() {\n        return this.processor;\n    }\n    /**\n   * Stops the track processor\n   * See https://github.com/livekit/track-processors-js for example usage\n   *\n   * @experimental\n   * @returns\n   */ stopProcessor() {\n        return __awaiter(this, arguments, void 0, function() {\n            var _this4 = this;\n            let keepElement = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n            return function*() {\n                var _a, _b;\n                if (!_this4.processor) return;\n                _this4.log.debug(\"stopping processor\", _this4.logContext);\n                (_a = _this4.processor.processedTrack) === null || _a === void 0 ? void 0 : _a.stop();\n                yield _this4.processor.destroy();\n                _this4.processor = undefined;\n                if (!keepElement) {\n                    (_b = _this4.processorElement) === null || _b === void 0 ? void 0 : _b.remove();\n                    _this4.processorElement = undefined;\n                }\n                // apply original track constraints in case the processor changed them\n                yield _this4._mediaStreamTrack.applyConstraints(_this4._constraints);\n                // force re-setting of the mediaStreamTrack on the sender\n                yield _this4.setMediaStreamTrack(_this4._mediaStreamTrack, true);\n                _this4.emit(TrackEvent.TrackProcessorUpdate);\n            }();\n        });\n    }\n}\nclass LocalAudioTrack extends LocalTrack {\n    /**\n   * boolean indicating whether enhanced noise cancellation is currently being used on this track\n   */ get enhancedNoiseCancellation() {\n        return this.isKrispNoiseFilterEnabled;\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let audioContext = arguments.length > 3 ? arguments[3] : undefined;\n        let loggerOptions = arguments.length > 4 ? arguments[4] : undefined;\n        super(mediaTrack, Track.Kind.Audio, constraints, userProvidedTrack, loggerOptions);\n        /** @internal */ this.stopOnMute = false;\n        this.isKrispNoiseFilterEnabled = false;\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                if (stats && this.prevStats) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.handleKrispNoiseFilterEnable = ()=>{\n            this.isKrispNoiseFilterEnabled = true;\n            this.log.debug(\"Krisp noise filter enabled\", this.logContext);\n            this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, true);\n        };\n        this.handleKrispNoiseFilterDisable = ()=>{\n            this.isKrispNoiseFilterEnabled = false;\n            this.log.debug(\"Krisp noise filter disabled\", this.logContext);\n            this.emit(TrackEvent.AudioTrackFeatureUpdate, this, AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION, false);\n        };\n        this.audioContext = audioContext;\n        this.checkForSilence();\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.isMuted) {\n                    this.log.debug(\"Track already muted\", this.logContext);\n                    return this;\n                }\n                // disabled special handling as it will cause BT headsets to switch communication modes\n                if (this.source === Track.Source.Microphone && this.stopOnMute && !this.isUserProvided) {\n                    this.log.debug(\"stopping mic track\", this.logContext);\n                    // also stop the track, so that microphone indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (!this.isMuted) {\n                    this.log.debug(\"Track already unmuted\", this.logContext);\n                    return this;\n                }\n                const deviceHasChanged = this._constraints.deviceId && this._mediaStreamTrack.getSettings().deviceId !== unwrapConstraint(this._constraints.deviceId);\n                if (this.source === Track.Source.Microphone && (this.stopOnMute || this._mediaStreamTrack.readyState === \"ended\" || deviceHasChanged) && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring mic track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    audio: options\n                });\n                if (typeof streamConstraints.audio !== \"boolean\") {\n                    constraints = streamConstraints.audio;\n                }\n            }\n            yield this.restart(constraints);\n        });\n    }\n    restart(constraints) {\n        const _super = Object.create(null, {\n            restart: {\n                get: ()=>super.restart\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const track = yield _super.restart.call(this, constraints);\n            this.checkForSilence();\n            return track;\n        });\n    }\n    /* @internal */ startMonitor() {\n        if (!isWeb()) {\n            return;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    setProcessor(processor) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const unlock = yield this.processorLock.lock();\n            try {\n                if (!isReactNative() && !this.audioContext) {\n                    throw Error(\"Audio context needs to be set on LocalAudioTrack in order to enable processors\");\n                }\n                if (this.processor) {\n                    yield this.stopProcessor();\n                }\n                const processorOptions = {\n                    kind: this.kind,\n                    track: this._mediaStreamTrack,\n                    // RN won't have or use AudioContext\n                    audioContext: this.audioContext\n                };\n                this.log.debug(\"setting up audio processor \".concat(processor.name), this.logContext);\n                yield processor.init(processorOptions);\n                this.processor = processor;\n                if (this.processor.processedTrack) {\n                    yield (_a = this.sender) === null || _a === void 0 ? void 0 : _a.replaceTrack(this.processor.processedTrack);\n                    this.processor.processedTrack.addEventListener(\"enable-lk-krisp-noise-filter\", this.handleKrispNoiseFilterEnable);\n                    this.processor.processedTrack.addEventListener(\"disable-lk-krisp-noise-filter\", this.handleKrispNoiseFilterDisable);\n                }\n                this.emit(TrackEvent.TrackProcessorUpdate, this.processor);\n            } finally{\n                unlock();\n            }\n        });\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n    }\n    getSenderStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return undefined;\n            }\n            const stats = yield this.sender.getStats();\n            let audioStats;\n            stats.forEach((v)=>{\n                if (v.type === \"outbound-rtp\") {\n                    audioStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        packetsSent: v.packetsSent,\n                        packetsLost: v.packetsLost,\n                        bytesSent: v.bytesSent,\n                        timestamp: v.timestamp,\n                        roundTripTime: v.roundTripTime,\n                        jitter: v.jitter\n                    };\n                }\n            });\n            return audioStats;\n        });\n    }\n    checkForSilence() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const trackIsSilent = yield detectSilence(this);\n            if (trackIsSilent) {\n                if (!this.isMuted) {\n                    this.log.warn(\"silence detected on local audio track\", this.logContext);\n                }\n                this.emit(TrackEvent.AudioSilenceDetected);\n            }\n            return trackIsSilent;\n        });\n    }\n}\n/** @internal */ function mediaTrackToLocalTrack(mediaStreamTrack, constraints, loggerOptions) {\n    switch(mediaStreamTrack.kind){\n        case \"audio\":\n            return new LocalAudioTrack(mediaStreamTrack, constraints, false, undefined, loggerOptions);\n        case \"video\":\n            return new LocalVideoTrack(mediaStreamTrack, constraints, false, loggerOptions);\n        default:\n            throw new TrackInvalidError(\"unsupported track type: \".concat(mediaStreamTrack.kind));\n    }\n}\n/* @internal */ const presets169 = Object.values(VideoPresets);\n/* @internal */ const presets43 = Object.values(VideoPresets43);\n/* @internal */ const presetsScreenShare = Object.values(ScreenSharePresets);\n/* @internal */ const defaultSimulcastPresets169 = [\n    VideoPresets.h180,\n    VideoPresets.h360\n];\n/* @internal */ const defaultSimulcastPresets43 = [\n    VideoPresets43.h180,\n    VideoPresets43.h360\n];\n/* @internal */ const computeDefaultScreenShareSimulcastPresets = (fromPreset)=>{\n    const layers = [\n        {\n            scaleResolutionDownBy: 2,\n            fps: fromPreset.encoding.maxFramerate\n        }\n    ];\n    return layers.map((t)=>{\n        var _a, _b;\n        return new VideoPreset(Math.floor(fromPreset.width / t.scaleResolutionDownBy), Math.floor(fromPreset.height / t.scaleResolutionDownBy), Math.max(150000, Math.floor(fromPreset.encoding.maxBitrate / (Math.pow(t.scaleResolutionDownBy, 2) * (((_a = fromPreset.encoding.maxFramerate) !== null && _a !== void 0 ? _a : 30) / ((_b = t.fps) !== null && _b !== void 0 ? _b : 30))))), t.fps, fromPreset.encoding.priority);\n    });\n};\n// /**\n//  *\n//  * @internal\n//  * @experimental\n//  */\n// const computeDefaultMultiCodecSimulcastEncodings = (width: number, height: number) => {\n//   // use vp8 as a default\n//   const vp8 = determineAppropriateEncoding(false, width, height);\n//   const vp9 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.9 };\n//   const h264 = { ...vp8, maxBitrate: vp8.maxBitrate * 1.1 };\n//   const av1 = { ...vp8, maxBitrate: vp8.maxBitrate * 0.7 };\n//   return {\n//     vp8,\n//     vp9,\n//     h264,\n//     av1,\n//   };\n// };\nconst videoRids = [\n    \"q\",\n    \"h\",\n    \"f\"\n];\n/* @internal */ function computeVideoEncodings(isScreenShare, width, height, options) {\n    var _a, _b;\n    let videoEncoding = options === null || options === void 0 ? void 0 : options.videoEncoding;\n    if (isScreenShare) {\n        videoEncoding = options === null || options === void 0 ? void 0 : options.screenShareEncoding;\n    }\n    const useSimulcast = options === null || options === void 0 ? void 0 : options.simulcast;\n    const scalabilityMode = options === null || options === void 0 ? void 0 : options.scalabilityMode;\n    const videoCodec = options === null || options === void 0 ? void 0 : options.videoCodec;\n    if (!videoEncoding && !useSimulcast && !scalabilityMode || !width || !height) {\n        // when we aren't simulcasting or svc, will need to return a single encoding without\n        // capping bandwidth. we always require a encoding for dynacast\n        return [\n            {}\n        ];\n    }\n    if (!videoEncoding) {\n        // find the right encoding based on width/height\n        videoEncoding = determineAppropriateEncoding(isScreenShare, width, height, videoCodec);\n        livekitLogger.debug(\"using video encoding\", videoEncoding);\n    }\n    const sourceFramerate = videoEncoding.maxFramerate;\n    const original = new VideoPreset(width, height, videoEncoding.maxBitrate, videoEncoding.maxFramerate, videoEncoding.priority);\n    if (scalabilityMode && isSVCCodec(videoCodec)) {\n        const sm = new ScalabilityMode(scalabilityMode);\n        const encodings = [];\n        if (sm.spatial > 3) {\n            throw new Error(\"unsupported scalabilityMode: \".concat(scalabilityMode));\n        }\n        // Before M113 in Chrome, defining multiple encodings with an SVC codec indicated\n        // that SVC mode should be used. Safari still works this way.\n        // This is a bit confusing but is due to how libwebrtc interpreted the encodings field\n        // before M113.\n        // Announced here: https://groups.google.com/g/discuss-webrtc/c/-QQ3pxrl-fw?pli=1\n        const browser = getBrowser();\n        if (isSafari() || // Even tho RN runs M114, it does not produce SVC layers when a single encoding\n        // is provided. So we'll use the legacy SVC specification for now.\n        // TODO: when we upstream libwebrtc, this will need additional verification\n        isReactNative() || (browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, \"113\") < 0) {\n            const bitratesRatio = sm.suffix == \"h\" ? 2 : 3;\n            for(let i = 0; i < sm.spatial; i += 1){\n                // in legacy SVC, scaleResolutionDownBy cannot be set\n                encodings.push({\n                    rid: videoRids[2 - i],\n                    maxBitrate: videoEncoding.maxBitrate / Math.pow(bitratesRatio, i),\n                    maxFramerate: original.encoding.maxFramerate\n                });\n            }\n            // legacy SVC, scalabilityMode is set only on the first encoding\n            /* @ts-ignore */ encodings[0].scalabilityMode = scalabilityMode;\n        } else {\n            encodings.push({\n                maxBitrate: videoEncoding.maxBitrate,\n                maxFramerate: original.encoding.maxFramerate,\n                /* @ts-ignore */ scalabilityMode: scalabilityMode\n            });\n        }\n        if (original.encoding.priority) {\n            encodings[0].priority = original.encoding.priority;\n            encodings[0].networkPriority = original.encoding.priority;\n        }\n        livekitLogger.debug(\"using svc encoding\", {\n            encodings\n        });\n        return encodings;\n    }\n    if (!useSimulcast) {\n        return [\n            videoEncoding\n        ];\n    }\n    let presets = [];\n    if (isScreenShare) {\n        presets = (_a = sortPresets(options === null || options === void 0 ? void 0 : options.screenShareSimulcastLayers)) !== null && _a !== void 0 ? _a : defaultSimulcastLayers(isScreenShare, original);\n    } else {\n        presets = (_b = sortPresets(options === null || options === void 0 ? void 0 : options.videoSimulcastLayers)) !== null && _b !== void 0 ? _b : defaultSimulcastLayers(isScreenShare, original);\n    }\n    let midPreset;\n    if (presets.length > 0) {\n        const lowPreset = presets[0];\n        if (presets.length > 1) {\n            [, midPreset] = presets;\n        }\n        // NOTE:\n        //   1. Ordering of these encodings is important. Chrome seems\n        //      to use the index into encodings to decide which layer\n        //      to disable when CPU constrained.\n        //      So encodings should be ordered in increasing spatial\n        //      resolution order.\n        //   2. livekit-server translates rids into layers. So, all encodings\n        //      should have the base layer `q` and then more added\n        //      based on other conditions.\n        const size = Math.max(width, height);\n        if (size >= 960 && midPreset) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                midPreset,\n                original\n            ], sourceFramerate);\n        }\n        if (size >= 480) {\n            return encodingsFromPresets(width, height, [\n                lowPreset,\n                original\n            ], sourceFramerate);\n        }\n    }\n    return encodingsFromPresets(width, height, [\n        original\n    ]);\n}\nfunction computeTrackBackupEncodings(track, videoCodec, opts) {\n    var _a, _b, _c, _d;\n    // backupCodec should not be true anymore, default codec is set in LocalParticipant.publish\n    if (!opts.backupCodec || opts.backupCodec === true || opts.backupCodec.codec === opts.videoCodec) {\n        // backup codec publishing is disabled\n        return;\n    }\n    if (videoCodec !== opts.backupCodec.codec) {\n        livekitLogger.warn(\"requested a different codec than specified as backup\", {\n            serverRequested: videoCodec,\n            backup: opts.backupCodec.codec\n        });\n    }\n    opts.videoCodec = videoCodec;\n    // use backup encoding setting as videoEncoding for backup codec publishing\n    opts.videoEncoding = opts.backupCodec.encoding;\n    const settings = track.mediaStreamTrack.getSettings();\n    const width = (_a = settings.width) !== null && _a !== void 0 ? _a : (_b = track.dimensions) === null || _b === void 0 ? void 0 : _b.width;\n    const height = (_c = settings.height) !== null && _c !== void 0 ? _c : (_d = track.dimensions) === null || _d === void 0 ? void 0 : _d.height;\n    // disable simulcast for screenshare backup codec since L1Tx is used by primary codec\n    if (track.source === Track.Source.ScreenShare && opts.simulcast) {\n        opts.simulcast = false;\n    }\n    const encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, width, height, opts);\n    return encodings;\n}\n/* @internal */ function determineAppropriateEncoding(isScreenShare, width, height, codec) {\n    const presets = presetsForResolution(isScreenShare, width, height);\n    let { encoding } = presets[0];\n    // handle portrait by swapping dimensions\n    const size = Math.max(width, height);\n    for(let i = 0; i < presets.length; i += 1){\n        const preset = presets[i];\n        encoding = preset.encoding;\n        if (preset.width >= size) {\n            break;\n        }\n    }\n    // presets are based on the assumption of vp8 as a codec\n    // for other codecs we adjust the maxBitrate if no specific videoEncoding has been provided\n    // users should override these with ones that are optimized for their use case\n    // NOTE: SVC codec bitrates are inclusive of all scalability layers. while\n    // bitrate for non-SVC codecs does not include other simulcast layers.\n    if (codec) {\n        switch(codec){\n            case \"av1\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.7;\n                break;\n            case \"vp9\":\n                encoding = Object.assign({}, encoding);\n                encoding.maxBitrate = encoding.maxBitrate * 0.85;\n                break;\n        }\n    }\n    return encoding;\n}\n/* @internal */ function presetsForResolution(isScreenShare, width, height) {\n    if (isScreenShare) {\n        return presetsScreenShare;\n    }\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return presets169;\n    }\n    return presets43;\n}\n/* @internal */ function defaultSimulcastLayers(isScreenShare, original) {\n    if (isScreenShare) {\n        return computeDefaultScreenShareSimulcastPresets(original);\n    }\n    const { width, height } = original;\n    const aspect = width > height ? width / height : height / width;\n    if (Math.abs(aspect - 16.0 / 9) < Math.abs(aspect - 4.0 / 3)) {\n        return defaultSimulcastPresets169;\n    }\n    return defaultSimulcastPresets43;\n}\n// presets should be ordered by low, medium, high\nfunction encodingsFromPresets(width, height, presets, sourceFramerate) {\n    const encodings = [];\n    presets.forEach((preset, idx)=>{\n        if (idx >= videoRids.length) {\n            return;\n        }\n        const size = Math.min(width, height);\n        const rid = videoRids[idx];\n        const encoding = {\n            rid,\n            scaleResolutionDownBy: Math.max(1, size / Math.min(preset.width, preset.height)),\n            maxBitrate: preset.encoding.maxBitrate\n        };\n        // ensure that the sourceFramerate is the highest framerate applied across all layers so that the\n        // original encoding doesn't get bumped unintentionally by any of the other layers\n        const maxFramerate = sourceFramerate && preset.encoding.maxFramerate ? Math.min(sourceFramerate, preset.encoding.maxFramerate) : preset.encoding.maxFramerate;\n        if (maxFramerate) {\n            encoding.maxFramerate = maxFramerate;\n        }\n        const canSetPriority = isFireFox() || idx === 0;\n        if (preset.encoding.priority && canSetPriority) {\n            encoding.priority = preset.encoding.priority;\n            encoding.networkPriority = preset.encoding.priority;\n        }\n        encodings.push(encoding);\n    });\n    // RN ios simulcast requires all same framerates.\n    if (isReactNative() && getReactNativeOs() === \"ios\") {\n        let topFramerate = undefined;\n        encodings.forEach((encoding)=>{\n            if (!topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            } else if (encoding.maxFramerate && encoding.maxFramerate > topFramerate) {\n                topFramerate = encoding.maxFramerate;\n            }\n        });\n        let notifyOnce = true;\n        encodings.forEach((encoding)=>{\n            var _a;\n            if (encoding.maxFramerate != topFramerate) {\n                if (notifyOnce) {\n                    notifyOnce = false;\n                    livekitLogger.info(\"Simulcast on iOS React-Native requires all encodings to share the same framerate.\");\n                }\n                livekitLogger.info('Setting framerate of encoding \"'.concat((_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\", '\" to ').concat(topFramerate));\n                encoding.maxFramerate = topFramerate;\n            }\n        });\n    }\n    return encodings;\n}\n/** @internal */ function sortPresets(presets) {\n    if (!presets) return;\n    return presets.sort((a, b)=>{\n        const { encoding: aEnc } = a;\n        const { encoding: bEnc } = b;\n        if (aEnc.maxBitrate > bEnc.maxBitrate) {\n            return 1;\n        }\n        if (aEnc.maxBitrate < bEnc.maxBitrate) return -1;\n        if (aEnc.maxBitrate === bEnc.maxBitrate && aEnc.maxFramerate && bEnc.maxFramerate) {\n            return aEnc.maxFramerate > bEnc.maxFramerate ? 1 : -1;\n        }\n        return 0;\n    });\n}\n/** @internal */ class ScalabilityMode {\n    constructor(scalabilityMode){\n        const results = scalabilityMode.match(/^L(\\d)T(\\d)(h|_KEY|_KEY_SHIFT){0,1}$/);\n        if (!results) {\n            throw new Error(\"invalid scalability mode\");\n        }\n        this.spatial = parseInt(results[1]);\n        this.temporal = parseInt(results[2]);\n        if (results.length > 3) {\n            switch(results[3]){\n                case \"h\":\n                case \"_KEY\":\n                case \"_KEY_SHIFT\":\n                    this.suffix = results[3];\n            }\n        }\n    }\n    toString() {\n        var _a;\n        return \"L\".concat(this.spatial, \"T\").concat(this.temporal).concat((_a = this.suffix) !== null && _a !== void 0 ? _a : \"\");\n    }\n}\nfunction getDefaultDegradationPreference(track) {\n    // a few of reasons we have different default paths:\n    // 1. without this, Chrome seems to aggressively resize the SVC video stating `quality-limitation: bandwidth` even when BW isn't an issue\n    // 2. since we are overriding contentHint to motion (to workaround L1T3 publishing), it overrides the default degradationPreference to `balanced`\n    if (track.source === Track.Source.ScreenShare || track.constraints.height && unwrapConstraint(track.constraints.height) >= 1080) {\n        return \"maintain-resolution\";\n    } else {\n        return \"balanced\";\n    }\n}\nconst refreshSubscribedCodecAfterNewCodec = 5000;\nclass LocalVideoTrack extends LocalTrack {\n    get sender() {\n        return this._sender;\n    }\n    set sender(sender) {\n        this._sender = sender;\n        if (this.degradationPreference) {\n            this.setDegradationPreference(this.degradationPreference);\n        }\n    }\n    /**\n   *\n   * @param mediaTrack\n   * @param constraints MediaTrackConstraints that are being used when restarting or reacquiring tracks\n   * @param userProvidedTrack Signals to the SDK whether or not the mediaTrack should be managed (i.e. released and reacquired) internally by the SDK\n   */ constructor(mediaTrack, constraints){\n        let userProvidedTrack = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n        let loggerOptions = arguments.length > 3 ? arguments[3] : undefined;\n        super(mediaTrack, Track.Kind.Video, constraints, userProvidedTrack, loggerOptions);\n        /* @internal */ this.simulcastCodecs = new Map();\n        this.degradationPreference = \"balanced\";\n        this.monitorSender = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.sender) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                let stats;\n                try {\n                    stats = yield this.getSenderStats();\n                } catch (e) {\n                    this.log.error(\"could not get audio sender stats\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    return;\n                }\n                const statsMap = new Map(stats.map((s)=>[\n                        s.rid,\n                        s\n                    ]));\n                if (this.prevStats) {\n                    let totalBitrate = 0;\n                    statsMap.forEach((s, key)=>{\n                        var _a;\n                        const prev = (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.get(key);\n                        totalBitrate += computeBitrate(s, prev);\n                    });\n                    this._currentBitrate = totalBitrate;\n                }\n                this.prevStats = statsMap;\n            });\n        this.senderLock = new _();\n    }\n    get isSimulcast() {\n        if (this.sender && this.sender.getParameters().encodings.length > 1) {\n            return true;\n        }\n        return false;\n    }\n    /* @internal */ startMonitor(signalClient) {\n        var _a;\n        this.signalClient = signalClient;\n        if (!isWeb()) {\n            return;\n        }\n        // save original encodings\n        // TODO : merge simulcast tracks stats\n        const params = (_a = this.sender) === null || _a === void 0 ? void 0 : _a.getParameters();\n        if (params) {\n            this.encodings = params.encodings;\n        }\n        if (this.monitorInterval) {\n            return;\n        }\n        this.monitorInterval = setInterval(()=>{\n            this.monitorSender();\n        }, monitorFrequency);\n    }\n    stop() {\n        this._mediaStreamTrack.getConstraints();\n        this.simulcastCodecs.forEach((trackInfo)=>{\n            trackInfo.mediaStreamTrack.stop();\n        });\n        super.stop();\n    }\n    pauseUpstream() {\n        const _super = Object.create(null, {\n            pauseUpstream: {\n                get: ()=>super.pauseUpstream\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_1, _b, _c;\n            var _d;\n            yield _super.pauseUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(null);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n        });\n    }\n    resumeUpstream() {\n        const _super = Object.create(null, {\n            resumeUpstream: {\n                get: ()=>super.resumeUpstream\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_2, _b, _c;\n            var _d;\n            yield _super.resumeUpstream.call(this);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    yield (_d = sc.sender) === null || _d === void 0 ? void 0 : _d.replaceTrack(sc.mediaStreamTrack);\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n        });\n    }\n    mute() {\n        const _super = Object.create(null, {\n            mute: {\n                get: ()=>super.mute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (this.isMuted) {\n                    this.log.debug(\"Track already muted\", this.logContext);\n                    return this;\n                }\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"stopping camera track\", this.logContext);\n                    // also stop the track, so that camera indicator is turned off\n                    this._mediaStreamTrack.stop();\n                }\n                yield _super.mute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    unmute() {\n        const _super = Object.create(null, {\n            unmute: {\n                get: ()=>super.unmute\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.muteLock.lock();\n            try {\n                if (!this.isMuted) {\n                    this.log.debug(\"Track already unmuted\", this.logContext);\n                    return this;\n                }\n                if (this.source === Track.Source.Camera && !this.isUserProvided) {\n                    this.log.debug(\"reacquiring camera track\", this.logContext);\n                    yield this.restartTrack();\n                }\n                yield _super.unmute.call(this);\n                return this;\n            } finally{\n                unlock();\n            }\n        });\n    }\n    setTrackMuted(muted) {\n        super.setTrackMuted(muted);\n        for (const sc of this.simulcastCodecs.values()){\n            sc.mediaStreamTrack.enabled = !muted;\n        }\n    }\n    getSenderStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.sender) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return [];\n            }\n            const items = [];\n            const stats = yield this.sender.getStats();\n            stats.forEach((v)=>{\n                var _a;\n                if (v.type === \"outbound-rtp\") {\n                    const vs = {\n                        type: \"video\",\n                        streamId: v.id,\n                        frameHeight: v.frameHeight,\n                        frameWidth: v.frameWidth,\n                        framesPerSecond: v.framesPerSecond,\n                        framesSent: v.framesSent,\n                        firCount: v.firCount,\n                        pliCount: v.pliCount,\n                        nackCount: v.nackCount,\n                        packetsSent: v.packetsSent,\n                        bytesSent: v.bytesSent,\n                        qualityLimitationReason: v.qualityLimitationReason,\n                        qualityLimitationDurations: v.qualityLimitationDurations,\n                        qualityLimitationResolutionChanges: v.qualityLimitationResolutionChanges,\n                        rid: (_a = v.rid) !== null && _a !== void 0 ? _a : v.id,\n                        retransmittedPacketsSent: v.retransmittedPacketsSent,\n                        targetBitrate: v.targetBitrate,\n                        timestamp: v.timestamp\n                    };\n                    //locate the appropriate remote-inbound-rtp item\n                    const r = stats.get(v.remoteId);\n                    if (r) {\n                        vs.jitter = r.jitter;\n                        vs.packetsLost = r.packetsLost;\n                        vs.roundTripTime = r.roundTripTime;\n                    }\n                    items.push(vs);\n                }\n            });\n            // make sure highest res layer is always first\n            items.sort((a, b)=>{\n                var _a, _b;\n                return ((_a = b.frameWidth) !== null && _a !== void 0 ? _a : 0) - ((_b = a.frameWidth) !== null && _b !== void 0 ? _b : 0);\n            });\n            return items;\n        });\n    }\n    setPublishingQuality(maxQuality) {\n        const qualities = [];\n        for(let q = VideoQuality.LOW; q <= VideoQuality.HIGH; q += 1){\n            qualities.push(new SubscribedQuality({\n                quality: q,\n                enabled: q <= maxQuality\n            }));\n        }\n        this.log.debug(\"setting publishing quality. max quality \".concat(maxQuality), this.logContext);\n        this.setPublishingLayers(qualities);\n    }\n    restartTrack(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_3, _b, _c;\n            var _d;\n            let constraints;\n            if (options) {\n                const streamConstraints = constraintsForOptions({\n                    video: options\n                });\n                if (typeof streamConstraints.video !== \"boolean\") {\n                    constraints = streamConstraints.video;\n                }\n            }\n            yield this.restart(constraints);\n            try {\n                for(var _e = true, _f = __asyncValues(this.simulcastCodecs.values()), _g; _g = yield _f.next(), _a = _g.done, !_a; _e = true){\n                    _c = _g.value;\n                    _e = false;\n                    const sc = _c;\n                    if (sc.sender && ((_d = sc.sender.transport) === null || _d === void 0 ? void 0 : _d.state) !== \"closed\") {\n                        sc.mediaStreamTrack = this.mediaStreamTrack.clone();\n                        yield sc.sender.replaceTrack(sc.mediaStreamTrack);\n                    }\n                }\n            } catch (e_3_1) {\n                e_3 = {\n                    error: e_3_1\n                };\n            } finally{\n                try {\n                    if (!_e && !_a && (_b = _f.return)) yield _b.call(_f);\n                } finally{\n                    if (e_3) throw e_3.error;\n                }\n            }\n        });\n    }\n    setProcessor(processor_1) {\n        const _super = Object.create(null, {\n            setProcessor: {\n                get: ()=>super.setProcessor\n            }\n        });\n        return __awaiter(this, arguments, void 0, function(processor) {\n            var _this = this;\n            let showProcessedStreamLocally = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                var _a, e_4, _b, _c;\n                var _d, _e;\n                yield _super.setProcessor.call(_this, processor, showProcessedStreamLocally);\n                if ((_d = _this.processor) === null || _d === void 0 ? void 0 : _d.processedTrack) {\n                    try {\n                        for(var _f = true, _g = __asyncValues(_this.simulcastCodecs.values()), _h; _h = yield _g.next(), _a = _h.done, !_a; _f = true){\n                            _c = _h.value;\n                            _f = false;\n                            const sc = _c;\n                            yield (_e = sc.sender) === null || _e === void 0 ? void 0 : _e.replaceTrack(_this.processor.processedTrack);\n                        }\n                    } catch (e_4_1) {\n                        e_4 = {\n                            error: e_4_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = _g.return)) yield _b.call(_g);\n                        } finally{\n                            if (e_4) throw e_4.error;\n                        }\n                    }\n                }\n            }();\n        });\n    }\n    setDegradationPreference(preference) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.degradationPreference = preference;\n            if (this.sender) {\n                try {\n                    this.log.debug(\"setting degradationPreference to \".concat(preference), this.logContext);\n                    const params = this.sender.getParameters();\n                    params.degradationPreference = preference;\n                    this.sender.setParameters(params);\n                } catch (e) {\n                    this.log.warn(\"failed to set degradationPreference\", Object.assign({\n                        error: e\n                    }, this.logContext));\n                }\n            }\n        });\n    }\n    addSimulcastTrack(codec, encodings) {\n        if (this.simulcastCodecs.has(codec)) {\n            this.log.error(\"\".concat(codec, \" already added, skipping adding simulcast codec\"), this.logContext);\n            return;\n        }\n        const simulcastCodecInfo = {\n            codec,\n            mediaStreamTrack: this.mediaStreamTrack.clone(),\n            sender: undefined,\n            encodings\n        };\n        this.simulcastCodecs.set(codec, simulcastCodecInfo);\n        return simulcastCodecInfo;\n    }\n    setSimulcastTrackSender(codec, sender) {\n        const simulcastCodecInfo = this.simulcastCodecs.get(codec);\n        if (!simulcastCodecInfo) {\n            return;\n        }\n        simulcastCodecInfo.sender = sender;\n        // browser will reenable disabled codec/layers after new codec has been published,\n        // so refresh subscribedCodecs after publish a new codec\n        setTimeout(()=>{\n            if (this.subscribedCodecs) {\n                this.setPublishingCodecs(this.subscribedCodecs);\n            }\n        }, refreshSubscribedCodecAfterNewCodec);\n    }\n    /**\n   * @internal\n   * Sets codecs that should be publishing, returns new codecs that have not yet\n   * been published\n   */ setPublishingCodecs(codecs) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, codecs_1, codecs_1_1;\n            var _b, e_5, _c, _d;\n            this.log.debug(\"setting publishing codecs\", Object.assign(Object.assign({}, this.logContext), {\n                codecs,\n                currentCodec: this.codec\n            }));\n            // only enable simulcast codec for preference codec setted\n            if (!this.codec && codecs.length > 0) {\n                yield this.setPublishingLayers(codecs[0].qualities);\n                return [];\n            }\n            this.subscribedCodecs = codecs;\n            const newCodecs = [];\n            try {\n                for(_a = true, codecs_1 = __asyncValues(codecs); codecs_1_1 = yield codecs_1.next(), _b = codecs_1_1.done, !_b; _a = true){\n                    _d = codecs_1_1.value;\n                    _a = false;\n                    const codec = _d;\n                    if (!this.codec || this.codec === codec.codec) {\n                        yield this.setPublishingLayers(codec.qualities);\n                    } else {\n                        const simulcastCodecInfo = this.simulcastCodecs.get(codec.codec);\n                        this.log.debug(\"try setPublishingCodec for \".concat(codec.codec), Object.assign(Object.assign({}, this.logContext), {\n                            simulcastCodecInfo\n                        }));\n                        if (!simulcastCodecInfo || !simulcastCodecInfo.sender) {\n                            for (const q of codec.qualities){\n                                if (q.enabled) {\n                                    newCodecs.push(codec.codec);\n                                    break;\n                                }\n                            }\n                        } else if (simulcastCodecInfo.encodings) {\n                            this.log.debug(\"try setPublishingLayersForSender \".concat(codec.codec), this.logContext);\n                            yield setPublishingLayersForSender(simulcastCodecInfo.sender, simulcastCodecInfo.encodings, codec.qualities, this.senderLock, this.log, this.logContext);\n                        }\n                    }\n                }\n            } catch (e_5_1) {\n                e_5 = {\n                    error: e_5_1\n                };\n            } finally{\n                try {\n                    if (!_a && !_b && (_c = codecs_1.return)) yield _c.call(codecs_1);\n                } finally{\n                    if (e_5) throw e_5.error;\n                }\n            }\n            return newCodecs;\n        });\n    }\n    /**\n   * @internal\n   * Sets layers that should be publishing\n   */ setPublishingLayers(qualities) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.log.debug(\"setting publishing layers\", Object.assign(Object.assign({}, this.logContext), {\n                qualities\n            }));\n            if (!this.sender || !this.encodings) {\n                return;\n            }\n            yield setPublishingLayersForSender(this.sender, this.encodings, qualities, this.senderLock, this.log, this.logContext);\n        });\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!isMobile()) return;\n            if (this.isInBackground && this.source === Track.Source.Camera) {\n                this._mediaStreamTrack.enabled = false;\n            }\n        });\n    }\n}\nfunction setPublishingLayersForSender(sender, senderEncodings, qualities, senderLock, log, logContext) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const unlock = yield senderLock.lock();\n        log.debug(\"setPublishingLayersForSender\", Object.assign(Object.assign({}, logContext), {\n            sender,\n            qualities,\n            senderEncodings\n        }));\n        try {\n            const params = sender.getParameters();\n            const { encodings } = params;\n            if (!encodings) {\n                return;\n            }\n            if (encodings.length !== senderEncodings.length) {\n                log.warn(\"cannot set publishing layers, encodings mismatch\", Object.assign(Object.assign({}, logContext), {\n                    encodings,\n                    senderEncodings\n                }));\n                return;\n            }\n            let hasChanged = false;\n            const browser = getBrowser();\n            const closableSpatial = (browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && compareVersions(browser === null || browser === void 0 ? void 0 : browser.version, \"133\") > 0;\n            /* @ts-ignore */ if (closableSpatial && encodings[0].scalabilityMode) {\n                // svc dynacast encodings\n                const encoding = encodings[0];\n                /* @ts-ignore */ const mode = new ScalabilityMode(encoding.scalabilityMode);\n                let maxQuality = VideoQuality$1.OFF;\n                qualities.forEach((q)=>{\n                    if (q.enabled && (maxQuality === VideoQuality$1.OFF || q.quality > maxQuality)) {\n                        maxQuality = q.quality;\n                    }\n                });\n                if (maxQuality === VideoQuality$1.OFF) {\n                    if (encoding.active) {\n                        encoding.active = false;\n                        hasChanged = true;\n                    }\n                } else if (!encoding.active || mode.spatial !== maxQuality + 1) {\n                    hasChanged = true;\n                    encoding.active = true;\n                    /* @ts-ignore */ const originalMode = new ScalabilityMode(senderEncodings[0].scalabilityMode);\n                    mode.spatial = maxQuality + 1;\n                    mode.suffix = originalMode.suffix;\n                    if (mode.spatial === 1) {\n                        // no suffix for L1Tx\n                        mode.suffix = undefined;\n                    }\n                    /* @ts-ignore */ encoding.scalabilityMode = mode.toString();\n                    encoding.scaleResolutionDownBy = Math.pow(2, 2 - maxQuality);\n                    if (senderEncodings[0].maxBitrate) {\n                        encoding.maxBitrate = senderEncodings[0].maxBitrate / (encoding.scaleResolutionDownBy * encoding.scaleResolutionDownBy);\n                    }\n                }\n            } else {\n                // simulcast dynacast encodings\n                encodings.forEach((encoding, idx)=>{\n                    var _a;\n                    let rid = (_a = encoding.rid) !== null && _a !== void 0 ? _a : \"\";\n                    if (rid === \"\") {\n                        rid = \"q\";\n                    }\n                    const quality = videoQualityForRid(rid);\n                    const subscribedQuality = qualities.find((q)=>q.quality === quality);\n                    if (!subscribedQuality) {\n                        return;\n                    }\n                    if (encoding.active !== subscribedQuality.enabled) {\n                        hasChanged = true;\n                        encoding.active = subscribedQuality.enabled;\n                        log.debug(\"setting layer \".concat(subscribedQuality.quality, \" to \").concat(encoding.active ? \"enabled\" : \"disabled\"), logContext);\n                        // FireFox does not support setting encoding.active to false, so we\n                        // have a workaround of lowering its bitrate and resolution to the min.\n                        if (isFireFox()) {\n                            if (subscribedQuality.enabled) {\n                                encoding.scaleResolutionDownBy = senderEncodings[idx].scaleResolutionDownBy;\n                                encoding.maxBitrate = senderEncodings[idx].maxBitrate;\n                                /* @ts-ignore */ encoding.maxFrameRate = senderEncodings[idx].maxFrameRate;\n                            } else {\n                                encoding.scaleResolutionDownBy = 4;\n                                encoding.maxBitrate = 10;\n                                /* @ts-ignore */ encoding.maxFrameRate = 2;\n                            }\n                        }\n                    }\n                });\n            }\n            if (hasChanged) {\n                params.encodings = encodings;\n                log.debug(\"setting encodings\", Object.assign(Object.assign({}, logContext), {\n                    encodings: params.encodings\n                }));\n                yield sender.setParameters(params);\n            }\n        } finally{\n            unlock();\n        }\n    });\n}\nfunction videoQualityForRid(rid) {\n    switch(rid){\n        case \"f\":\n            return VideoQuality.HIGH;\n        case \"h\":\n            return VideoQuality.MEDIUM;\n        case \"q\":\n            return VideoQuality.LOW;\n        default:\n            return VideoQuality.HIGH;\n    }\n}\nfunction videoLayersFromEncodings(width, height, encodings, svc) {\n    // default to a single layer, HQ\n    if (!encodings) {\n        return [\n            new VideoLayer({\n                quality: VideoQuality.HIGH,\n                width,\n                height,\n                bitrate: 0,\n                ssrc: 0\n            })\n        ];\n    }\n    if (svc) {\n        // svc layers\n        /* @ts-ignore */ const encodingSM = encodings[0].scalabilityMode;\n        const sm = new ScalabilityMode(encodingSM);\n        const layers = [];\n        const resRatio = sm.suffix == \"h\" ? 1.5 : 2;\n        const bitratesRatio = sm.suffix == \"h\" ? 2 : 3;\n        for(let i = 0; i < sm.spatial; i += 1){\n            layers.push(new VideoLayer({\n                quality: Math.min(VideoQuality.HIGH, sm.spatial - 1) - i,\n                width: Math.ceil(width / Math.pow(resRatio, i)),\n                height: Math.ceil(height / Math.pow(resRatio, i)),\n                bitrate: encodings[0].maxBitrate ? Math.ceil(encodings[0].maxBitrate / Math.pow(bitratesRatio, i)) : 0,\n                ssrc: 0\n            }));\n        }\n        return layers;\n    }\n    return encodings.map((encoding)=>{\n        var _a, _b, _c;\n        const scale = (_a = encoding.scaleResolutionDownBy) !== null && _a !== void 0 ? _a : 1;\n        let quality = videoQualityForRid((_b = encoding.rid) !== null && _b !== void 0 ? _b : \"\");\n        return new VideoLayer({\n            quality,\n            width: Math.ceil(width / scale),\n            height: Math.ceil(height / scale),\n            bitrate: (_c = encoding.maxBitrate) !== null && _c !== void 0 ? _c : 0,\n            ssrc: 0\n        });\n    });\n}\nconst lossyDataChannel = \"_lossy\";\nconst reliableDataChannel = \"_reliable\";\nconst minReconnectWait = 2 * 1000;\nconst leaveReconnect = \"leave-reconnect\";\nvar PCState;\n(function(PCState) {\n    PCState[PCState[\"New\"] = 0] = \"New\";\n    PCState[PCState[\"Connected\"] = 1] = \"Connected\";\n    PCState[PCState[\"Disconnected\"] = 2] = \"Disconnected\";\n    PCState[PCState[\"Reconnecting\"] = 3] = \"Reconnecting\";\n    PCState[PCState[\"Closed\"] = 4] = \"Closed\";\n})(PCState || (PCState = {}));\n/** @internal */ class RTCEngine extends eventsExports.EventEmitter {\n    get isClosed() {\n        return this._isClosed;\n    }\n    get pendingReconnect() {\n        return !!this.reconnectTimeout;\n    }\n    constructor(options){\n        var _a;\n        super();\n        this.options = options;\n        this.rtcConfig = {};\n        this.peerConnectionTimeout = roomConnectOptionDefaults.peerConnectionTimeout;\n        this.fullReconnectOnNext = false;\n        this.subscriberPrimary = false;\n        this.pcState = PCState.New;\n        this._isClosed = true;\n        this.pendingTrackResolvers = {};\n        this.reconnectAttempts = 0;\n        this.reconnectStart = 0;\n        this.attemptingReconnect = false;\n        /** keeps track of how often an initial join connection has been tried */ this.joinAttempts = 0;\n        /** specifies how often an initial join connection is allowed to retry */ this.maxJoinAttempts = 1;\n        this.shouldFailNext = false;\n        this.log = livekitLogger;\n        this.handleDataChannel = (_a)=>__awaiter(this, [\n                _a\n            ], void 0, function(_ref) {\n                var _this = this;\n                let { channel } = _ref;\n                return function*() {\n                    if (!channel) {\n                        return;\n                    }\n                    if (channel.label === reliableDataChannel) {\n                        _this.reliableDCSub = channel;\n                    } else if (channel.label === lossyDataChannel) {\n                        _this.lossyDCSub = channel;\n                    } else {\n                        return;\n                    }\n                    _this.log.debug(\"on data channel \".concat(channel.id, \", \").concat(channel.label), _this.logContext);\n                    channel.onmessage = _this.handleDataMessage;\n                }();\n            });\n        this.handleDataMessage = (message)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                // make sure to respect incoming data message order by processing message events one after the other\n                const unlock = yield this.dataProcessLock.lock();\n                try {\n                    // decode\n                    let buffer;\n                    if (message.data instanceof ArrayBuffer) {\n                        buffer = message.data;\n                    } else if (message.data instanceof Blob) {\n                        buffer = yield message.data.arrayBuffer();\n                    } else {\n                        this.log.error(\"unsupported data type\", Object.assign(Object.assign({}, this.logContext), {\n                            data: message.data\n                        }));\n                        return;\n                    }\n                    const dp = DataPacket.fromBinary(new Uint8Array(buffer));\n                    if (((_a = dp.value) === null || _a === void 0 ? void 0 : _a.case) === \"speaker\") {\n                        // dispatch speaker updates\n                        this.emit(EngineEvent.ActiveSpeakersUpdate, dp.value.value.speakers);\n                    } else {\n                        if (((_b = dp.value) === null || _b === void 0 ? void 0 : _b.case) === \"user\") {\n                            // compatibility\n                            applyUserDataCompat(dp, dp.value.value);\n                        }\n                        this.emit(EngineEvent.DataPacketReceived, dp);\n                    }\n                } finally{\n                    unlock();\n                }\n            });\n        this.handleDataError = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? \"lossy\" : \"reliable\";\n            if (event instanceof ErrorEvent && event.error) {\n                const { error } = event.error;\n                this.log.error(\"DataChannel error on \".concat(channelKind, \": \").concat(event.message), Object.assign(Object.assign({}, this.logContext), {\n                    error\n                }));\n            } else {\n                this.log.error(\"Unknown DataChannel error on \".concat(channelKind), Object.assign(Object.assign({}, this.logContext), {\n                    event\n                }));\n            }\n        };\n        this.handleBufferedAmountLow = (event)=>{\n            const channel = event.currentTarget;\n            const channelKind = channel.maxRetransmits === 0 ? DataPacket_Kind.LOSSY : DataPacket_Kind.RELIABLE;\n            this.updateAndEmitDCBufferStatus(channelKind);\n        };\n        // websocket reconnect behavior. if websocket is interrupted, and the PeerConnection\n        // continues to work, we can reconnect to websocket to continue the session\n        // after a number of retries, we'll close and give up permanently\n        this.handleDisconnect = (connection, disconnectReason)=>{\n            if (this._isClosed) {\n                return;\n            }\n            this.log.warn(\"\".concat(connection, \" disconnected\"), this.logContext);\n            if (this.reconnectAttempts === 0) {\n                // only reset start time on the first try\n                this.reconnectStart = Date.now();\n            }\n            const disconnect = (duration)=>{\n                this.log.warn(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(duration, \"ms. giving up\"), this.logContext);\n                this.emit(EngineEvent.Disconnected);\n                this.close();\n            };\n            const duration = Date.now() - this.reconnectStart;\n            let delay = this.getNextRetryDelay({\n                elapsedMs: duration,\n                retryCount: this.reconnectAttempts\n            });\n            if (delay === null) {\n                disconnect(duration);\n                return;\n            }\n            if (connection === leaveReconnect) {\n                delay = 0;\n            }\n            this.log.debug(\"reconnecting in \".concat(delay, \"ms\"), this.logContext);\n            this.clearReconnectTimeout();\n            if (this.token && this.regionUrlProvider) {\n                // token may have been refreshed, we do not want to recreate the regionUrlProvider\n                // since the current engine may have inherited a regional url\n                this.regionUrlProvider.updateToken(this.token);\n            }\n            this.reconnectTimeout = CriticalTimers.setTimeout(()=>this.attemptReconnect(disconnectReason).finally(()=>this.reconnectTimeout = undefined), delay);\n        };\n        this.waitForRestarted = ()=>{\n            return new Promise((resolve, reject)=>{\n                if (this.pcState === PCState.Connected) {\n                    resolve();\n                }\n                const onRestarted = ()=>{\n                    this.off(EngineEvent.Disconnected, onDisconnected);\n                    resolve();\n                };\n                const onDisconnected = ()=>{\n                    this.off(EngineEvent.Restarted, onRestarted);\n                    reject();\n                };\n                this.once(EngineEvent.Restarted, onRestarted);\n                this.once(EngineEvent.Disconnected, onDisconnected);\n            });\n        };\n        this.updateAndEmitDCBufferStatus = (kind)=>{\n            const status = this.isBufferStatusLow(kind);\n            if (typeof status !== \"undefined\" && status !== this.dcBufferStatus.get(kind)) {\n                this.dcBufferStatus.set(kind, status);\n                this.emit(EngineEvent.DCBufferStatusChanged, status, kind);\n            }\n        };\n        this.isBufferStatusLow = (kind)=>{\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                return dc.bufferedAmount <= dc.bufferedAmountLowThreshold;\n            }\n        };\n        this.handleBrowserOnLine = ()=>{\n            // in case the engine is currently reconnecting, attempt a reconnect immediately after the browser state has changed to 'onLine'\n            if (this.client.currentState === SignalConnectionState.RECONNECTING) {\n                this.clearReconnectTimeout();\n                this.attemptReconnect(ReconnectReason.RR_SIGNAL_DISCONNECTED);\n            }\n        };\n        this.log = getLogger((_a = options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Engine);\n        this.loggerOptions = {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.logContext\n        };\n        this.client = new SignalClient(undefined, this.loggerOptions);\n        this.client.signalLatency = this.options.expSignalLatency;\n        this.reconnectPolicy = this.options.reconnectPolicy;\n        this.registerOnLineListener();\n        this.closingLock = new _();\n        this.dataProcessLock = new _();\n        this.dcBufferStatus = new Map([\n            [\n                DataPacket_Kind.LOSSY,\n                true\n            ],\n            [\n                DataPacket_Kind.RELIABLE,\n                true\n            ]\n        ]);\n        this.client.onParticipantUpdate = (updates)=>this.emit(EngineEvent.ParticipantUpdate, updates);\n        this.client.onConnectionQuality = (update)=>this.emit(EngineEvent.ConnectionQualityUpdate, update);\n        this.client.onRoomUpdate = (update)=>this.emit(EngineEvent.RoomUpdate, update);\n        this.client.onSubscriptionError = (resp)=>this.emit(EngineEvent.SubscriptionError, resp);\n        this.client.onSubscriptionPermissionUpdate = (update)=>this.emit(EngineEvent.SubscriptionPermissionUpdate, update);\n        this.client.onSpeakersChanged = (update)=>this.emit(EngineEvent.SpeakersChanged, update);\n        this.client.onStreamStateUpdate = (update)=>this.emit(EngineEvent.StreamStateChanged, update);\n        this.client.onRequestResponse = (response)=>this.emit(EngineEvent.SignalRequestResponse, response);\n    }\n    /** @internal */ get logContext() {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        return {\n            room: (_b = (_a = this.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.room) === null || _b === void 0 ? void 0 : _b.name,\n            roomID: (_d = (_c = this.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.room) === null || _d === void 0 ? void 0 : _d.sid,\n            participant: (_f = (_e = this.latestJoinResponse) === null || _e === void 0 ? void 0 : _e.participant) === null || _f === void 0 ? void 0 : _f.identity,\n            pID: (_h = (_g = this.latestJoinResponse) === null || _g === void 0 ? void 0 : _g.participant) === null || _h === void 0 ? void 0 : _h.sid\n        };\n    }\n    join(url, token, opts, abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.url = url;\n            this.token = token;\n            this.signalOpts = opts;\n            this.maxJoinAttempts = opts.maxRetries;\n            try {\n                this.joinAttempts += 1;\n                this.setupSignalClientCallbacks();\n                const joinResponse = yield this.client.join(url, token, opts, abortSignal);\n                this._isClosed = false;\n                this.latestJoinResponse = joinResponse;\n                this.subscriberPrimary = joinResponse.subscriberPrimary;\n                if (!this.pcManager) {\n                    yield this.configure(joinResponse);\n                }\n                // create offer\n                if (!this.subscriberPrimary || joinResponse.fastPublish) {\n                    this.negotiate();\n                }\n                this.clientConfiguration = joinResponse.clientConfiguration;\n                // emit signal connected event after a short delay to allow for join response to be processed on room\n                setTimeout(()=>{\n                    this.emit(EngineEvent.SignalConnected);\n                }, 10);\n                return joinResponse;\n            } catch (e) {\n                if (e instanceof ConnectionError) {\n                    if (e.reason === ConnectionErrorReason.ServerUnreachable) {\n                        this.log.warn(\"Couldn't connect to server, attempt \".concat(this.joinAttempts, \" of \").concat(this.maxJoinAttempts), this.logContext);\n                        if (this.joinAttempts < this.maxJoinAttempts) {\n                            return this.join(url, token, opts, abortSignal);\n                        }\n                    }\n                }\n                throw e;\n            }\n        });\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const unlock = yield this.closingLock.lock();\n            if (this.isClosed) {\n                unlock();\n                return;\n            }\n            try {\n                this._isClosed = true;\n                this.joinAttempts = 0;\n                this.emit(EngineEvent.Closing);\n                this.removeAllListeners();\n                this.deregisterOnLineListener();\n                this.clearPendingReconnect();\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n            } finally{\n                unlock();\n            }\n        });\n    }\n    cleanupPeerConnections() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.close();\n            this.pcManager = undefined;\n            const dcCleanup = (dc)=>{\n                if (!dc) return;\n                dc.close();\n                dc.onbufferedamountlow = null;\n                dc.onclose = null;\n                dc.onclosing = null;\n                dc.onerror = null;\n                dc.onmessage = null;\n                dc.onopen = null;\n            };\n            dcCleanup(this.lossyDC);\n            dcCleanup(this.lossyDCSub);\n            dcCleanup(this.reliableDC);\n            dcCleanup(this.reliableDCSub);\n            this.lossyDC = undefined;\n            this.lossyDCSub = undefined;\n            this.reliableDC = undefined;\n            this.reliableDCSub = undefined;\n        });\n    }\n    cleanupClient() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.close();\n            this.client.resetCallbacks();\n        });\n    }\n    addTrack(req) {\n        if (this.pendingTrackResolvers[req.cid]) {\n            throw new TrackInvalidError(\"a track with the same ID has already been published\");\n        }\n        return new Promise((resolve, reject)=>{\n            const publicationTimeout = setTimeout(()=>{\n                delete this.pendingTrackResolvers[req.cid];\n                reject(new ConnectionError(\"publication of local track timed out, no response from server\", ConnectionErrorReason.InternalError));\n            }, 10000);\n            this.pendingTrackResolvers[req.cid] = {\n                resolve: (info)=>{\n                    clearTimeout(publicationTimeout);\n                    resolve(info);\n                },\n                reject: ()=>{\n                    clearTimeout(publicationTimeout);\n                    reject(new Error(\"Cancelled publication by calling unpublish\"));\n                }\n            };\n            this.client.sendAddTrack(req);\n        });\n    }\n    /**\n   * Removes sender from PeerConnection, returning true if it was removed successfully\n   * and a negotiation is necessary\n   * @param sender\n   * @returns\n   */ removeTrack(sender) {\n        if (sender.track && this.pendingTrackResolvers[sender.track.id]) {\n            const { reject } = this.pendingTrackResolvers[sender.track.id];\n            if (reject) {\n                reject();\n            }\n            delete this.pendingTrackResolvers[sender.track.id];\n        }\n        try {\n            this.pcManager.removeTrack(sender);\n            return true;\n        } catch (e) {\n            this.log.warn(\"failed to remove track\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        return false;\n    }\n    updateMuteStatus(trackSid, muted) {\n        this.client.sendMuteTrack(trackSid, muted);\n    }\n    get dataSubscriberReadyState() {\n        var _a;\n        return (_a = this.reliableDCSub) === null || _a === void 0 ? void 0 : _a.readyState;\n    }\n    getConnectedServerAddress() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.pcManager) === null || _a === void 0 ? void 0 : _a.getConnectedAddress();\n        });\n    }\n    /* @internal */ setRegionUrlProvider(provider) {\n        this.regionUrlProvider = provider;\n    }\n    configure(joinResponse) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            // already configured\n            if (this.pcManager && this.pcManager.currentState !== PCTransportState.NEW) {\n                return;\n            }\n            this.participantSid = (_a = joinResponse.participant) === null || _a === void 0 ? void 0 : _a.sid;\n            const rtcConfig = this.makeRTCConfiguration(joinResponse);\n            this.pcManager = new PCTransportManager(rtcConfig, joinResponse.subscriberPrimary, this.loggerOptions);\n            this.emit(EngineEvent.TransportsCreated, this.pcManager.publisher, this.pcManager.subscriber);\n            this.pcManager.onIceCandidate = (candidate, target)=>{\n                this.client.sendIceCandidate(candidate, target);\n            };\n            this.pcManager.onPublisherOffer = (offer)=>{\n                this.client.sendOffer(offer);\n            };\n            this.pcManager.onDataChannel = this.handleDataChannel;\n            this.pcManager.onStateChange = (connectionState, publisherState, subscriberState)=>__awaiter(this, void 0, void 0, function*() {\n                    this.log.debug(\"primary PC state changed \".concat(connectionState), this.logContext);\n                    if ([\n                        \"closed\",\n                        \"disconnected\",\n                        \"failed\"\n                    ].includes(publisherState)) {\n                        // reset publisher connection promise\n                        this.publisherConnectionPromise = undefined;\n                    }\n                    if (connectionState === PCTransportState.CONNECTED) {\n                        const shouldEmit = this.pcState === PCState.New;\n                        this.pcState = PCState.Connected;\n                        if (shouldEmit) {\n                            this.emit(EngineEvent.Connected, joinResponse);\n                        }\n                    } else if (connectionState === PCTransportState.FAILED) {\n                        // on Safari, PeerConnection will switch to 'disconnected' during renegotiation\n                        if (this.pcState === PCState.Connected) {\n                            this.pcState = PCState.Disconnected;\n                            this.handleDisconnect(\"peerconnection failed\", subscriberState === \"failed\" ? ReconnectReason.RR_SUBSCRIBER_FAILED : ReconnectReason.RR_PUBLISHER_FAILED);\n                        }\n                    }\n                    // detect cases where both signal client and peer connection are severed and assume that user has lost network connection\n                    const isSignalSevered = this.client.isDisconnected || this.client.currentState === SignalConnectionState.RECONNECTING;\n                    const isPCSevered = [\n                        PCTransportState.FAILED,\n                        PCTransportState.CLOSING,\n                        PCTransportState.CLOSED\n                    ].includes(connectionState);\n                    if (isSignalSevered && isPCSevered && !this._isClosed) {\n                        this.emit(EngineEvent.Offline);\n                    }\n                });\n            this.pcManager.onTrack = (ev)=>{\n                this.emit(EngineEvent.MediaTrackAdded, ev.track, ev.streams[0], ev.receiver);\n            };\n            if (!supportOptionalDatachannel((_b = joinResponse.serverInfo) === null || _b === void 0 ? void 0 : _b.protocol)) {\n                this.createDataChannels();\n            }\n        });\n    }\n    setupSignalClientCallbacks() {\n        // configure signaling client\n        this.client.onAnswer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                this.log.debug(\"received server answer\", Object.assign(Object.assign({}, this.logContext), {\n                    RTCSdpType: sd.type\n                }));\n                yield this.pcManager.setPublisherAnswer(sd);\n            });\n        // add candidate on trickle\n        this.client.onTrickle = (candidate, target)=>{\n            if (!this.pcManager) {\n                return;\n            }\n            this.log.debug(\"got ICE candidate from peer\", Object.assign(Object.assign({}, this.logContext), {\n                candidate,\n                target\n            }));\n            this.pcManager.addIceCandidate(candidate, target);\n        };\n        // when server creates an offer for the client\n        this.client.onOffer = (sd)=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.pcManager) {\n                    return;\n                }\n                const answer = yield this.pcManager.createSubscriberAnswerFromOffer(sd);\n                this.client.sendAnswer(answer);\n            });\n        this.client.onLocalTrackPublished = (res)=>{\n            var _a;\n            this.log.debug(\"received trackPublishedResponse\", Object.assign(Object.assign({}, this.logContext), {\n                cid: res.cid,\n                track: (_a = res.track) === null || _a === void 0 ? void 0 : _a.sid\n            }));\n            if (!this.pendingTrackResolvers[res.cid]) {\n                this.log.error(\"missing track resolver for \".concat(res.cid), Object.assign(Object.assign({}, this.logContext), {\n                    cid: res.cid\n                }));\n                return;\n            }\n            const { resolve } = this.pendingTrackResolvers[res.cid];\n            delete this.pendingTrackResolvers[res.cid];\n            resolve(res.track);\n        };\n        this.client.onLocalTrackUnpublished = (response)=>{\n            this.emit(EngineEvent.LocalTrackUnpublished, response);\n        };\n        this.client.onLocalTrackSubscribed = (trackSid)=>{\n            this.emit(EngineEvent.LocalTrackSubscribed, trackSid);\n        };\n        this.client.onTokenRefresh = (token)=>{\n            this.token = token;\n        };\n        this.client.onRemoteMuteChanged = (trackSid, muted)=>{\n            this.emit(EngineEvent.RemoteMute, trackSid, muted);\n        };\n        this.client.onSubscribedQualityUpdate = (update)=>{\n            this.emit(EngineEvent.SubscribedQualityUpdate, update);\n        };\n        this.client.onClose = ()=>{\n            this.handleDisconnect(\"signal\", ReconnectReason.RR_SIGNAL_DISCONNECTED);\n        };\n        this.client.onLeave = (leave)=>{\n            this.log.debug(\"client leave request\", Object.assign(Object.assign({}, this.logContext), {\n                reason: leave === null || leave === void 0 ? void 0 : leave.reason\n            }));\n            if (leave.regions && this.regionUrlProvider) {\n                this.log.debug(\"updating regions\", this.logContext);\n                this.regionUrlProvider.setServerReportedRegions(leave.regions);\n            }\n            switch(leave.action){\n                case LeaveRequest_Action.DISCONNECT:\n                    this.emit(EngineEvent.Disconnected, leave === null || leave === void 0 ? void 0 : leave.reason);\n                    this.close();\n                    break;\n                case LeaveRequest_Action.RECONNECT:\n                    this.fullReconnectOnNext = true;\n                    // reconnect immediately instead of waiting for next attempt\n                    this.handleDisconnect(leaveReconnect);\n                    break;\n                case LeaveRequest_Action.RESUME:\n                    // reconnect immediately instead of waiting for next attempt\n                    this.handleDisconnect(leaveReconnect);\n            }\n        };\n    }\n    makeRTCConfiguration(serverResponse) {\n        var _a;\n        const rtcConfig = Object.assign({}, this.rtcConfig);\n        if ((_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.e2eeEnabled) {\n            this.log.debug(\"E2EE - setting up transports with insertable streams\", this.logContext);\n            //  this makes sure that no data is sent before the transforms are ready\n            // @ts-ignore\n            rtcConfig.encodedInsertableStreams = true;\n        }\n        // update ICE servers before creating PeerConnection\n        if (serverResponse.iceServers && !rtcConfig.iceServers) {\n            const rtcIceServers = [];\n            serverResponse.iceServers.forEach((iceServer)=>{\n                const rtcIceServer = {\n                    urls: iceServer.urls\n                };\n                if (iceServer.username) rtcIceServer.username = iceServer.username;\n                if (iceServer.credential) {\n                    rtcIceServer.credential = iceServer.credential;\n                }\n                rtcIceServers.push(rtcIceServer);\n            });\n            rtcConfig.iceServers = rtcIceServers;\n        }\n        if (serverResponse.clientConfiguration && serverResponse.clientConfiguration.forceRelay === ClientConfigSetting.ENABLED) {\n            rtcConfig.iceTransportPolicy = \"relay\";\n        }\n        // @ts-ignore\n        rtcConfig.sdpSemantics = \"unified-plan\";\n        // @ts-ignore\n        rtcConfig.continualGatheringPolicy = \"gather_continually\";\n        return rtcConfig;\n    }\n    createDataChannels() {\n        if (!this.pcManager) {\n            return;\n        }\n        // clear old data channel callbacks if recreate\n        if (this.lossyDC) {\n            this.lossyDC.onmessage = null;\n            this.lossyDC.onerror = null;\n        }\n        if (this.reliableDC) {\n            this.reliableDC.onmessage = null;\n            this.reliableDC.onerror = null;\n        }\n        // create data channels\n        this.lossyDC = this.pcManager.createPublisherDataChannel(lossyDataChannel, {\n            // will drop older packets that arrive\n            ordered: true,\n            maxRetransmits: 0\n        });\n        this.reliableDC = this.pcManager.createPublisherDataChannel(reliableDataChannel, {\n            ordered: true\n        });\n        // also handle messages over the pub channel, for backwards compatibility\n        this.lossyDC.onmessage = this.handleDataMessage;\n        this.reliableDC.onmessage = this.handleDataMessage;\n        // handle datachannel errors\n        this.lossyDC.onerror = this.handleDataError;\n        this.reliableDC.onerror = this.handleDataError;\n        // set up dc buffer threshold, set to 64kB (otherwise 0 by default)\n        this.lossyDC.bufferedAmountLowThreshold = 65535;\n        this.reliableDC.bufferedAmountLowThreshold = 65535;\n        // handle buffer amount low events\n        this.lossyDC.onbufferedamountlow = this.handleBufferedAmountLow;\n        this.reliableDC.onbufferedamountlow = this.handleBufferedAmountLow;\n    }\n    createSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (supportsTransceiver()) {\n                const sender = yield this.createTransceiverRTCRtpSender(track, opts, encodings);\n                return sender;\n            }\n            if (supportsAddTrack()) {\n                this.log.warn(\"using add-track fallback\", this.logContext);\n                const sender = yield this.createRTCRtpSender(track.mediaStreamTrack);\n                return sender;\n            }\n            throw new UnexpectedConnectionState(\"Required webRTC APIs not supported on this device\");\n        });\n    }\n    createSimulcastSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // store RTCRtpSender\n            if (supportsTransceiver()) {\n                return this.createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings);\n            }\n            if (supportsAddTrack()) {\n                this.log.debug(\"using add-track fallback\", this.logContext);\n                return this.createRTCRtpSender(track.mediaStreamTrack);\n            }\n            throw new UnexpectedConnectionState(\"Cannot stream on this device\");\n        });\n    }\n    createTransceiverRTCRtpSender(track, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const streams = [];\n            if (track.mediaStream) {\n                streams.push(track.mediaStream);\n            }\n            if (isVideoTrack(track)) {\n                track.codec = opts.videoCodec;\n            }\n            const transceiverInit = {\n                direction: \"sendonly\",\n                streams\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(track.mediaStreamTrack, transceiverInit);\n            return transceiver.sender;\n        });\n    }\n    createSimulcastTransceiverSender(track, simulcastTrack, opts, encodings) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            const transceiverInit = {\n                direction: \"sendonly\"\n            };\n            if (encodings) {\n                transceiverInit.sendEncodings = encodings;\n            }\n            // addTransceiver for react-native is async. web is synchronous, but await won't effect it.\n            const transceiver = yield this.pcManager.addPublisherTransceiver(simulcastTrack.mediaStreamTrack, transceiverInit);\n            if (!opts.videoCodec) {\n                return;\n            }\n            track.setSimulcastTrackSender(opts.videoCodec, transceiver.sender);\n            return transceiver.sender;\n        });\n    }\n    createRTCRtpSender(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher is closed\");\n            }\n            return this.pcManager.addPublisherTrack(track);\n        });\n    }\n    attemptReconnect(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            if (this._isClosed) {\n                return;\n            }\n            // guard for attempting reconnection multiple times while one attempt is still not finished\n            if (this.attemptingReconnect) {\n                livekitLogger.warn(\"already attempting reconnect, returning early\", this.logContext);\n                return;\n            }\n            if (((_a = this.clientConfiguration) === null || _a === void 0 ? void 0 : _a.resumeConnection) === ClientConfigSetting.DISABLED || // signaling state could change to closed due to hardware sleep\n            // those connections cannot be resumed\n            ((_c = (_b = this.pcManager) === null || _b === void 0 ? void 0 : _b.currentState) !== null && _c !== void 0 ? _c : PCTransportState.NEW) === PCTransportState.NEW) {\n                this.fullReconnectOnNext = true;\n            }\n            try {\n                this.attemptingReconnect = true;\n                if (this.fullReconnectOnNext) {\n                    yield this.restartConnection();\n                } else {\n                    yield this.resumeConnection(reason);\n                }\n                this.clearPendingReconnect();\n                this.fullReconnectOnNext = false;\n            } catch (e) {\n                this.reconnectAttempts += 1;\n                let recoverable = true;\n                if (e instanceof UnexpectedConnectionState) {\n                    this.log.debug(\"received unrecoverable error\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                    // unrecoverable\n                    recoverable = false;\n                } else if (!(e instanceof SignalReconnectError)) {\n                    // cannot resume\n                    this.fullReconnectOnNext = true;\n                }\n                if (recoverable) {\n                    this.handleDisconnect(\"reconnect\", ReconnectReason.RR_UNKNOWN);\n                } else {\n                    this.log.info(\"could not recover connection after \".concat(this.reconnectAttempts, \" attempts, \").concat(Date.now() - this.reconnectStart, \"ms. giving up\"), this.logContext);\n                    this.emit(EngineEvent.Disconnected);\n                    yield this.close();\n                }\n            } finally{\n                this.attemptingReconnect = false;\n            }\n        });\n    }\n    getNextRetryDelay(context) {\n        try {\n            return this.reconnectPolicy.nextRetryDelayInMs(context);\n        } catch (e) {\n            this.log.warn(\"encountered error in reconnect policy\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n        }\n        // error in user code with provided reconnect policy, stop reconnecting\n        return null;\n    }\n    restartConnection(regionUrl) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            try {\n                if (!this.url || !this.token) {\n                    // permanent failure, don't attempt reconnection\n                    throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n                }\n                this.log.info(\"reconnecting, attempt: \".concat(this.reconnectAttempts), this.logContext);\n                this.emit(EngineEvent.Restarting);\n                if (!this.client.isDisconnected) {\n                    yield this.client.sendLeave();\n                }\n                yield this.cleanupPeerConnections();\n                yield this.cleanupClient();\n                let joinResponse;\n                try {\n                    if (!this.signalOpts) {\n                        this.log.warn(\"attempted connection restart, without signal options present\", this.logContext);\n                        throw new SignalReconnectError();\n                    }\n                    // in case a regionUrl is passed, the region URL takes precedence\n                    joinResponse = yield this.join(regionUrl !== null && regionUrl !== void 0 ? regionUrl : this.url, this.token, this.signalOpts);\n                } catch (e) {\n                    if (e instanceof ConnectionError && e.reason === ConnectionErrorReason.NotAllowed) {\n                        throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                    }\n                    throw new SignalReconnectError();\n                }\n                if (this.shouldFailNext) {\n                    this.shouldFailNext = false;\n                    throw new Error(\"simulated failure\");\n                }\n                this.client.setReconnected();\n                this.emit(EngineEvent.SignalRestarted, joinResponse);\n                yield this.waitForPCReconnected();\n                // re-check signal connection state before setting engine as resumed\n                if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                    throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n                }\n                (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.resetAttempts();\n                // reconnect success\n                this.emit(EngineEvent.Restarted);\n            } catch (error) {\n                const nextRegionUrl = yield (_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.getNextBestRegionUrl();\n                if (nextRegionUrl) {\n                    yield this.restartConnection(nextRegionUrl);\n                    return;\n                } else {\n                    // no more regions to try (or we're not on cloud)\n                    (_c = this.regionUrlProvider) === null || _c === void 0 ? void 0 : _c.resetAttempts();\n                    throw error;\n                }\n            }\n        });\n    }\n    resumeConnection(reason) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!this.url || !this.token) {\n                // permanent failure, don't attempt reconnection\n                throw new UnexpectedConnectionState(\"could not reconnect, url or token not saved\");\n            }\n            // trigger publisher reconnect\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"publisher and subscriber connections unset\");\n            }\n            this.log.info(\"resuming signal connection, attempt \".concat(this.reconnectAttempts), this.logContext);\n            this.emit(EngineEvent.Resuming);\n            let res;\n            try {\n                this.setupSignalClientCallbacks();\n                res = yield this.client.reconnect(this.url, this.token, this.participantSid, reason);\n            } catch (error) {\n                let message = \"\";\n                if (error instanceof Error) {\n                    message = error.message;\n                    this.log.error(error.message, Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.NotAllowed) {\n                    throw new UnexpectedConnectionState(\"could not reconnect, token might be expired\");\n                }\n                if (error instanceof ConnectionError && error.reason === ConnectionErrorReason.LeaveRequest) {\n                    throw error;\n                }\n                throw new SignalReconnectError(message);\n            }\n            this.emit(EngineEvent.SignalResumed);\n            if (res) {\n                const rtcConfig = this.makeRTCConfiguration(res);\n                this.pcManager.updateConfiguration(rtcConfig);\n            } else {\n                this.log.warn(\"Did not receive reconnect response\", this.logContext);\n            }\n            if (this.shouldFailNext) {\n                this.shouldFailNext = false;\n                throw new Error(\"simulated failure\");\n            }\n            yield this.pcManager.triggerIceRestart();\n            yield this.waitForPCReconnected();\n            // re-check signal connection state before setting engine as resumed\n            if (this.client.currentState !== SignalConnectionState.CONNECTED) {\n                throw new SignalReconnectError(\"Signal connection got severed during reconnect\");\n            }\n            this.client.setReconnected();\n            // recreate publish datachannel if it's id is null\n            // (for safari https://bugs.webkit.org/show_bug.cgi?id=184688)\n            if (((_a = this.reliableDC) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\" && this.reliableDC.id === null) {\n                this.createDataChannels();\n            }\n            // resume success\n            this.emit(EngineEvent.Resumed);\n        });\n    }\n    waitForPCInitialConnection(timeout, abortController) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.pcManager) {\n                throw new UnexpectedConnectionState(\"PC manager is closed\");\n            }\n            yield this.pcManager.ensurePCTransportConnection(abortController, timeout);\n        });\n    }\n    waitForPCReconnected() {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.pcState = PCState.Reconnecting;\n            this.log.debug(\"waiting for peer connection to reconnect\", this.logContext);\n            try {\n                yield sleep(minReconnectWait); // FIXME setTimeout again not ideal for a connection critical path\n                if (!this.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                yield this.pcManager.ensurePCTransportConnection(undefined, this.peerConnectionTimeout);\n                this.pcState = PCState.Connected;\n            } catch (e) {\n                // TODO do we need a `failed` state here for the PC?\n                this.pcState = PCState.Disconnected;\n                throw new ConnectionError(\"could not establish PC connection, \".concat(e.message), ConnectionErrorReason.InternalError);\n            }\n        });\n    }\n    /** @internal */ publishRpcResponse(destinationIdentity, requestId, payload, error) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcResponse\",\n                    value: new RpcResponse({\n                        requestId,\n                        value: error ? {\n                            case: \"error\",\n                            value: error.toProto()\n                        } : {\n                            case: \"payload\",\n                            value: payload !== null && payload !== void 0 ? payload : \"\"\n                        }\n                    })\n                }\n            });\n            yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /** @internal */ publishRpcAck(destinationIdentity, requestId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcAck\",\n                    value: new RpcAck({\n                        requestId\n                    })\n                }\n            });\n            yield this.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /* @internal */ sendDataPacket(packet, kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = packet.toBinary();\n            // make sure we do have a data connection\n            yield this.ensurePublisherConnected(kind);\n            const dc = this.dataChannelForKind(kind);\n            if (dc) {\n                dc.send(msg);\n            }\n            this.updateAndEmitDCBufferStatus(kind);\n        });\n    }\n    waitForBufferStatusLow(kind) {\n        return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                if (this.isBufferStatusLow(kind)) {\n                    resolve();\n                } else {\n                    const onClosing = ()=>reject(\"Engine closed\");\n                    this.once(EngineEvent.Closing, onClosing);\n                    while(!this.dcBufferStatus.get(kind)){\n                        yield sleep(10);\n                    }\n                    this.off(EngineEvent.Closing, onClosing);\n                    resolve();\n                }\n            }));\n    }\n    /**\n   * @internal\n   */ ensureDataTransportConnected(kind_1) {\n        return __awaiter(this, arguments, void 0, function(kind) {\n            var _this2 = this;\n            let subscriber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.subscriberPrimary;\n            return function*() {\n                var _a;\n                if (!_this2.pcManager) {\n                    throw new UnexpectedConnectionState(\"PC manager is closed\");\n                }\n                const transport = subscriber ? _this2.pcManager.subscriber : _this2.pcManager.publisher;\n                const transportName = subscriber ? \"Subscriber\" : \"Publisher\";\n                if (!transport) {\n                    throw new ConnectionError(\"\".concat(transportName, \" connection not set\"), ConnectionErrorReason.InternalError);\n                }\n                let needNegotiation = false;\n                if (!subscriber && !_this2.dataChannelForKind(kind, subscriber)) {\n                    _this2.createDataChannels();\n                    needNegotiation = true;\n                }\n                if (!needNegotiation && !subscriber && !_this2.pcManager.publisher.isICEConnected && _this2.pcManager.publisher.getICEConnectionState() !== \"checking\") {\n                    needNegotiation = true;\n                }\n                if (needNegotiation) {\n                    // start negotiation\n                    _this2.negotiate();\n                }\n                const targetChannel = _this2.dataChannelForKind(kind, subscriber);\n                if ((targetChannel === null || targetChannel === void 0 ? void 0 : targetChannel.readyState) === \"open\") {\n                    return;\n                }\n                // wait until ICE connected\n                const endTime = new Date().getTime() + _this2.peerConnectionTimeout;\n                while(new Date().getTime() < endTime){\n                    if (transport.isICEConnected && ((_a = _this2.dataChannelForKind(kind, subscriber)) === null || _a === void 0 ? void 0 : _a.readyState) === \"open\") {\n                        return;\n                    }\n                    yield sleep(50);\n                }\n                throw new ConnectionError(\"could not establish \".concat(transportName, \" connection, state: \").concat(transport.getICEConnectionState()), ConnectionErrorReason.InternalError);\n            }();\n        });\n    }\n    ensurePublisherConnected(kind) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.publisherConnectionPromise) {\n                this.publisherConnectionPromise = this.ensureDataTransportConnected(kind, false);\n            }\n            yield this.publisherConnectionPromise;\n        });\n    }\n    /* @internal */ verifyTransport() {\n        if (!this.pcManager) {\n            return false;\n        }\n        // primary connection\n        if (this.pcManager.currentState !== PCTransportState.CONNECTED) {\n            return false;\n        }\n        // ensure signal is connected\n        if (!this.client.ws || this.client.ws.readyState === WebSocket.CLOSED) {\n            return false;\n        }\n        return true;\n    }\n    /** @internal */ negotiate() {\n        return __awaiter(this, void 0, void 0, function*() {\n            // observe signal state\n            return new Promise((resolve, reject)=>__awaiter(this, void 0, void 0, function*() {\n                    if (!this.pcManager) {\n                        reject(new NegotiationError(\"PC manager is closed\"));\n                        return;\n                    }\n                    this.pcManager.requirePublisher();\n                    // don't negotiate without any transceivers or data channel, it will generate sdp without ice frag then negotiate failed\n                    if (this.pcManager.publisher.getTransceivers().length == 0 && !this.lossyDC && !this.reliableDC) {\n                        this.createDataChannels();\n                    }\n                    const abortController = new AbortController();\n                    const handleClosed = ()=>{\n                        abortController.abort();\n                        this.log.debug(\"engine disconnected while negotiation was ongoing\", this.logContext);\n                        resolve();\n                        return;\n                    };\n                    if (this.isClosed) {\n                        reject(\"cannot negotiate on closed engine\");\n                    }\n                    this.on(EngineEvent.Closing, handleClosed);\n                    this.pcManager.publisher.once(PCEvents.RTPVideoPayloadTypes, (rtpTypes)=>{\n                        const rtpMap = new Map();\n                        rtpTypes.forEach((rtp)=>{\n                            const codec = rtp.codec.toLowerCase();\n                            if (isVideoCodec(codec)) {\n                                rtpMap.set(rtp.payload, codec);\n                            }\n                        });\n                        this.emit(EngineEvent.RTPVideoMapUpdate, rtpMap);\n                    });\n                    try {\n                        yield this.pcManager.negotiate(abortController);\n                        resolve();\n                    } catch (e) {\n                        if (e instanceof NegotiationError) {\n                            this.fullReconnectOnNext = true;\n                        }\n                        this.handleDisconnect(\"negotiation\", ReconnectReason.RR_UNKNOWN);\n                        reject(e);\n                    } finally{\n                        this.off(EngineEvent.Closing, handleClosed);\n                    }\n                }));\n        });\n    }\n    dataChannelForKind(kind, sub) {\n        if (!sub) {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDC;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDC;\n            }\n        } else {\n            if (kind === DataPacket_Kind.LOSSY) {\n                return this.lossyDCSub;\n            }\n            if (kind === DataPacket_Kind.RELIABLE) {\n                return this.reliableDCSub;\n            }\n        }\n    }\n    /** @internal */ sendSyncState(remoteTracks, localTracks) {\n        var _a, _b;\n        if (!this.pcManager) {\n            this.log.warn(\"sync state cannot be sent without peer connection setup\", this.logContext);\n            return;\n        }\n        const previousAnswer = this.pcManager.subscriber.getLocalDescription();\n        const previousOffer = this.pcManager.subscriber.getRemoteDescription();\n        /* 1. autosubscribe on, so subscribed tracks = all tracks - unsub tracks,\n          in this case, we send unsub tracks, so server add all tracks to this\n          subscribe pc and unsub special tracks from it.\n       2. autosubscribe off, we send subscribed tracks.\n    */ const autoSubscribe = (_b = (_a = this.signalOpts) === null || _a === void 0 ? void 0 : _a.autoSubscribe) !== null && _b !== void 0 ? _b : true;\n        const trackSids = new Array();\n        const trackSidsDisabled = new Array();\n        remoteTracks.forEach((track)=>{\n            if (track.isDesired !== autoSubscribe) {\n                trackSids.push(track.trackSid);\n            }\n            if (!track.isEnabled) {\n                trackSidsDisabled.push(track.trackSid);\n            }\n        });\n        this.client.sendSyncState(new SyncState({\n            answer: previousAnswer ? toProtoSessionDescription({\n                sdp: previousAnswer.sdp,\n                type: previousAnswer.type\n            }) : undefined,\n            offer: previousOffer ? toProtoSessionDescription({\n                sdp: previousOffer.sdp,\n                type: previousOffer.type\n            }) : undefined,\n            subscription: new UpdateSubscription({\n                trackSids,\n                subscribe: !autoSubscribe,\n                participantTracks: []\n            }),\n            publishTracks: getTrackPublicationInfo(localTracks),\n            dataChannels: this.dataChannelsInfo(),\n            trackSidsDisabled\n        }));\n    }\n    /* @internal */ failNext() {\n        // debugging method to fail the next reconnect/resume attempt\n        this.shouldFailNext = true;\n    }\n    dataChannelsInfo() {\n        const infos = [];\n        const getInfo = (dc, target)=>{\n            if ((dc === null || dc === void 0 ? void 0 : dc.id) !== undefined && dc.id !== null) {\n                infos.push(new DataChannelInfo({\n                    label: dc.label,\n                    id: dc.id,\n                    target\n                }));\n            }\n        };\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE), SignalTarget.PUBLISHER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.LOSSY, true), SignalTarget.SUBSCRIBER);\n        getInfo(this.dataChannelForKind(DataPacket_Kind.RELIABLE, true), SignalTarget.SUBSCRIBER);\n        return infos;\n    }\n    clearReconnectTimeout() {\n        if (this.reconnectTimeout) {\n            CriticalTimers.clearTimeout(this.reconnectTimeout);\n        }\n    }\n    clearPendingReconnect() {\n        this.clearReconnectTimeout();\n        this.reconnectAttempts = 0;\n    }\n    registerOnLineListener() {\n        if (isWeb()) {\n            window.addEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n    deregisterOnLineListener() {\n        if (isWeb()) {\n            window.removeEventListener(\"online\", this.handleBrowserOnLine);\n        }\n    }\n}\nclass SignalReconnectError extends Error {\n}\nfunction supportOptionalDatachannel(protocol) {\n    return protocol !== undefined && protocol > 13;\n}\nfunction applyUserDataCompat(newObj, oldObj) {\n    const participantIdentity = newObj.participantIdentity ? newObj.participantIdentity : oldObj.participantIdentity;\n    newObj.participantIdentity = participantIdentity;\n    oldObj.participantIdentity = participantIdentity;\n    const destinationIdentities = newObj.destinationIdentities.length !== 0 ? newObj.destinationIdentities : oldObj.destinationIdentities;\n    newObj.destinationIdentities = destinationIdentities;\n    oldObj.destinationIdentities = destinationIdentities;\n}\nclass RegionUrlProvider {\n    constructor(url, token){\n        this.lastUpdateAt = 0;\n        this.settingsCacheTime = 3000;\n        this.attemptedRegions = [];\n        this.serverUrl = new URL(url);\n        this.token = token;\n    }\n    updateToken(token) {\n        this.token = token;\n    }\n    isCloud() {\n        return isCloud(this.serverUrl);\n    }\n    getServerUrl() {\n        return this.serverUrl;\n    }\n    getNextBestRegionUrl(abortSignal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.isCloud()) {\n                throw Error(\"region availability is only supported for LiveKit Cloud domains\");\n            }\n            if (!this.regionSettings || Date.now() - this.lastUpdateAt > this.settingsCacheTime) {\n                this.regionSettings = yield this.fetchRegionSettings(abortSignal);\n            }\n            const regionsLeft = this.regionSettings.regions.filter((region)=>!this.attemptedRegions.find((attempted)=>attempted.url === region.url));\n            if (regionsLeft.length > 0) {\n                const nextRegion = regionsLeft[0];\n                this.attemptedRegions.push(nextRegion);\n                livekitLogger.debug(\"next region: \".concat(nextRegion.region));\n                return nextRegion.url;\n            } else {\n                return null;\n            }\n        });\n    }\n    resetAttempts() {\n        this.attemptedRegions = [];\n    }\n    /* @internal */ fetchRegionSettings(signal) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionSettingsResponse = yield fetch(\"\".concat(getCloudConfigUrl(this.serverUrl), \"/regions\"), {\n                headers: {\n                    authorization: \"Bearer \".concat(this.token)\n                },\n                signal\n            });\n            if (regionSettingsResponse.ok) {\n                const regionSettings = yield regionSettingsResponse.json();\n                this.lastUpdateAt = Date.now();\n                return regionSettings;\n            } else {\n                throw new ConnectionError(\"Could not fetch region settings: \".concat(regionSettingsResponse.statusText), regionSettingsResponse.status === 401 ? ConnectionErrorReason.NotAllowed : ConnectionErrorReason.InternalError, regionSettingsResponse.status);\n            }\n        });\n    }\n    setServerReportedRegions(regions) {\n        this.regionSettings = regions;\n        this.lastUpdateAt = Date.now();\n    }\n}\nfunction getCloudConfigUrl(serverUrl) {\n    return \"\".concat(serverUrl.protocol.replace(\"ws\", \"http\"), \"//\").concat(serverUrl.host, \"/settings\");\n}\nclass BaseStreamReader {\n    get info() {\n        return this._info;\n    }\n    constructor(info, stream, totalByteSize){\n        this.reader = stream;\n        this.totalByteSize = totalByteSize;\n        this._info = info;\n        this.bytesReceived = 0;\n    }\n}\nclass ByteStreamReader extends BaseStreamReader {\n    handleChunkReceived(chunk) {\n        var _a;\n        this.bytesReceived += chunk.content.byteLength;\n        const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n        (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n    }\n    [Symbol.asyncIterator]() {\n        const reader = this.reader.getReader();\n        return {\n            next: ()=>__awaiter(this, void 0, void 0, function*() {\n                    try {\n                        const { done, value } = yield reader.read();\n                        if (done) {\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        } else {\n                            this.handleChunkReceived(value);\n                            return {\n                                done: false,\n                                value: value.content\n                            };\n                        }\n                    } catch (error) {\n                        // TODO handle errors\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                }),\n            return () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    reader.releaseLock();\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                });\n            }\n        };\n    }\n    readAll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_1, _b, _c;\n            let chunks = new Set();\n            try {\n                for(var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const chunk = _c;\n                    chunks.add(chunk);\n                }\n            } catch (e_1_1) {\n                e_1 = {\n                    error: e_1_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_1) throw e_1.error;\n                }\n            }\n            return Array.from(chunks);\n        });\n    }\n}\n/**\n * A class to read chunks from a ReadableStream and provide them in a structured format.\n */ class TextStreamReader extends BaseStreamReader {\n    /**\n   * A TextStreamReader instance can be used as an AsyncIterator that returns the entire string\n   * that has been received up to the current point in time.\n   */ constructor(info, stream, totalChunkCount){\n        super(info, stream, totalChunkCount);\n        this.receivedChunks = new Map();\n    }\n    handleChunkReceived(chunk) {\n        var _a;\n        const index = bigIntToNumber(chunk.chunkIndex);\n        const previousChunkAtIndex = this.receivedChunks.get(index);\n        if (previousChunkAtIndex && previousChunkAtIndex.version > chunk.version) {\n            // we have a newer version already, dropping the old one\n            return;\n        }\n        this.receivedChunks.set(index, chunk);\n        this.bytesReceived += chunk.content.byteLength;\n        const currentProgress = this.totalByteSize ? this.bytesReceived / this.totalByteSize : undefined;\n        (_a = this.onProgress) === null || _a === void 0 ? void 0 : _a.call(this, currentProgress);\n    }\n    /**\n   * Async iterator implementation to allow usage of `for await...of` syntax.\n   * Yields structured chunks from the stream.\n   *\n   */ [Symbol.asyncIterator]() {\n        const reader = this.reader.getReader();\n        const decoder = new TextDecoder();\n        return {\n            next: ()=>__awaiter(this, void 0, void 0, function*() {\n                    try {\n                        const { done, value } = yield reader.read();\n                        if (done) {\n                            return {\n                                done: true,\n                                value: undefined\n                            };\n                        } else {\n                            this.handleChunkReceived(value);\n                            return {\n                                done: false,\n                                value: decoder.decode(value.content)\n                            };\n                        }\n                    } catch (error) {\n                        // TODO handle errors\n                        return {\n                            done: true,\n                            value: undefined\n                        };\n                    }\n                }),\n            return () {\n                return __awaiter(this, void 0, void 0, function*() {\n                    reader.releaseLock();\n                    return {\n                        done: true,\n                        value: undefined\n                    };\n                });\n            }\n        };\n    }\n    readAll() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, e_2, _b, _c;\n            let finalString = \"\";\n            try {\n                for(var _d = true, _e = __asyncValues(this), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true){\n                    _c = _f.value;\n                    _d = false;\n                    const chunk = _c;\n                    finalString += chunk;\n                }\n            } catch (e_2_1) {\n                e_2 = {\n                    error: e_2_1\n                };\n            } finally{\n                try {\n                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);\n                } finally{\n                    if (e_2) throw e_2.error;\n                }\n            }\n            return finalString;\n        });\n    }\n}\nclass BaseStreamWriter {\n    constructor(writableStream, info, onClose){\n        this.writableStream = writableStream;\n        this.defaultWriter = writableStream.getWriter();\n        this.onClose = onClose;\n        this.info = info;\n    }\n    write(chunk) {\n        return this.defaultWriter.write(chunk);\n    }\n    close() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield this.defaultWriter.close();\n            this.defaultWriter.releaseLock();\n            (_a = this.onClose) === null || _a === void 0 ? void 0 : _a.call(this);\n        });\n    }\n}\nclass TextStreamWriter extends BaseStreamWriter {\n}\nclass ByteStreamWriter extends BaseStreamWriter {\n}\nclass RemoteTrack extends Track {\n    constructor(mediaTrack, sid, kind, receiver, loggerOptions){\n        super(mediaTrack, kind, loggerOptions);\n        this.sid = sid;\n        this.receiver = receiver;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** @internal */ setMuted(muted) {\n        if (this.isMuted !== muted) {\n            this.isMuted = muted;\n            this._mediaStreamTrack.enabled = !muted;\n            this.emit(muted ? TrackEvent.Muted : TrackEvent.Unmuted, this);\n        }\n    }\n    /** @internal */ setMediaStream(stream) {\n        // this is needed to determine when the track is finished\n        this.mediaStream = stream;\n        const onRemoveTrack = (event)=>{\n            if (event.track === this._mediaStreamTrack) {\n                stream.removeEventListener(\"removetrack\", onRemoveTrack);\n                if (this.receiver && \"playoutDelayHint\" in this.receiver) {\n                    this.receiver.playoutDelayHint = undefined;\n                }\n                this.receiver = undefined;\n                this._currentBitrate = 0;\n                this.emit(TrackEvent.Ended, this);\n            }\n        };\n        stream.addEventListener(\"removetrack\", onRemoveTrack);\n    }\n    start() {\n        this.startMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.enable();\n    }\n    stop() {\n        this.stopMonitor();\n        // use `enabled` of track to enable re-use of transceiver\n        super.disable();\n    }\n    /**\n   * Gets the RTCStatsReport for the RemoteTrack's underlying RTCRtpReceiver\n   * See https://developer.mozilla.org/en-US/docs/Web/API/RTCStatsReport\n   *\n   * @returns Promise<RTCStatsReport> | undefined\n   */ getRTCStatsReport() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (!((_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getStats)) {\n                return;\n            }\n            const statsReport = yield this.receiver.getStats();\n            return statsReport;\n        });\n    }\n    /**\n   * Allows to set a playout delay (in seconds) for this track.\n   * A higher value allows for more buffering of the track in the browser\n   * and will result in a delay of media being played back of `delayInSeconds`\n   */ setPlayoutDelay(delayInSeconds) {\n        if (this.receiver) {\n            if (\"playoutDelayHint\" in this.receiver) {\n                this.receiver.playoutDelayHint = delayInSeconds;\n            } else {\n                this.log.warn(\"Playout delay not supported in this browser\");\n            }\n        } else {\n            this.log.warn(\"Cannot set playout delay, track already ended\");\n        }\n    }\n    /**\n   * Returns the current playout delay (in seconds) of this track.\n   */ getPlayoutDelay() {\n        if (this.receiver) {\n            if (\"playoutDelayHint\" in this.receiver) {\n                return this.receiver.playoutDelayHint;\n            } else {\n                this.log.warn(\"Playout delay not supported in this browser\");\n            }\n        } else {\n            this.log.warn(\"Cannot get playout delay, track already ended\");\n        }\n        return 0;\n    }\n    /* @internal */ startMonitor() {\n        if (!this.monitorInterval) {\n            this.monitorInterval = setInterval(()=>this.monitorReceiver(), monitorFrequency);\n        }\n        if (supportsSynchronizationSources()) {\n            this.registerTimeSyncUpdate();\n        }\n    }\n    registerTimeSyncUpdate() {\n        const loop = ()=>{\n            var _a;\n            this.timeSyncHandle = requestAnimationFrame(()=>loop());\n            const sources = (_a = this.receiver) === null || _a === void 0 ? void 0 : _a.getSynchronizationSources()[0];\n            if (sources) {\n                const { timestamp, rtpTimestamp } = sources;\n                if (rtpTimestamp && this.rtpTimestamp !== rtpTimestamp) {\n                    this.emit(TrackEvent.TimeSyncUpdate, {\n                        timestamp,\n                        rtpTimestamp\n                    });\n                    this.rtpTimestamp = rtpTimestamp;\n                }\n            }\n        };\n        loop();\n    }\n}\nclass RemoteAudioTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, audioContext, audioOutput, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Audio, receiver, loggerOptions);\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.audioContext = audioContext;\n        this.webAudioPluginNodes = [];\n        if (audioOutput) {\n            this.sinkId = audioOutput.deviceId;\n        }\n    }\n    /**\n   * sets the volume for all attached audio elements\n   */ setVolume(volume) {\n        var _a;\n        for (const el of this.attachedElements){\n            if (this.audioContext) {\n                (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.gain.setTargetAtTime(volume, 0, 0.1);\n            } else {\n                el.volume = volume;\n            }\n        }\n        if (isReactNative()) {\n            // @ts-ignore\n            this._mediaStreamTrack._setVolume(volume);\n        }\n        this.elementVolume = volume;\n    }\n    /**\n   * gets the volume of attached audio elements (loudest)\n   */ getVolume() {\n        if (this.elementVolume) {\n            return this.elementVolume;\n        }\n        if (isReactNative()) {\n            // RN volume value defaults to 1.0 if hasn't been changed.\n            return 1.0;\n        }\n        let highestVolume = 0;\n        this.attachedElements.forEach((element)=>{\n            if (element.volume > highestVolume) {\n                highestVolume = element.volume;\n            }\n        });\n        return highestVolume;\n    }\n    /**\n   * calls setSinkId on all attached elements, if supported\n   * @param deviceId audio output device\n   */ setSinkId(deviceId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.sinkId = deviceId;\n            yield Promise.all(this.attachedElements.map((elm)=>{\n                if (!supportsSetSinkId(elm)) {\n                    return;\n                }\n                /* @ts-ignore */ return elm.setSinkId(deviceId);\n            }));\n        });\n    }\n    attach(element) {\n        const needsNewWebAudioConnection = this.attachedElements.length === 0;\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        if (this.sinkId && supportsSetSinkId(element)) {\n            /* @ts-ignore */ element.setSinkId(this.sinkId);\n        }\n        if (this.audioContext && needsNewWebAudioConnection) {\n            this.log.debug(\"using audio context mapping\", this.logContext);\n            this.connectWebAudio(this.audioContext, element);\n            element.volume = 0;\n            element.muted = true;\n        }\n        if (this.elementVolume) {\n            // make sure volume setting is being applied to the newly attached element\n            this.setVolume(this.elementVolume);\n        }\n        return element;\n    }\n    detach(element) {\n        let detached;\n        if (!element) {\n            detached = super.detach();\n            this.disconnectWebAudio();\n        } else {\n            detached = super.detach(element);\n            // if there are still any attached elements after detaching, connect webaudio to the first element that's left\n            // disconnect webaudio otherwise\n            if (this.audioContext) {\n                if (this.attachedElements.length > 0) {\n                    this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n                } else {\n                    this.disconnectWebAudio();\n                }\n            }\n        }\n        return detached;\n    }\n    /**\n   * @internal\n   * @experimental\n   */ setAudioContext(audioContext) {\n        this.audioContext = audioContext;\n        if (audioContext && this.attachedElements.length > 0) {\n            this.connectWebAudio(audioContext, this.attachedElements[0]);\n        } else if (!audioContext) {\n            this.disconnectWebAudio();\n        }\n    }\n    /**\n   * @internal\n   * @experimental\n   * @param {AudioNode[]} nodes - An array of WebAudio nodes. These nodes should not be connected to each other when passed, as the sdk will take care of connecting them in the order of the array.\n   */ setWebAudioPlugins(nodes) {\n        this.webAudioPluginNodes = nodes;\n        if (this.attachedElements.length > 0 && this.audioContext) {\n            this.connectWebAudio(this.audioContext, this.attachedElements[0]);\n        }\n    }\n    connectWebAudio(context, element) {\n        this.disconnectWebAudio();\n        // @ts-ignore attached elements always have a srcObject set\n        this.sourceNode = context.createMediaStreamSource(element.srcObject);\n        let lastNode = this.sourceNode;\n        this.webAudioPluginNodes.forEach((node)=>{\n            lastNode.connect(node);\n            lastNode = node;\n        });\n        this.gainNode = context.createGain();\n        lastNode.connect(this.gainNode);\n        this.gainNode.connect(context.destination);\n        if (this.elementVolume) {\n            this.gainNode.gain.setTargetAtTime(this.elementVolume, 0, 0.1);\n        }\n        // try to resume the context if it isn't running already\n        if (context.state !== \"running\") {\n            context.resume().then(()=>{\n                if (context.state !== \"running\") {\n                    this.emit(TrackEvent.AudioPlaybackFailed, new Error(\"Audio Context couldn't be started automatically\"));\n                }\n            }).catch((e)=>{\n                this.emit(TrackEvent.AudioPlaybackFailed, e);\n            });\n        }\n    }\n    disconnectWebAudio() {\n        var _a, _b;\n        (_a = this.gainNode) === null || _a === void 0 ? void 0 : _a.disconnect();\n        (_b = this.sourceNode) === null || _b === void 0 ? void 0 : _b.disconnect();\n        this.gainNode = undefined;\n        this.sourceNode = undefined;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    receiverStats = {\n                        type: \"audio\",\n                        streamId: v.id,\n                        timestamp: v.timestamp,\n                        jitter: v.jitter,\n                        bytesReceived: v.bytesReceived,\n                        concealedSamples: v.concealedSamples,\n                        concealmentEvents: v.concealmentEvents,\n                        silentConcealedSamples: v.silentConcealedSamples,\n                        silentConcealmentEvents: v.silentConcealmentEvents,\n                        totalAudioEnergy: v.totalAudioEnergy,\n                        totalSamplesDuration: v.totalSamplesDuration\n                    };\n                }\n            });\n            return receiverStats;\n        });\n    }\n}\nconst REACTION_DELAY = 100;\nclass RemoteVideoTrack extends RemoteTrack {\n    constructor(mediaTrack, sid, receiver, adaptiveStreamSettings, loggerOptions){\n        super(mediaTrack, sid, Track.Kind.Video, receiver, loggerOptions);\n        this.elementInfos = [];\n        this.monitorReceiver = ()=>__awaiter(this, void 0, void 0, function*() {\n                if (!this.receiver) {\n                    this._currentBitrate = 0;\n                    return;\n                }\n                const stats = yield this.getReceiverStats();\n                if (stats && this.prevStats && this.receiver) {\n                    this._currentBitrate = computeBitrate(stats, this.prevStats);\n                }\n                this.prevStats = stats;\n            });\n        this.debouncedHandleResize = r(()=>{\n            this.updateDimensions();\n        }, REACTION_DELAY);\n        this.adaptiveStreamSettings = adaptiveStreamSettings;\n    }\n    get isAdaptiveStream() {\n        return this.adaptiveStreamSettings !== undefined;\n    }\n    /**\n   * Note: When using adaptiveStream, you need to use remoteVideoTrack.attach() to add the track to a HTMLVideoElement, otherwise your video tracks might never start\n   */ get mediaStreamTrack() {\n        return this._mediaStreamTrack;\n    }\n    /** @internal */ setMuted(muted) {\n        super.setMuted(muted);\n        this.attachedElements.forEach((element)=>{\n            // detach or attach\n            if (muted) {\n                detachTrack(this._mediaStreamTrack, element);\n            } else {\n                attachToElement(this._mediaStreamTrack, element);\n            }\n        });\n    }\n    attach(element) {\n        if (!element) {\n            element = super.attach();\n        } else {\n            super.attach(element);\n        }\n        // It's possible attach is called multiple times on an element. When that's\n        // the case, we'd want to avoid adding duplicate elementInfos\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info.element === element) === undefined) {\n            const elementInfo = new HTMLElementInfo(element);\n            this.observeElementInfo(elementInfo);\n        }\n        return element;\n    }\n    /**\n   * Observe an ElementInfo for changes when adaptive streaming.\n   * @param elementInfo\n   * @internal\n   */ observeElementInfo(elementInfo) {\n        if (this.adaptiveStreamSettings && this.elementInfos.find((info)=>info === elementInfo) === undefined) {\n            elementInfo.handleResize = ()=>{\n                this.debouncedHandleResize();\n            };\n            elementInfo.handleVisibilityChanged = ()=>{\n                this.updateVisibility();\n            };\n            this.elementInfos.push(elementInfo);\n            elementInfo.observe();\n            // trigger the first resize update cycle\n            // if the tab is backgrounded, the initial resize event does not fire until\n            // the tab comes into focus for the first time.\n            this.debouncedHandleResize();\n            this.updateVisibility();\n        } else {\n            this.log.warn(\"visibility resize observer not triggered\", this.logContext);\n        }\n    }\n    /**\n   * Stop observing an ElementInfo for changes.\n   * @param elementInfo\n   * @internal\n   */ stopObservingElementInfo(elementInfo) {\n        if (!this.isAdaptiveStream) {\n            this.log.warn(\"stopObservingElementInfo ignored\", this.logContext);\n            return;\n        }\n        const stopElementInfos = this.elementInfos.filter((info)=>info === elementInfo);\n        for (const info of stopElementInfos){\n            info.stopObserving();\n        }\n        this.elementInfos = this.elementInfos.filter((info)=>info !== elementInfo);\n        this.updateVisibility();\n        this.debouncedHandleResize();\n    }\n    detach(element) {\n        let detachedElements = [];\n        if (element) {\n            this.stopObservingElement(element);\n            return super.detach(element);\n        }\n        detachedElements = super.detach();\n        for (const e of detachedElements){\n            this.stopObservingElement(e);\n        }\n        return detachedElements;\n    }\n    /** @internal */ getDecoderImplementation() {\n        var _a;\n        return (_a = this.prevStats) === null || _a === void 0 ? void 0 : _a.decoderImplementation;\n    }\n    getReceiverStats() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.receiver || !this.receiver.getStats) {\n                return;\n            }\n            const stats = yield this.receiver.getStats();\n            let receiverStats;\n            let codecID = \"\";\n            let codecs = new Map();\n            stats.forEach((v)=>{\n                if (v.type === \"inbound-rtp\") {\n                    codecID = v.codecId;\n                    receiverStats = {\n                        type: \"video\",\n                        streamId: v.id,\n                        framesDecoded: v.framesDecoded,\n                        framesDropped: v.framesDropped,\n                        framesReceived: v.framesReceived,\n                        packetsReceived: v.packetsReceived,\n                        packetsLost: v.packetsLost,\n                        frameWidth: v.frameWidth,\n                        frameHeight: v.frameHeight,\n                        pliCount: v.pliCount,\n                        firCount: v.firCount,\n                        nackCount: v.nackCount,\n                        jitter: v.jitter,\n                        timestamp: v.timestamp,\n                        bytesReceived: v.bytesReceived,\n                        decoderImplementation: v.decoderImplementation\n                    };\n                } else if (v.type === \"codec\") {\n                    codecs.set(v.id, v);\n                }\n            });\n            if (receiverStats && codecID !== \"\" && codecs.get(codecID)) {\n                receiverStats.mimeType = codecs.get(codecID).mimeType;\n            }\n            return receiverStats;\n        });\n    }\n    stopObservingElement(element) {\n        const stopElementInfos = this.elementInfos.filter((info)=>info.element === element);\n        for (const info of stopElementInfos){\n            this.stopObservingElementInfo(info);\n        }\n    }\n    handleAppVisibilityChanged() {\n        const _super = Object.create(null, {\n            handleAppVisibilityChanged: {\n                get: ()=>super.handleAppVisibilityChanged\n            }\n        });\n        return __awaiter(this, void 0, void 0, function*() {\n            yield _super.handleAppVisibilityChanged.call(this);\n            if (!this.isAdaptiveStream) return;\n            this.updateVisibility();\n        });\n    }\n    updateVisibility() {\n        var _a, _b;\n        const lastVisibilityChange = this.elementInfos.reduce((prev, info)=>Math.max(prev, info.visibilityChangedAt || 0), 0);\n        const backgroundPause = ((_b = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pauseVideoInBackground) !== null && _b !== void 0 ? _b : true // default to true\n        ) ? this.isInBackground : false;\n        const isPiPMode = this.elementInfos.some((info)=>info.pictureInPicture);\n        const isVisible = this.elementInfos.some((info)=>info.visible) && !backgroundPause || isPiPMode;\n        if (this.lastVisible === isVisible) {\n            return;\n        }\n        if (!isVisible && Date.now() - lastVisibilityChange < REACTION_DELAY) {\n            // delay hidden events\n            CriticalTimers.setTimeout(()=>{\n                this.updateVisibility();\n            }, REACTION_DELAY);\n            return;\n        }\n        this.lastVisible = isVisible;\n        this.emit(TrackEvent.VisibilityChanged, isVisible, this);\n    }\n    updateDimensions() {\n        var _a, _b;\n        let maxWidth = 0;\n        let maxHeight = 0;\n        const pixelDensity = this.getPixelDensity();\n        for (const info of this.elementInfos){\n            const currentElementWidth = info.width() * pixelDensity;\n            const currentElementHeight = info.height() * pixelDensity;\n            if (currentElementWidth + currentElementHeight > maxWidth + maxHeight) {\n                maxWidth = currentElementWidth;\n                maxHeight = currentElementHeight;\n            }\n        }\n        if (((_a = this.lastDimensions) === null || _a === void 0 ? void 0 : _a.width) === maxWidth && ((_b = this.lastDimensions) === null || _b === void 0 ? void 0 : _b.height) === maxHeight) {\n            return;\n        }\n        this.lastDimensions = {\n            width: maxWidth,\n            height: maxHeight\n        };\n        this.emit(TrackEvent.VideoDimensionsChanged, this.lastDimensions, this);\n    }\n    getPixelDensity() {\n        var _a;\n        const pixelDensity = (_a = this.adaptiveStreamSettings) === null || _a === void 0 ? void 0 : _a.pixelDensity;\n        if (pixelDensity === \"screen\") {\n            return getDevicePixelRatio();\n        } else if (!pixelDensity) {\n            // when unset, we'll pick a sane default here.\n            // for higher pixel density devices (mobile phones, etc), we'll use 2\n            // otherwise it defaults to 1\n            const devicePixelRatio = getDevicePixelRatio();\n            if (devicePixelRatio > 2) {\n                return 2;\n            } else {\n                return 1;\n            }\n        }\n        return pixelDensity;\n    }\n}\nclass HTMLElementInfo {\n    get visible() {\n        return this.isPiP || this.isIntersecting;\n    }\n    get pictureInPicture() {\n        return this.isPiP;\n    }\n    constructor(element, visible){\n        this.onVisibilityChanged = (entry)=>{\n            var _a;\n            const { target, isIntersecting } = entry;\n            if (target === this.element) {\n                this.isIntersecting = isIntersecting;\n                this.isPiP = isElementInPiP(this.element);\n                this.visibilityChangedAt = Date.now();\n                (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n        };\n        this.onEnterPiP = ()=>{\n            var _a, _b, _c;\n            (_b = (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) === null || _b === void 0 ? void 0 : _b.addEventListener(\"pagehide\", this.onLeavePiP);\n            this.isPiP = isElementInPiP(this.element);\n            (_c = this.handleVisibilityChanged) === null || _c === void 0 ? void 0 : _c.call(this);\n        };\n        this.onLeavePiP = ()=>{\n            var _a;\n            this.isPiP = isElementInPiP(this.element);\n            (_a = this.handleVisibilityChanged) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element = element;\n        this.isIntersecting = visible !== null && visible !== void 0 ? visible : isElementInViewport(element);\n        this.isPiP = isWeb() && isElementInPiP(element);\n        this.visibilityChangedAt = 0;\n    }\n    width() {\n        return this.element.clientWidth;\n    }\n    height() {\n        return this.element.clientHeight;\n    }\n    observe() {\n        var _a, _b, _c;\n        // make sure we update the current visible state once we start to observe\n        this.isIntersecting = isElementInViewport(this.element);\n        this.isPiP = isElementInPiP(this.element);\n        this.element.handleResize = ()=>{\n            var _a;\n            (_a = this.handleResize) === null || _a === void 0 ? void 0 : _a.call(this);\n        };\n        this.element.handleVisibilityChanged = this.onVisibilityChanged;\n        getIntersectionObserver().observe(this.element);\n        getResizeObserver().observe(this.element);\n        this.element.addEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.addEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n        (_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.addEventListener(\"enter\", this.onEnterPiP);\n        (_c = (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window) === null || _c === void 0 ? void 0 : _c.addEventListener(\"pagehide\", this.onLeavePiP);\n    }\n    stopObserving() {\n        var _a, _b, _c, _d, _e;\n        (_a = getIntersectionObserver()) === null || _a === void 0 ? void 0 : _a.unobserve(this.element);\n        (_b = getResizeObserver()) === null || _b === void 0 ? void 0 : _b.unobserve(this.element);\n        this.element.removeEventListener(\"enterpictureinpicture\", this.onEnterPiP);\n        this.element.removeEventListener(\"leavepictureinpicture\", this.onLeavePiP);\n        (_c = window.documentPictureInPicture) === null || _c === void 0 ? void 0 : _c.removeEventListener(\"enter\", this.onEnterPiP);\n        (_e = (_d = window.documentPictureInPicture) === null || _d === void 0 ? void 0 : _d.window) === null || _e === void 0 ? void 0 : _e.removeEventListener(\"pagehide\", this.onLeavePiP);\n    }\n}\nfunction isElementInPiP(el) {\n    var _a, _b;\n    // Simple video PiP\n    if (document.pictureInPictureElement === el) return true;\n    // Document PiP\n    if ((_a = window.documentPictureInPicture) === null || _a === void 0 ? void 0 : _a.window) return isElementInViewport(el, (_b = window.documentPictureInPicture) === null || _b === void 0 ? void 0 : _b.window);\n    return false;\n}\n// does not account for occlusion by other elements or opacity property\nfunction isElementInViewport(el, win) {\n    const viewportWindow = win || window;\n    let top = el.offsetTop;\n    let left = el.offsetLeft;\n    const width = el.offsetWidth;\n    const height = el.offsetHeight;\n    const { hidden } = el;\n    const { display } = getComputedStyle(el);\n    while(el.offsetParent){\n        el = el.offsetParent;\n        top += el.offsetTop;\n        left += el.offsetLeft;\n    }\n    return top < viewportWindow.pageYOffset + viewportWindow.innerHeight && left < viewportWindow.pageXOffset + viewportWindow.innerWidth && top + height > viewportWindow.pageYOffset && left + width > viewportWindow.pageXOffset && !hidden && display !== \"none\";\n}\nclass TrackPublication extends eventsExports.EventEmitter {\n    constructor(kind, id, name, loggerOptions){\n        var _a;\n        super();\n        this.metadataMuted = false;\n        this.encryption = Encryption_Type.NONE;\n        this.log = livekitLogger;\n        this.handleMuted = ()=>{\n            this.emit(TrackEvent.Muted);\n        };\n        this.handleUnmuted = ()=>{\n            this.emit(TrackEvent.Unmuted);\n        };\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Publication);\n        this.loggerContextCb = this.loggerContextCb;\n        this.setMaxListeners(100);\n        this.kind = kind;\n        this.trackSid = id;\n        this.trackName = name;\n        this.source = Track.Source.Unknown;\n    }\n    /** @internal */ setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Muted, this.handleMuted);\n            this.track.off(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n        this.track = track;\n        if (track) {\n            // forward events\n            track.on(TrackEvent.Muted, this.handleMuted);\n            track.on(TrackEvent.Unmuted, this.handleUnmuted);\n        }\n    }\n    get logContext() {\n        var _a;\n        return Object.assign(Object.assign({}, (_a = this.loggerContextCb) === null || _a === void 0 ? void 0 : _a.call(this)), getLogContextFromTrack(this));\n    }\n    get isMuted() {\n        return this.metadataMuted;\n    }\n    get isEnabled() {\n        return true;\n    }\n    get isSubscribed() {\n        return this.track !== undefined;\n    }\n    get isEncrypted() {\n        return this.encryption !== Encryption_Type.NONE;\n    }\n    /**\n   * an [AudioTrack] if this publication holds an audio track\n   */ get audioTrack() {\n        if (isAudioTrack(this.track)) {\n            return this.track;\n        }\n    }\n    /**\n   * an [VideoTrack] if this publication holds a video track\n   */ get videoTrack() {\n        if (isVideoTrack(this.track)) {\n            return this.track;\n        }\n    }\n    /** @internal */ updateInfo(info) {\n        this.trackSid = info.sid;\n        this.trackName = info.name;\n        this.source = Track.sourceFromProto(info.source);\n        this.mimeType = info.mimeType;\n        if (this.kind === Track.Kind.Video && info.width > 0) {\n            this.dimensions = {\n                width: info.width,\n                height: info.height\n            };\n            this.simulcasted = info.simulcast;\n        }\n        this.encryption = info.encryption;\n        this.trackInfo = info;\n        this.log.debug(\"update publication info\", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n    }\n}\n(function(TrackPublication) {\n    (function(SubscriptionStatus) {\n        SubscriptionStatus[\"Desired\"] = \"desired\";\n        SubscriptionStatus[\"Subscribed\"] = \"subscribed\";\n        SubscriptionStatus[\"Unsubscribed\"] = \"unsubscribed\";\n    })(TrackPublication.SubscriptionStatus || (TrackPublication.SubscriptionStatus = {}));\n    (function(PermissionStatus) {\n        PermissionStatus[\"Allowed\"] = \"allowed\";\n        PermissionStatus[\"NotAllowed\"] = \"not_allowed\";\n    })(TrackPublication.PermissionStatus || (TrackPublication.PermissionStatus = {}));\n})(TrackPublication || (TrackPublication = {}));\nclass LocalTrackPublication extends TrackPublication {\n    get isUpstreamPaused() {\n        var _a;\n        return (_a = this.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused;\n    }\n    constructor(kind, ti, track, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        this.handleTrackEnded = ()=>{\n            this.emit(TrackEvent.Ended);\n        };\n        this.updateInfo(ti);\n        this.setTrack(track);\n    }\n    setTrack(track) {\n        if (this.track) {\n            this.track.off(TrackEvent.Ended, this.handleTrackEnded);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n        }\n    }\n    get isMuted() {\n        if (this.track) {\n            return this.track.isMuted;\n        }\n        return super.isMuted;\n    }\n    get audioTrack() {\n        return super.audioTrack;\n    }\n    get videoTrack() {\n        return super.videoTrack;\n    }\n    get isLocal() {\n        return true;\n    }\n    /**\n   * Mute the track associated with this publication\n   */ mute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.mute();\n        });\n    }\n    /**\n   * Unmute track associated with this publication\n   */ unmute() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            return (_a = this.track) === null || _a === void 0 ? void 0 : _a.unmute();\n        });\n    }\n    /**\n   * Pauses the media stream track associated with this publication from being sent to the server\n   * and signals \"muted\" event to other participants\n   * Useful if you want to pause the stream without pausing the local media stream track\n   */ pauseUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.pauseUpstream();\n        });\n    }\n    /**\n   * Resumes sending the media stream track associated with this publication to the server after a call to [[pauseUpstream()]]\n   * and signals \"unmuted\" event to other participants (unless the track is explicitly muted)\n   */ resumeUpstream() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            yield (_a = this.track) === null || _a === void 0 ? void 0 : _a.resumeUpstream();\n        });\n    }\n    getTrackFeatures() {\n        var _a;\n        if (isAudioTrack(this.track)) {\n            const settings = this.track.getSourceTrackSettings();\n            const features = new Set();\n            if (settings.autoGainControl) {\n                features.add(AudioTrackFeature.TF_AUTO_GAIN_CONTROL);\n            }\n            if (settings.echoCancellation) {\n                features.add(AudioTrackFeature.TF_ECHO_CANCELLATION);\n            }\n            if (settings.noiseSuppression) {\n                features.add(AudioTrackFeature.TF_NOISE_SUPPRESSION);\n            }\n            if (settings.channelCount && settings.channelCount > 1) {\n                features.add(AudioTrackFeature.TF_STEREO);\n            }\n            if (!((_a = this.options) === null || _a === void 0 ? void 0 : _a.dtx)) {\n                features.add(AudioTrackFeature.TF_NO_DTX);\n            }\n            if (this.track.enhancedNoiseCancellation) {\n                features.add(AudioTrackFeature.TF_ENHANCED_NOISE_CANCELLATION);\n            }\n            return Array.from(features.values());\n        } else return [];\n    }\n}\n/**\n * Creates a local video and audio track at the same time. When acquiring both\n * audio and video tracks together, it'll display a single permission prompt to\n * the user instead of two separate ones.\n * @param options\n */ function createLocalTracks(options, loggerOptions) {\n    return __awaiter(this, void 0, void 0, function*() {\n        options !== null && options !== void 0 ? options : options = {};\n        let attemptExactMatch = false;\n        const { audioProcessor, videoProcessor, optionsWithoutProcessor: internalOptions } = extractProcessorsFromOptions(options);\n        let retryAudioOptions = internalOptions.audio;\n        let retryVideoOptions = internalOptions.video;\n        if (audioProcessor && typeof internalOptions.audio === \"object\") {\n            internalOptions.audio.processor = audioProcessor;\n        }\n        if (videoProcessor && typeof internalOptions.video === \"object\") {\n            internalOptions.video.processor = videoProcessor;\n        }\n        // if the user passes a device id as a string, we default to exact match\n        if (options.audio && typeof internalOptions.audio === \"object\" && typeof internalOptions.audio.deviceId === \"string\") {\n            const deviceId = internalOptions.audio.deviceId;\n            internalOptions.audio.deviceId = {\n                exact: deviceId\n            };\n            attemptExactMatch = true;\n            retryAudioOptions = Object.assign(Object.assign({}, internalOptions.audio), {\n                deviceId: {\n                    ideal: deviceId\n                }\n            });\n        }\n        if (internalOptions.video && typeof internalOptions.video === \"object\" && typeof internalOptions.video.deviceId === \"string\") {\n            const deviceId = internalOptions.video.deviceId;\n            internalOptions.video.deviceId = {\n                exact: deviceId\n            };\n            attemptExactMatch = true;\n            retryVideoOptions = Object.assign(Object.assign({}, internalOptions.video), {\n                deviceId: {\n                    ideal: deviceId\n                }\n            });\n        }\n        // TODO if internal options don't have device Id specified, set it to 'default'\n        if (internalOptions.audio === true || typeof internalOptions.audio === \"object\" && !internalOptions.audio.deviceId) {\n            internalOptions.audio = {\n                deviceId: \"default\"\n            };\n        }\n        if (internalOptions.video === true || typeof internalOptions.video === \"object\" && !internalOptions.video.deviceId) {\n            internalOptions.video = {\n                deviceId: \"default\"\n            };\n        }\n        const opts = mergeDefaultOptions(internalOptions, audioDefaults, videoDefaults);\n        const constraints = constraintsForOptions(opts);\n        // Keep a reference to the promise on DeviceManager and await it in getLocalDevices()\n        // works around iOS Safari Bug https://bugs.webkit.org/show_bug.cgi?id=179363\n        const mediaPromise = navigator.mediaDevices.getUserMedia(constraints);\n        if (internalOptions.audio) {\n            DeviceManager.userMediaPromiseMap.set(\"audioinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"audioinput\"));\n        }\n        if (internalOptions.video) {\n            DeviceManager.userMediaPromiseMap.set(\"videoinput\", mediaPromise);\n            mediaPromise.catch(()=>DeviceManager.userMediaPromiseMap.delete(\"videoinput\"));\n        }\n        try {\n            const stream = yield mediaPromise;\n            return yield Promise.all(stream.getTracks().map((mediaStreamTrack)=>__awaiter(this, void 0, void 0, function*() {\n                    const isAudio = mediaStreamTrack.kind === \"audio\";\n                    let trackOptions = isAudio ? opts.audio : opts.video;\n                    if (typeof trackOptions === \"boolean\" || !trackOptions) {\n                        trackOptions = {};\n                    }\n                    let trackConstraints;\n                    const conOrBool = isAudio ? constraints.audio : constraints.video;\n                    if (typeof conOrBool !== \"boolean\") {\n                        trackConstraints = conOrBool;\n                    }\n                    // update the constraints with the device id the user gave permissions to in the permission prompt\n                    // otherwise each track restart (e.g. mute - unmute) will try to initialize the device again -> causing additional permission prompts\n                    const newDeviceId = mediaStreamTrack.getSettings().deviceId;\n                    if ((trackConstraints === null || trackConstraints === void 0 ? void 0 : trackConstraints.deviceId) && unwrapConstraint(trackConstraints.deviceId) !== newDeviceId) {\n                        trackConstraints.deviceId = newDeviceId;\n                    } else if (!trackConstraints) {\n                        trackConstraints = {\n                            deviceId: newDeviceId\n                        };\n                    }\n                    const track = mediaTrackToLocalTrack(mediaStreamTrack, trackConstraints, loggerOptions);\n                    if (track.kind === Track.Kind.Video) {\n                        track.source = Track.Source.Camera;\n                    } else if (track.kind === Track.Kind.Audio) {\n                        track.source = Track.Source.Microphone;\n                    }\n                    track.mediaStream = stream;\n                    if (isAudioTrack(track) && audioProcessor) {\n                        yield track.setProcessor(audioProcessor);\n                    } else if (isVideoTrack(track) && videoProcessor) {\n                        yield track.setProcessor(videoProcessor);\n                    }\n                    return track;\n                })));\n        } catch (e) {\n            if (!attemptExactMatch) {\n                throw e;\n            }\n            return createLocalTracks(Object.assign(Object.assign({}, options), {\n                audio: retryAudioOptions,\n                video: retryVideoOptions\n            }), loggerOptions);\n        }\n    });\n}\n/**\n * Creates a [[LocalVideoTrack]] with getUserMedia()\n * @param options\n */ function createLocalVideoTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: false,\n            video: options !== null && options !== void 0 ? options : true\n        });\n        return tracks[0];\n    });\n}\nfunction createLocalAudioTrack(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        const tracks = yield createLocalTracks({\n            audio: options !== null && options !== void 0 ? options : true,\n            video: false\n        });\n        return tracks[0];\n    });\n}\n/**\n * Creates a screen capture tracks with getDisplayMedia().\n * A LocalVideoTrack is always created and returned.\n * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n */ function createLocalScreenTracks(options) {\n    return __awaiter(this, void 0, void 0, function*() {\n        if (options === undefined) {\n            options = {};\n        }\n        if (options.resolution === undefined && !isSafari17()) {\n            options.resolution = ScreenSharePresets.h1080fps30.resolution;\n        }\n        if (navigator.mediaDevices.getDisplayMedia === undefined) {\n            throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n        }\n        const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n        const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n        const tracks = stream.getVideoTracks();\n        if (tracks.length === 0) {\n            throw new TrackInvalidError(\"no video track found\");\n        }\n        const screenVideo = new LocalVideoTrack(tracks[0], undefined, false);\n        screenVideo.source = Track.Source.ScreenShare;\n        const localTracks = [\n            screenVideo\n        ];\n        if (stream.getAudioTracks().length > 0) {\n            const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false);\n            screenAudio.source = Track.Source.ScreenShareAudio;\n            localTracks.push(screenAudio);\n        }\n        return localTracks;\n    });\n}\nvar ConnectionQuality;\n(function(ConnectionQuality) {\n    ConnectionQuality[\"Excellent\"] = \"excellent\";\n    ConnectionQuality[\"Good\"] = \"good\";\n    ConnectionQuality[\"Poor\"] = \"poor\";\n    /**\n   * Indicates that a participant has temporarily (or permanently) lost connection to LiveKit.\n   * For permanent disconnection a `ParticipantDisconnected` event will be emitted after a timeout\n   */ ConnectionQuality[\"Lost\"] = \"lost\";\n    ConnectionQuality[\"Unknown\"] = \"unknown\";\n})(ConnectionQuality || (ConnectionQuality = {}));\nfunction qualityFromProto(q) {\n    switch(q){\n        case ConnectionQuality$1.EXCELLENT:\n            return ConnectionQuality.Excellent;\n        case ConnectionQuality$1.GOOD:\n            return ConnectionQuality.Good;\n        case ConnectionQuality$1.POOR:\n            return ConnectionQuality.Poor;\n        case ConnectionQuality$1.LOST:\n            return ConnectionQuality.Lost;\n        default:\n            return ConnectionQuality.Unknown;\n    }\n}\nclass Participant extends eventsExports.EventEmitter {\n    get logContext() {\n        var _a, _b;\n        return Object.assign({}, (_b = (_a = this.loggerOptions) === null || _a === void 0 ? void 0 : _a.loggerContextCb) === null || _b === void 0 ? void 0 : _b.call(_a));\n    }\n    get isEncrypted() {\n        return this.trackPublications.size > 0 && Array.from(this.trackPublications.values()).every((tr)=>tr.isEncrypted);\n    }\n    get isAgent() {\n        var _a;\n        return ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.agent) || this.kind === ParticipantInfo_Kind.AGENT;\n    }\n    get kind() {\n        return this._kind;\n    }\n    /** participant attributes, similar to metadata, but as a key/value map */ get attributes() {\n        return Object.freeze(Object.assign({}, this._attributes));\n    }\n    /** @internal */ constructor(sid, identity, name, metadata, attributes, loggerOptions){\n        let kind = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : ParticipantInfo_Kind.STANDARD;\n        var _a;\n        super();\n        /** audio level between 0-1.0, 1 being loudest, 0 being softest */ this.audioLevel = 0;\n        /** if participant is currently speaking */ this.isSpeaking = false;\n        this._connectionQuality = ConnectionQuality.Unknown;\n        this.log = livekitLogger;\n        this.log = getLogger((_a = loggerOptions === null || loggerOptions === void 0 ? void 0 : loggerOptions.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Participant);\n        this.loggerOptions = loggerOptions;\n        this.setMaxListeners(100);\n        this.sid = sid;\n        this.identity = identity;\n        this.name = name;\n        this.metadata = metadata;\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.trackPublications = new Map();\n        this._kind = kind;\n        this._attributes = attributes !== null && attributes !== void 0 ? attributes : {};\n    }\n    getTrackPublications() {\n        return Array.from(this.trackPublications.values());\n    }\n    /**\n   * Finds the first track that matches the source filter, for example, getting\n   * the user's camera track with getTrackBySource(Track.Source.Camera).\n   */ getTrackPublication(source) {\n        for (const [, pub] of this.trackPublications){\n            if (pub.source === source) {\n                return pub;\n            }\n        }\n    }\n    /**\n   * Finds the first track that matches the track's name.\n   */ getTrackPublicationByName(name) {\n        for (const [, pub] of this.trackPublications){\n            if (pub.trackName === name) {\n                return pub;\n            }\n        }\n    }\n    get connectionQuality() {\n        return this._connectionQuality;\n    }\n    get isCameraEnabled() {\n        var _a;\n        const track = this.getTrackPublication(Track.Source.Camera);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isMicrophoneEnabled() {\n        var _a;\n        const track = this.getTrackPublication(Track.Source.Microphone);\n        return !((_a = track === null || track === void 0 ? void 0 : track.isMuted) !== null && _a !== void 0 ? _a : true);\n    }\n    get isScreenShareEnabled() {\n        const track = this.getTrackPublication(Track.Source.ScreenShare);\n        return !!track;\n    }\n    get isLocal() {\n        return false;\n    }\n    /** when participant joined the room */ get joinedAt() {\n        if (this.participantInfo) {\n            return new Date(Number.parseInt(this.participantInfo.joinedAt.toString()) * 1000);\n        }\n        return new Date();\n    }\n    /** @internal */ updateInfo(info) {\n        // it's possible the update could be applied out of order due to await\n        // during reconnect sequences. when that happens, it's possible for server\n        // to have sent more recent version of participant info while JS is waiting\n        // to process the existing payload.\n        // when the participant sid remains the same, and we already have a later version\n        // of the payload, they can be safely skipped\n        if (this.participantInfo && this.participantInfo.sid === info.sid && this.participantInfo.version > info.version) {\n            return false;\n        }\n        this.identity = info.identity;\n        this.sid = info.sid;\n        this._setName(info.name);\n        this._setMetadata(info.metadata);\n        this._setAttributes(info.attributes);\n        if (info.permission) {\n            this.setPermissions(info.permission);\n        }\n        // set this last so setMetadata can detect changes\n        this.participantInfo = info;\n        this.log.trace(\"update participant info\", Object.assign(Object.assign({}, this.logContext), {\n            info\n        }));\n        return true;\n    }\n    /**\n   * Updates metadata from server\n   **/ _setMetadata(md) {\n        const changed = this.metadata !== md;\n        const prevMetadata = this.metadata;\n        this.metadata = md;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantMetadataChanged, prevMetadata);\n        }\n    }\n    _setName(name) {\n        const changed = this.name !== name;\n        this.name = name;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantNameChanged, name);\n        }\n    }\n    /**\n   * Updates metadata from server\n   **/ _setAttributes(attributes) {\n        const diff = diffAttributes(this.attributes, attributes);\n        this._attributes = attributes;\n        if (Object.keys(diff).length > 0) {\n            this.emit(ParticipantEvent.AttributesChanged, diff);\n        }\n    }\n    /** @internal */ setPermissions(permissions) {\n        var _a, _b, _c, _d, _e, _f;\n        const prevPermissions = this.permissions;\n        const changed = permissions.canPublish !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublish) || permissions.canSubscribe !== ((_b = this.permissions) === null || _b === void 0 ? void 0 : _b.canSubscribe) || permissions.canPublishData !== ((_c = this.permissions) === null || _c === void 0 ? void 0 : _c.canPublishData) || permissions.hidden !== ((_d = this.permissions) === null || _d === void 0 ? void 0 : _d.hidden) || permissions.recorder !== ((_e = this.permissions) === null || _e === void 0 ? void 0 : _e.recorder) || permissions.canPublishSources.length !== this.permissions.canPublishSources.length || permissions.canPublishSources.some((value, index)=>{\n            var _a;\n            return value !== ((_a = this.permissions) === null || _a === void 0 ? void 0 : _a.canPublishSources[index]);\n        }) || permissions.canSubscribeMetrics !== ((_f = this.permissions) === null || _f === void 0 ? void 0 : _f.canSubscribeMetrics);\n        this.permissions = permissions;\n        if (changed) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setIsSpeaking(speaking) {\n        if (speaking === this.isSpeaking) {\n            return;\n        }\n        this.isSpeaking = speaking;\n        if (speaking) {\n            this.lastSpokeAt = new Date();\n        }\n        this.emit(ParticipantEvent.IsSpeakingChanged, speaking);\n    }\n    /** @internal */ setConnectionQuality(q) {\n        const prevQuality = this._connectionQuality;\n        this._connectionQuality = qualityFromProto(q);\n        if (prevQuality !== this._connectionQuality) {\n            this.emit(ParticipantEvent.ConnectionQualityChanged, this._connectionQuality);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioContext(ctx) {\n        this.audioContext = ctx;\n        this.audioTrackPublications.forEach((track)=>isAudioTrack(track.track) && track.track.setAudioContext(ctx));\n    }\n    addTrackPublication(publication) {\n        // forward publication driven events\n        publication.on(TrackEvent.Muted, ()=>{\n            this.emit(ParticipantEvent.TrackMuted, publication);\n        });\n        publication.on(TrackEvent.Unmuted, ()=>{\n            this.emit(ParticipantEvent.TrackUnmuted, publication);\n        });\n        const pub = publication;\n        if (pub.track) {\n            pub.track.sid = publication.trackSid;\n        }\n        this.trackPublications.set(publication.trackSid, publication);\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTrackPublications.set(publication.trackSid, publication);\n                break;\n            case Track.Kind.Video:\n                this.videoTrackPublications.set(publication.trackSid, publication);\n                break;\n        }\n    }\n}\nfunction trackPermissionToProto(perms) {\n    var _a, _b, _c;\n    if (!perms.participantSid && !perms.participantIdentity) {\n        throw new Error(\"Invalid track permission, must provide at least one of participantIdentity and participantSid\");\n    }\n    return new TrackPermission({\n        participantIdentity: (_a = perms.participantIdentity) !== null && _a !== void 0 ? _a : \"\",\n        participantSid: (_b = perms.participantSid) !== null && _b !== void 0 ? _b : \"\",\n        allTracks: (_c = perms.allowAll) !== null && _c !== void 0 ? _c : false,\n        trackSids: perms.allowedTrackSids || []\n    });\n}\nconst STREAM_CHUNK_SIZE = 15000;\nclass LocalParticipant extends Participant {\n    /** @internal */ constructor(sid, identity, engine, options, roomRpcHandlers){\n        super(sid, identity, undefined, undefined, undefined, {\n            loggerName: options.loggerName,\n            loggerContextCb: ()=>this.engine.logContext\n        });\n        this.pendingPublishing = new Set();\n        this.pendingPublishPromises = new Map();\n        this.participantTrackPermissions = [];\n        this.allParticipantsAllowedToSubscribe = true;\n        this.encryptionType = Encryption_Type.NONE;\n        this.enabledPublishVideoCodecs = [];\n        this.pendingAcks = new Map();\n        this.pendingResponses = new Map();\n        this.handleReconnecting = ()=>{\n            if (!this.reconnectFuture) {\n                this.reconnectFuture = new Future();\n            }\n        };\n        this.handleReconnected = ()=>{\n            var _a, _b;\n            (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.resolve) === null || _b === void 0 ? void 0 : _b.call(_a);\n            this.reconnectFuture = undefined;\n            this.updateTrackSubscriptionPermissions();\n        };\n        this.handleDisconnected = ()=>{\n            var _a, _b;\n            if (this.reconnectFuture) {\n                this.reconnectFuture.promise.catch((e)=>this.log.warn(e.message, this.logContext));\n                (_b = (_a = this.reconnectFuture) === null || _a === void 0 ? void 0 : _a.reject) === null || _b === void 0 ? void 0 : _b.call(_a, \"Got disconnected during reconnection attempt\");\n                this.reconnectFuture = undefined;\n            }\n        };\n        this.handleSignalRequestResponse = (response)=>{\n            const { requestId, reason, message } = response;\n            const targetRequest = this.pendingSignalRequests.get(requestId);\n            if (targetRequest) {\n                if (reason !== RequestResponse_Reason.OK) {\n                    targetRequest.reject(new SignalRequestError(message, reason));\n                }\n                this.pendingSignalRequests.delete(requestId);\n            }\n        };\n        this.handleDataPacket = (packet)=>{\n            switch(packet.value.case){\n                case \"rpcResponse\":\n                    let rpcResponse = packet.value.value;\n                    let payload = null;\n                    let error = null;\n                    if (rpcResponse.value.case === \"payload\") {\n                        payload = rpcResponse.value.value;\n                    } else if (rpcResponse.value.case === \"error\") {\n                        error = RpcError.fromProto(rpcResponse.value.value);\n                    }\n                    this.handleIncomingRpcResponse(rpcResponse.requestId, payload, error);\n                    break;\n                case \"rpcAck\":\n                    let rpcAck = packet.value.value;\n                    this.handleIncomingRpcAck(rpcAck.requestId);\n                    break;\n            }\n        };\n        this.updateTrackSubscriptionPermissions = ()=>{\n            this.log.debug(\"updating track subscription permissions\", Object.assign(Object.assign({}, this.logContext), {\n                allParticipantsAllowed: this.allParticipantsAllowedToSubscribe,\n                participantTrackPermissions: this.participantTrackPermissions\n            }));\n            this.engine.client.sendUpdateSubscriptionPermissions(this.allParticipantsAllowedToSubscribe, this.participantTrackPermissions.map((p)=>trackPermissionToProto(p)));\n        };\n        /** @internal */ this.onTrackUnmuted = (track)=>{\n            this.onTrackMuted(track, track.isUpstreamPaused);\n        };\n        // when the local track changes in mute status, we'll notify server as such\n        /** @internal */ this.onTrackMuted = (track, muted)=>{\n            if (muted === undefined) {\n                muted = true;\n            }\n            if (!track.sid) {\n                this.log.error(\"could not update mute status for unpublished track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            this.engine.updateMuteStatus(track.sid, muted);\n        };\n        this.onTrackUpstreamPaused = (track)=>{\n            this.log.debug(\"upstream paused\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, true);\n        };\n        this.onTrackUpstreamResumed = (track)=>{\n            this.log.debug(\"upstream resumed\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            this.onTrackMuted(track, track.isMuted);\n        };\n        this.onTrackFeatureUpdate = (track)=>{\n            const pub = this.audioTrackPublications.get(track.sid);\n            if (!pub) {\n                this.log.warn(\"Could not update local audio track settings, missing publication for track \".concat(track.sid), this.logContext);\n                return;\n            }\n            this.engine.client.sendUpdateLocalAudioTrack(pub.trackSid, pub.getTrackFeatures());\n        };\n        this.handleSubscribedQualityUpdate = (update)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, e_1, _b, _c;\n                var _d, _e;\n                if (!((_d = this.roomOptions) === null || _d === void 0 ? void 0 : _d.dynacast)) {\n                    return;\n                }\n                const pub = this.videoTrackPublications.get(update.trackSid);\n                if (!pub) {\n                    this.log.warn(\"received subscribed quality update for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                        trackSid: update.trackSid\n                    }));\n                    return;\n                }\n                if (update.subscribedCodecs.length > 0) {\n                    if (!pub.videoTrack) {\n                        return;\n                    }\n                    const newCodecs = yield pub.videoTrack.setPublishingCodecs(update.subscribedCodecs);\n                    try {\n                        for(var _f = true, newCodecs_1 = __asyncValues(newCodecs), newCodecs_1_1; newCodecs_1_1 = yield newCodecs_1.next(), _a = newCodecs_1_1.done, !_a; _f = true){\n                            _c = newCodecs_1_1.value;\n                            _f = false;\n                            const codec = _c;\n                            if (isBackupCodec(codec)) {\n                                this.log.debug(\"publish \".concat(codec, \" for \").concat(pub.videoTrack.sid), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)));\n                                yield this.publishAdditionalCodecForTrack(pub.videoTrack, codec, pub.options);\n                            }\n                        }\n                    } catch (e_1_1) {\n                        e_1 = {\n                            error: e_1_1\n                        };\n                    } finally{\n                        try {\n                            if (!_f && !_a && (_b = newCodecs_1.return)) yield _b.call(newCodecs_1);\n                        } finally{\n                            if (e_1) throw e_1.error;\n                        }\n                    }\n                } else if (update.subscribedQualities.length > 0) {\n                    yield (_e = pub.videoTrack) === null || _e === void 0 ? void 0 : _e.setPublishingLayers(update.subscribedQualities);\n                }\n            });\n        this.handleLocalTrackUnpublished = (unpublished)=>{\n            const track = this.trackPublications.get(unpublished.trackSid);\n            if (!track) {\n                this.log.warn(\"received unpublished event for unknown track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: unpublished.trackSid\n                }));\n                return;\n            }\n            this.unpublishTrack(track.track);\n        };\n        this.handleTrackEnded = (track)=>__awaiter(this, void 0, void 0, function*() {\n                if (track.source === Track.Source.ScreenShare || track.source === Track.Source.ScreenShareAudio) {\n                    this.log.debug(\"unpublishing local track due to TrackEnded\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    this.unpublishTrack(track);\n                } else if (track.isUserProvided) {\n                    yield track.mute();\n                } else if (isLocalAudioTrack(track) || isLocalVideoTrack(track)) {\n                    try {\n                        if (isWeb()) {\n                            try {\n                                const currentPermissions = yield navigator === null || navigator === void 0 ? void 0 : navigator.permissions.query({\n                                    // the permission query for camera and microphone currently not supported in Safari and Firefox\n                                    // @ts-ignore\n                                    name: track.source === Track.Source.Camera ? \"camera\" : \"microphone\"\n                                });\n                                if (currentPermissions && currentPermissions.state === \"denied\") {\n                                    this.log.warn(\"user has revoked access to \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                                    // detect granted change after permissions were denied to try and resume then\n                                    currentPermissions.onchange = ()=>{\n                                        if (currentPermissions.state !== \"denied\") {\n                                            if (!track.isMuted) {\n                                                track.restartTrack();\n                                            }\n                                            currentPermissions.onchange = null;\n                                        }\n                                    };\n                                    throw new Error(\"GetUserMedia Permission denied\");\n                                }\n                            } catch (e) {\n                            // permissions query fails for firefox, we continue and try to restart the track\n                            }\n                        }\n                        if (!track.isMuted) {\n                            this.log.debug(\"track ended, attempting to use a different device\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            if (isLocalAudioTrack(track)) {\n                                // fall back to default device if available\n                                yield track.restartTrack({\n                                    deviceId: \"default\"\n                                });\n                            } else {\n                                yield track.restartTrack();\n                            }\n                        }\n                    } catch (e) {\n                        this.log.warn(\"could not restart track, muting instead\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                        yield track.mute();\n                    }\n                }\n            });\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.trackPublications = new Map();\n        this.engine = engine;\n        this.roomOptions = options;\n        this.setupEngine(engine);\n        this.activeDeviceMap = new Map([\n            [\n                \"audioinput\",\n                \"default\"\n            ],\n            [\n                \"videoinput\",\n                \"default\"\n            ],\n            [\n                \"audiooutput\",\n                \"default\"\n            ]\n        ]);\n        this.pendingSignalRequests = new Map();\n        this.rpcHandlers = roomRpcHandlers;\n    }\n    get lastCameraError() {\n        return this.cameraError;\n    }\n    get lastMicrophoneError() {\n        return this.microphoneError;\n    }\n    get isE2EEEnabled() {\n        return this.encryptionType !== Encryption_Type.NONE;\n    }\n    getTrackPublication(source) {\n        const track = super.getTrackPublication(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackPublicationByName(name) {\n        const track = super.getTrackPublicationByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * @internal\n   */ setupEngine(engine) {\n        this.engine = engine;\n        this.engine.on(EngineEvent.RemoteMute, (trackSid, muted)=>{\n            const pub = this.trackPublications.get(trackSid);\n            if (!pub || !pub.track) {\n                return;\n            }\n            if (muted) {\n                pub.mute();\n            } else {\n                pub.unmute();\n            }\n        });\n        this.engine.on(EngineEvent.Connected, this.handleReconnected).on(EngineEvent.SignalRestarted, this.handleReconnected).on(EngineEvent.SignalResumed, this.handleReconnected).on(EngineEvent.Restarting, this.handleReconnecting).on(EngineEvent.Resuming, this.handleReconnecting).on(EngineEvent.LocalTrackUnpublished, this.handleLocalTrackUnpublished).on(EngineEvent.SubscribedQualityUpdate, this.handleSubscribedQualityUpdate).on(EngineEvent.Disconnected, this.handleDisconnected).on(EngineEvent.SignalRequestResponse, this.handleSignalRequestResponse).on(EngineEvent.DataPacketReceived, this.handleDataPacket);\n    }\n    /**\n   * Sets and updates the metadata of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */ setMetadata(metadata) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                metadata\n            });\n        });\n    }\n    /**\n   * Sets and updates the name of the local participant.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * method will throw if the user doesn't have the required permissions\n   * @param metadata\n   */ setName(name) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                name\n            });\n        });\n    }\n    /**\n   * Set or update participant attributes. It will make updates only to keys that\n   * are present in `attributes`, and will not override others.\n   * Note: this requires `canUpdateOwnMetadata` permission.\n   * @param attributes attributes to update\n   */ setAttributes(attributes) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.requestMetadataUpdate({\n                attributes\n            });\n        });\n    }\n    requestMetadataUpdate(_a) {\n        return __awaiter(this, arguments, void 0, function(_ref) {\n            var _this = this;\n            let { metadata, name, attributes } = _ref;\n            return function*() {\n                return new Promise((resolve, reject)=>__awaiter(_this, void 0, void 0, function*() {\n                        var _a, _b;\n                        try {\n                            let isRejected = false;\n                            const requestId = yield this.engine.client.sendUpdateLocalMetadata((_a = metadata !== null && metadata !== void 0 ? metadata : this.metadata) !== null && _a !== void 0 ? _a : \"\", (_b = name !== null && name !== void 0 ? name : this.name) !== null && _b !== void 0 ? _b : \"\", attributes);\n                            const startTime = performance.now();\n                            this.pendingSignalRequests.set(requestId, {\n                                resolve,\n                                reject: (error)=>{\n                                    reject(error);\n                                    isRejected = true;\n                                },\n                                values: {\n                                    name,\n                                    metadata,\n                                    attributes\n                                }\n                            });\n                            while(performance.now() - startTime < 5000 && !isRejected){\n                                if ((!name || this.name === name) && (!metadata || this.metadata === metadata) && (!attributes || Object.entries(attributes).every((_ref2)=>{\n                                    let [key, value] = _ref2;\n                                    return this.attributes[key] === value || value === \"\" && !this.attributes[key];\n                                }))) {\n                                    this.pendingSignalRequests.delete(requestId);\n                                    resolve();\n                                    return;\n                                }\n                                yield sleep(50);\n                            }\n                            reject(new SignalRequestError(\"Request to update local metadata timed out\", \"TimeoutError\"));\n                        } catch (e) {\n                            if (e instanceof Error) reject(e);\n                        }\n                    }));\n            }();\n        });\n    }\n    /**\n   * Enable or disable a participant's camera track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setCameraEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Camera, enabled, options, publishOptions);\n    }\n    /**\n   * Enable or disable a participant's microphone track.\n   *\n   * If a track has already published, it'll mute or unmute the track.\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setMicrophoneEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.Microphone, enabled, options, publishOptions);\n    }\n    /**\n   * Start or stop sharing a participant's screen\n   * Resolves with a `LocalTrackPublication` instance if successful and `undefined` otherwise\n   */ setScreenShareEnabled(enabled, options, publishOptions) {\n        return this.setTrackEnabled(Track.Source.ScreenShare, enabled, options, publishOptions);\n    }\n    /** @internal */ setPermissions(permissions) {\n        const prevPermissions = this.permissions;\n        const changed = super.setPermissions(permissions);\n        if (changed && prevPermissions) {\n            this.emit(ParticipantEvent.ParticipantPermissionsChanged, prevPermissions);\n        }\n        return changed;\n    }\n    /** @internal */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.encryptionType = enabled ? Encryption_Type.GCM : Encryption_Type.NONE;\n            yield this.republishAllTracks(undefined, false);\n        });\n    }\n    setTrackEnabled(source, enabled, options, publishOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            this.log.debug(\"setTrackEnabled\", Object.assign(Object.assign({}, this.logContext), {\n                source,\n                enabled\n            }));\n            if (this.republishPromise) {\n                yield this.republishPromise;\n            }\n            let track = this.getTrackPublication(source);\n            if (enabled) {\n                if (track) {\n                    yield track.unmute();\n                } else {\n                    let localTracks;\n                    if (this.pendingPublishing.has(source)) {\n                        const pendingTrack = yield this.waitForPendingPublicationOfSource(source);\n                        if (!pendingTrack) {\n                            this.log.info(\"waiting for pending publication promise timed out\", Object.assign(Object.assign({}, this.logContext), {\n                                source\n                            }));\n                        }\n                        yield pendingTrack === null || pendingTrack === void 0 ? void 0 : pendingTrack.unmute();\n                        return pendingTrack;\n                    }\n                    this.pendingPublishing.add(source);\n                    try {\n                        switch(source){\n                            case Track.Source.Camera:\n                                localTracks = yield this.createTracks({\n                                    video: (_a = options) !== null && _a !== void 0 ? _a : true\n                                });\n                                break;\n                            case Track.Source.Microphone:\n                                localTracks = yield this.createTracks({\n                                    audio: (_b = options) !== null && _b !== void 0 ? _b : true\n                                });\n                                break;\n                            case Track.Source.ScreenShare:\n                                localTracks = yield this.createScreenTracks(Object.assign({}, options));\n                                break;\n                            default:\n                                throw new TrackInvalidError(source);\n                        }\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        if (e instanceof Error) {\n                            this.emit(ParticipantEvent.MediaDevicesError, e);\n                        }\n                        this.pendingPublishing.delete(source);\n                        throw e;\n                    }\n                    try {\n                        const publishPromises = [];\n                        for (const localTrack of localTracks){\n                            this.log.info(\"publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(localTrack)));\n                            publishPromises.push(this.publishTrack(localTrack, publishOptions));\n                        }\n                        const publishedTracks = yield Promise.all(publishPromises);\n                        // for screen share publications including audio, this will only return the screen share publication, not the screen share audio one\n                        // revisit if we want to return an array of tracks instead for v2\n                        [track] = publishedTracks;\n                    } catch (e) {\n                        localTracks === null || localTracks === void 0 ? void 0 : localTracks.forEach((tr)=>{\n                            tr.stop();\n                        });\n                        throw e;\n                    } finally{\n                        this.pendingPublishing.delete(source);\n                    }\n                }\n            } else {\n                if (!(track === null || track === void 0 ? void 0 : track.track) && this.pendingPublishing.has(source)) {\n                    // if there's no track available yet first wait for pending publishing promises of that source to see if it becomes available\n                    track = yield this.waitForPendingPublicationOfSource(source);\n                    if (!track) {\n                        this.log.info(\"waiting for pending publication promise timed out\", Object.assign(Object.assign({}, this.logContext), {\n                            source\n                        }));\n                    }\n                }\n                if (track && track.track) {\n                    // screenshare cannot be muted, unpublish instead\n                    if (source === Track.Source.ScreenShare) {\n                        track = yield this.unpublishTrack(track.track);\n                        const screenAudioTrack = this.getTrackPublication(Track.Source.ScreenShareAudio);\n                        if (screenAudioTrack && screenAudioTrack.track) {\n                            this.unpublishTrack(screenAudioTrack.track);\n                        }\n                    } else {\n                        yield track.mute();\n                    }\n                }\n            }\n            return track;\n        });\n    }\n    /**\n   * Publish both camera and microphone at the same time. This is useful for\n   * displaying a single Permission Dialog box to the end user.\n   */ enableCameraAndMicrophone() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.pendingPublishing.has(Track.Source.Camera) || this.pendingPublishing.has(Track.Source.Microphone)) {\n                // no-op it's already been requested\n                return;\n            }\n            this.pendingPublishing.add(Track.Source.Camera);\n            this.pendingPublishing.add(Track.Source.Microphone);\n            try {\n                const tracks = yield this.createTracks({\n                    audio: true,\n                    video: true\n                });\n                yield Promise.all(tracks.map((track)=>this.publishTrack(track)));\n            } finally{\n                this.pendingPublishing.delete(Track.Source.Camera);\n                this.pendingPublishing.delete(Track.Source.Microphone);\n            }\n        });\n    }\n    /**\n   * Create local camera and/or microphone tracks\n   * @param options\n   * @returns\n   */ createTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            options !== null && options !== void 0 ? options : options = {};\n            const mergedOptionsWithProcessors = mergeDefaultOptions(options, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.audioCaptureDefaults, (_b = this.roomOptions) === null || _b === void 0 ? void 0 : _b.videoCaptureDefaults);\n            try {\n                const tracks = yield createLocalTracks(mergedOptionsWithProcessors, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                const localTracks = tracks.map((track)=>{\n                    if (isAudioTrack(track)) {\n                        this.microphoneError = undefined;\n                        track.setAudioContext(this.audioContext);\n                        track.source = Track.Source.Microphone;\n                        this.emit(ParticipantEvent.AudioStreamAcquired);\n                    }\n                    if (isVideoTrack(track)) {\n                        this.cameraError = undefined;\n                        track.source = Track.Source.Camera;\n                    }\n                    return track;\n                });\n                return localTracks;\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (options.audio) {\n                        this.microphoneError = err;\n                    }\n                    if (options.video) {\n                        this.cameraError = err;\n                    }\n                }\n                throw err;\n            }\n        });\n    }\n    /**\n   * Creates a screen capture tracks with getDisplayMedia().\n   * A LocalVideoTrack is always created and returned.\n   * If { audio: true }, and the browser supports audio capture, a LocalAudioTrack is also created.\n   */ createScreenTracks(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (options === undefined) {\n                options = {};\n            }\n            if (navigator.mediaDevices.getDisplayMedia === undefined) {\n                throw new DeviceUnsupportedError(\"getDisplayMedia not supported\");\n            }\n            if (options.resolution === undefined && !isSafari17()) {\n                // we need to constrain the dimensions, otherwise it could lead to low bitrate\n                // due to encoding a huge video. Encoding such large surfaces is really expensive\n                // unfortunately Safari 17 has a but and cannot be constrained by default\n                options.resolution = ScreenSharePresets.h1080fps30.resolution;\n            }\n            const constraints = screenCaptureToDisplayMediaStreamOptions(options);\n            const stream = yield navigator.mediaDevices.getDisplayMedia(constraints);\n            const tracks = stream.getVideoTracks();\n            if (tracks.length === 0) {\n                throw new TrackInvalidError(\"no video track found\");\n            }\n            const screenVideo = new LocalVideoTrack(tracks[0], undefined, false, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            screenVideo.source = Track.Source.ScreenShare;\n            if (options.contentHint) {\n                screenVideo.mediaStreamTrack.contentHint = options.contentHint;\n            }\n            const localTracks = [\n                screenVideo\n            ];\n            if (stream.getAudioTracks().length > 0) {\n                this.emit(ParticipantEvent.AudioStreamAcquired);\n                const screenAudio = new LocalAudioTrack(stream.getAudioTracks()[0], undefined, false, this.audioContext, {\n                    loggerName: this.roomOptions.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                screenAudio.source = Track.Source.ScreenShareAudio;\n                localTracks.push(screenAudio);\n            }\n            return localTracks;\n        });\n    }\n    /**\n   * Publish a new track to the room\n   * @param track\n   * @param options\n   */ publishTrack(track, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.publishOrRepublishTrack(track, options);\n        });\n    }\n    publishOrRepublishTrack(track_1, options_1) {\n        return __awaiter(this, arguments, void 0, function(track, options) {\n            var _this2 = this;\n            let isRepublish = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n            return function*() {\n                var _a, _b, _c, _d;\n                if (isLocalAudioTrack(track)) {\n                    track.setAudioContext(_this2.audioContext);\n                }\n                yield (_a = _this2.reconnectFuture) === null || _a === void 0 ? void 0 : _a.promise;\n                if (_this2.republishPromise && !isRepublish) {\n                    yield _this2.republishPromise;\n                }\n                if (isLocalTrack(track) && _this2.pendingPublishPromises.has(track)) {\n                    yield _this2.pendingPublishPromises.get(track);\n                }\n                let defaultConstraints;\n                if (track instanceof MediaStreamTrack) {\n                    defaultConstraints = track.getConstraints();\n                } else {\n                    // we want to access constraints directly as `track.mediaStreamTrack`\n                    // might be pointing to a non-device track (e.g. processed track) already\n                    defaultConstraints = track.constraints;\n                    let deviceKind = undefined;\n                    switch(track.source){\n                        case Track.Source.Microphone:\n                            deviceKind = \"audioinput\";\n                            break;\n                        case Track.Source.Camera:\n                            deviceKind = \"videoinput\";\n                    }\n                    if (deviceKind && _this2.activeDeviceMap.has(deviceKind)) {\n                        defaultConstraints = Object.assign(Object.assign({}, defaultConstraints), {\n                            deviceId: _this2.activeDeviceMap.get(deviceKind)\n                        });\n                    }\n                }\n                // convert raw media track into audio or video track\n                if (track instanceof MediaStreamTrack) {\n                    switch(track.kind){\n                        case \"audio\":\n                            track = new LocalAudioTrack(track, defaultConstraints, true, _this2.audioContext, {\n                                loggerName: _this2.roomOptions.loggerName,\n                                loggerContextCb: ()=>_this2.logContext\n                            });\n                            break;\n                        case \"video\":\n                            track = new LocalVideoTrack(track, defaultConstraints, true, {\n                                loggerName: _this2.roomOptions.loggerName,\n                                loggerContextCb: ()=>_this2.logContext\n                            });\n                            break;\n                        default:\n                            throw new TrackInvalidError(\"unsupported MediaStreamTrack kind \".concat(track.kind));\n                    }\n                } else {\n                    track.updateLoggerOptions({\n                        loggerName: _this2.roomOptions.loggerName,\n                        loggerContextCb: ()=>_this2.logContext\n                    });\n                }\n                // is it already published? if so skip\n                let existingPublication;\n                _this2.trackPublications.forEach((publication)=>{\n                    if (!publication.track) {\n                        return;\n                    }\n                    if (publication.track === track) {\n                        existingPublication = publication;\n                    }\n                });\n                if (existingPublication) {\n                    _this2.log.warn(\"track has already been published, skipping\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(existingPublication)));\n                    return existingPublication;\n                }\n                const isStereoInput = \"channelCount\" in track.mediaStreamTrack.getSettings() && // @ts-ignore `channelCount` on getSettings() is currently only available for Safari, but is generally the best way to determine a stereo track https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackSettings/channelCount\n                track.mediaStreamTrack.getSettings().channelCount === 2 || track.mediaStreamTrack.getConstraints().channelCount === 2;\n                const isStereo = (_b = options === null || options === void 0 ? void 0 : options.forceStereo) !== null && _b !== void 0 ? _b : isStereoInput;\n                // disable dtx for stereo track if not enabled explicitly\n                if (isStereo) {\n                    if (!options) {\n                        options = {};\n                    }\n                    if (options.dtx === undefined) {\n                        _this2.log.info(\"Opus DTX will be disabled for stereo tracks by default. Enable them explicitly to make it work.\", Object.assign(Object.assign({}, _this2.logContext), getLogContextFromTrack(track)));\n                    }\n                    if (options.red === undefined) {\n                        _this2.log.info(\"Opus RED will be disabled for stereo tracks by default. Enable them explicitly to make it work.\");\n                    }\n                    (_c = options.dtx) !== null && _c !== void 0 ? _c : options.dtx = false;\n                    (_d = options.red) !== null && _d !== void 0 ? _d : options.red = false;\n                }\n                const opts = Object.assign(Object.assign({}, _this2.roomOptions.publishDefaults), options);\n                if (!isE2EESimulcastSupported() && _this2.roomOptions.e2ee) {\n                    _this2.log.info(\"End-to-end encryption is set up, simulcast publishing will be disabled on Safari versions and iOS browsers running iOS < v17.2\", Object.assign({}, _this2.logContext));\n                    opts.simulcast = false;\n                }\n                if (opts.source) {\n                    track.source = opts.source;\n                }\n                const publishPromise = new Promise((resolve, reject)=>__awaiter(_this2, void 0, void 0, function*() {\n                        try {\n                            if (this.engine.client.currentState !== SignalConnectionState.CONNECTED) {\n                                this.log.debug(\"deferring track publication until signal is connected\", Object.assign(Object.assign({}, this.logContext), {\n                                    track: getLogContextFromTrack(track)\n                                }));\n                                const onSignalConnected = ()=>__awaiter(this, void 0, void 0, function*() {\n                                        try {\n                                            const publication = yield this.publish(track, opts, isStereo);\n                                            resolve(publication);\n                                        } catch (e) {\n                                            reject(e);\n                                        }\n                                    });\n                                setTimeout(()=>{\n                                    this.engine.off(EngineEvent.SignalConnected, onSignalConnected);\n                                    reject(new PublishTrackError(\"publishing rejected as engine not connected within timeout\", 408));\n                                }, 15000);\n                                this.engine.once(EngineEvent.SignalConnected, onSignalConnected);\n                                this.engine.on(EngineEvent.Closing, ()=>{\n                                    this.engine.off(EngineEvent.SignalConnected, onSignalConnected);\n                                    reject(new PublishTrackError(\"publishing rejected as engine closed\", 499));\n                                });\n                            } else {\n                                try {\n                                    const publication = yield this.publish(track, opts, isStereo);\n                                    resolve(publication);\n                                } catch (e) {\n                                    reject(e);\n                                }\n                            }\n                        } catch (e) {\n                            reject(e);\n                        }\n                    }));\n                _this2.pendingPublishPromises.set(track, publishPromise);\n                try {\n                    const publication = yield publishPromise;\n                    return publication;\n                } catch (e) {\n                    throw e;\n                } finally{\n                    _this2.pendingPublishPromises.delete(track);\n                }\n            }();\n        });\n    }\n    hasPermissionsToPublish(track) {\n        if (!this.permissions) {\n            this.log.warn(\"no permissions present for publishing track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            return false;\n        }\n        const { canPublish, canPublishSources } = this.permissions;\n        if (canPublish && (canPublishSources.length === 0 || canPublishSources.map((source)=>getTrackSourceFromProto(source)).includes(track.source))) {\n            return true;\n        }\n        this.log.warn(\"insufficient permissions to publish\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n        return false;\n    }\n    publish(track, opts, isStereo) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n            if (!this.hasPermissionsToPublish(track)) {\n                throw new PublishTrackError(\"failed to publish track, insufficient permissions\", 403);\n            }\n            const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack)=>isLocalTrack(track) && publishedTrack.source === track.source);\n            if (existingTrackOfSource && track.source !== Track.Source.Unknown) {\n                this.log.info(\"publishing a second track with the same source: \".concat(track.source), Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n            }\n            if (opts.stopMicTrackOnMute && isAudioTrack(track)) {\n                track.stopOnMute = true;\n            }\n            if (track.source === Track.Source.ScreenShare && isFireFox()) {\n                // Firefox does not work well with simulcasted screen share\n                // we frequently get no data on layer 0 when enabled\n                opts.simulcast = false;\n            }\n            // require full AV1/VP9 SVC support prior to using it\n            if (opts.videoCodec === \"av1\" && !supportsAV1()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === \"vp9\" && !supportsVP9()) {\n                opts.videoCodec = undefined;\n            }\n            if (opts.videoCodec === undefined) {\n                opts.videoCodec = defaultVideoCodec;\n            }\n            if (this.enabledPublishVideoCodecs.length > 0) {\n                // fallback to a supported codec if it is not supported\n                if (!this.enabledPublishVideoCodecs.some((c)=>opts.videoCodec === mimeTypeToVideoCodecString(c.mime))) {\n                    opts.videoCodec = mimeTypeToVideoCodecString(this.enabledPublishVideoCodecs[0].mime);\n                }\n            }\n            const videoCodec = opts.videoCodec;\n            // handle track actions\n            track.on(TrackEvent.Muted, this.onTrackMuted);\n            track.on(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.on(TrackEvent.Ended, this.handleTrackEnded);\n            track.on(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.on(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            track.on(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n            // create track publication from track\n            const req = new AddTrackRequest({\n                // get local track id for use during publishing\n                cid: track.mediaStreamTrack.id,\n                name: opts.name,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                disableDtx: !((_a = opts.dtx) !== null && _a !== void 0 ? _a : true),\n                encryption: this.encryptionType,\n                stereo: isStereo,\n                disableRed: this.isE2EEEnabled || !((_b = opts.red) !== null && _b !== void 0 ? _b : true),\n                stream: opts === null || opts === void 0 ? void 0 : opts.stream,\n                backupCodecPolicy: opts === null || opts === void 0 ? void 0 : opts.backupCodecPolicy\n            });\n            // compute encodings and layers for video\n            let encodings;\n            if (track.kind === Track.Kind.Video) {\n                let dims = {\n                    width: 0,\n                    height: 0\n                };\n                try {\n                    dims = yield track.waitForDimensions();\n                } catch (e) {\n                    // use defaults, it's quite painful for congestion control without simulcast\n                    // so using default dims according to publish settings\n                    const defaultRes = (_d = (_c = this.roomOptions.videoCaptureDefaults) === null || _c === void 0 ? void 0 : _c.resolution) !== null && _d !== void 0 ? _d : VideoPresets.h720.resolution;\n                    dims = {\n                        width: defaultRes.width,\n                        height: defaultRes.height\n                    };\n                    // log failure\n                    this.log.error(\"could not determine track dimensions, using defaults\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                        dims\n                    }));\n                }\n                // width and height should be defined for video\n                req.width = dims.width;\n                req.height = dims.height;\n                // for svc codecs, disable simulcast and use vp8 for backup codec\n                if (isLocalVideoTrack(track)) {\n                    if (isSVCCodec(videoCodec)) {\n                        if (track.source === Track.Source.ScreenShare) {\n                            // vp9 svc with screenshare cannot encode multiple spatial layers\n                            // doing so reduces publish resolution to minimal resolution\n                            opts.scalabilityMode = \"L1T3\";\n                            // Chrome does not allow more than 5 fps with L1T3, and it has encoding bugs with L3T3\n                            // It has a different path for screenshare handling and it seems to be untested/buggy\n                            // As a workaround, we are setting contentHint to force it to go through the same\n                            // path as regular camera video. While this is not optimal, it delivers the performance\n                            // that we need\n                            if (\"contentHint\" in track.mediaStreamTrack) {\n                                track.mediaStreamTrack.contentHint = \"motion\";\n                                this.log.info(\"forcing contentHint to motion for screenshare with SVC codecs\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                            }\n                        }\n                        // set scalabilityMode to 'L3T3_KEY' by default\n                        opts.scalabilityMode = (_e = opts.scalabilityMode) !== null && _e !== void 0 ? _e : \"L3T3_KEY\";\n                    }\n                    req.simulcastCodecs = [\n                        new SimulcastCodec({\n                            codec: videoCodec,\n                            cid: track.mediaStreamTrack.id\n                        })\n                    ];\n                    // set up backup\n                    if (opts.backupCodec === true) {\n                        opts.backupCodec = {\n                            codec: defaultVideoCodec\n                        };\n                    }\n                    if (opts.backupCodec && videoCodec !== opts.backupCodec.codec && // TODO remove this once e2ee is supported for backup codecs\n                    req.encryption === Encryption_Type.NONE) {\n                        // multi-codec simulcast requires dynacast\n                        if (!this.roomOptions.dynacast) {\n                            this.roomOptions.dynacast = true;\n                        }\n                        req.simulcastCodecs.push(new SimulcastCodec({\n                            codec: opts.backupCodec.codec,\n                            cid: \"\"\n                        }));\n                    }\n                }\n                encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                req.layers = videoLayersFromEncodings(req.width, req.height, encodings, isSVCCodec(opts.videoCodec));\n            } else if (track.kind === Track.Kind.Audio) {\n                encodings = [\n                    {\n                        maxBitrate: (_f = opts.audioPreset) === null || _f === void 0 ? void 0 : _f.maxBitrate,\n                        priority: (_h = (_g = opts.audioPreset) === null || _g === void 0 ? void 0 : _g.priority) !== null && _h !== void 0 ? _h : \"high\",\n                        networkPriority: (_k = (_j = opts.audioPreset) === null || _j === void 0 ? void 0 : _j.priority) !== null && _k !== void 0 ? _k : \"high\"\n                    }\n                ];\n            }\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const negotiate = ()=>__awaiter(this, void 0, void 0, function*() {\n                    var _a, _b, _c;\n                    if (!this.engine.pcManager) {\n                        throw new UnexpectedConnectionState(\"pcManager is not ready\");\n                    }\n                    track.sender = yield this.engine.createSender(track, opts, encodings);\n                    if (isLocalVideoTrack(track)) {\n                        (_a = opts.degradationPreference) !== null && _a !== void 0 ? _a : opts.degradationPreference = getDefaultDegradationPreference(track);\n                        track.setDegradationPreference(opts.degradationPreference);\n                    }\n                    if (encodings) {\n                        if (isFireFox() && track.kind === Track.Kind.Audio) {\n                            /* Refer to RFC https://datatracker.ietf.org/doc/html/rfc7587#section-6.1,\n               livekit-server uses maxaveragebitrate=510000 in the answer sdp to permit client to\n               publish high quality audio track. But firefox always uses this value as the actual\n               bitrates, causing the audio bitrates to rise to 510Kbps in any stereo case unexpectedly.\n               So the client need to modify maxaverragebitrates in answer sdp to user provided value to\n               fix the issue.\n             */ let trackTransceiver = undefined;\n                            for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                                if (transceiver.sender === track.sender) {\n                                    trackTransceiver = transceiver;\n                                    break;\n                                }\n                            }\n                            if (trackTransceiver) {\n                                this.engine.pcManager.publisher.setTrackCodecBitrate({\n                                    transceiver: trackTransceiver,\n                                    codec: \"opus\",\n                                    maxbr: ((_b = encodings[0]) === null || _b === void 0 ? void 0 : _b.maxBitrate) ? encodings[0].maxBitrate / 1000 : 0\n                                });\n                            }\n                        } else if (track.codec && isSVCCodec(track.codec) && ((_c = encodings[0]) === null || _c === void 0 ? void 0 : _c.maxBitrate)) {\n                            this.engine.pcManager.publisher.setTrackCodecBitrate({\n                                cid: req.cid,\n                                codec: track.codec,\n                                maxbr: encodings[0].maxBitrate / 1000\n                            });\n                        }\n                    }\n                    yield this.engine.negotiate();\n                });\n            let ti;\n            if (this.enabledPublishVideoCodecs.length > 0) {\n                const rets = yield Promise.all([\n                    this.engine.addTrack(req),\n                    negotiate()\n                ]);\n                ti = rets[0];\n            } else {\n                ti = yield this.engine.addTrack(req);\n                // server might not support the codec the client has requested, in that case, fallback\n                // to a supported codec\n                let primaryCodecMime;\n                ti.codecs.forEach((codec)=>{\n                    if (primaryCodecMime === undefined) {\n                        primaryCodecMime = codec.mimeType;\n                    }\n                });\n                if (primaryCodecMime && track.kind === Track.Kind.Video) {\n                    const updatedCodec = mimeTypeToVideoCodecString(primaryCodecMime);\n                    if (updatedCodec !== videoCodec) {\n                        this.log.debug(\"falling back to server selected codec\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)), {\n                            codec: updatedCodec\n                        }));\n                        opts.videoCodec = updatedCodec;\n                        // recompute encodings since bitrates/etc could have changed\n                        encodings = computeVideoEncodings(track.source === Track.Source.ScreenShare, req.width, req.height, opts);\n                    }\n                }\n                yield negotiate();\n            }\n            const publication = new LocalTrackPublication(track.kind, ti, track, {\n                loggerName: this.roomOptions.loggerName,\n                loggerContextCb: ()=>this.logContext\n            });\n            // save options for when it needs to be republished again\n            publication.options = opts;\n            track.sid = ti.sid;\n            this.log.debug(\"publishing \".concat(track.kind, \" with encodings\"), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n            if (isLocalVideoTrack(track)) {\n                track.startMonitor(this.engine.client);\n            } else if (isLocalAudioTrack(track)) {\n                track.startMonitor();\n            }\n            this.addTrackPublication(publication);\n            // send event for publication\n            this.emit(ParticipantEvent.LocalTrackPublished, publication);\n            return publication;\n        });\n    }\n    get isLocal() {\n        return true;\n    }\n    /** @internal\n   * publish additional codec to existing track\n   */ publishAdditionalCodecForTrack(track, videoCodec, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            // TODO remove once e2ee is supported for backup tracks\n            if (this.encryptionType !== Encryption_Type.NONE) {\n                return;\n            }\n            // is it not published? if so skip\n            let existingPublication;\n            this.trackPublications.forEach((publication)=>{\n                if (!publication.track) {\n                    return;\n                }\n                if (publication.track === track) {\n                    existingPublication = publication;\n                }\n            });\n            if (!existingPublication) {\n                throw new TrackInvalidError(\"track is not published\");\n            }\n            if (!isLocalVideoTrack(track)) {\n                throw new TrackInvalidError(\"track is not a video track\");\n            }\n            const opts = Object.assign(Object.assign({}, (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.publishDefaults), options);\n            const encodings = computeTrackBackupEncodings(track, videoCodec, opts);\n            if (!encodings) {\n                this.log.info(\"backup codec has been disabled, ignoring request to add additional codec for track\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                return;\n            }\n            const simulcastTrack = track.addSimulcastTrack(videoCodec, encodings);\n            if (!simulcastTrack) {\n                return;\n            }\n            const req = new AddTrackRequest({\n                cid: simulcastTrack.mediaStreamTrack.id,\n                type: Track.kindToProto(track.kind),\n                muted: track.isMuted,\n                source: Track.sourceToProto(track.source),\n                sid: track.sid,\n                simulcastCodecs: [\n                    {\n                        codec: opts.videoCodec,\n                        cid: simulcastTrack.mediaStreamTrack.id\n                    }\n                ]\n            });\n            req.layers = videoLayersFromEncodings(req.width, req.height, encodings);\n            if (!this.engine || this.engine.isClosed) {\n                throw new UnexpectedConnectionState(\"cannot publish track when not connected\");\n            }\n            const negotiate = ()=>__awaiter(this, void 0, void 0, function*() {\n                    yield this.engine.createSimulcastSender(track, simulcastTrack, opts, encodings);\n                    yield this.engine.negotiate();\n                });\n            const rets = yield Promise.all([\n                this.engine.addTrack(req),\n                negotiate()\n            ]);\n            const ti = rets[0];\n            this.log.debug(\"published \".concat(videoCodec, \" for track \").concat(track.sid), Object.assign(Object.assign({}, this.logContext), {\n                encodings,\n                trackInfo: ti\n            }));\n        });\n    }\n    unpublishTrack(track, stopOnUnpublish) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            if (isLocalTrack(track)) {\n                const publishPromise = this.pendingPublishPromises.get(track);\n                if (publishPromise) {\n                    this.log.info(\"awaiting publish promise before attempting to unpublish\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(track)));\n                    yield publishPromise;\n                }\n            }\n            // look through all published tracks to find the right ones\n            const publication = this.getPublicationForTrack(track);\n            const pubLogContext = publication ? getLogContextFromTrack(publication) : undefined;\n            this.log.debug(\"unpublishing track\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n            if (!publication || !publication.track) {\n                this.log.warn(\"track was not unpublished because no publication was found\", Object.assign(Object.assign({}, this.logContext), pubLogContext));\n                return undefined;\n            }\n            track = publication.track;\n            track.off(TrackEvent.Muted, this.onTrackMuted);\n            track.off(TrackEvent.Unmuted, this.onTrackUnmuted);\n            track.off(TrackEvent.Ended, this.handleTrackEnded);\n            track.off(TrackEvent.UpstreamPaused, this.onTrackUpstreamPaused);\n            track.off(TrackEvent.UpstreamResumed, this.onTrackUpstreamResumed);\n            track.off(TrackEvent.AudioTrackFeatureUpdate, this.onTrackFeatureUpdate);\n            if (stopOnUnpublish === undefined) {\n                stopOnUnpublish = (_b = (_a = this.roomOptions) === null || _a === void 0 ? void 0 : _a.stopLocalTrackOnUnpublish) !== null && _b !== void 0 ? _b : true;\n            }\n            if (stopOnUnpublish) {\n                track.stop();\n            } else {\n                track.stopMonitor();\n            }\n            let negotiationNeeded = false;\n            const trackSender = track.sender;\n            track.sender = undefined;\n            if (this.engine.pcManager && this.engine.pcManager.currentState < PCTransportState.FAILED && trackSender) {\n                try {\n                    for (const transceiver of this.engine.pcManager.publisher.getTransceivers()){\n                        // if sender is not currently sending (after replaceTrack(null))\n                        // removeTrack would have no effect.\n                        // to ensure we end up successfully removing the track, manually set\n                        // the transceiver to inactive\n                        if (transceiver.sender === trackSender) {\n                            transceiver.direction = \"inactive\";\n                            negotiationNeeded = true;\n                        }\n                    }\n                    if (this.engine.removeTrack(trackSender)) {\n                        negotiationNeeded = true;\n                    }\n                    if (isLocalVideoTrack(track)) {\n                        for (const [, trackInfo] of track.simulcastCodecs){\n                            if (trackInfo.sender) {\n                                if (this.engine.removeTrack(trackInfo.sender)) {\n                                    negotiationNeeded = true;\n                                }\n                                trackInfo.sender = undefined;\n                            }\n                        }\n                        track.simulcastCodecs.clear();\n                    }\n                } catch (e) {\n                    this.log.warn(\"failed to unpublish track\", Object.assign(Object.assign(Object.assign({}, this.logContext), pubLogContext), {\n                        error: e\n                    }));\n                }\n            }\n            // remove from our maps\n            this.trackPublications.delete(publication.trackSid);\n            switch(publication.kind){\n                case Track.Kind.Audio:\n                    this.audioTrackPublications.delete(publication.trackSid);\n                    break;\n                case Track.Kind.Video:\n                    this.videoTrackPublications.delete(publication.trackSid);\n                    break;\n            }\n            this.emit(ParticipantEvent.LocalTrackUnpublished, publication);\n            publication.setTrack(undefined);\n            if (negotiationNeeded) {\n                yield this.engine.negotiate();\n            }\n            return publication;\n        });\n    }\n    unpublishTracks(tracks) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(tracks.map((track)=>this.unpublishTrack(track)));\n            return results.filter((track)=>!!track);\n        });\n    }\n    republishAllTracks(options_1) {\n        return __awaiter(this, arguments, void 0, function(options) {\n            var _this3 = this;\n            let restartTracks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n            return function*() {\n                if (_this3.republishPromise) {\n                    yield _this3.republishPromise;\n                }\n                _this3.republishPromise = new Promise((resolve, reject)=>__awaiter(_this3, void 0, void 0, function*() {\n                        try {\n                            const localPubs = [];\n                            this.trackPublications.forEach((pub)=>{\n                                if (pub.track) {\n                                    if (options) {\n                                        pub.options = Object.assign(Object.assign({}, pub.options), options);\n                                    }\n                                    localPubs.push(pub);\n                                }\n                            });\n                            yield Promise.all(localPubs.map((pub)=>__awaiter(this, void 0, void 0, function*() {\n                                    const track = pub.track;\n                                    yield this.unpublishTrack(track, false);\n                                    if (restartTracks && !track.isMuted && track.source !== Track.Source.ScreenShare && track.source !== Track.Source.ScreenShareAudio && (isLocalAudioTrack(track) || isLocalVideoTrack(track)) && !track.isUserProvided) {\n                                        // generally we need to restart the track before publishing, often a full reconnect\n                                        // is necessary because computer had gone to sleep.\n                                        this.log.debug(\"restarting existing track\", Object.assign(Object.assign({}, this.logContext), {\n                                            track: pub.trackSid\n                                        }));\n                                        yield track.restartTrack();\n                                    }\n                                    yield this.publishOrRepublishTrack(track, pub.options, true);\n                                })));\n                            resolve();\n                        } catch (error) {\n                            reject(error);\n                        } finally{\n                            this.republishPromise = undefined;\n                        }\n                    }));\n                yield _this3.republishPromise;\n            }();\n        });\n    }\n    /**\n   * Publish a new data payload to the room. Data will be forwarded to each\n   * participant in the room if the destination field in publishOptions is empty\n   *\n   * @param data Uint8Array of the payload. To send string data, use TextEncoder.encode\n   * @param options optionally specify a `reliable`, `topic` and `destination`\n   */ publishData(data_1) {\n        return __awaiter(this, arguments, void 0, function(data) {\n            var _this4 = this;\n            let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n            return function*() {\n                const kind = options.reliable ? DataPacket_Kind.RELIABLE : DataPacket_Kind.LOSSY;\n                const destinationIdentities = options.destinationIdentities;\n                const topic = options.topic;\n                const packet = new DataPacket({\n                    kind: kind,\n                    value: {\n                        case: \"user\",\n                        value: new UserPacket({\n                            participantIdentity: _this4.identity,\n                            payload: data,\n                            destinationIdentities,\n                            topic\n                        })\n                    }\n                });\n                yield _this4.engine.sendDataPacket(packet, kind);\n            }();\n        });\n    }\n    /**\n   * Publish SIP DTMF message to the room.\n   *\n   * @param code DTMF code\n   * @param digit DTMF digit\n   */ publishDtmf(code, digit) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"sipDtmf\",\n                    value: new SipDTMF({\n                        code: code,\n                        digit: digit\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    sendChatMessage(text, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = {\n                id: crypto.randomUUID(),\n                message: text,\n                timestamp: Date.now(),\n                attachedFiles: options === null || options === void 0 ? void 0 : options.attachments\n            };\n            const packet = new DataPacket({\n                value: {\n                    case: \"chatMessage\",\n                    value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n                        timestamp: protoInt64.parse(msg.timestamp)\n                    }))\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            this.emit(ParticipantEvent.ChatMessage, msg);\n            return msg;\n        });\n    }\n    editChatMessage(editText, originalMessage) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const msg = Object.assign(Object.assign({}, originalMessage), {\n                message: editText,\n                editTimestamp: Date.now()\n            });\n            const packet = new DataPacket({\n                value: {\n                    case: \"chatMessage\",\n                    value: new ChatMessage(Object.assign(Object.assign({}, msg), {\n                        timestamp: protoInt64.parse(msg.timestamp),\n                        editTimestamp: protoInt64.parse(msg.editTimestamp)\n                    }))\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            this.emit(ParticipantEvent.ChatMessage, msg);\n            return msg;\n        });\n    }\n    sendText(text, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const streamId = crypto.randomUUID();\n            const textInBytes = new TextEncoder().encode(text);\n            const totalTextLength = textInBytes.byteLength;\n            const fileIds = (_a = options === null || options === void 0 ? void 0 : options.attachments) === null || _a === void 0 ? void 0 : _a.map(()=>crypto.randomUUID());\n            const progresses = new Array(fileIds ? fileIds.length + 1 : 1).fill(0);\n            const handleProgress = (progress, idx)=>{\n                var _a;\n                progresses[idx] = progress;\n                const totalProgress = progresses.reduce((acc, val)=>acc + val, 0);\n                (_a = options === null || options === void 0 ? void 0 : options.onProgress) === null || _a === void 0 ? void 0 : _a.call(options, totalProgress);\n            };\n            const writer = yield this.streamText({\n                streamId,\n                totalSize: totalTextLength,\n                destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities,\n                topic: options === null || options === void 0 ? void 0 : options.topic,\n                attachedStreamIds: fileIds,\n                attributes: options === null || options === void 0 ? void 0 : options.attributes\n            });\n            yield writer.write(text);\n            // set text part of progress to 1\n            handleProgress(1, 0);\n            yield writer.close();\n            if ((options === null || options === void 0 ? void 0 : options.attachments) && fileIds) {\n                yield Promise.all(options.attachments.map((file, idx)=>__awaiter(this, void 0, void 0, function*() {\n                        return this._sendFile(fileIds[idx], file, {\n                            topic: options.topic,\n                            mimeType: file.type,\n                            onProgress: (progress)=>{\n                                handleProgress(progress, idx + 1);\n                            }\n                        });\n                    })));\n            }\n            return writer.info;\n        });\n    }\n    /**\n   * @internal\n   * @experimental CAUTION, might get removed in a minor release\n   */ streamText(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            const info = {\n                id: streamId,\n                mimeType: \"text/plain\",\n                timestamp: Date.now(),\n                topic: (_b = options === null || options === void 0 ? void 0 : options.topic) !== null && _b !== void 0 ? _b : \"\",\n                size: options === null || options === void 0 ? void 0 : options.totalSize,\n                attributes: options === null || options === void 0 ? void 0 : options.attributes\n            };\n            const header = new DataStream_Header({\n                streamId,\n                mimeType: info.mimeType,\n                topic: info.topic,\n                timestamp: numberToBigInt(info.timestamp),\n                totalLength: numberToBigInt(options === null || options === void 0 ? void 0 : options.totalSize),\n                attributes: info.attributes,\n                contentHeader: {\n                    case: \"textHeader\",\n                    value: new DataStream_TextHeader({\n                        version: options === null || options === void 0 ? void 0 : options.version,\n                        attachedStreamIds: options === null || options === void 0 ? void 0 : options.attachedStreamIds,\n                        replyToStreamId: options === null || options === void 0 ? void 0 : options.replyToStreamId,\n                        operationType: (options === null || options === void 0 ? void 0 : options.type) === \"update\" ? DataStream_OperationType.UPDATE : DataStream_OperationType.CREATE\n                    })\n                }\n            });\n            const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n            const packet = new DataPacket({\n                destinationIdentities,\n                value: {\n                    case: \"streamHeader\",\n                    value: header\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            let chunkId = 0;\n            const localP = this;\n            const writableStream = new WritableStream({\n                // Implement the sink\n                write (text) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        for (const textByteChunk of splitUtf8(text, STREAM_CHUNK_SIZE)){\n                            yield localP.engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\n                            const chunk = new DataStream_Chunk({\n                                content: textByteChunk,\n                                streamId,\n                                chunkIndex: numberToBigInt(chunkId)\n                            });\n                            const chunkPacket = new DataPacket({\n                                destinationIdentities,\n                                value: {\n                                    case: \"streamChunk\",\n                                    value: chunk\n                                }\n                            });\n                            yield localP.engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                            chunkId += 1;\n                        }\n                    });\n                },\n                close () {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const trailer = new DataStream_Trailer({\n                            streamId\n                        });\n                        const trailerPacket = new DataPacket({\n                            destinationIdentities,\n                            value: {\n                                case: \"streamTrailer\",\n                                value: trailer\n                            }\n                        });\n                        yield localP.engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n                    });\n                },\n                abort (err) {\n                    console.log(\"Sink error:\", err);\n                // TODO handle aborts to signal something to receiver side\n                }\n            });\n            let onEngineClose = ()=>__awaiter(this, void 0, void 0, function*() {\n                    yield writer.close();\n                });\n            localP.engine.once(EngineEvent.Closing, onEngineClose);\n            const writer = new TextStreamWriter(writableStream, info, ()=>this.engine.off(EngineEvent.Closing, onEngineClose));\n            return writer;\n        });\n    }\n    sendFile(file, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const streamId = crypto.randomUUID();\n            yield this._sendFile(streamId, file, options);\n            return {\n                id: streamId\n            };\n        });\n    }\n    _sendFile(streamId, file, options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const writer = yield this.streamBytes({\n                streamId,\n                totalSize: file.size,\n                name: file.name,\n                mimeType: (_a = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _a !== void 0 ? _a : file.type,\n                topic: options === null || options === void 0 ? void 0 : options.topic,\n                destinationIdentities: options === null || options === void 0 ? void 0 : options.destinationIdentities\n            });\n            const reader = file.stream().getReader();\n            while(true){\n                const { done, value } = yield reader.read();\n                if (done) {\n                    break;\n                }\n                yield writer.write(value);\n            }\n            yield writer.close();\n            return writer.info;\n        });\n    }\n    streamBytes(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c, _d, _e;\n            const streamId = (_a = options === null || options === void 0 ? void 0 : options.streamId) !== null && _a !== void 0 ? _a : crypto.randomUUID();\n            const destinationIdentities = options === null || options === void 0 ? void 0 : options.destinationIdentities;\n            const info = {\n                id: streamId,\n                mimeType: (_b = options === null || options === void 0 ? void 0 : options.mimeType) !== null && _b !== void 0 ? _b : \"application/octet-stream\",\n                topic: (_c = options === null || options === void 0 ? void 0 : options.topic) !== null && _c !== void 0 ? _c : \"\",\n                timestamp: Date.now(),\n                attributes: options === null || options === void 0 ? void 0 : options.attributes,\n                size: options === null || options === void 0 ? void 0 : options.totalSize,\n                name: (_d = options === null || options === void 0 ? void 0 : options.name) !== null && _d !== void 0 ? _d : \"unknown\"\n            };\n            const header = new DataStream_Header({\n                totalLength: numberToBigInt((_e = info.size) !== null && _e !== void 0 ? _e : 0),\n                mimeType: info.mimeType,\n                streamId,\n                topic: info.topic,\n                timestamp: numberToBigInt(Date.now()),\n                contentHeader: {\n                    case: \"byteHeader\",\n                    value: new DataStream_ByteHeader({\n                        name: info.name\n                    })\n                }\n            });\n            const packet = new DataPacket({\n                destinationIdentities,\n                value: {\n                    case: \"streamHeader\",\n                    value: header\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n            let chunkId = 0;\n            const writeMutex = new _();\n            const engine = this.engine;\n            const log = this.log;\n            const writableStream = new WritableStream({\n                write (chunk) {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const unlock = yield writeMutex.lock();\n                        let byteOffset = 0;\n                        try {\n                            while(byteOffset < chunk.byteLength){\n                                const subChunk = chunk.slice(byteOffset, byteOffset + STREAM_CHUNK_SIZE);\n                                yield engine.waitForBufferStatusLow(DataPacket_Kind.RELIABLE);\n                                const chunkPacket = new DataPacket({\n                                    destinationIdentities,\n                                    value: {\n                                        case: \"streamChunk\",\n                                        value: new DataStream_Chunk({\n                                            content: subChunk,\n                                            streamId,\n                                            chunkIndex: numberToBigInt(chunkId)\n                                        })\n                                    }\n                                });\n                                yield engine.sendDataPacket(chunkPacket, DataPacket_Kind.RELIABLE);\n                                chunkId += 1;\n                                byteOffset += subChunk.byteLength;\n                            }\n                        } finally{\n                            unlock();\n                        }\n                    });\n                },\n                close () {\n                    return __awaiter(this, void 0, void 0, function*() {\n                        const trailer = new DataStream_Trailer({\n                            streamId\n                        });\n                        const trailerPacket = new DataPacket({\n                            destinationIdentities,\n                            value: {\n                                case: \"streamTrailer\",\n                                value: trailer\n                            }\n                        });\n                        yield engine.sendDataPacket(trailerPacket, DataPacket_Kind.RELIABLE);\n                    });\n                },\n                abort (err) {\n                    log.error(\"Sink error:\", err);\n                }\n            });\n            const byteWriter = new ByteStreamWriter(writableStream, info);\n            return byteWriter;\n        });\n    }\n    /**\n   * Initiate an RPC call to a remote participant\n   * @param params - Parameters for initiating the RPC call, see {@link PerformRpcParams}\n   * @returns A promise that resolves with the response payload or rejects with an error.\n   * @throws Error on failure. Details in `message`.\n   */ performRpc(_a) {\n        return __awaiter(this, arguments, void 0, function(_ref3) {\n            var _this5 = this;\n            let { destinationIdentity, method, payload, responseTimeout = 10000 } = _ref3;\n            return function*() {\n                const maxRoundTripLatency = 2000;\n                return new Promise((resolve, reject)=>__awaiter(_this5, void 0, void 0, function*() {\n                        var _a, _b, _c, _d;\n                        if (byteLength(payload) > MAX_PAYLOAD_BYTES) {\n                            reject(RpcError.builtIn(\"REQUEST_PAYLOAD_TOO_LARGE\"));\n                            return;\n                        }\n                        if (((_b = (_a = this.engine.latestJoinResponse) === null || _a === void 0 ? void 0 : _a.serverInfo) === null || _b === void 0 ? void 0 : _b.version) && compareVersions((_d = (_c = this.engine.latestJoinResponse) === null || _c === void 0 ? void 0 : _c.serverInfo) === null || _d === void 0 ? void 0 : _d.version, \"1.8.0\") < 0) {\n                            reject(RpcError.builtIn(\"UNSUPPORTED_SERVER\"));\n                            return;\n                        }\n                        const id = crypto.randomUUID();\n                        yield this.publishRpcRequest(destinationIdentity, id, method, payload, responseTimeout - maxRoundTripLatency);\n                        const ackTimeoutId = setTimeout(()=>{\n                            this.pendingAcks.delete(id);\n                            reject(RpcError.builtIn(\"CONNECTION_TIMEOUT\"));\n                            this.pendingResponses.delete(id);\n                            clearTimeout(responseTimeoutId);\n                        }, maxRoundTripLatency);\n                        this.pendingAcks.set(id, {\n                            resolve: ()=>{\n                                clearTimeout(ackTimeoutId);\n                            },\n                            participantIdentity: destinationIdentity\n                        });\n                        const responseTimeoutId = setTimeout(()=>{\n                            this.pendingResponses.delete(id);\n                            reject(RpcError.builtIn(\"RESPONSE_TIMEOUT\"));\n                        }, responseTimeout);\n                        this.pendingResponses.set(id, {\n                            resolve: (responsePayload, responseError)=>{\n                                clearTimeout(responseTimeoutId);\n                                if (this.pendingAcks.has(id)) {\n                                    console.warn(\"RPC response received before ack\", id);\n                                    this.pendingAcks.delete(id);\n                                    clearTimeout(ackTimeoutId);\n                                }\n                                if (responseError) {\n                                    reject(responseError);\n                                } else {\n                                    resolve(responsePayload !== null && responsePayload !== void 0 ? responsePayload : \"\");\n                                }\n                            },\n                            participantIdentity: destinationIdentity\n                        });\n                    }));\n            }();\n        });\n    }\n    /**\n   * @deprecated use `room.registerRpcMethod` instead\n   */ registerRpcMethod(method, handler) {\n        if (this.rpcHandlers.has(method)) {\n            this.log.warn(\"you're overriding the RPC handler for method \".concat(method, \", in the future this will throw an error\"));\n        }\n        this.rpcHandlers.set(method, handler);\n    }\n    /**\n   * @deprecated use `room.unregisterRpcMethod` instead\n   */ unregisterRpcMethod(method) {\n        this.rpcHandlers.delete(method);\n    }\n    /**\n   * Control who can subscribe to LocalParticipant's published tracks.\n   *\n   * By default, all participants can subscribe. This allows fine-grained control over\n   * who is able to subscribe at a participant and track level.\n   *\n   * Note: if access is given at a track-level (i.e. both [allParticipantsAllowed] and\n   * [ParticipantTrackPermission.allTracksAllowed] are false), any newer published tracks\n   * will not grant permissions to any participants and will require a subsequent\n   * permissions update to allow subscription.\n   *\n   * @param allParticipantsAllowed Allows all participants to subscribe all tracks.\n   *  Takes precedence over [[participantTrackPermissions]] if set to true.\n   *  By default this is set to true.\n   * @param participantTrackPermissions Full list of individual permissions per\n   *  participant/track. Any omitted participants will not receive any permissions.\n   */ setTrackSubscriptionPermissions(allParticipantsAllowed) {\n        let participantTrackPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n        this.participantTrackPermissions = participantTrackPermissions;\n        this.allParticipantsAllowedToSubscribe = allParticipantsAllowed;\n        if (!this.engine.client.isDisconnected) {\n            this.updateTrackSubscriptionPermissions();\n        }\n    }\n    handleIncomingRpcAck(requestId) {\n        const handler = this.pendingAcks.get(requestId);\n        if (handler) {\n            handler.resolve();\n            this.pendingAcks.delete(requestId);\n        } else {\n            console.error(\"Ack received for unexpected RPC request\", requestId);\n        }\n    }\n    handleIncomingRpcResponse(requestId, payload, error) {\n        const handler = this.pendingResponses.get(requestId);\n        if (handler) {\n            handler.resolve(payload, error);\n            this.pendingResponses.delete(requestId);\n        } else {\n            console.error(\"Response received for unexpected RPC request\", requestId);\n        }\n    }\n    /** @internal */ publishRpcRequest(destinationIdentity, requestId, method, payload, responseTimeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const packet = new DataPacket({\n                destinationIdentities: [\n                    destinationIdentity\n                ],\n                kind: DataPacket_Kind.RELIABLE,\n                value: {\n                    case: \"rpcRequest\",\n                    value: new RpcRequest({\n                        id: requestId,\n                        method,\n                        payload,\n                        responseTimeoutMs: responseTimeout,\n                        version: 1\n                    })\n                }\n            });\n            yield this.engine.sendDataPacket(packet, DataPacket_Kind.RELIABLE);\n        });\n    }\n    /** @internal */ handleParticipantDisconnected(participantIdentity) {\n        for (const [id, { participantIdentity: pendingIdentity }] of this.pendingAcks){\n            if (pendingIdentity === participantIdentity) {\n                this.pendingAcks.delete(id);\n            }\n        }\n        for (const [id, { participantIdentity: pendingIdentity, resolve }] of this.pendingResponses){\n            if (pendingIdentity === participantIdentity) {\n                resolve(null, RpcError.builtIn(\"RECIPIENT_DISCONNECTED\"));\n                this.pendingResponses.delete(id);\n            }\n        }\n    }\n    /** @internal */ setEnabledPublishCodecs(codecs) {\n        this.enabledPublishVideoCodecs = codecs.filter((c)=>c.mime.split(\"/\")[0].toLowerCase() === \"video\");\n    }\n    /** @internal */ updateInfo(info) {\n        if (info.sid !== this.sid) {\n            // drop updates that specify a wrong sid.\n            // the sid for local participant is only explicitly set on join and full reconnect\n            return false;\n        }\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // reconcile track mute status.\n        // if server's track mute status doesn't match actual, we'll have to update\n        // the server's copy\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            const pub = this.trackPublications.get(ti.sid);\n            if (pub) {\n                const mutedOnServer = pub.isMuted || ((_b = (_a = pub.track) === null || _a === void 0 ? void 0 : _a.isUpstreamPaused) !== null && _b !== void 0 ? _b : false);\n                if (mutedOnServer !== ti.muted) {\n                    this.log.debug(\"updating server mute state after reconcile\", Object.assign(Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(pub)), {\n                        mutedOnServer\n                    }));\n                    this.engine.client.sendMuteTrack(ti.sid, mutedOnServer);\n                }\n            }\n        });\n        return true;\n    }\n    getPublicationForTrack(track) {\n        let publication;\n        this.trackPublications.forEach((pub)=>{\n            const localTrack = pub.track;\n            if (!localTrack) {\n                return;\n            }\n            // this looks overly complicated due to this object tree\n            if (track instanceof MediaStreamTrack) {\n                if (isLocalAudioTrack(localTrack) || isLocalVideoTrack(localTrack)) {\n                    if (localTrack.mediaStreamTrack === track) {\n                        publication = pub;\n                    }\n                }\n            } else if (track === localTrack) {\n                publication = pub;\n            }\n        });\n        return publication;\n    }\n    waitForPendingPublicationOfSource(source) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const waitForPendingTimeout = 10000;\n            const startTime = Date.now();\n            while(Date.now() < startTime + waitForPendingTimeout){\n                const publishPromiseEntry = Array.from(this.pendingPublishPromises.entries()).find((_ref4)=>{\n                    let [pendingTrack] = _ref4;\n                    return pendingTrack.source === source;\n                });\n                if (publishPromiseEntry) {\n                    return publishPromiseEntry[1];\n                }\n                yield sleep(20);\n            }\n        });\n    }\n}\nclass RemoteTrackPublication extends TrackPublication {\n    constructor(kind, ti, autoSubscribe, loggerOptions){\n        super(kind, ti.sid, ti.name, loggerOptions);\n        this.track = undefined;\n        /** @internal */ this.allowed = true;\n        this.disabled = false;\n        this.currentVideoQuality = VideoQuality.HIGH;\n        this.handleEnded = (track)=>{\n            this.setTrack(undefined);\n            this.emit(TrackEvent.Ended, track);\n        };\n        this.handleVisibilityChange = (visible)=>{\n            this.log.debug(\"adaptivestream video visibility \".concat(this.trackSid, \", visible=\").concat(visible), this.logContext);\n            this.disabled = !visible;\n            this.emitTrackUpdate();\n        };\n        this.handleVideoDimensionsChange = (dimensions)=>{\n            this.log.debug(\"adaptivestream video dimensions \".concat(dimensions.width, \"x\").concat(dimensions.height), this.logContext);\n            this.videoDimensions = dimensions;\n            this.emitTrackUpdate();\n        };\n        this.subscribed = autoSubscribe;\n        this.updateInfo(ti);\n    }\n    /**\n   * Subscribe or unsubscribe to this remote track\n   * @param subscribed true to subscribe to a track, false to unsubscribe\n   */ setSubscribed(subscribed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.subscribed = subscribed;\n        // reset allowed status when desired subscription state changes\n        // server will notify client via signal message if it's not allowed\n        if (subscribed) {\n            this.allowed = true;\n        }\n        const sub = new UpdateSubscription({\n            trackSids: [\n                this.trackSid\n            ],\n            subscribe: this.subscribed,\n            participantTracks: [\n                new ParticipantTracks({\n                    // sending an empty participant id since TrackPublication doesn't keep it\n                    // this is filled in by the participant that receives this message\n                    participantSid: \"\",\n                    trackSids: [\n                        this.trackSid\n                    ]\n                })\n            ]\n        });\n        this.emit(TrackEvent.UpdateSubscription, sub);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n        this.emitPermissionUpdateIfChanged(prevPermission);\n    }\n    get subscriptionStatus() {\n        if (this.subscribed === false) {\n            return TrackPublication.SubscriptionStatus.Unsubscribed;\n        }\n        if (!super.isSubscribed) {\n            return TrackPublication.SubscriptionStatus.Desired;\n        }\n        return TrackPublication.SubscriptionStatus.Subscribed;\n    }\n    get permissionStatus() {\n        return this.allowed ? TrackPublication.PermissionStatus.Allowed : TrackPublication.PermissionStatus.NotAllowed;\n    }\n    /**\n   * Returns true if track is subscribed, and ready for playback\n   */ get isSubscribed() {\n        if (this.subscribed === false) {\n            return false;\n        }\n        return super.isSubscribed;\n    }\n    // returns client's desire to subscribe to a track, also true if autoSubscribe is enabled\n    get isDesired() {\n        return this.subscribed !== false;\n    }\n    get isEnabled() {\n        return !this.disabled;\n    }\n    get isLocal() {\n        return false;\n    }\n    /**\n   * disable server from sending down data for this track. this is useful when\n   * the participant is off screen, you may disable streaming down their video\n   * to reduce bandwidth requirements\n   * @param enabled\n   */ setEnabled(enabled) {\n        if (!this.isManualOperationAllowed() || this.disabled === !enabled) {\n            return;\n        }\n        this.disabled = !enabled;\n        this.emitTrackUpdate();\n    }\n    /**\n   * for tracks that support simulcasting, adjust subscribed quality\n   *\n   * This indicates the highest quality the client can accept. if network\n   * bandwidth does not allow, server will automatically reduce quality to\n   * optimize for uninterrupted video\n   */ setVideoQuality(quality) {\n        if (!this.isManualOperationAllowed() || this.currentVideoQuality === quality) {\n            return;\n        }\n        this.currentVideoQuality = quality;\n        this.videoDimensions = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoDimensions(dimensions) {\n        var _a, _b;\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (((_a = this.videoDimensions) === null || _a === void 0 ? void 0 : _a.width) === dimensions.width && ((_b = this.videoDimensions) === null || _b === void 0 ? void 0 : _b.height) === dimensions.height) {\n            return;\n        }\n        if (isRemoteVideoTrack(this.track)) {\n            this.videoDimensions = dimensions;\n        }\n        this.currentVideoQuality = undefined;\n        this.emitTrackUpdate();\n    }\n    setVideoFPS(fps) {\n        if (!this.isManualOperationAllowed()) {\n            return;\n        }\n        if (!isRemoteVideoTrack(this.track)) {\n            return;\n        }\n        if (this.fps === fps) {\n            return;\n        }\n        this.fps = fps;\n        this.emitTrackUpdate();\n    }\n    get videoQuality() {\n        return this.currentVideoQuality;\n    }\n    /** @internal */ setTrack(track) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        const prevTrack = this.track;\n        if (prevTrack === track) {\n            return;\n        }\n        if (prevTrack) {\n            // unregister listener\n            prevTrack.off(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            prevTrack.off(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            prevTrack.off(TrackEvent.Ended, this.handleEnded);\n            prevTrack.detach();\n            prevTrack.stopMonitor();\n            this.emit(TrackEvent.Unsubscribed, prevTrack);\n        }\n        super.setTrack(track);\n        if (track) {\n            track.sid = this.trackSid;\n            track.on(TrackEvent.VideoDimensionsChanged, this.handleVideoDimensionsChange);\n            track.on(TrackEvent.VisibilityChanged, this.handleVisibilityChange);\n            track.on(TrackEvent.Ended, this.handleEnded);\n            this.emit(TrackEvent.Subscribed, track);\n        }\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setAllowed(allowed) {\n        const prevStatus = this.subscriptionStatus;\n        const prevPermission = this.permissionStatus;\n        this.allowed = allowed;\n        this.emitPermissionUpdateIfChanged(prevPermission);\n        this.emitSubscriptionUpdateIfChanged(prevStatus);\n    }\n    /** @internal */ setSubscriptionError(error) {\n        this.emit(TrackEvent.SubscriptionFailed, error);\n    }\n    /** @internal */ updateInfo(info) {\n        super.updateInfo(info);\n        const prevMetadataMuted = this.metadataMuted;\n        this.metadataMuted = info.muted;\n        if (this.track) {\n            this.track.setMuted(info.muted);\n        } else if (prevMetadataMuted !== info.muted) {\n            this.emit(info.muted ? TrackEvent.Muted : TrackEvent.Unmuted);\n        }\n    }\n    emitSubscriptionUpdateIfChanged(previousStatus) {\n        const currentStatus = this.subscriptionStatus;\n        if (previousStatus === currentStatus) {\n            return;\n        }\n        this.emit(TrackEvent.SubscriptionStatusChanged, currentStatus, previousStatus);\n    }\n    emitPermissionUpdateIfChanged(previousPermissionStatus) {\n        const currentPermissionStatus = this.permissionStatus;\n        if (currentPermissionStatus !== previousPermissionStatus) {\n            this.emit(TrackEvent.SubscriptionPermissionChanged, this.permissionStatus, previousPermissionStatus);\n        }\n    }\n    isManualOperationAllowed() {\n        if (this.kind === Track.Kind.Video && this.isAdaptiveStream) {\n            this.log.warn(\"adaptive stream is enabled, cannot change video track settings\", this.logContext);\n            return false;\n        }\n        if (!this.isDesired) {\n            this.log.warn(\"cannot update track settings when not subscribed\", this.logContext);\n            return false;\n        }\n        return true;\n    }\n    get isAdaptiveStream() {\n        return isRemoteVideoTrack(this.track) && this.track.isAdaptiveStream;\n    }\n    /* @internal */ emitTrackUpdate() {\n        const settings = new UpdateTrackSettings({\n            trackSids: [\n                this.trackSid\n            ],\n            disabled: this.disabled,\n            fps: this.fps\n        });\n        if (this.videoDimensions) {\n            settings.width = Math.ceil(this.videoDimensions.width);\n            settings.height = Math.ceil(this.videoDimensions.height);\n        } else if (this.currentVideoQuality !== undefined) {\n            settings.quality = this.currentVideoQuality;\n        } else {\n            // defaults to high quality\n            settings.quality = VideoQuality.HIGH;\n        }\n        this.emit(TrackEvent.UpdateSettings, settings);\n    }\n}\nclass RemoteParticipant extends Participant {\n    /** @internal */ static fromParticipantInfo(signalClient, pi, loggerOptions) {\n        return new RemoteParticipant(signalClient, pi.sid, pi.identity, pi.name, pi.metadata, pi.attributes, loggerOptions, pi.kind);\n    }\n    get logContext() {\n        return Object.assign(Object.assign({}, super.logContext), {\n            rpID: this.sid,\n            remoteParticipant: this.identity\n        });\n    }\n    /** @internal */ constructor(signalClient, sid, identity, name, metadata, attributes, loggerOptions){\n        let kind = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : ParticipantInfo_Kind.STANDARD;\n        super(sid, identity || \"\", name, metadata, attributes, loggerOptions, kind);\n        this.signalClient = signalClient;\n        this.trackPublications = new Map();\n        this.audioTrackPublications = new Map();\n        this.videoTrackPublications = new Map();\n        this.volumeMap = new Map();\n    }\n    addTrackPublication(publication) {\n        super.addTrackPublication(publication);\n        // register action events\n        publication.on(TrackEvent.UpdateSettings, (settings)=>{\n            this.log.debug(\"send update settings\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.signalClient.sendUpdateTrackSettings(settings);\n        });\n        publication.on(TrackEvent.UpdateSubscription, (sub)=>{\n            sub.participantTracks.forEach((pt)=>{\n                pt.participantSid = this.sid;\n            });\n            this.signalClient.sendUpdateSubscription(sub);\n        });\n        publication.on(TrackEvent.SubscriptionPermissionChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionPermissionChanged, publication, status);\n        });\n        publication.on(TrackEvent.SubscriptionStatusChanged, (status)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionStatusChanged, publication, status);\n        });\n        publication.on(TrackEvent.Subscribed, (track)=>{\n            this.emit(ParticipantEvent.TrackSubscribed, track, publication);\n        });\n        publication.on(TrackEvent.Unsubscribed, (previousTrack)=>{\n            this.emit(ParticipantEvent.TrackUnsubscribed, previousTrack, publication);\n        });\n        publication.on(TrackEvent.SubscriptionFailed, (error)=>{\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, publication.trackSid, error);\n        });\n    }\n    getTrackPublication(source) {\n        const track = super.getTrackPublication(source);\n        if (track) {\n            return track;\n        }\n    }\n    getTrackPublicationByName(name) {\n        const track = super.getTrackPublicationByName(name);\n        if (track) {\n            return track;\n        }\n    }\n    /**\n   * sets the volume on the participant's audio track\n   * by default, this affects the microphone publication\n   * a different source can be passed in as a second argument\n   * if no track exists the volume will be applied when the microphone track is added\n   */ setVolume(volume) {\n        let source = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Track.Source.Microphone;\n        this.volumeMap.set(source, volume);\n        const audioPublication = this.getTrackPublication(source);\n        if (audioPublication && audioPublication.track) {\n            audioPublication.track.setVolume(volume);\n        }\n    }\n    /**\n   * gets the volume on the participant's microphone track\n   */ getVolume() {\n        let source = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Track.Source.Microphone;\n        const audioPublication = this.getTrackPublication(source);\n        if (audioPublication && audioPublication.track) {\n            return audioPublication.track.getVolume();\n        }\n        return this.volumeMap.get(source);\n    }\n    /** @internal */ addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft) {\n        // find the track publication\n        // it's possible for the media track to arrive before participant info\n        let publication = this.getTrackPublicationBySid(sid);\n        // it's also possible that the browser didn't honor our original track id\n        // FireFox would use its own local uuid instead of server track id\n        if (!publication) {\n            if (!sid.startsWith(\"TR\")) {\n                // find the first track that matches type\n                this.trackPublications.forEach((p)=>{\n                    if (!publication && mediaTrack.kind === p.kind.toString()) {\n                        publication = p;\n                    }\n                });\n            }\n        }\n        // when we couldn't locate the track, it's possible that the metadata hasn't\n        // yet arrived. Wait a bit longer for it to arrive, or fire an error\n        if (!publication) {\n            if (triesLeft === 0) {\n                this.log.error(\"could not find published track\", Object.assign(Object.assign({}, this.logContext), {\n                    trackSid: sid\n                }));\n                this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n                return;\n            }\n            if (triesLeft === undefined) triesLeft = 20;\n            setTimeout(()=>{\n                this.addSubscribedMediaTrack(mediaTrack, sid, mediaStream, receiver, adaptiveStreamSettings, triesLeft - 1);\n            }, 150);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            this.log.error(\"unable to subscribe because MediaStreamTrack is ended. Do not call MediaStreamTrack.stop()\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n            this.emit(ParticipantEvent.TrackSubscriptionFailed, sid);\n            return;\n        }\n        const isVideo = mediaTrack.kind === \"video\";\n        let track;\n        if (isVideo) {\n            track = new RemoteVideoTrack(mediaTrack, sid, receiver, adaptiveStreamSettings);\n        } else {\n            track = new RemoteAudioTrack(mediaTrack, sid, receiver, this.audioContext, this.audioOutput);\n        }\n        // set track info\n        track.source = publication.source;\n        // keep publication's muted status\n        track.isMuted = publication.isMuted;\n        track.setMediaStream(mediaStream);\n        track.start();\n        publication.setTrack(track);\n        // set participant volumes on new audio tracks\n        if (this.volumeMap.has(publication.source) && isRemoteTrack(track) && isAudioTrack(track)) {\n            track.setVolume(this.volumeMap.get(publication.source));\n        }\n        return publication;\n    }\n    /** @internal */ get hasMetadata() {\n        return !!this.participantInfo;\n    }\n    /**\n   * @internal\n   */ getTrackPublicationBySid(sid) {\n        return this.trackPublications.get(sid);\n    }\n    /** @internal */ updateInfo(info) {\n        if (!super.updateInfo(info)) {\n            return false;\n        }\n        // we are getting a list of all available tracks, reconcile in here\n        // and send out events for changes\n        // reconcile track publications, publish events only if metadata is already there\n        // i.e. changes since the local participant has joined\n        const validTracks = new Map();\n        const newTracks = new Map();\n        info.tracks.forEach((ti)=>{\n            var _a, _b;\n            let publication = this.getTrackPublicationBySid(ti.sid);\n            if (!publication) {\n                // new publication\n                const kind = Track.kindFromProto(ti.type);\n                if (!kind) {\n                    return;\n                }\n                publication = new RemoteTrackPublication(kind, ti, (_a = this.signalClient.connectOptions) === null || _a === void 0 ? void 0 : _a.autoSubscribe, {\n                    loggerContextCb: ()=>this.logContext,\n                    loggerName: (_b = this.loggerOptions) === null || _b === void 0 ? void 0 : _b.loggerName\n                });\n                publication.updateInfo(ti);\n                newTracks.set(ti.sid, publication);\n                const existingTrackOfSource = Array.from(this.trackPublications.values()).find((publishedTrack)=>publishedTrack.source === (publication === null || publication === void 0 ? void 0 : publication.source));\n                if (existingTrackOfSource && publication.source !== Track.Source.Unknown) {\n                    this.log.debug(\"received a second track publication for \".concat(this.identity, \" with the same source: \").concat(publication.source), Object.assign(Object.assign({}, this.logContext), {\n                        oldTrack: getLogContextFromTrack(existingTrackOfSource),\n                        newTrack: getLogContextFromTrack(publication)\n                    }));\n                }\n                this.addTrackPublication(publication);\n            } else {\n                publication.updateInfo(ti);\n            }\n            validTracks.set(ti.sid, publication);\n        });\n        // detect removed tracks\n        this.trackPublications.forEach((publication)=>{\n            if (!validTracks.has(publication.trackSid)) {\n                this.log.trace(\"detected removed track on remote participant, unpublishing\", Object.assign(Object.assign({}, this.logContext), getLogContextFromTrack(publication)));\n                this.unpublishTrack(publication.trackSid, true);\n            }\n        });\n        // always emit events for new publications, Room will not forward them unless it's ready\n        newTracks.forEach((publication)=>{\n            this.emit(ParticipantEvent.TrackPublished, publication);\n        });\n        return true;\n    }\n    /** @internal */ unpublishTrack(sid, sendUnpublish) {\n        const publication = this.trackPublications.get(sid);\n        if (!publication) {\n            return;\n        }\n        // also send unsubscribe, if track is actively subscribed\n        const { track } = publication;\n        if (track) {\n            track.stop();\n            publication.setTrack(undefined);\n        }\n        // remove track from maps only after unsubscribed has been fired\n        this.trackPublications.delete(sid);\n        // remove from the right type map\n        switch(publication.kind){\n            case Track.Kind.Audio:\n                this.audioTrackPublications.delete(sid);\n                break;\n            case Track.Kind.Video:\n                this.videoTrackPublications.delete(sid);\n                break;\n        }\n        if (sendUnpublish) {\n            this.emit(ParticipantEvent.TrackUnpublished, publication);\n        }\n    }\n    /**\n   * @internal\n   */ setAudioOutput(output) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.audioOutput = output;\n            const promises = [];\n            this.audioTrackPublications.forEach((pub)=>{\n                var _a;\n                if (isAudioTrack(pub.track) && isRemoteTrack(pub.track)) {\n                    promises.push(pub.track.setSinkId((_a = output.deviceId) !== null && _a !== void 0 ? _a : \"default\"));\n                }\n            });\n            yield Promise.all(promises);\n        });\n    }\n    /** @internal */ emit(event) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        this.log.trace(\"participant event\", Object.assign(Object.assign({}, this.logContext), {\n            event,\n            args\n        }));\n        return super.emit(event, ...args);\n    }\n}\nvar ConnectionState;\n(function(ConnectionState) {\n    ConnectionState[\"Disconnected\"] = \"disconnected\";\n    ConnectionState[\"Connecting\"] = \"connecting\";\n    ConnectionState[\"Connected\"] = \"connected\";\n    ConnectionState[\"Reconnecting\"] = \"reconnecting\";\n    ConnectionState[\"SignalReconnecting\"] = \"signalReconnecting\";\n})(ConnectionState || (ConnectionState = {}));\nconst connectionReconcileFrequency = 4 * 1000;\n/**\n * In LiveKit, a room is the logical grouping for a list of participants.\n * Participants in a room can publish tracks, and subscribe to others' tracks.\n *\n * a Room fires [[RoomEvent | RoomEvents]].\n *\n * @noInheritDoc\n */ class Room extends eventsExports.EventEmitter {\n    /**\n   * Creates a new Room, the primary construct for a LiveKit session.\n   * @param options\n   */ constructor(options){\n        var _this;\n        var _a, _b, _c;\n        super();\n        _this = this;\n        this.state = ConnectionState.Disconnected;\n        /**\n     * list of participants that are actively speaking. when this changes\n     * a [[RoomEvent.ActiveSpeakersChanged]] event is fired\n     */ this.activeSpeakers = [];\n        /** reflects the sender encryption status of the local participant */ this.isE2EEEnabled = false;\n        this.audioEnabled = true;\n        this.isVideoPlaybackBlocked = false;\n        this.log = livekitLogger;\n        this.bufferedEvents = [];\n        this.isResuming = false;\n        this.byteStreamControllers = new Map();\n        this.textStreamControllers = new Map();\n        this.byteStreamHandlers = new Map();\n        this.textStreamHandlers = new Map();\n        this.rpcHandlers = new Map();\n        this.connect = (url, token, opts)=>__awaiter(this, void 0, void 0, function*() {\n                var _a;\n                if (!isBrowserSupported()) {\n                    if (isReactNative()) {\n                        throw Error(\"WebRTC isn't detected, have you called registerGlobals?\");\n                    } else {\n                        throw Error(\"LiveKit doesn't seem to be supported on this browser. Try to update your browser and make sure no browser extensions are disabling webRTC.\");\n                    }\n                }\n                // In case a disconnect called happened right before the connect call, make sure the disconnect is completed first by awaiting its lock\n                const unlockDisconnect = yield this.disconnectLock.lock();\n                if (this.state === ConnectionState.Connected) {\n                    // when the state is reconnecting or connected, this function returns immediately\n                    this.log.info(\"already connected to room \".concat(this.name), this.logContext);\n                    unlockDisconnect();\n                    return Promise.resolve();\n                }\n                if (this.connectFuture) {\n                    unlockDisconnect();\n                    return this.connectFuture.promise;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connecting);\n                if (((_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.getServerUrl().toString()) !== url) {\n                    this.regionUrl = undefined;\n                    this.regionUrlProvider = undefined;\n                }\n                if (isCloud(new URL(url))) {\n                    if (this.regionUrlProvider === undefined) {\n                        this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    } else {\n                        this.regionUrlProvider.updateToken(token);\n                    }\n                    // trigger the first fetch without waiting for a response\n                    // if initial connection fails, this will speed up picking regional url\n                    // on subsequent runs\n                    this.regionUrlProvider.fetchRegionSettings().then((settings)=>{\n                        var _a;\n                        (_a = this.regionUrlProvider) === null || _a === void 0 ? void 0 : _a.setServerReportedRegions(settings);\n                    }).catch((e)=>{\n                        this.log.warn(\"could not fetch region settings\", Object.assign(Object.assign({}, this.logContext), {\n                            error: e\n                        }));\n                    });\n                }\n                const connectFn = (resolve, reject, regionUrl)=>__awaiter(this, void 0, void 0, function*() {\n                        var _a, _b;\n                        if (this.abortController) {\n                            this.abortController.abort();\n                        }\n                        // explicit creation as local var needed to satisfy TS compiler when passing it to `attemptConnection` further down\n                        const abortController = new AbortController();\n                        this.abortController = abortController;\n                        // at this point the intention to connect has been signalled so we can allow cancelling of the connection via disconnect() again\n                        unlockDisconnect === null || unlockDisconnect === void 0 ? void 0 : unlockDisconnect();\n                        try {\n                            yield this.attemptConnection(regionUrl !== null && regionUrl !== void 0 ? regionUrl : url, token, opts, abortController);\n                            this.abortController = undefined;\n                            resolve();\n                        } catch (e) {\n                            if (this.regionUrlProvider && e instanceof ConnectionError && e.reason !== ConnectionErrorReason.Cancelled && e.reason !== ConnectionErrorReason.NotAllowed) {\n                                let nextUrl = null;\n                                try {\n                                    nextUrl = yield this.regionUrlProvider.getNextBestRegionUrl((_a = this.abortController) === null || _a === void 0 ? void 0 : _a.signal);\n                                } catch (error) {\n                                    if (error instanceof ConnectionError && (error.status === 401 || error.reason === ConnectionErrorReason.Cancelled)) {\n                                        this.handleDisconnect(this.options.stopLocalTrackOnUnpublish);\n                                        reject(error);\n                                        return;\n                                    }\n                                }\n                                if (nextUrl && !((_b = this.abortController) === null || _b === void 0 ? void 0 : _b.signal.aborted)) {\n                                    this.log.info(\"Initial connection failed with ConnectionError: \".concat(e.message, \". Retrying with another region: \").concat(nextUrl), this.logContext);\n                                    this.recreateEngine();\n                                    yield connectFn(resolve, reject, nextUrl);\n                                } else {\n                                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, getDisconnectReasonFromConnectionError(e));\n                                    reject(e);\n                                }\n                            } else {\n                                let disconnectReason = DisconnectReason.UNKNOWN_REASON;\n                                if (e instanceof ConnectionError) {\n                                    disconnectReason = getDisconnectReasonFromConnectionError(e);\n                                }\n                                this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, disconnectReason);\n                                reject(e);\n                            }\n                        }\n                    });\n                const regionUrl = this.regionUrl;\n                this.regionUrl = undefined;\n                this.connectFuture = new Future((resolve, reject)=>{\n                    connectFn(resolve, reject, regionUrl);\n                }, ()=>{\n                    this.clearConnectionFutures();\n                });\n                return this.connectFuture.promise;\n            });\n        this.connectSignal = (url, token, engine, connectOptions, roomOptions, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c;\n                const joinResponse = yield engine.join(url, token, {\n                    autoSubscribe: connectOptions.autoSubscribe,\n                    adaptiveStream: typeof roomOptions.adaptiveStream === \"object\" ? true : roomOptions.adaptiveStream,\n                    maxRetries: connectOptions.maxRetries,\n                    e2eeEnabled: !!this.e2eeManager,\n                    websocketTimeout: connectOptions.websocketTimeout\n                }, abortController.signal);\n                let serverInfo = joinResponse.serverInfo;\n                if (!serverInfo) {\n                    serverInfo = {\n                        version: joinResponse.serverVersion,\n                        region: joinResponse.serverRegion\n                    };\n                }\n                this.serverInfo = serverInfo;\n                this.log.debug(\"connected to Livekit Server \".concat(Object.entries(serverInfo).map((_ref)=>{\n                    let [key, value] = _ref;\n                    return \"\".concat(key, \": \").concat(value);\n                }).join(\", \")), {\n                    room: (_a = joinResponse.room) === null || _a === void 0 ? void 0 : _a.name,\n                    roomSid: (_b = joinResponse.room) === null || _b === void 0 ? void 0 : _b.sid,\n                    identity: (_c = joinResponse.participant) === null || _c === void 0 ? void 0 : _c.identity\n                });\n                if (!serverInfo.version) {\n                    throw new UnsupportedServer(\"unknown server version\");\n                }\n                if (serverInfo.version === \"0.15.1\" && this.options.dynacast) {\n                    this.log.debug(\"disabling dynacast due to server version\", this.logContext);\n                    // dynacast has a bug in 0.15.1, so we cannot use it then\n                    roomOptions.dynacast = false;\n                }\n                return joinResponse;\n            });\n        this.applyJoinResponse = (joinResponse)=>{\n            const pi = joinResponse.participant;\n            this.localParticipant.sid = pi.sid;\n            this.localParticipant.identity = pi.identity;\n            this.localParticipant.setEnabledPublishCodecs(joinResponse.enabledPublishCodecs);\n            if (this.options.e2ee && this.e2eeManager) {\n                try {\n                    this.e2eeManager.setSifTrailer(joinResponse.sifTrailer);\n                } catch (e) {\n                    this.log.error(e instanceof Error ? e.message : \"Could not set SifTrailer\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            // populate remote participants, these should not trigger new events\n            this.handleParticipantUpdates([\n                pi,\n                ...joinResponse.otherParticipants\n            ]);\n            if (joinResponse.room) {\n                this.handleRoomUpdate(joinResponse.room);\n            }\n        };\n        this.attemptConnection = (url, token, opts, abortController)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                if (this.state === ConnectionState.Reconnecting || this.isResuming || ((_a = this.engine) === null || _a === void 0 ? void 0 : _a.pendingReconnect)) {\n                    this.log.info(\"Reconnection attempt replaced by new connection attempt\", this.logContext);\n                    // make sure we close and recreate the existing engine in order to get rid of any potentially ongoing reconnection attempts\n                    this.recreateEngine();\n                } else {\n                    // create engine if previously disconnected\n                    this.maybeCreateEngine();\n                }\n                if ((_b = this.regionUrlProvider) === null || _b === void 0 ? void 0 : _b.isCloud()) {\n                    this.engine.setRegionUrlProvider(this.regionUrlProvider);\n                }\n                this.acquireAudioContext();\n                this.connOptions = Object.assign(Object.assign({}, roomConnectOptionDefaults), opts);\n                if (this.connOptions.rtcConfig) {\n                    this.engine.rtcConfig = this.connOptions.rtcConfig;\n                }\n                if (this.connOptions.peerConnectionTimeout) {\n                    this.engine.peerConnectionTimeout = this.connOptions.peerConnectionTimeout;\n                }\n                try {\n                    const joinResponse = yield this.connectSignal(url, token, this.engine, this.connOptions, this.options, abortController);\n                    this.applyJoinResponse(joinResponse);\n                    // forward metadata changed for the local participant\n                    this.setupLocalParticipantEvents();\n                    this.emit(RoomEvent.SignalConnected);\n                } catch (err) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    const resultingError = new ConnectionError(\"could not establish signal connection\", ConnectionErrorReason.ServerUnreachable);\n                    if (err instanceof Error) {\n                        resultingError.message = \"\".concat(resultingError.message, \": \").concat(err.message);\n                    }\n                    if (err instanceof ConnectionError) {\n                        resultingError.reason = err.reason;\n                        resultingError.status = err.status;\n                    }\n                    this.log.debug(\"error trying to establish signal connection\", Object.assign(Object.assign({}, this.logContext), {\n                        error: err\n                    }));\n                    throw resultingError;\n                }\n                if (abortController.signal.aborted) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw new ConnectionError(\"Connection attempt aborted\", ConnectionErrorReason.Cancelled);\n                }\n                try {\n                    yield this.engine.waitForPCInitialConnection(this.connOptions.peerConnectionTimeout, abortController);\n                } catch (e) {\n                    yield this.engine.close();\n                    this.recreateEngine();\n                    throw e;\n                }\n                // also hook unload event\n                if (isWeb() && this.options.disconnectOnPageLeave) {\n                    // capturing both 'pagehide' and 'beforeunload' to capture broadest set of browser behaviors\n                    window.addEventListener(\"pagehide\", this.onPageLeave);\n                    window.addEventListener(\"beforeunload\", this.onPageLeave);\n                }\n                if (isWeb()) {\n                    document.addEventListener(\"freeze\", this.onPageLeave);\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Connected);\n                this.registerConnectionReconcile();\n            });\n        /**\n     * disconnects the room, emits [[RoomEvent.Disconnected]]\n     */ this.disconnect = function() {\n            for(var _len = arguments.length, args_1 = new Array(_len), _key = 0; _key < _len; _key++){\n                args_1[_key] = arguments[_key];\n            }\n            return __awaiter(_this, [\n                ...args_1\n            ], void 0, function() {\n                var _this2 = this;\n                let stopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n                return function*() {\n                    var _a, _b, _c, _d;\n                    const unlock = yield _this2.disconnectLock.lock();\n                    try {\n                        if (_this2.state === ConnectionState.Disconnected) {\n                            _this2.log.debug(\"already disconnected\", _this2.logContext);\n                            return;\n                        }\n                        _this2.log.info(\"disconnect from room\", Object.assign({}, _this2.logContext));\n                        if (_this2.state === ConnectionState.Connecting || _this2.state === ConnectionState.Reconnecting || _this2.isResuming) {\n                            // try aborting pending connection attempt\n                            _this2.log.warn(\"abort connection attempt\", _this2.logContext);\n                            (_a = _this2.abortController) === null || _a === void 0 ? void 0 : _a.abort();\n                            // in case the abort controller didn't manage to cancel the connection attempt, reject the connect promise explicitly\n                            (_c = (_b = _this2.connectFuture) === null || _b === void 0 ? void 0 : _b.reject) === null || _c === void 0 ? void 0 : _c.call(_b, new ConnectionError(\"Client initiated disconnect\", ConnectionErrorReason.Cancelled));\n                            _this2.connectFuture = undefined;\n                        }\n                        // send leave\n                        if (!((_d = _this2.engine) === null || _d === void 0 ? void 0 : _d.client.isDisconnected)) {\n                            yield _this2.engine.client.sendLeave();\n                        }\n                        // close engine (also closes client)\n                        if (_this2.engine) {\n                            yield _this2.engine.close();\n                        }\n                        _this2.handleDisconnect(stopTracks, DisconnectReason.CLIENT_INITIATED);\n                        /* @ts-ignore */ _this2.engine = undefined;\n                    } finally{\n                        unlock();\n                    }\n                }();\n            });\n        };\n        this.onPageLeave = ()=>__awaiter(this, void 0, void 0, function*() {\n                this.log.info(\"Page leave detected, disconnecting\", this.logContext);\n                yield this.disconnect();\n            });\n        /**\n     * Browsers have different policies regarding audio playback. Most requiring\n     * some form of user interaction (click/tap/etc).\n     * In those cases, audio will be silent until a click/tap triggering one of the following\n     * - `startAudio`\n     * - `getUserMedia`\n     */ this.startAudio = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                const browser = getBrowser();\n                if (browser && browser.os === \"iOS\") {\n                    /**\n         * iOS blocks audio element playback if\n         * - user is not publishing audio themselves and\n         * - no other audio source is playing\n         *\n         * as a workaround, we create an audio element with an empty track, so that\n         * silent audio is always playing\n         */ const audioId = \"livekit-dummy-audio-el\";\n                    let dummyAudioEl = document.getElementById(audioId);\n                    if (!dummyAudioEl) {\n                        dummyAudioEl = document.createElement(\"audio\");\n                        dummyAudioEl.id = audioId;\n                        dummyAudioEl.autoplay = true;\n                        dummyAudioEl.hidden = true;\n                        const track = getEmptyAudioStreamTrack();\n                        track.enabled = true;\n                        const stream = new MediaStream([\n                            track\n                        ]);\n                        dummyAudioEl.srcObject = stream;\n                        document.addEventListener(\"visibilitychange\", ()=>{\n                            if (!dummyAudioEl) {\n                                return;\n                            }\n                            // set the srcObject to null on page hide in order to prevent lock screen controls to show up for it\n                            dummyAudioEl.srcObject = document.hidden ? null : stream;\n                            if (!document.hidden) {\n                                this.log.debug(\"page visible again, triggering startAudio to resume playback and update playback status\", this.logContext);\n                                this.startAudio();\n                            }\n                        });\n                        document.body.append(dummyAudioEl);\n                        this.once(RoomEvent.Disconnected, ()=>{\n                            dummyAudioEl === null || dummyAudioEl === void 0 ? void 0 : dummyAudioEl.remove();\n                            dummyAudioEl = null;\n                        });\n                    }\n                    elements.push(dummyAudioEl);\n                }\n                this.remoteParticipants.forEach((p)=>{\n                    p.audioTrackPublications.forEach((t)=>{\n                        if (t.track) {\n                            t.track.attachedElements.forEach((e)=>{\n                                elements.push(e);\n                            });\n                        }\n                    });\n                });\n                try {\n                    yield Promise.all([\n                        this.acquireAudioContext(),\n                        ...elements.map((e)=>{\n                            e.muted = false;\n                            return e.play();\n                        })\n                    ]);\n                    this.handleAudioPlaybackStarted();\n                } catch (err) {\n                    this.handleAudioPlaybackFailed(err);\n                    throw err;\n                }\n            });\n        this.startVideo = ()=>__awaiter(this, void 0, void 0, function*() {\n                const elements = [];\n                for (const p of this.remoteParticipants.values()){\n                    p.videoTrackPublications.forEach((tr)=>{\n                        var _a;\n                        (_a = tr.track) === null || _a === void 0 ? void 0 : _a.attachedElements.forEach((el)=>{\n                            if (!elements.includes(el)) {\n                                elements.push(el);\n                            }\n                        });\n                    });\n                }\n                yield Promise.all(elements.map((el)=>el.play())).then(()=>{\n                    this.handleVideoPlaybackStarted();\n                }).catch((e)=>{\n                    if (e.name === \"NotAllowedError\") {\n                        this.handleVideoPlaybackFailed();\n                    } else {\n                        this.log.warn(\"Resuming video playback failed, make sure you call `startVideo` directly in a user gesture handler\", this.logContext);\n                    }\n                });\n            });\n        this.handleRestarting = ()=>{\n            this.clearConnectionReconcile();\n            // in case we went from resuming to full-reconnect, make sure to reflect it on the isResuming flag\n            this.isResuming = false;\n            // also unwind existing participants & existing subscriptions\n            for (const p of this.remoteParticipants.values()){\n                this.handleParticipantDisconnected(p.identity, p);\n            }\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        };\n        this.handleSignalRestarted = (joinResponse)=>__awaiter(this, void 0, void 0, function*() {\n                this.log.debug(\"signal reconnected to server, region \".concat(joinResponse.serverRegion), Object.assign(Object.assign({}, this.logContext), {\n                    region: joinResponse.serverRegion\n                }));\n                this.bufferedEvents = [];\n                this.applyJoinResponse(joinResponse);\n                try {\n                    // unpublish & republish tracks\n                    yield this.localParticipant.republishAllTracks(undefined, true);\n                } catch (error) {\n                    this.log.error(\"error trying to re-publish tracks after reconnection\", Object.assign(Object.assign({}, this.logContext), {\n                        error\n                    }));\n                }\n                try {\n                    yield this.engine.waitForRestarted();\n                    this.log.debug(\"fully reconnected to server\", Object.assign(Object.assign({}, this.logContext), {\n                        region: joinResponse.serverRegion\n                    }));\n                } catch (_a) {\n                    // reconnection failed, handleDisconnect is being invoked already, just return here\n                    return;\n                }\n                this.setAndEmitConnectionState(ConnectionState.Connected);\n                this.emit(RoomEvent.Reconnected);\n                this.registerConnectionReconcile();\n                this.emitBufferedEvents();\n            });\n        this.handleParticipantUpdates = (participantInfos)=>{\n            // handle changes to participant state, and send events\n            participantInfos.forEach((info)=>{\n                var _a;\n                if (info.identity === this.localParticipant.identity) {\n                    this.localParticipant.updateInfo(info);\n                    return;\n                }\n                // LiveKit server doesn't send identity info prior to version 1.5.2 in disconnect updates\n                // so we try to map an empty identity to an already known sID manually\n                if (info.identity === \"\") {\n                    info.identity = (_a = this.sidToIdentity.get(info.sid)) !== null && _a !== void 0 ? _a : \"\";\n                }\n                let remoteParticipant = this.remoteParticipants.get(info.identity);\n                // when it's disconnected, send updates\n                if (info.state === ParticipantInfo_State.DISCONNECTED) {\n                    this.handleParticipantDisconnected(info.identity, remoteParticipant);\n                } else {\n                    // create participant if doesn't exist\n                    remoteParticipant = this.getOrCreateParticipant(info.identity, info);\n                }\n            });\n        };\n        // updates are sent only when there's a change to speaker ordering\n        this.handleActiveSpeakersUpdate = (speakers)=>{\n            const activeSpeakers = [];\n            const seenSids = {};\n            speakers.forEach((speaker)=>{\n                seenSids[speaker.sid] = true;\n                if (speaker.sid === this.localParticipant.sid) {\n                    this.localParticipant.audioLevel = speaker.level;\n                    this.localParticipant.setIsSpeaking(true);\n                    activeSpeakers.push(this.localParticipant);\n                } else {\n                    const p = this.getRemoteParticipantBySid(speaker.sid);\n                    if (p) {\n                        p.audioLevel = speaker.level;\n                        p.setIsSpeaking(true);\n                        activeSpeakers.push(p);\n                    }\n                }\n            });\n            if (!seenSids[this.localParticipant.sid]) {\n                this.localParticipant.audioLevel = 0;\n                this.localParticipant.setIsSpeaking(false);\n            }\n            this.remoteParticipants.forEach((p)=>{\n                if (!seenSids[p.sid]) {\n                    p.audioLevel = 0;\n                    p.setIsSpeaking(false);\n                }\n            });\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        // process list of changed speakers\n        this.handleSpeakersChanged = (speakerUpdates)=>{\n            const lastSpeakers = new Map();\n            this.activeSpeakers.forEach((p)=>{\n                const remoteParticipant = this.remoteParticipants.get(p.identity);\n                if (remoteParticipant && remoteParticipant.sid !== p.sid) {\n                    return;\n                }\n                lastSpeakers.set(p.sid, p);\n            });\n            speakerUpdates.forEach((speaker)=>{\n                let p = this.getRemoteParticipantBySid(speaker.sid);\n                if (speaker.sid === this.localParticipant.sid) {\n                    p = this.localParticipant;\n                }\n                if (!p) {\n                    return;\n                }\n                p.audioLevel = speaker.level;\n                p.setIsSpeaking(speaker.active);\n                if (speaker.active) {\n                    lastSpeakers.set(speaker.sid, p);\n                } else {\n                    lastSpeakers.delete(speaker.sid);\n                }\n            });\n            const activeSpeakers = Array.from(lastSpeakers.values());\n            activeSpeakers.sort((a, b)=>b.audioLevel - a.audioLevel);\n            this.activeSpeakers = activeSpeakers;\n            this.emitWhenConnected(RoomEvent.ActiveSpeakersChanged, activeSpeakers);\n        };\n        this.handleStreamStateUpdate = (streamStateUpdate)=>{\n            streamStateUpdate.streamStates.forEach((streamState)=>{\n                const participant = this.getRemoteParticipantBySid(streamState.participantSid);\n                if (!participant) {\n                    return;\n                }\n                const pub = participant.getTrackPublicationBySid(streamState.trackSid);\n                if (!pub || !pub.track) {\n                    return;\n                }\n                const newStreamState = Track.streamStateFromProto(streamState.state);\n                if (newStreamState !== pub.track.streamState) {\n                    pub.track.streamState = newStreamState;\n                    participant.emit(ParticipantEvent.TrackStreamStateChanged, pub, pub.track.streamState);\n                    this.emitWhenConnected(RoomEvent.TrackStreamStateChanged, pub, pub.track.streamState, participant);\n                }\n            });\n        };\n        this.handleSubscriptionPermissionUpdate = (update)=>{\n            const participant = this.getRemoteParticipantBySid(update.participantSid);\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublicationBySid(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setAllowed(update.allowed);\n        };\n        this.handleSubscriptionError = (update)=>{\n            const participant = Array.from(this.remoteParticipants.values()).find((p)=>p.trackPublications.has(update.trackSid));\n            if (!participant) {\n                return;\n            }\n            const pub = participant.getTrackPublicationBySid(update.trackSid);\n            if (!pub) {\n                return;\n            }\n            pub.setSubscriptionError(update.err);\n        };\n        this.handleDataPacket = (packet)=>{\n            // find the participant\n            const participant = this.remoteParticipants.get(packet.participantIdentity);\n            if (packet.value.case === \"user\") {\n                this.handleUserPacket(participant, packet.value.value, packet.kind);\n            } else if (packet.value.case === \"transcription\") {\n                this.handleTranscription(participant, packet.value.value);\n            } else if (packet.value.case === \"sipDtmf\") {\n                this.handleSipDtmf(participant, packet.value.value);\n            } else if (packet.value.case === \"chatMessage\") {\n                this.handleChatMessage(participant, packet.value.value);\n            } else if (packet.value.case === \"metrics\") {\n                this.handleMetrics(packet.value.value, participant);\n            } else if (packet.value.case === \"streamHeader\") {\n                this.handleStreamHeader(packet.value.value, packet.participantIdentity);\n            } else if (packet.value.case === \"streamChunk\") {\n                this.handleStreamChunk(packet.value.value);\n            } else if (packet.value.case === \"streamTrailer\") {\n                this.handleStreamTrailer(packet.value.value);\n            } else if (packet.value.case === \"rpcRequest\") {\n                const rpc = packet.value.value;\n                this.handleIncomingRpcRequest(packet.participantIdentity, rpc.id, rpc.method, rpc.payload, rpc.responseTimeoutMs, rpc.version);\n            }\n        };\n        this.handleUserPacket = (participant, userPacket, kind)=>{\n            this.emit(RoomEvent.DataReceived, userPacket.payload, participant, kind, userPacket.topic);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.DataReceived, userPacket.payload, kind);\n        };\n        this.handleSipDtmf = (participant, dtmf)=>{\n            this.emit(RoomEvent.SipDTMFReceived, dtmf, participant);\n            // also emit on the participant\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.SipDTMFReceived, dtmf);\n        };\n        this.bufferedSegments = new Map();\n        this.handleTranscription = (_remoteParticipant, transcription)=>{\n            // find the participant\n            const participant = transcription.transcribedParticipantIdentity === this.localParticipant.identity ? this.localParticipant : this.getParticipantByIdentity(transcription.transcribedParticipantIdentity);\n            const publication = participant === null || participant === void 0 ? void 0 : participant.trackPublications.get(transcription.trackId);\n            const segments = extractTranscriptionSegments(transcription, this.transcriptionReceivedTimes);\n            publication === null || publication === void 0 ? void 0 : publication.emit(TrackEvent.TranscriptionReceived, segments);\n            participant === null || participant === void 0 ? void 0 : participant.emit(ParticipantEvent.TranscriptionReceived, segments, publication);\n            this.emit(RoomEvent.TranscriptionReceived, segments, participant, publication);\n        };\n        this.handleChatMessage = (participant, chatMessage)=>{\n            const msg = extractChatMessage(chatMessage);\n            this.emit(RoomEvent.ChatMessage, msg, participant);\n        };\n        this.handleMetrics = (metrics, participant)=>{\n            this.emit(RoomEvent.MetricsReceived, metrics, participant);\n        };\n        this.handleAudioPlaybackStarted = ()=>{\n            if (this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = true;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, true);\n        };\n        this.handleAudioPlaybackFailed = (e)=>{\n            this.log.warn(\"could not playback audio\", Object.assign(Object.assign({}, this.logContext), {\n                error: e\n            }));\n            if (!this.canPlaybackAudio) {\n                return;\n            }\n            this.audioEnabled = false;\n            this.emit(RoomEvent.AudioPlaybackStatusChanged, false);\n        };\n        this.handleVideoPlaybackStarted = ()=>{\n            if (this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = false;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, true);\n            }\n        };\n        this.handleVideoPlaybackFailed = ()=>{\n            if (!this.isVideoPlaybackBlocked) {\n                this.isVideoPlaybackBlocked = true;\n                this.emit(RoomEvent.VideoPlaybackStatusChanged, false);\n            }\n        };\n        this.handleDeviceChange = ()=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b;\n                const previousDevices = DeviceManager.getInstance().previousDevices;\n                // check for available devices, but don't request permissions in order to avoid prompts for kinds that haven't been used before\n                const availableDevices = yield DeviceManager.getInstance().getDevices(undefined, false);\n                const browser = getBrowser();\n                if ((browser === null || browser === void 0 ? void 0 : browser.name) === \"Chrome\" && browser.os !== \"iOS\") {\n                    for (let availableDevice of availableDevices){\n                        const previousDevice = previousDevices.find((info)=>info.deviceId === availableDevice.deviceId);\n                        if (previousDevice && previousDevice.label !== \"\" && previousDevice.kind === availableDevice.kind && previousDevice.label !== availableDevice.label) {\n                            // label has changed on device the same deviceId, indicating that the default device has changed on the OS level\n                            if (this.getActiveDevice(availableDevice.kind) === \"default\") {\n                                // emit an active device change event only if the selected output device is actually on `default`\n                                this.emit(RoomEvent.ActiveDeviceChanged, availableDevice.kind, availableDevice.deviceId);\n                            }\n                        }\n                    }\n                }\n                // inputs are automatically handled via TrackEvent.Ended causing a TrackEvent.Restarted. Here we only need to worry about audiooutputs changing\n                const kinds = [\n                    \"audiooutput\",\n                    \"audioinput\",\n                    \"videoinput\"\n                ];\n                for (let kind of kinds){\n                    const devicesOfKind = availableDevices.filter((d)=>d.kind === kind);\n                    const activeDevice = this.getActiveDevice(kind);\n                    if (activeDevice === ((_a = previousDevices.filter((info)=>info.kind === kind)[0]) === null || _a === void 0 ? void 0 : _a.deviceId)) {\n                        // in  Safari the first device is always the default, so we assume a user on the default device would like to switch to the default once it changes\n                        // FF doesn't emit an event when the default device changes, so we perform the same best effort and switch to the new device once connected and if it's the first in the array\n                        if (devicesOfKind.length > 0 && ((_b = devicesOfKind[0]) === null || _b === void 0 ? void 0 : _b.deviceId) !== activeDevice) {\n                            yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n                            continue;\n                        }\n                    }\n                    if (kind === \"audioinput\" && !isSafari() || kind === \"videoinput\") {\n                        continue;\n                    }\n                    // switch to first available device if previously active device is not available any more\n                    if (devicesOfKind.length > 0 && !devicesOfKind.find((deviceInfo)=>deviceInfo.deviceId === this.getActiveDevice(kind))) {\n                        yield this.switchActiveDevice(kind, devicesOfKind[0].deviceId);\n                    }\n                }\n                this.emit(RoomEvent.MediaDevicesChanged);\n            });\n        this.handleRoomUpdate = (room)=>{\n            const oldRoom = this.roomInfo;\n            this.roomInfo = room;\n            if (oldRoom && oldRoom.metadata !== room.metadata) {\n                this.emitWhenConnected(RoomEvent.RoomMetadataChanged, room.metadata);\n            }\n            if ((oldRoom === null || oldRoom === void 0 ? void 0 : oldRoom.activeRecording) !== room.activeRecording) {\n                this.emitWhenConnected(RoomEvent.RecordingStatusChanged, room.activeRecording);\n            }\n        };\n        this.handleConnectionQualityUpdate = (update)=>{\n            update.updates.forEach((info)=>{\n                if (info.participantSid === this.localParticipant.sid) {\n                    this.localParticipant.setConnectionQuality(info.quality);\n                    return;\n                }\n                const participant = this.getRemoteParticipantBySid(info.participantSid);\n                if (participant) {\n                    participant.setConnectionQuality(info.quality);\n                }\n            });\n        };\n        this.onLocalParticipantMetadataChanged = (metadata)=>{\n            this.emit(RoomEvent.ParticipantMetadataChanged, metadata, this.localParticipant);\n        };\n        this.onLocalParticipantNameChanged = (name)=>{\n            this.emit(RoomEvent.ParticipantNameChanged, name, this.localParticipant);\n        };\n        this.onLocalAttributesChanged = (changedAttributes)=>{\n            this.emit(RoomEvent.ParticipantAttributesChanged, changedAttributes, this.localParticipant);\n        };\n        this.onLocalTrackMuted = (pub)=>{\n            this.emit(RoomEvent.TrackMuted, pub, this.localParticipant);\n        };\n        this.onLocalTrackUnmuted = (pub)=>{\n            this.emit(RoomEvent.TrackUnmuted, pub, this.localParticipant);\n        };\n        this.onTrackProcessorUpdate = (processor)=>{\n            var _a;\n            (_a = processor === null || processor === void 0 ? void 0 : processor.onPublish) === null || _a === void 0 ? void 0 : _a.call(processor, this);\n        };\n        this.onLocalTrackPublished = (pub)=>__awaiter(this, void 0, void 0, function*() {\n                var _a, _b, _c, _d, _e, _f;\n                (_a = pub.track) === null || _a === void 0 ? void 0 : _a.on(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n                (_b = pub.track) === null || _b === void 0 ? void 0 : _b.on(TrackEvent.Restarted, this.onLocalTrackRestarted);\n                (_e = (_d = (_c = pub.track) === null || _c === void 0 ? void 0 : _c.getProcessor()) === null || _d === void 0 ? void 0 : _d.onPublish) === null || _e === void 0 ? void 0 : _e.call(_d, this);\n                this.emit(RoomEvent.LocalTrackPublished, pub, this.localParticipant);\n                if (isLocalAudioTrack(pub.track)) {\n                    const trackIsSilent = yield pub.track.checkForSilence();\n                    if (trackIsSilent) {\n                        this.emit(RoomEvent.LocalAudioSilenceDetected, pub);\n                    }\n                }\n                const deviceId = yield (_f = pub.track) === null || _f === void 0 ? void 0 : _f.getDeviceId(false);\n                const deviceKind = sourceToKind(pub.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalTrackUnpublished = (pub)=>{\n            var _a, _b;\n            (_a = pub.track) === null || _a === void 0 ? void 0 : _a.off(TrackEvent.TrackProcessorUpdate, this.onTrackProcessorUpdate);\n            (_b = pub.track) === null || _b === void 0 ? void 0 : _b.off(TrackEvent.Restarted, this.onLocalTrackRestarted);\n            this.emit(RoomEvent.LocalTrackUnpublished, pub, this.localParticipant);\n        };\n        this.onLocalTrackRestarted = (track)=>__awaiter(this, void 0, void 0, function*() {\n                const deviceId = yield track.getDeviceId(false);\n                const deviceKind = sourceToKind(track.source);\n                if (deviceKind && deviceId && deviceId !== this.localParticipant.activeDeviceMap.get(deviceKind)) {\n                    this.log.debug(\"local track restarted, setting \".concat(deviceKind, \" \").concat(deviceId, \" active\"), this.logContext);\n                    this.localParticipant.activeDeviceMap.set(deviceKind, deviceId);\n                    this.emit(RoomEvent.ActiveDeviceChanged, deviceKind, deviceId);\n                }\n            });\n        this.onLocalConnectionQualityChanged = (quality)=>{\n            this.emit(RoomEvent.ConnectionQualityChanged, quality, this.localParticipant);\n        };\n        this.onMediaDevicesError = (e)=>{\n            this.emit(RoomEvent.MediaDevicesError, e);\n        };\n        this.onLocalParticipantPermissionsChanged = (prevPermissions)=>{\n            this.emit(RoomEvent.ParticipantPermissionsChanged, prevPermissions, this.localParticipant);\n        };\n        this.onLocalChatMessageSent = (msg)=>{\n            this.emit(RoomEvent.ChatMessage, msg, this.localParticipant);\n        };\n        this.setMaxListeners(100);\n        this.remoteParticipants = new Map();\n        this.sidToIdentity = new Map();\n        this.options = Object.assign(Object.assign({}, roomOptionDefaults), options);\n        this.log = getLogger((_a = this.options.loggerName) !== null && _a !== void 0 ? _a : LoggerNames.Room);\n        this.transcriptionReceivedTimes = new Map();\n        this.options.audioCaptureDefaults = Object.assign(Object.assign({}, audioDefaults), options === null || options === void 0 ? void 0 : options.audioCaptureDefaults);\n        this.options.videoCaptureDefaults = Object.assign(Object.assign({}, videoDefaults), options === null || options === void 0 ? void 0 : options.videoCaptureDefaults);\n        this.options.publishDefaults = Object.assign(Object.assign({}, publishDefaults), options === null || options === void 0 ? void 0 : options.publishDefaults);\n        this.maybeCreateEngine();\n        this.disconnectLock = new _();\n        this.localParticipant = new LocalParticipant(\"\", \"\", this.engine, this.options, this.rpcHandlers);\n        if (this.options.videoCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"videoinput\", unwrapConstraint(this.options.videoCaptureDefaults.deviceId));\n        }\n        if (this.options.audioCaptureDefaults.deviceId) {\n            this.localParticipant.activeDeviceMap.set(\"audioinput\", unwrapConstraint(this.options.audioCaptureDefaults.deviceId));\n        }\n        if ((_b = this.options.audioOutput) === null || _b === void 0 ? void 0 : _b.deviceId) {\n            this.switchActiveDevice(\"audiooutput\", unwrapConstraint(this.options.audioOutput.deviceId)).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        if (this.options.e2ee) {\n            this.setupE2EE();\n        }\n        if (isWeb()) {\n            const abortController = new AbortController();\n            // in order to catch device changes prior to room connection we need to register the event in the constructor\n            (_c = navigator.mediaDevices) === null || _c === void 0 ? void 0 : _c.addEventListener(\"devicechange\", this.handleDeviceChange, {\n                signal: abortController.signal\n            });\n            if (Room.cleanupRegistry) {\n                Room.cleanupRegistry.register(this, ()=>{\n                    abortController.abort();\n                });\n            }\n        }\n    }\n    registerTextStreamHandler(topic, callback) {\n        if (this.textStreamHandlers.has(topic)) {\n            throw new TypeError('A text stream handler for topic \"'.concat(topic, '\" has already been set.'));\n        }\n        this.textStreamHandlers.set(topic, callback);\n    }\n    unregisterTextStreamHandler(topic) {\n        this.textStreamHandlers.delete(topic);\n    }\n    registerByteStreamHandler(topic, callback) {\n        if (this.byteStreamHandlers.has(topic)) {\n            throw new TypeError('A byte stream handler for topic \"'.concat(topic, '\" has already been set.'));\n        }\n        this.byteStreamHandlers.set(topic, callback);\n    }\n    unregisterByteStreamHandler(topic) {\n        this.byteStreamHandlers.delete(topic);\n    }\n    /**\n   * Establishes the participant as a receiver for calls of the specified RPC method.\n   *\n   * @param method - The name of the indicated RPC method\n   * @param handler - Will be invoked when an RPC request for this method is received\n   * @returns A promise that resolves when the method is successfully registered\n   * @throws {Error} If a handler for this method is already registered (must call unregisterRpcMethod first)\n   *\n   * @example\n   * ```typescript\n   * room.localParticipant?.registerRpcMethod(\n   *   'greet',\n   *   async (data: RpcInvocationData) => {\n   *     console.log(`Received greeting from ${data.callerIdentity}: ${data.payload}`);\n   *     return `Hello, ${data.callerIdentity}!`;\n   *   }\n   * );\n   * ```\n   *\n   * The handler should return a Promise that resolves to a string.\n   * If unable to respond within `responseTimeout`, the request will result in an error on the caller's side.\n   *\n   * You may throw errors of type `RpcError` with a string `message` in the handler,\n   * and they will be received on the caller's side with the message intact.\n   * Other errors thrown in your handler will not be transmitted as-is, and will instead arrive to the caller as `1500` (\"Application Error\").\n   */ registerRpcMethod(method, handler) {\n        if (this.rpcHandlers.has(method)) {\n            throw Error(\"RPC handler already registered for method \".concat(method, \", unregisterRpcMethod before trying to register again\"));\n        }\n        this.rpcHandlers.set(method, handler);\n    }\n    /**\n   * Unregisters a previously registered RPC method.\n   *\n   * @param method - The name of the RPC method to unregister\n   */ unregisterRpcMethod(method) {\n        this.rpcHandlers.delete(method);\n    }\n    handleIncomingRpcRequest(callerIdentity, requestId, method, payload, responseTimeout, version) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.engine.publishRpcAck(callerIdentity, requestId);\n            if (version !== 1) {\n                yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn(\"UNSUPPORTED_VERSION\"));\n                return;\n            }\n            const handler = this.rpcHandlers.get(method);\n            if (!handler) {\n                yield this.engine.publishRpcResponse(callerIdentity, requestId, null, RpcError.builtIn(\"UNSUPPORTED_METHOD\"));\n                return;\n            }\n            let responseError = null;\n            let responsePayload = null;\n            try {\n                const response = yield handler({\n                    requestId,\n                    callerIdentity,\n                    payload,\n                    responseTimeout\n                });\n                if (byteLength(response) > MAX_PAYLOAD_BYTES) {\n                    responseError = RpcError.builtIn(\"RESPONSE_PAYLOAD_TOO_LARGE\");\n                    console.warn(\"RPC Response payload too large for \".concat(method));\n                } else {\n                    responsePayload = response;\n                }\n            } catch (error) {\n                if (error instanceof RpcError) {\n                    responseError = error;\n                } else {\n                    console.warn(\"Uncaught error returned by RPC handler for \".concat(method, \". Returning APPLICATION_ERROR instead.\"), error);\n                    responseError = RpcError.builtIn(\"APPLICATION_ERROR\");\n                }\n            }\n            yield this.engine.publishRpcResponse(callerIdentity, requestId, responsePayload, responseError);\n        });\n    }\n    /**\n   * @experimental\n   */ setE2EEEnabled(enabled) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.e2eeManager) {\n                yield Promise.all([\n                    this.localParticipant.setE2EEEnabled(enabled)\n                ]);\n                if (this.localParticipant.identity !== \"\") {\n                    this.e2eeManager.setParticipantCryptorEnabled(enabled, this.localParticipant.identity);\n                }\n            } else {\n                throw Error(\"e2ee not configured, please set e2ee settings within the room options\");\n            }\n        });\n    }\n    setupE2EE() {\n        var _a;\n        if (this.options.e2ee) {\n            if (\"e2eeManager\" in this.options.e2ee) {\n                this.e2eeManager = this.options.e2ee.e2eeManager;\n            } else {\n                this.e2eeManager = new E2EEManager(this.options.e2ee);\n            }\n            this.e2eeManager.on(EncryptionEvent.ParticipantEncryptionStatusChanged, (enabled, participant)=>{\n                if (isLocalParticipant(participant)) {\n                    this.isE2EEEnabled = enabled;\n                }\n                this.emit(RoomEvent.ParticipantEncryptionStatusChanged, enabled, participant);\n            });\n            this.e2eeManager.on(EncryptionEvent.EncryptionError, (error)=>this.emit(RoomEvent.EncryptionError, error));\n            (_a = this.e2eeManager) === null || _a === void 0 ? void 0 : _a.setup(this);\n        }\n    }\n    get logContext() {\n        var _a;\n        return {\n            room: this.name,\n            roomID: (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.sid,\n            participant: this.localParticipant.identity,\n            pID: this.localParticipant.sid\n        };\n    }\n    /**\n   * if the current room has a participant with `recorder: true` in its JWT grant\n   **/ get isRecording() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.activeRecording) !== null && _b !== void 0 ? _b : false;\n    }\n    /**\n   * server assigned unique room id.\n   * returns once a sid has been issued by the server.\n   */ getSid() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state === ConnectionState.Disconnected) {\n                return \"\";\n            }\n            if (this.roomInfo && this.roomInfo.sid !== \"\") {\n                return this.roomInfo.sid;\n            }\n            return new Promise((resolve, reject)=>{\n                const handleRoomUpdate = (roomInfo)=>{\n                    if (roomInfo.sid !== \"\") {\n                        this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n                        resolve(roomInfo.sid);\n                    }\n                };\n                this.engine.on(EngineEvent.RoomUpdate, handleRoomUpdate);\n                this.once(RoomEvent.Disconnected, ()=>{\n                    this.engine.off(EngineEvent.RoomUpdate, handleRoomUpdate);\n                    reject(\"Room disconnected before room server id was available\");\n                });\n            });\n        });\n    }\n    /** user assigned name, derived from JWT token */ get name() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : \"\";\n    }\n    /** room metadata */ get metadata() {\n        var _a;\n        return (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.metadata;\n    }\n    get numParticipants() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numParticipants) !== null && _b !== void 0 ? _b : 0;\n    }\n    get numPublishers() {\n        var _a, _b;\n        return (_b = (_a = this.roomInfo) === null || _a === void 0 ? void 0 : _a.numPublishers) !== null && _b !== void 0 ? _b : 0;\n    }\n    maybeCreateEngine() {\n        if (this.engine && !this.engine.isClosed) {\n            return;\n        }\n        this.engine = new RTCEngine(this.options);\n        this.engine.on(EngineEvent.ParticipantUpdate, this.handleParticipantUpdates).on(EngineEvent.RoomUpdate, this.handleRoomUpdate).on(EngineEvent.SpeakersChanged, this.handleSpeakersChanged).on(EngineEvent.StreamStateChanged, this.handleStreamStateUpdate).on(EngineEvent.ConnectionQualityUpdate, this.handleConnectionQualityUpdate).on(EngineEvent.SubscriptionError, this.handleSubscriptionError).on(EngineEvent.SubscriptionPermissionUpdate, this.handleSubscriptionPermissionUpdate).on(EngineEvent.MediaTrackAdded, (mediaTrack, stream, receiver)=>{\n            this.onTrackAdded(mediaTrack, stream, receiver);\n        }).on(EngineEvent.Disconnected, (reason)=>{\n            this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, reason);\n        }).on(EngineEvent.ActiveSpeakersUpdate, this.handleActiveSpeakersUpdate).on(EngineEvent.DataPacketReceived, this.handleDataPacket).on(EngineEvent.Resuming, ()=>{\n            this.clearConnectionReconcile();\n            this.isResuming = true;\n            this.log.info(\"Resuming signal connection\", this.logContext);\n            if (this.setAndEmitConnectionState(ConnectionState.SignalReconnecting)) {\n                this.emit(RoomEvent.SignalReconnecting);\n            }\n        }).on(EngineEvent.Resumed, ()=>{\n            this.registerConnectionReconcile();\n            this.isResuming = false;\n            this.log.info(\"Resumed signal connection\", this.logContext);\n            this.updateSubscriptions();\n            this.emitBufferedEvents();\n            if (this.setAndEmitConnectionState(ConnectionState.Connected)) {\n                this.emit(RoomEvent.Reconnected);\n            }\n        }).on(EngineEvent.SignalResumed, ()=>{\n            this.bufferedEvents = [];\n            if (this.state === ConnectionState.Reconnecting || this.isResuming) {\n                this.sendSyncState();\n            }\n        }).on(EngineEvent.Restarting, this.handleRestarting).on(EngineEvent.SignalRestarted, this.handleSignalRestarted).on(EngineEvent.Offline, ()=>{\n            if (this.setAndEmitConnectionState(ConnectionState.Reconnecting)) {\n                this.emit(RoomEvent.Reconnecting);\n            }\n        }).on(EngineEvent.DCBufferStatusChanged, (status, kind)=>{\n            this.emit(RoomEvent.DCBufferStatusChanged, status, kind);\n        }).on(EngineEvent.LocalTrackSubscribed, (subscribedSid)=>{\n            const trackPublication = this.localParticipant.getTrackPublications().find((_ref2)=>{\n                let { trackSid } = _ref2;\n                return trackSid === subscribedSid;\n            });\n            if (!trackPublication) {\n                this.log.warn(\"could not find local track subscription for subscribed event\", this.logContext);\n                return;\n            }\n            this.localParticipant.emit(ParticipantEvent.LocalTrackSubscribed, trackPublication);\n            this.emitWhenConnected(RoomEvent.LocalTrackSubscribed, trackPublication, this.localParticipant);\n        });\n        if (this.localParticipant) {\n            this.localParticipant.setupEngine(this.engine);\n        }\n        if (this.e2eeManager) {\n            this.e2eeManager.setupEngine(this.engine);\n        }\n    }\n    /**\n   * getLocalDevices abstracts navigator.mediaDevices.enumerateDevices.\n   * In particular, it requests device permissions by default if needed\n   * and makes sure the returned device does not consist of dummy devices\n   * @param kind\n   * @returns a list of available local devices\n   */ static getLocalDevices(kind) {\n        let requestPermissions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n        return DeviceManager.getInstance().getDevices(kind, requestPermissions);\n    }\n    /**\n   * prepareConnection should be called as soon as the page is loaded, in order\n   * to speed up the connection attempt. This function will\n   * - perform DNS resolution and pre-warm the DNS cache\n   * - establish TLS connection and cache TLS keys\n   *\n   * With LiveKit Cloud, it will also determine the best edge data center for\n   * the current client to connect to if a token is provided.\n   */ prepareConnection(url, token) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.state !== ConnectionState.Disconnected) {\n                return;\n            }\n            this.log.debug(\"prepareConnection to \".concat(url), this.logContext);\n            try {\n                if (isCloud(new URL(url)) && token) {\n                    this.regionUrlProvider = new RegionUrlProvider(url, token);\n                    const regionUrl = yield this.regionUrlProvider.getNextBestRegionUrl();\n                    // we will not replace the regionUrl if an attempt had already started\n                    // to avoid overriding regionUrl after a new connection attempt had started\n                    if (regionUrl && this.state === ConnectionState.Disconnected) {\n                        this.regionUrl = regionUrl;\n                        yield fetch(toHttpUrl(regionUrl), {\n                            method: \"HEAD\"\n                        });\n                        this.log.debug(\"prepared connection to \".concat(regionUrl), this.logContext);\n                    }\n                } else {\n                    yield fetch(toHttpUrl(url), {\n                        method: \"HEAD\"\n                    });\n                }\n            } catch (e) {\n                this.log.warn(\"could not prepare connection\", Object.assign(Object.assign({}, this.logContext), {\n                    error: e\n                }));\n            }\n        });\n    }\n    /**\n   * retrieves a participant by identity\n   * @param identity\n   * @returns\n   */ getParticipantByIdentity(identity) {\n        if (this.localParticipant.identity === identity) {\n            return this.localParticipant;\n        }\n        return this.remoteParticipants.get(identity);\n    }\n    clearConnectionFutures() {\n        this.connectFuture = undefined;\n    }\n    /**\n   * @internal for testing\n   */ simulateScenario(scenario, arg) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let postAction = ()=>{};\n            let req;\n            switch(scenario){\n                case \"signal-reconnect\":\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate disconnect\");\n                    break;\n                case \"speaker\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"speakerUpdate\",\n                            value: 3\n                        }\n                    });\n                    break;\n                case \"node-failure\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"nodeFailure\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"server-leave\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"serverLeave\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"migration\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"migration\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"resume-reconnect\":\n                    this.engine.failNext();\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                    break;\n                case \"disconnect-signal-on-resume\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResume\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"disconnect-signal-on-resume-no-messages\":\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            // @ts-expect-error function is private\n                            yield this.engine.client.handleOnClose(\"simulate resume-disconnect\");\n                        });\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"disconnectSignalOnResumeNoMessages\",\n                            value: true\n                        }\n                    });\n                    break;\n                case \"full-reconnect\":\n                    this.engine.fullReconnectOnNext = true;\n                    // @ts-expect-error function is private\n                    yield this.engine.client.handleOnClose(\"simulate full-reconnect\");\n                    break;\n                case \"force-tcp\":\n                case \"force-tls\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"switchCandidateProtocol\",\n                            value: scenario === \"force-tls\" ? 2 : 1\n                        }\n                    });\n                    postAction = ()=>__awaiter(this, void 0, void 0, function*() {\n                            const onLeave = this.engine.client.onLeave;\n                            if (onLeave) {\n                                onLeave(new LeaveRequest({\n                                    reason: DisconnectReason.CLIENT_INITIATED,\n                                    action: LeaveRequest_Action.RECONNECT\n                                }));\n                            }\n                        });\n                    break;\n                case \"subscriber-bandwidth\":\n                    if (arg === undefined || typeof arg !== \"number\") {\n                        throw new Error(\"subscriber-bandwidth requires a number as argument\");\n                    }\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"subscriberBandwidth\",\n                            value: numberToBigInt(arg)\n                        }\n                    });\n                    break;\n                case \"leave-full-reconnect\":\n                    req = new SimulateScenario({\n                        scenario: {\n                            case: \"leaveRequestFullReconnect\",\n                            value: true\n                        }\n                    });\n            }\n            if (req) {\n                yield this.engine.client.sendSimulateScenario(req);\n                yield postAction();\n            }\n        });\n    }\n    /**\n   * Returns true if audio playback is enabled\n   */ get canPlaybackAudio() {\n        return this.audioEnabled;\n    }\n    /**\n   * Returns true if video playback is enabled\n   */ get canPlaybackVideo() {\n        return !this.isVideoPlaybackBlocked;\n    }\n    getActiveDevice(kind) {\n        return this.localParticipant.activeDeviceMap.get(kind);\n    }\n    /**\n   * Switches all active devices used in this room to the given device.\n   *\n   * Note: setting AudioOutput is not supported on some browsers. See [setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId#browser_compatibility)\n   *\n   * @param kind use `videoinput` for camera track,\n   *  `audioinput` for microphone track,\n   *  `audiooutput` to set speaker for all incoming audio tracks\n   * @param deviceId\n   */ switchActiveDevice(kind_1, deviceId_1) {\n        return __awaiter(this, arguments, void 0, function(kind, deviceId) {\n            var _this3 = this;\n            let exact = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            return function*() {\n                var _a, _b, _c, _d, _e, _f, _g;\n                var _h;\n                let success = true;\n                let needsUpdateWithoutTracks = false;\n                const deviceConstraint = exact ? {\n                    exact: deviceId\n                } : deviceId;\n                if (kind === \"audioinput\") {\n                    needsUpdateWithoutTracks = _this3.localParticipant.audioTrackPublications.size === 0;\n                    const prevDeviceId = (_a = _this3.getActiveDevice(kind)) !== null && _a !== void 0 ? _a : _this3.options.audioCaptureDefaults.deviceId;\n                    _this3.options.audioCaptureDefaults.deviceId = deviceConstraint;\n                    const tracks = Array.from(_this3.localParticipant.audioTrackPublications.values()).filter((track)=>track.source === Track.Source.Microphone);\n                    try {\n                        success = (yield Promise.all(tracks.map((t)=>{\n                            var _a;\n                            return (_a = t.audioTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                        }))).every((val)=>val === true);\n                    } catch (e) {\n                        _this3.options.audioCaptureDefaults.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                } else if (kind === \"videoinput\") {\n                    needsUpdateWithoutTracks = _this3.localParticipant.videoTrackPublications.size === 0;\n                    const prevDeviceId = (_b = _this3.getActiveDevice(kind)) !== null && _b !== void 0 ? _b : _this3.options.videoCaptureDefaults.deviceId;\n                    _this3.options.videoCaptureDefaults.deviceId = deviceConstraint;\n                    const tracks = Array.from(_this3.localParticipant.videoTrackPublications.values()).filter((track)=>track.source === Track.Source.Camera);\n                    try {\n                        success = (yield Promise.all(tracks.map((t)=>{\n                            var _a;\n                            return (_a = t.videoTrack) === null || _a === void 0 ? void 0 : _a.setDeviceId(deviceConstraint);\n                        }))).every((val)=>val === true);\n                    } catch (e) {\n                        _this3.options.videoCaptureDefaults.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                } else if (kind === \"audiooutput\") {\n                    if (!supportsSetSinkId() && !_this3.options.webAudioMix || _this3.options.webAudioMix && _this3.audioContext && !(\"setSinkId\" in _this3.audioContext)) {\n                        throw new Error(\"cannot switch audio output, setSinkId not supported\");\n                    }\n                    if (_this3.options.webAudioMix) {\n                        // setting `default` for web audio output doesn't work, so we need to normalize the id before\n                        deviceId = (_c = yield DeviceManager.getInstance().normalizeDeviceId(\"audiooutput\", deviceId)) !== null && _c !== void 0 ? _c : \"\";\n                    }\n                    (_d = (_h = _this3.options).audioOutput) !== null && _d !== void 0 ? _d : _h.audioOutput = {};\n                    const prevDeviceId = (_e = _this3.getActiveDevice(kind)) !== null && _e !== void 0 ? _e : _this3.options.audioOutput.deviceId;\n                    _this3.options.audioOutput.deviceId = deviceId;\n                    try {\n                        if (_this3.options.webAudioMix) {\n                            // @ts-expect-error setSinkId is not yet in the typescript type of AudioContext\n                            (_f = _this3.audioContext) === null || _f === void 0 ? void 0 : _f.setSinkId(deviceId);\n                        }\n                        // also set audio output on all audio elements, even if webAudioMix is enabled in order to workaround echo cancellation not working on chrome with non-default output devices\n                        // see https://issues.chromium.org/issues/40252911#comment7\n                        yield Promise.all(Array.from(_this3.remoteParticipants.values()).map((p)=>p.setAudioOutput({\n                                deviceId\n                            })));\n                    } catch (e) {\n                        _this3.options.audioOutput.deviceId = prevDeviceId;\n                        throw e;\n                    }\n                }\n                if (needsUpdateWithoutTracks || kind === \"audiooutput\") {\n                    // if there are not active tracks yet or we're switching audiooutput, we need to manually update the active device map here as changing audio output won't result in a track restart\n                    _this3.localParticipant.activeDeviceMap.set(kind, kind === \"audiooutput\" && ((_g = _this3.options.audioOutput) === null || _g === void 0 ? void 0 : _g.deviceId) || deviceId);\n                    _this3.emit(RoomEvent.ActiveDeviceChanged, kind, deviceId);\n                }\n                return success;\n            }();\n        });\n    }\n    setupLocalParticipantEvents() {\n        this.localParticipant.on(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).on(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).on(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).on(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).on(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).on(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).on(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).on(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).on(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).on(ParticipantEvent.AudioStreamAcquired, this.startAudio).on(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).on(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n    }\n    recreateEngine() {\n        var _a;\n        (_a = this.engine) === null || _a === void 0 ? void 0 : _a.close();\n        /* @ts-ignore */ this.engine = undefined;\n        this.isResuming = false;\n        // clear out existing remote participants, since they may have attached\n        // the old engine\n        this.remoteParticipants.clear();\n        this.sidToIdentity.clear();\n        this.bufferedEvents = [];\n        this.maybeCreateEngine();\n    }\n    onTrackAdded(mediaTrack, stream, receiver) {\n        // don't fire onSubscribed when connecting\n        // WebRTC fires onTrack as soon as setRemoteDescription is called on the offer\n        // at that time, ICE connectivity has not been established so the track is not\n        // technically subscribed.\n        // We'll defer these events until when the room is connected or eventually disconnected.\n        if (this.state === ConnectionState.Connecting || this.state === ConnectionState.Reconnecting) {\n            const reconnectedHandler = ()=>{\n                this.onTrackAdded(mediaTrack, stream, receiver);\n                cleanup();\n            };\n            const cleanup = ()=>{\n                this.off(RoomEvent.Reconnected, reconnectedHandler);\n                this.off(RoomEvent.Connected, reconnectedHandler);\n                this.off(RoomEvent.Disconnected, cleanup);\n            };\n            this.once(RoomEvent.Reconnected, reconnectedHandler);\n            this.once(RoomEvent.Connected, reconnectedHandler);\n            this.once(RoomEvent.Disconnected, cleanup);\n            return;\n        }\n        if (this.state === ConnectionState.Disconnected) {\n            this.log.warn(\"skipping incoming track after Room disconnected\", this.logContext);\n            return;\n        }\n        if (mediaTrack.readyState === \"ended\") {\n            this.log.info(\"skipping incoming track as it already ended\", this.logContext);\n            return;\n        }\n        const parts = unpackStreamId(stream.id);\n        const participantSid = parts[0];\n        let streamId = parts[1];\n        let trackId = mediaTrack.id;\n        // firefox will get streamId (pID|trackId) instead of (pID|streamId) as it doesn't support sync tracks by stream\n        // and generates its own track id instead of infer from sdp track id.\n        if (streamId && streamId.startsWith(\"TR\")) trackId = streamId;\n        if (participantSid === this.localParticipant.sid) {\n            this.log.warn(\"tried to create RemoteParticipant for local participant\", this.logContext);\n            return;\n        }\n        const participant = Array.from(this.remoteParticipants.values()).find((p)=>p.sid === participantSid);\n        if (!participant) {\n            this.log.error(\"Tried to add a track for a participant, that's not present. Sid: \".concat(participantSid), this.logContext);\n            return;\n        }\n        let adaptiveStreamSettings;\n        if (this.options.adaptiveStream) {\n            if (typeof this.options.adaptiveStream === \"object\") {\n                adaptiveStreamSettings = this.options.adaptiveStream;\n            } else {\n                adaptiveStreamSettings = {};\n            }\n        }\n        participant.addSubscribedMediaTrack(mediaTrack, trackId, stream, receiver, adaptiveStreamSettings);\n    }\n    handleDisconnect() {\n        let shouldStopTracks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n        let reason = arguments.length > 1 ? arguments[1] : undefined;\n        var _a;\n        this.clearConnectionReconcile();\n        this.isResuming = false;\n        this.bufferedEvents = [];\n        this.transcriptionReceivedTimes.clear();\n        if (this.state === ConnectionState.Disconnected) {\n            return;\n        }\n        this.regionUrl = undefined;\n        try {\n            this.remoteParticipants.forEach((p)=>{\n                p.trackPublications.forEach((pub)=>{\n                    p.unpublishTrack(pub.trackSid);\n                });\n            });\n            this.localParticipant.trackPublications.forEach((pub)=>{\n                var _a, _b, _c;\n                if (pub.track) {\n                    this.localParticipant.unpublishTrack(pub.track, shouldStopTracks);\n                }\n                if (shouldStopTracks) {\n                    (_a = pub.track) === null || _a === void 0 ? void 0 : _a.detach();\n                    (_b = pub.track) === null || _b === void 0 ? void 0 : _b.stop();\n                } else {\n                    (_c = pub.track) === null || _c === void 0 ? void 0 : _c.stopMonitor();\n                }\n            });\n            this.localParticipant.off(ParticipantEvent.ParticipantMetadataChanged, this.onLocalParticipantMetadataChanged).off(ParticipantEvent.ParticipantNameChanged, this.onLocalParticipantNameChanged).off(ParticipantEvent.AttributesChanged, this.onLocalAttributesChanged).off(ParticipantEvent.TrackMuted, this.onLocalTrackMuted).off(ParticipantEvent.TrackUnmuted, this.onLocalTrackUnmuted).off(ParticipantEvent.LocalTrackPublished, this.onLocalTrackPublished).off(ParticipantEvent.LocalTrackUnpublished, this.onLocalTrackUnpublished).off(ParticipantEvent.ConnectionQualityChanged, this.onLocalConnectionQualityChanged).off(ParticipantEvent.MediaDevicesError, this.onMediaDevicesError).off(ParticipantEvent.AudioStreamAcquired, this.startAudio).off(ParticipantEvent.ChatMessage, this.onLocalChatMessageSent).off(ParticipantEvent.ParticipantPermissionsChanged, this.onLocalParticipantPermissionsChanged);\n            this.localParticipant.trackPublications.clear();\n            this.localParticipant.videoTrackPublications.clear();\n            this.localParticipant.audioTrackPublications.clear();\n            this.remoteParticipants.clear();\n            this.sidToIdentity.clear();\n            this.activeSpeakers = [];\n            if (this.audioContext && typeof this.options.webAudioMix === \"boolean\") {\n                this.audioContext.close();\n                this.audioContext = undefined;\n            }\n            if (isWeb()) {\n                window.removeEventListener(\"beforeunload\", this.onPageLeave);\n                window.removeEventListener(\"pagehide\", this.onPageLeave);\n                window.removeEventListener(\"freeze\", this.onPageLeave);\n                (_a = navigator.mediaDevices) === null || _a === void 0 ? void 0 : _a.removeEventListener(\"devicechange\", this.handleDeviceChange);\n            }\n        } finally{\n            this.setAndEmitConnectionState(ConnectionState.Disconnected);\n            this.emit(RoomEvent.Disconnected, reason);\n        }\n    }\n    handleParticipantDisconnected(identity, participant) {\n        var _a;\n        // remove and send event\n        this.remoteParticipants.delete(identity);\n        if (!participant) {\n            return;\n        }\n        participant.trackPublications.forEach((publication)=>{\n            participant.unpublishTrack(publication.trackSid, true);\n        });\n        this.emit(RoomEvent.ParticipantDisconnected, participant);\n        (_a = this.localParticipant) === null || _a === void 0 ? void 0 : _a.handleParticipantDisconnected(participant.identity);\n    }\n    handleStreamHeader(streamHeader, participantIdentity) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            if (streamHeader.contentHeader.case === \"byteHeader\") {\n                const streamHandlerCallback = this.byteStreamHandlers.get(streamHeader.topic);\n                if (!streamHandlerCallback) {\n                    this.log.debug(\"ignoring incoming byte stream due to no handler for topic\", streamHeader.topic);\n                    return;\n                }\n                let streamController;\n                const info = {\n                    id: streamHeader.streamId,\n                    name: (_a = streamHeader.contentHeader.value.name) !== null && _a !== void 0 ? _a : \"unknown\",\n                    mimeType: streamHeader.mimeType,\n                    size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n                    topic: streamHeader.topic,\n                    timestamp: bigIntToNumber(streamHeader.timestamp),\n                    attributes: streamHeader.attributes\n                };\n                const stream = new ReadableStream({\n                    start: (controller)=>{\n                        streamController = controller;\n                        this.byteStreamControllers.set(streamHeader.streamId, {\n                            info,\n                            controller: streamController,\n                            startTime: Date.now()\n                        });\n                    }\n                });\n                streamHandlerCallback(new ByteStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\n                    identity: participantIdentity\n                });\n            } else if (streamHeader.contentHeader.case === \"textHeader\") {\n                const streamHandlerCallback = this.textStreamHandlers.get(streamHeader.topic);\n                if (!streamHandlerCallback) {\n                    this.log.debug(\"ignoring incoming text stream due to no handler for topic\", streamHeader.topic);\n                    return;\n                }\n                let streamController;\n                const info = {\n                    id: streamHeader.streamId,\n                    mimeType: streamHeader.mimeType,\n                    size: streamHeader.totalLength ? Number(streamHeader.totalLength) : undefined,\n                    topic: streamHeader.topic,\n                    timestamp: Number(streamHeader.timestamp),\n                    attributes: streamHeader.attributes\n                };\n                const stream = new ReadableStream({\n                    start: (controller)=>{\n                        streamController = controller;\n                        this.textStreamControllers.set(streamHeader.streamId, {\n                            info,\n                            controller: streamController,\n                            startTime: Date.now()\n                        });\n                    }\n                });\n                streamHandlerCallback(new TextStreamReader(info, stream, bigIntToNumber(streamHeader.totalLength)), {\n                    identity: participantIdentity\n                });\n            }\n        });\n    }\n    handleStreamChunk(chunk) {\n        const fileBuffer = this.byteStreamControllers.get(chunk.streamId);\n        if (fileBuffer) {\n            if (chunk.content.length > 0) {\n                fileBuffer.controller.enqueue(chunk);\n            }\n        }\n        const textBuffer = this.textStreamControllers.get(chunk.streamId);\n        if (textBuffer) {\n            if (chunk.content.length > 0) {\n                textBuffer.controller.enqueue(chunk);\n            }\n        }\n    }\n    handleStreamTrailer(trailer) {\n        const textBuffer = this.textStreamControllers.get(trailer.streamId);\n        if (textBuffer) {\n            textBuffer.info.attributes = Object.assign(Object.assign({}, textBuffer.info.attributes), trailer.attributes);\n            textBuffer.controller.close();\n            this.textStreamControllers.delete(trailer.streamId);\n        }\n        const fileBuffer = this.byteStreamControllers.get(trailer.streamId);\n        if (fileBuffer) {\n            {\n                fileBuffer.info.attributes = Object.assign(Object.assign({}, fileBuffer.info.attributes), trailer.attributes);\n                fileBuffer.controller.close();\n                this.byteStreamControllers.delete(trailer.streamId);\n            }\n        }\n    }\n    acquireAudioContext() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            if (typeof this.options.webAudioMix !== \"boolean\" && this.options.webAudioMix.audioContext) {\n                // override audio context with custom audio context if supplied by user\n                this.audioContext = this.options.webAudioMix.audioContext;\n            } else if (!this.audioContext || this.audioContext.state === \"closed\") {\n                // by using an AudioContext, it reduces lag on audio elements\n                // https://stackoverflow.com/questions/9811429/html5-audio-tag-on-safari-has-a-delay/54119854#54119854\n                this.audioContext = (_a = getNewAudioContext()) !== null && _a !== void 0 ? _a : undefined;\n            }\n            if (this.options.webAudioMix) {\n                this.remoteParticipants.forEach((participant)=>participant.setAudioContext(this.audioContext));\n            }\n            this.localParticipant.setAudioContext(this.audioContext);\n            if (this.audioContext && this.audioContext.state === \"suspended\") {\n                // for iOS a newly created AudioContext is always in `suspended` state.\n                // we try our best to resume the context here, if that doesn't work, we just continue with regular processing\n                try {\n                    yield Promise.race([\n                        this.audioContext.resume(),\n                        sleep(200)\n                    ]);\n                } catch (e) {\n                    this.log.warn(\"Could not resume audio context\", Object.assign(Object.assign({}, this.logContext), {\n                        error: e\n                    }));\n                }\n            }\n            const newContextIsRunning = ((_b = this.audioContext) === null || _b === void 0 ? void 0 : _b.state) === \"running\";\n            if (newContextIsRunning !== this.canPlaybackAudio) {\n                this.audioEnabled = newContextIsRunning;\n                this.emit(RoomEvent.AudioPlaybackStatusChanged, newContextIsRunning);\n            }\n        });\n    }\n    createParticipant(identity, info) {\n        var _a;\n        let participant;\n        if (info) {\n            participant = RemoteParticipant.fromParticipantInfo(this.engine.client, info, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        } else {\n            participant = new RemoteParticipant(this.engine.client, \"\", identity, undefined, undefined, undefined, {\n                loggerContextCb: ()=>this.logContext,\n                loggerName: this.options.loggerName\n            });\n        }\n        if (this.options.webAudioMix) {\n            participant.setAudioContext(this.audioContext);\n        }\n        if ((_a = this.options.audioOutput) === null || _a === void 0 ? void 0 : _a.deviceId) {\n            participant.setAudioOutput(this.options.audioOutput).catch((e)=>this.log.warn(\"Could not set audio output: \".concat(e.message), this.logContext));\n        }\n        return participant;\n    }\n    getOrCreateParticipant(identity, info) {\n        if (this.remoteParticipants.has(identity)) {\n            const existingParticipant = this.remoteParticipants.get(identity);\n            if (info) {\n                const wasUpdated = existingParticipant.updateInfo(info);\n                if (wasUpdated) {\n                    this.sidToIdentity.set(info.sid, info.identity);\n                }\n            }\n            return existingParticipant;\n        }\n        const participant = this.createParticipant(identity, info);\n        this.remoteParticipants.set(identity, participant);\n        this.sidToIdentity.set(info.sid, info.identity);\n        // if we have valid info and the participant wasn't in the map before, we can assume the participant is new\n        // firing here to make sure that `ParticipantConnected` fires before the initial track events\n        this.emitWhenConnected(RoomEvent.ParticipantConnected, participant);\n        // also forward events\n        // trackPublished is only fired for tracks added after both local participant\n        // and remote participant joined the room\n        participant.on(ParticipantEvent.TrackPublished, (trackPublication)=>{\n            this.emitWhenConnected(RoomEvent.TrackPublished, trackPublication, participant);\n        }).on(ParticipantEvent.TrackSubscribed, (track, publication)=>{\n            // monitor playback status\n            if (track.kind === Track.Kind.Audio) {\n                track.on(TrackEvent.AudioPlaybackStarted, this.handleAudioPlaybackStarted);\n                track.on(TrackEvent.AudioPlaybackFailed, this.handleAudioPlaybackFailed);\n            } else if (track.kind === Track.Kind.Video) {\n                track.on(TrackEvent.VideoPlaybackFailed, this.handleVideoPlaybackFailed);\n                track.on(TrackEvent.VideoPlaybackStarted, this.handleVideoPlaybackStarted);\n            }\n            this.emit(RoomEvent.TrackSubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackUnpublished, (publication)=>{\n            this.emit(RoomEvent.TrackUnpublished, publication, participant);\n        }).on(ParticipantEvent.TrackUnsubscribed, (track, publication)=>{\n            this.emit(RoomEvent.TrackUnsubscribed, track, publication, participant);\n        }).on(ParticipantEvent.TrackMuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackMuted, pub, participant);\n        }).on(ParticipantEvent.TrackUnmuted, (pub)=>{\n            this.emitWhenConnected(RoomEvent.TrackUnmuted, pub, participant);\n        }).on(ParticipantEvent.ParticipantMetadataChanged, (metadata)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantMetadataChanged, metadata, participant);\n        }).on(ParticipantEvent.ParticipantNameChanged, (name)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantNameChanged, name, participant);\n        }).on(ParticipantEvent.AttributesChanged, (changedAttributes)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantAttributesChanged, changedAttributes, participant);\n        }).on(ParticipantEvent.ConnectionQualityChanged, (quality)=>{\n            this.emitWhenConnected(RoomEvent.ConnectionQualityChanged, quality, participant);\n        }).on(ParticipantEvent.ParticipantPermissionsChanged, (prevPermissions)=>{\n            this.emitWhenConnected(RoomEvent.ParticipantPermissionsChanged, prevPermissions, participant);\n        }).on(ParticipantEvent.TrackSubscriptionStatusChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionStatusChanged, pub, status, participant);\n        }).on(ParticipantEvent.TrackSubscriptionFailed, (trackSid, error)=>{\n            this.emit(RoomEvent.TrackSubscriptionFailed, trackSid, participant, error);\n        }).on(ParticipantEvent.TrackSubscriptionPermissionChanged, (pub, status)=>{\n            this.emitWhenConnected(RoomEvent.TrackSubscriptionPermissionChanged, pub, status, participant);\n        });\n        // update info at the end after callbacks have been set up\n        if (info) {\n            participant.updateInfo(info);\n        }\n        return participant;\n    }\n    sendSyncState() {\n        const remoteTracks = Array.from(this.remoteParticipants.values()).reduce((acc, participant)=>{\n            acc.push(...participant.getTrackPublications()); // FIXME would be nice to have this return RemoteTrackPublications directly instead of the type cast\n            return acc;\n        }, []);\n        const localTracks = this.localParticipant.getTrackPublications(); // FIXME would be nice to have this return LocalTrackPublications directly instead of the type cast\n        this.engine.sendSyncState(remoteTracks, localTracks);\n    }\n    /**\n   * After resuming, we'll need to notify the server of the current\n   * subscription settings.\n   */ updateSubscriptions() {\n        for (const p of this.remoteParticipants.values()){\n            for (const pub of p.videoTrackPublications.values()){\n                if (pub.isSubscribed && isRemotePub(pub)) {\n                    pub.emitTrackUpdate();\n                }\n            }\n        }\n    }\n    getRemoteParticipantBySid(sid) {\n        const identity = this.sidToIdentity.get(sid);\n        if (identity) {\n            return this.remoteParticipants.get(identity);\n        }\n    }\n    registerConnectionReconcile() {\n        this.clearConnectionReconcile();\n        let consecutiveFailures = 0;\n        this.connectionReconcileInterval = CriticalTimers.setInterval(()=>{\n            if (// ensure we didn't tear it down\n            !this.engine || // engine detected close, but Room missed it\n            this.engine.isClosed || // transports failed without notifying engine\n            !this.engine.verifyTransport()) {\n                consecutiveFailures++;\n                this.log.warn(\"detected connection state mismatch\", Object.assign(Object.assign({}, this.logContext), {\n                    numFailures: consecutiveFailures,\n                    engine: this.engine ? {\n                        closed: this.engine.isClosed,\n                        transportsConnected: this.engine.verifyTransport()\n                    } : undefined\n                }));\n                if (consecutiveFailures >= 3) {\n                    this.recreateEngine();\n                    this.handleDisconnect(this.options.stopLocalTrackOnUnpublish, DisconnectReason.STATE_MISMATCH);\n                }\n            } else {\n                consecutiveFailures = 0;\n            }\n        }, connectionReconcileFrequency);\n    }\n    clearConnectionReconcile() {\n        if (this.connectionReconcileInterval) {\n            CriticalTimers.clearInterval(this.connectionReconcileInterval);\n        }\n    }\n    setAndEmitConnectionState(state) {\n        if (state === this.state) {\n            // unchanged\n            return false;\n        }\n        this.state = state;\n        this.emit(RoomEvent.ConnectionStateChanged, this.state);\n        return true;\n    }\n    emitBufferedEvents() {\n        this.bufferedEvents.forEach((_ref3)=>{\n            let [ev, args] = _ref3;\n            this.emit(ev, ...args);\n        });\n        this.bufferedEvents = [];\n    }\n    emitWhenConnected(event) {\n        for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n            args[_key2 - 1] = arguments[_key2];\n        }\n        if (this.state === ConnectionState.Reconnecting || this.isResuming || !this.engine || this.engine.pendingReconnect) {\n            // in case the room is reconnecting, buffer the events by firing them later after emitting RoomEvent.Reconnected\n            this.bufferedEvents.push([\n                event,\n                args\n            ]);\n        } else if (this.state === ConnectionState.Connected) {\n            return this.emit(event, ...args);\n        }\n        return false;\n    }\n    /**\n   * Allows to populate a room with simulated participants.\n   * No actual connection to a server will be established, all state is\n   * @experimental\n   */ simulateParticipants(options) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const publishOptions = Object.assign({\n                audio: true,\n                video: true,\n                useRealTracks: false\n            }, options.publish);\n            const participantOptions = Object.assign({\n                count: 9,\n                audio: false,\n                video: true,\n                aspectRatios: [\n                    1.66,\n                    1.7,\n                    1.3\n                ]\n            }, options.participants);\n            this.handleDisconnect();\n            this.roomInfo = new Room$1({\n                sid: \"RM_SIMULATED\",\n                name: \"simulated-room\",\n                emptyTimeout: 0,\n                maxParticipants: 0,\n                creationTime: protoInt64.parse(new Date().getTime()),\n                metadata: \"\",\n                numParticipants: 1,\n                numPublishers: 1,\n                turnPassword: \"\",\n                enabledCodecs: [],\n                activeRecording: false\n            });\n            this.localParticipant.updateInfo(new ParticipantInfo({\n                identity: \"simulated-local\",\n                name: \"local-name\"\n            }));\n            this.setupLocalParticipantEvents();\n            this.emit(RoomEvent.SignalConnected);\n            this.emit(RoomEvent.Connected);\n            this.setAndEmitConnectionState(ConnectionState.Connected);\n            if (publishOptions.video) {\n                const camPub = new LocalTrackPublication(Track.Kind.Video, new TrackInfo({\n                    source: TrackSource.CAMERA,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO,\n                    name: \"video-dummy\"\n                }), new LocalVideoTrack(publishOptions.useRealTracks ? (yield window.navigator.mediaDevices.getUserMedia({\n                    video: true\n                })).getVideoTracks()[0] : createDummyVideoStreamTrack(160 * ((_a = participantOptions.aspectRatios[0]) !== null && _a !== void 0 ? _a : 1), 160, true, true), undefined, false, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(camPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, camPub);\n            }\n            if (publishOptions.audio) {\n                const audioPub = new LocalTrackPublication(Track.Kind.Audio, new TrackInfo({\n                    source: TrackSource.MICROPHONE,\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    type: TrackType.AUDIO\n                }), new LocalAudioTrack(publishOptions.useRealTracks ? (yield navigator.mediaDevices.getUserMedia({\n                    audio: true\n                })).getAudioTracks()[0] : getEmptyAudioStreamTrack(), undefined, false, this.audioContext, {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                }), {\n                    loggerName: this.options.loggerName,\n                    loggerContextCb: ()=>this.logContext\n                });\n                // @ts-ignore\n                this.localParticipant.addTrackPublication(audioPub);\n                this.localParticipant.emit(ParticipantEvent.LocalTrackPublished, audioPub);\n            }\n            for(let i = 0; i < participantOptions.count - 1; i += 1){\n                let info = new ParticipantInfo({\n                    sid: Math.floor(Math.random() * 10000).toString(),\n                    identity: \"simulated-\".concat(i),\n                    state: ParticipantInfo_State.ACTIVE,\n                    tracks: [],\n                    joinedAt: protoInt64.parse(Date.now())\n                });\n                const p = this.getOrCreateParticipant(info.identity, info);\n                if (participantOptions.video) {\n                    const dummyVideo = createDummyVideoStreamTrack(160 * ((_b = participantOptions.aspectRatios[i % participantOptions.aspectRatios.length]) !== null && _b !== void 0 ? _b : 1), 160, false, true);\n                    const videoTrack = new TrackInfo({\n                        source: TrackSource.CAMERA,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyVideo, videoTrack.sid, new MediaStream([\n                        dummyVideo\n                    ]), new RTCRtpReceiver());\n                    info.tracks = [\n                        ...info.tracks,\n                        videoTrack\n                    ];\n                }\n                if (participantOptions.audio) {\n                    const dummyTrack = getEmptyAudioStreamTrack();\n                    const audioTrack = new TrackInfo({\n                        source: TrackSource.MICROPHONE,\n                        sid: Math.floor(Math.random() * 10000).toString(),\n                        type: TrackType.AUDIO\n                    });\n                    p.addSubscribedMediaTrack(dummyTrack, audioTrack.sid, new MediaStream([\n                        dummyTrack\n                    ]), new RTCRtpReceiver());\n                    info.tracks = [\n                        ...info.tracks,\n                        audioTrack\n                    ];\n                }\n                p.updateInfo(info);\n            }\n        });\n    }\n    // /** @internal */\n    emit(event) {\n        for(var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++){\n            args[_key3 - 1] = arguments[_key3];\n        }\n        // active speaker updates are too spammy\n        if (event !== RoomEvent.ActiveSpeakersChanged && event !== RoomEvent.TranscriptionReceived) {\n            // only extract logContext from arguments in order to avoid logging the whole object tree\n            const minimizedArgs = mapArgs(args).filter((arg)=>arg !== undefined);\n            this.log.debug(\"room event \".concat(event), Object.assign(Object.assign({}, this.logContext), {\n                event,\n                args: minimizedArgs\n            }));\n        }\n        return super.emit(event, ...args);\n    }\n}\nRoom.cleanupRegistry = typeof FinalizationRegistry !== \"undefined\" && new FinalizationRegistry((cleanup)=>{\n    cleanup();\n});\nfunction mapArgs(args) {\n    return args.map((arg)=>{\n        if (!arg) {\n            return;\n        }\n        if (Array.isArray(arg)) {\n            return mapArgs(arg);\n        }\n        if (typeof arg === \"object\") {\n            return \"logContext\" in arg ? arg.logContext : undefined;\n        }\n        return arg;\n    });\n}\nvar CheckStatus;\n(function(CheckStatus) {\n    CheckStatus[CheckStatus[\"IDLE\"] = 0] = \"IDLE\";\n    CheckStatus[CheckStatus[\"RUNNING\"] = 1] = \"RUNNING\";\n    CheckStatus[CheckStatus[\"SKIPPED\"] = 2] = \"SKIPPED\";\n    CheckStatus[CheckStatus[\"SUCCESS\"] = 3] = \"SUCCESS\";\n    CheckStatus[CheckStatus[\"FAILED\"] = 4] = \"FAILED\";\n})(CheckStatus || (CheckStatus = {}));\nclass Checker extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.status = CheckStatus.IDLE;\n        this.logs = [];\n        this.options = {};\n        this.url = url;\n        this.token = token;\n        this.name = this.constructor.name;\n        this.room = new Room(options.roomOptions);\n        this.connectOptions = options.connectOptions;\n        this.options = options;\n    }\n    run(onComplete) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.status !== CheckStatus.IDLE) {\n                throw Error(\"check is running already\");\n            }\n            this.setStatus(CheckStatus.RUNNING);\n            try {\n                yield this.perform();\n            } catch (err) {\n                if (err instanceof Error) {\n                    if (this.options.errorsAsWarnings) {\n                        this.appendWarning(err.message);\n                    } else {\n                        this.appendError(err.message);\n                    }\n                }\n            }\n            yield this.disconnect();\n            // sleep for a bit to ensure disconnect\n            yield new Promise((resolve)=>setTimeout(resolve, 500));\n            // @ts-ignore\n            if (this.status !== CheckStatus.SKIPPED) {\n                this.setStatus(this.isSuccess() ? CheckStatus.SUCCESS : CheckStatus.FAILED);\n            }\n            if (onComplete) {\n                onComplete();\n            }\n            return this.getInfo();\n        });\n    }\n    isSuccess() {\n        return !this.logs.some((l)=>l.level === \"error\");\n    }\n    connect(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room.state === ConnectionState.Connected) {\n                return this.room;\n            }\n            if (!url) {\n                url = this.url;\n            }\n            yield this.room.connect(url, this.token, this.connectOptions);\n            return this.room;\n        });\n    }\n    disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this.room && this.room.state !== ConnectionState.Disconnected) {\n                yield this.room.disconnect();\n                // wait for it to go through\n                yield new Promise((resolve)=>setTimeout(resolve, 500));\n            }\n        });\n    }\n    skip() {\n        this.setStatus(CheckStatus.SKIPPED);\n    }\n    switchProtocol(protocol) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasReconnecting = false;\n            let hasReconnected = false;\n            this.room.on(RoomEvent.Reconnecting, ()=>{\n                hasReconnecting = true;\n            });\n            this.room.once(RoomEvent.Reconnected, ()=>{\n                hasReconnected = true;\n            });\n            this.room.simulateScenario(\"force-\".concat(protocol));\n            yield new Promise((resolve)=>setTimeout(resolve, 1000));\n            if (!hasReconnecting) {\n                // no need to wait for reconnection\n                return;\n            }\n            // wait for 10 seconds for reconnection\n            const timeout = Date.now() + 10000;\n            while(Date.now() < timeout){\n                if (hasReconnected) {\n                    return;\n                }\n                yield sleep(100);\n            }\n            throw new Error(\"Could not reconnect using \".concat(protocol, \" protocol after 10 seconds\"));\n        });\n    }\n    appendMessage(message) {\n        this.logs.push({\n            level: \"info\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendWarning(message) {\n        this.logs.push({\n            level: \"warning\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    appendError(message) {\n        this.logs.push({\n            level: \"error\",\n            message\n        });\n        this.emit(\"update\", this.getInfo());\n    }\n    setStatus(status) {\n        this.status = status;\n        this.emit(\"update\", this.getInfo());\n    }\n    get engine() {\n        var _a;\n        return (_a = this.room) === null || _a === void 0 ? void 0 : _a.engine;\n    }\n    getInfo() {\n        return {\n            logs: this.logs,\n            name: this.name,\n            status: this.status,\n            description: this.description\n        };\n    }\n}\n/**\n * Checks for connections quality to closests Cloud regions and determining the best quality\n */ class CloudRegionCheck extends Checker {\n    get description() {\n        return \"Cloud regions\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const regionProvider = new RegionUrlProvider(this.url, this.token);\n            if (!regionProvider.isCloud()) {\n                this.skip();\n                return;\n            }\n            const regionStats = [];\n            const seenUrls = new Set();\n            for(let i = 0; i < 3; i++){\n                const regionUrl = yield regionProvider.getNextBestRegionUrl();\n                if (!regionUrl) {\n                    break;\n                }\n                if (seenUrls.has(regionUrl)) {\n                    continue;\n                }\n                seenUrls.add(regionUrl);\n                const stats = yield this.checkCloudRegion(regionUrl);\n                this.appendMessage(\"\".concat(stats.region, \" RTT: \").concat(stats.rtt, \"ms, duration: \").concat(stats.duration, \"ms\"));\n                regionStats.push(stats);\n            }\n            regionStats.sort((a, b)=>{\n                return (a.duration - b.duration) * 0.5 + (a.rtt - b.rtt) * 0.5;\n            });\n            const bestRegion = regionStats[0];\n            this.bestStats = bestRegion;\n            this.appendMessage(\"best Cloud region: \".concat(bestRegion.region));\n        });\n    }\n    getInfo() {\n        const info = super.getInfo();\n        info.data = this.bestStats;\n        return info;\n    }\n    checkCloudRegion(url) {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            yield this.connect(url);\n            if (this.options.protocol === \"tcp\") {\n                yield this.switchProtocol(\"tcp\");\n            }\n            const region = (_a = this.room.serverInfo) === null || _a === void 0 ? void 0 : _a.region;\n            if (!region) {\n                throw new Error(\"Region not found\");\n            }\n            const writer = yield this.room.localParticipant.streamText({\n                topic: \"test\"\n            });\n            const chunkSize = 1000; // each chunk is about 1000 bytes\n            const totalSize = 1000000; // approximately 1MB of data\n            const numChunks = totalSize / chunkSize; // will yield 1000 chunks\n            const chunkData = \"A\".repeat(chunkSize); // create a string of 1000 'A' characters\n            const startTime = Date.now();\n            for(let i = 0; i < numChunks; i++){\n                yield writer.write(chunkData);\n            }\n            yield writer.close();\n            const endTime = Date.now();\n            const stats = yield (_b = this.room.engine.pcManager) === null || _b === void 0 ? void 0 : _b.publisher.getStats();\n            const regionStats = {\n                region: region,\n                rtt: 10000,\n                duration: endTime - startTime\n            };\n            stats === null || stats === void 0 ? void 0 : stats.forEach((stat)=>{\n                if (stat.type === \"candidate-pair\" && stat.nominated) {\n                    regionStats.rtt = stat.currentRoundTripTime * 1000;\n                }\n            });\n            yield this.disconnect();\n            return regionStats;\n        });\n    }\n}\nconst TEST_DURATION = 10000;\nclass ConnectionProtocolCheck extends Checker {\n    get description() {\n        return \"Connection via UDP vs TCP\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const udpStats = yield this.checkConnectionProtocol(\"udp\");\n            const tcpStats = yield this.checkConnectionProtocol(\"tcp\");\n            this.bestStats = udpStats;\n            // udp should is the better protocol typically. however, we'd prefer TCP when either of these conditions are true:\n            // 1. the bandwidth limitation is worse on UDP by 500ms\n            // 2. the packet loss is higher on UDP by 1%\n            if (udpStats.qualityLimitationDurations.bandwidth - tcpStats.qualityLimitationDurations.bandwidth > 0.5 || (udpStats.packetsLost - tcpStats.packetsLost) / udpStats.packetsSent > 0.01) {\n                this.appendMessage(\"best connection quality via tcp\");\n                this.bestStats = tcpStats;\n            } else {\n                this.appendMessage(\"best connection quality via udp\");\n            }\n            const stats = this.bestStats;\n            this.appendMessage(\"upstream bitrate: \".concat((stats.bitrateTotal / stats.count / 1000 / 1000).toFixed(2), \" mbps\"));\n            this.appendMessage(\"RTT: \".concat((stats.rttTotal / stats.count * 1000).toFixed(2), \" ms\"));\n            this.appendMessage(\"jitter: \".concat((stats.jitterTotal / stats.count * 1000).toFixed(2), \" ms\"));\n            if (stats.packetsLost > 0) {\n                this.appendWarning(\"packets lost: \".concat((stats.packetsLost / stats.packetsSent * 100).toFixed(2), \"%\"));\n            }\n            if (stats.qualityLimitationDurations.bandwidth > 1) {\n                this.appendWarning(\"bandwidth limited \".concat((stats.qualityLimitationDurations.bandwidth / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n            }\n            if (stats.qualityLimitationDurations.cpu > 0) {\n                this.appendWarning(\"cpu limited \".concat((stats.qualityLimitationDurations.cpu / (TEST_DURATION / 1000) * 100).toFixed(2), \"%\"));\n            }\n        });\n    }\n    getInfo() {\n        const info = super.getInfo();\n        info.data = this.bestStats;\n        return info;\n    }\n    checkConnectionProtocol(protocol) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.connect();\n            if (protocol === \"tcp\") {\n                yield this.switchProtocol(\"tcp\");\n            } else {\n                yield this.switchProtocol(\"udp\");\n            }\n            // create a canvas with animated content\n            const canvas = document.createElement(\"canvas\");\n            canvas.width = 1280;\n            canvas.height = 720;\n            const ctx = canvas.getContext(\"2d\");\n            if (!ctx) {\n                throw new Error(\"Could not get canvas context\");\n            }\n            let hue = 0;\n            const animate = ()=>{\n                hue = (hue + 1) % 360;\n                ctx.fillStyle = \"hsl(\".concat(hue, \", 100%, 50%)\");\n                ctx.fillRect(0, 0, canvas.width, canvas.height);\n                requestAnimationFrame(animate);\n            };\n            animate();\n            // create video track from canvas\n            const stream = canvas.captureStream(30); // 30fps\n            const videoTrack = stream.getVideoTracks()[0];\n            // publish to room\n            const pub = yield this.room.localParticipant.publishTrack(videoTrack, {\n                simulcast: false,\n                degradationPreference: \"maintain-resolution\",\n                videoEncoding: {\n                    maxBitrate: 2000000\n                }\n            });\n            const track = pub.track;\n            const protocolStats = {\n                protocol,\n                packetsLost: 0,\n                packetsSent: 0,\n                qualityLimitationDurations: {},\n                rttTotal: 0,\n                jitterTotal: 0,\n                bitrateTotal: 0,\n                count: 0\n            };\n            // gather stats once a second\n            const interval = setInterval(()=>__awaiter(this, void 0, void 0, function*() {\n                    const stats = yield track.getRTCStatsReport();\n                    stats === null || stats === void 0 ? void 0 : stats.forEach((stat)=>{\n                        if (stat.type === \"outbound-rtp\") {\n                            protocolStats.packetsSent = stat.packetsSent;\n                            protocolStats.qualityLimitationDurations = stat.qualityLimitationDurations;\n                            protocolStats.bitrateTotal += stat.targetBitrate;\n                            protocolStats.count++;\n                        } else if (stat.type === \"remote-inbound-rtp\") {\n                            protocolStats.packetsLost = stat.packetsLost;\n                            protocolStats.rttTotal += stat.roundTripTime;\n                            protocolStats.jitterTotal += stat.jitter;\n                        }\n                    });\n                }), 1000);\n            // wait a bit to gather stats\n            yield new Promise((resolve)=>setTimeout(resolve, TEST_DURATION));\n            clearInterval(interval);\n            videoTrack.stop();\n            canvas.remove();\n            yield this.disconnect();\n            return protocolStats;\n        });\n    }\n}\nclass PublishAudioCheck extends Checker {\n    get description() {\n        return \"Can publish audio\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            const track = yield createLocalAudioTrack();\n            const trackIsSilent = yield detectSilence(track, 1000);\n            if (trackIsSilent) {\n                throw new Error(\"unable to detect audio from microphone\");\n            }\n            this.appendMessage(\"detected audio from microphone\");\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 3000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && (stat.kind === \"audio\" || !stat.kind && stat.mediaType === \"audio\")) {\n                    numPackets = stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" audio packets\"));\n        });\n    }\n}\nclass PublishVideoCheck extends Checker {\n    get description() {\n        return \"Can publish video\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            const track = yield createLocalVideoTrack();\n            // check if we have video from camera\n            yield this.checkForVideo(track.mediaStreamTrack);\n            room.localParticipant.publishTrack(track);\n            // wait for a few seconds to publish\n            yield new Promise((resolve)=>setTimeout(resolve, 5000));\n            // verify RTC stats that it's publishing\n            const stats = yield (_a = track.sender) === null || _a === void 0 ? void 0 : _a.getStats();\n            if (!stats) {\n                throw new Error(\"Could not get RTCStats\");\n            }\n            let numPackets = 0;\n            stats.forEach((stat)=>{\n                if (stat.type === \"outbound-rtp\" && (stat.kind === \"video\" || !stat.kind && stat.mediaType === \"video\")) {\n                    numPackets += stat.packetsSent;\n                }\n            });\n            if (numPackets === 0) {\n                throw new Error(\"Could not determine packets are sent\");\n            }\n            this.appendMessage(\"published \".concat(numPackets, \" video packets\"));\n        });\n    }\n    checkForVideo(track) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const stream = new MediaStream();\n            stream.addTrack(track.clone());\n            // Create video element to check frames\n            const video = document.createElement(\"video\");\n            video.srcObject = stream;\n            video.muted = true;\n            yield new Promise((resolve)=>{\n                video.onplay = ()=>{\n                    setTimeout(()=>{\n                        var _a, _b, _c, _d;\n                        const canvas = document.createElement(\"canvas\");\n                        const settings = track.getSettings();\n                        const width = (_b = (_a = settings.width) !== null && _a !== void 0 ? _a : video.videoWidth) !== null && _b !== void 0 ? _b : 1280;\n                        const height = (_d = (_c = settings.height) !== null && _c !== void 0 ? _c : video.videoHeight) !== null && _d !== void 0 ? _d : 720;\n                        canvas.width = width;\n                        canvas.height = height;\n                        const ctx = canvas.getContext(\"2d\");\n                        // Draw video frame to canvas\n                        ctx.drawImage(video, 0, 0);\n                        // Get image data and check if all pixels are black\n                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                        const data = imageData.data;\n                        let isAllBlack = true;\n                        for(let i = 0; i < data.length; i += 4){\n                            if (data[i] !== 0 || data[i + 1] !== 0 || data[i + 2] !== 0) {\n                                isAllBlack = false;\n                                break;\n                            }\n                        }\n                        if (isAllBlack) {\n                            this.appendError(\"camera appears to be producing only black frames\");\n                        } else {\n                            this.appendMessage(\"received video frames\");\n                        }\n                        resolve();\n                    }, 1000);\n                };\n                video.play();\n            });\n            video.remove();\n        });\n    }\n}\nclass ReconnectCheck extends Checker {\n    get description() {\n        return \"Resuming connection after interruption\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a;\n            const room = yield this.connect();\n            let reconnectingTriggered = false;\n            let reconnected = false;\n            let reconnectResolver;\n            const reconnectTimeout = new Promise((resolve)=>{\n                setTimeout(resolve, 5000);\n                reconnectResolver = resolve;\n            });\n            const handleReconnecting = ()=>{\n                reconnectingTriggered = true;\n            };\n            room.on(RoomEvent.SignalReconnecting, handleReconnecting).on(RoomEvent.Reconnecting, handleReconnecting).on(RoomEvent.Reconnected, ()=>{\n                reconnected = true;\n                reconnectResolver(true);\n            });\n            (_a = room.engine.client.ws) === null || _a === void 0 ? void 0 : _a.close();\n            const onClose = room.engine.client.onClose;\n            if (onClose) {\n                onClose(\"\");\n            }\n            yield reconnectTimeout;\n            if (!reconnectingTriggered) {\n                throw new Error(\"Did not attempt to reconnect\");\n            } else if (!reconnected || room.state !== ConnectionState.Connected) {\n                this.appendWarning(\"reconnection is only possible in Redis-based configurations\");\n                throw new Error(\"Not able to reconnect\");\n            }\n        });\n    }\n}\nclass TURNCheck extends Checker {\n    get description() {\n        return \"Can connect via TURN\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b;\n            const signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            let hasTLS = false;\n            let hasTURN = false;\n            let hasSTUN = false;\n            for (let iceServer of joinRes.iceServers){\n                for (let url of iceServer.urls){\n                    if (url.startsWith(\"turn:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                    } else if (url.startsWith(\"turns:\")) {\n                        hasTURN = true;\n                        hasSTUN = true;\n                        hasTLS = true;\n                    }\n                    if (url.startsWith(\"stun:\")) {\n                        hasSTUN = true;\n                    }\n                }\n            }\n            if (!hasSTUN) {\n                this.appendWarning(\"No STUN servers configured on server side.\");\n            } else if (hasTURN && !hasTLS) {\n                this.appendWarning(\"TURN is configured server side, but TURN/TLS is unavailable.\");\n            }\n            yield signalClient.close();\n            if (((_b = (_a = this.connectOptions) === null || _a === void 0 ? void 0 : _a.rtcConfig) === null || _b === void 0 ? void 0 : _b.iceServers) || hasTURN) {\n                yield this.room.connect(this.url, this.token, {\n                    rtcConfig: {\n                        iceTransportPolicy: \"relay\"\n                    }\n                });\n            } else {\n                this.appendWarning(\"No TURN servers configured.\");\n                this.skip();\n                yield new Promise((resolve)=>setTimeout(resolve, 0));\n            }\n        });\n    }\n}\nclass WebRTCCheck extends Checker {\n    get description() {\n        return \"Establishing WebRTC connection\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hasTcp = false;\n            let hasIpv4Udp = false;\n            this.room.on(RoomEvent.SignalConnected, ()=>{\n                const prevTrickle = this.room.engine.client.onTrickle;\n                this.room.engine.client.onTrickle = (sd, target)=>{\n                    if (sd.candidate) {\n                        const candidate = new RTCIceCandidate(sd);\n                        let str = \"\".concat(candidate.protocol, \" \").concat(candidate.address, \":\").concat(candidate.port, \" \").concat(candidate.type);\n                        if (candidate.address) {\n                            if (isIPPrivate(candidate.address)) {\n                                str += \" (private)\";\n                            } else {\n                                if (candidate.protocol === \"tcp\" && candidate.tcpType === \"passive\") {\n                                    hasTcp = true;\n                                    str += \" (passive)\";\n                                } else if (candidate.protocol === \"udp\") {\n                                    hasIpv4Udp = true;\n                                }\n                            }\n                        }\n                        this.appendMessage(str);\n                    }\n                    if (prevTrickle) {\n                        prevTrickle(sd, target);\n                    }\n                };\n                if (this.room.engine.pcManager) {\n                    this.room.engine.pcManager.subscriber.onIceCandidateError = (ev)=>{\n                        if (ev instanceof RTCPeerConnectionIceErrorEvent) {\n                            this.appendWarning(\"error with ICE candidate: \".concat(ev.errorCode, \" \").concat(ev.errorText, \" \").concat(ev.url));\n                        }\n                    };\n                }\n            });\n            try {\n                yield this.connect();\n                livekitLogger.info(\"now the room is connected\");\n            } catch (err) {\n                this.appendWarning(\"ports need to be open on firewall in order to connect.\");\n                throw err;\n            }\n            if (!hasTcp) {\n                this.appendWarning(\"Server is not configured for ICE/TCP\");\n            }\n            if (!hasIpv4Udp) {\n                this.appendWarning(\"No public IPv4 UDP candidates were found. Your server is likely not configured correctly\");\n            }\n        });\n    }\n}\nfunction isIPPrivate(address) {\n    const parts = address.split(\".\");\n    if (parts.length === 4) {\n        if (parts[0] === \"10\") {\n            return true;\n        } else if (parts[0] === \"192\" && parts[1] === \"168\") {\n            return true;\n        } else if (parts[0] === \"172\") {\n            const second = parseInt(parts[1], 10);\n            if (second >= 16 && second <= 31) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nclass WebSocketCheck extends Checker {\n    get description() {\n        return \"Connecting to signal connection via WebSocket\";\n    }\n    perform() {\n        return __awaiter(this, void 0, void 0, function*() {\n            var _a, _b, _c;\n            if (this.url.startsWith(\"ws:\") || this.url.startsWith(\"http:\")) {\n                this.appendWarning(\"Server is insecure, clients may block connections to it\");\n            }\n            let signalClient = new SignalClient();\n            const joinRes = yield signalClient.join(this.url, this.token, {\n                autoSubscribe: true,\n                maxRetries: 0,\n                e2eeEnabled: false,\n                websocketTimeout: 15000\n            });\n            this.appendMessage(\"Connected to server, version \".concat(joinRes.serverVersion, \".\"));\n            if (((_a = joinRes.serverInfo) === null || _a === void 0 ? void 0 : _a.edition) === ServerInfo_Edition.Cloud && ((_b = joinRes.serverInfo) === null || _b === void 0 ? void 0 : _b.region)) {\n                this.appendMessage(\"LiveKit Cloud: \".concat((_c = joinRes.serverInfo) === null || _c === void 0 ? void 0 : _c.region));\n            }\n            yield signalClient.close();\n        });\n    }\n}\nclass ConnectionCheck extends eventsExports.EventEmitter {\n    constructor(url, token){\n        let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        super();\n        this.options = {};\n        this.checkResults = new Map();\n        this.url = url;\n        this.token = token;\n        this.options = options;\n    }\n    getNextCheckId() {\n        const nextId = this.checkResults.size;\n        this.checkResults.set(nextId, {\n            logs: [],\n            status: CheckStatus.IDLE,\n            name: \"\",\n            description: \"\"\n        });\n        return nextId;\n    }\n    updateCheck(checkId, info) {\n        this.checkResults.set(checkId, info);\n        this.emit(\"checkUpdate\", checkId, info);\n    }\n    isSuccess() {\n        return Array.from(this.checkResults.values()).every((r)=>r.status !== CheckStatus.FAILED);\n    }\n    getResults() {\n        return Array.from(this.checkResults.values());\n    }\n    createAndRunCheck(check) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const checkId = this.getNextCheckId();\n            const test = new check(this.url, this.token, this.options);\n            const handleUpdate = (info)=>{\n                this.updateCheck(checkId, info);\n            };\n            test.on(\"update\", handleUpdate);\n            const result = yield test.run();\n            test.off(\"update\", handleUpdate);\n            return result;\n        });\n    }\n    checkWebsocket() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebSocketCheck);\n        });\n    }\n    checkWebRTC() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(WebRTCCheck);\n        });\n    }\n    checkTURN() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(TURNCheck);\n        });\n    }\n    checkReconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(ReconnectCheck);\n        });\n    }\n    checkPublishAudio() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishAudioCheck);\n        });\n    }\n    checkPublishVideo() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(PublishVideoCheck);\n        });\n    }\n    checkConnectionProtocol() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const info = yield this.createAndRunCheck(ConnectionProtocolCheck);\n            if (info.data && \"protocol\" in info.data) {\n                const stats = info.data;\n                this.options.protocol = stats.protocol;\n            }\n            return info;\n        });\n    }\n    checkCloudRegion() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.createAndRunCheck(CloudRegionCheck);\n        });\n    }\n}\n/**\n * Try to analyze the local track to determine the facing mode of a track.\n *\n * @remarks\n * There is no property supported by all browsers to detect whether a video track originated from a user- or environment-facing camera device.\n * For this reason, we use the `facingMode` property when available, but will fall back on a string-based analysis of the device label to determine the facing mode.\n * If both methods fail, the default facing mode will be used.\n *\n * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaTrackConstraints/facingMode | MDN docs on facingMode}\n * @experimental\n */ function facingModeFromLocalTrack(localTrack) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var _a;\n    const track = isLocalTrack(localTrack) ? localTrack.mediaStreamTrack : localTrack;\n    const trackSettings = track.getSettings();\n    let result = {\n        facingMode: (_a = options.defaultFacingMode) !== null && _a !== void 0 ? _a : \"user\",\n        confidence: \"low\"\n    };\n    // 1. Try to get facingMode from track settings.\n    if (\"facingMode\" in trackSettings) {\n        const rawFacingMode = trackSettings.facingMode;\n        livekitLogger.trace(\"rawFacingMode\", {\n            rawFacingMode\n        });\n        if (rawFacingMode && typeof rawFacingMode === \"string\" && isFacingModeValue(rawFacingMode)) {\n            result = {\n                facingMode: rawFacingMode,\n                confidence: \"high\"\n            };\n        }\n    }\n    // 2. If we don't have a high confidence we try to get the facing mode from the device label.\n    if ([\n        \"low\",\n        \"medium\"\n    ].includes(result.confidence)) {\n        livekitLogger.trace(\"Try to get facing mode from device label: (\".concat(track.label, \")\"));\n        const labelAnalysisResult = facingModeFromDeviceLabel(track.label);\n        if (labelAnalysisResult !== undefined) {\n            result = labelAnalysisResult;\n        }\n    }\n    return result;\n}\nconst knownDeviceLabels = new Map([\n    [\n        \"obs virtual camera\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\nconst knownDeviceLabelSections = new Map([\n    [\n        \"iphone\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ],\n    [\n        \"ipad\",\n        {\n            facingMode: \"environment\",\n            confidence: \"medium\"\n        }\n    ]\n]);\n/**\n * Attempt to analyze the device label to determine the facing mode.\n *\n * @experimental\n */ function facingModeFromDeviceLabel(deviceLabel) {\n    var _a;\n    const label = deviceLabel.trim().toLowerCase();\n    // Empty string is a valid device label but we can't infer anything from it.\n    if (label === \"\") {\n        return undefined;\n    }\n    // Can we match against widely known device labels.\n    if (knownDeviceLabels.has(label)) {\n        return knownDeviceLabels.get(label);\n    }\n    // Can we match against sections of the device label.\n    return (_a = Array.from(knownDeviceLabelSections.entries()).find((_ref)=>{\n        let [section] = _ref;\n        return label.includes(section);\n    })) === null || _a === void 0 ? void 0 : _a[1];\n}\nfunction isFacingModeValue(item) {\n    const allowedValues = [\n        \"user\",\n        \"environment\",\n        \"left\",\n        \"right\"\n    ];\n    return item === undefined || allowedValues.includes(item);\n}\n //# sourceMappingURL=livekit-client.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGl2ZWtpdC1jbGllbnQvZGlzdC9saXZla2l0LWNsaWVudC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLFNBQVNBLGlCQUFpQkMsQ0FBQyxFQUFFQyxDQUFDO0lBQzVCQSxFQUFFQyxPQUFPLENBQUMsU0FBVUMsQ0FBQztRQUNuQkEsS0FBSyxPQUFPQSxNQUFNLFlBQVksQ0FBQ0MsTUFBTUMsT0FBTyxDQUFDRixNQUFNRyxPQUFPQyxJQUFJLENBQUNKLEdBQUdELE9BQU8sQ0FBQyxTQUFVTSxDQUFDO1lBQ25GLElBQUlBLE1BQU0sYUFBYSxDQUFFQSxDQUFBQSxLQUFLUixDQUFBQSxHQUFJO2dCQUNoQyxJQUFJUyxJQUFJSCxPQUFPSSx3QkFBd0IsQ0FBQ1AsR0FBR0s7Z0JBQzNDRixPQUFPSyxjQUFjLENBQUNYLEdBQUdRLEdBQUdDLEVBQUVHLEdBQUcsR0FBR0gsSUFBSTtvQkFDdENJLFlBQVk7b0JBQ1pELEtBQUs7d0JBQWMsT0FBT1QsQ0FBQyxDQUFDSyxFQUFFO29CQUFFO2dCQUNsQztZQUNGO1FBQ0Y7SUFDRjtJQUNBLE9BQU9GLE9BQU9RLE1BQU0sQ0FBQ2Q7QUFDdkI7QUFFQSxJQUFJRyxJQUFJRyxPQUFPSyxjQUFjO0FBQzdCLElBQUlJLElBQUksQ0FBQ0MsR0FBR0MsR0FBR0MsSUFBTUQsS0FBS0QsSUFBSWIsRUFBRWEsR0FBR0MsR0FBRztRQUNwQ0osWUFBWTtRQUNaTSxjQUFjO1FBQ2RDLFVBQVU7UUFDVkMsT0FBT0g7SUFDVCxLQUFLRixDQUFDLENBQUNDLEVBQUUsR0FBR0M7QUFDWixJQUFJSSxJQUFJLENBQUNOLEdBQUdDLEdBQUdDLElBQU1ILEVBQUVDLEdBQUcsT0FBT0MsS0FBSyxXQUFXQSxJQUFJLEtBQUtB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UUFBQztRQUFRO1lBQ1h2akYsWUFBWTtZQUNadWpGLFlBQVk7UUFDZDtLQUFFO0NBQUM7QUFDSDs7OztDQUlDLEdBQ0QsU0FBU0ksMEJBQTBCRyxXQUFXO0lBQzVDLElBQUlsMkc7SUFDSixNQUFNMnlCLFFBQVF1akYsWUFBWTVqRyxJQUFJLEdBQUcwQyxXQUFXO0lBQzVDLDRFQUE0RTtJQUM1RSxJQUFJMmQsVUFBVSxJQUFJO1FBQ2hCLE9BQU9sb0I7SUFDVDtJQUNBLG1EQUFtRDtJQUNuRCxJQUFJdXJHLGtCQUFrQnIrRixHQUFHLENBQUNnYixRQUFRO1FBQ2hDLE9BQU9xakYsa0JBQWtCbDhHLEdBQUcsQ0FBQzY0QjtJQUMvQjtJQUNBLHFEQUFxRDtJQUNyRCxPQUFPLENBQUMzeUIsS0FBSzFHLE1BQU1tNUMsSUFBSSxDQUFDd2pFLHlCQUF5QmhtRyxPQUFPLElBQUkvQixJQUFJLENBQUNpbkMsQ0FBQUE7UUFDL0QsSUFBSSxDQUFDZ2hFLFFBQVEsR0FBR2hoRTtRQUNoQixPQUFPeGlCLE1BQU1DLFFBQVEsQ0FBQ3VqRjtJQUN4QixFQUFDLE1BQU8sUUFBUW4yRyxPQUFPLEtBQUssSUFBSSxLQUFLLElBQUlBLEVBQUUsQ0FBQyxFQUFFO0FBQ2hEO0FBQ0EsU0FBUzYxRyxrQkFBa0JwaEcsSUFBSTtJQUM3QixNQUFNMmhHLGdCQUFnQjtRQUFDO1FBQVE7UUFBZTtRQUFRO0tBQVE7SUFDOUQsT0FBTzNoRyxTQUFTaEssYUFBYTJyRyxjQUFjeGpGLFFBQVEsQ0FBQ25lO0FBQ3REO0FBRTJ5RCxDQUMzeUQsK0NBQStDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vYW5pbWEtcHJvamVjdC8uL25vZGVfbW9kdWxlcy9saXZla2l0LWNsaWVudC9kaXN0L2xpdmVraXQtY2xpZW50LmVzbS5tanM/MzI5YiJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBfbWVyZ2VOYW1lc3BhY2VzKG4sIG0pIHtcbiAgbS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgZSAmJiB0eXBlb2YgZSAhPT0gJ3N0cmluZycgJiYgIUFycmF5LmlzQXJyYXkoZSkgJiYgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgaWYgKGsgIT09ICdkZWZhdWx0JyAmJiAhKGsgaW4gbikpIHtcbiAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobiwgaywgZC5nZXQgPyBkIDoge1xuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIE9iamVjdC5mcmVlemUobik7XG59XG5cbnZhciBlID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyIGggPSAoaSwgcywgdCkgPT4gcyBpbiBpID8gZShpLCBzLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgd3JpdGFibGU6IHRydWUsXG4gIHZhbHVlOiB0XG59KSA6IGlbc10gPSB0O1xudmFyIG8gPSAoaSwgcywgdCkgPT4gaChpLCB0eXBlb2YgcyAhPSBcInN5bWJvbFwiID8gcyArIFwiXCIgOiBzLCB0KTtcbmNsYXNzIF8ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBvKHRoaXMsIFwiX2xvY2tpbmdcIik7XG4gICAgbyh0aGlzLCBcIl9sb2Nrc1wiKTtcbiAgICB0aGlzLl9sb2NraW5nID0gUHJvbWlzZS5yZXNvbHZlKCksIHRoaXMuX2xvY2tzID0gMDtcbiAgfVxuICBpc0xvY2tlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbG9ja3MgPiAwO1xuICB9XG4gIGxvY2soKSB7XG4gICAgdGhpcy5fbG9ja3MgKz0gMTtcbiAgICBsZXQgcztcbiAgICBjb25zdCB0ID0gbmV3IFByb21pc2UobCA9PiBzID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9sb2NrcyAtPSAxLCBsKCk7XG4gICAgICB9KSxcbiAgICAgIGMgPSB0aGlzLl9sb2NraW5nLnRoZW4oKCkgPT4gcyk7XG4gICAgcmV0dXJuIHRoaXMuX2xvY2tpbmcgPSB0aGlzLl9sb2NraW5nLnRoZW4oKCkgPT4gdCksIGM7XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQXNzZXJ0IHRoYXQgY29uZGl0aW9uIGlzIHRydXRoeSBvciB0aHJvdyBlcnJvciAod2l0aCBtZXNzYWdlKVxuICovXG5mdW5jdGlvbiBhc3NlcnQoY29uZGl0aW9uLCBtc2cpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9ucyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIGJvb2xlYW5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgfVxufVxuY29uc3QgRkxPQVQzMl9NQVggPSAzLjQwMjgyMzQ2NjM4NTI4ODZlMzgsXG4gIEZMT0FUMzJfTUlOID0gLTM0MDI4MjM0NjYzODUyODg2ZTIyLFxuICBVSU5UMzJfTUFYID0gMHhmZmZmZmZmZixcbiAgSU5UMzJfTUFYID0gMHg3ZmZmZmZmZixcbiAgSU5UMzJfTUlOID0gLTIxNDc0ODM2NDg7XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHNpZ25lZCBwcm90b2J1ZiAzMi1iaXQgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0SW50MzIoYXJnKSB7XG4gIGlmICh0eXBlb2YgYXJnICE9PSBcIm51bWJlclwiKSB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGludCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGFyZykgfHwgYXJnID4gSU5UMzJfTUFYIHx8IGFyZyA8IElOVDMyX01JTikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBpbnQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuLyoqXG4gKiBBc3NlcnQgYSB2YWxpZCB1bnNpZ25lZCBwcm90b2J1ZiAzMi1iaXQgaW50ZWdlci5cbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VUludDMyKGFyZykge1xuICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50IDMyOiBcIiArIHR5cGVvZiBhcmcpO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIoYXJnKSB8fCBhcmcgPiBVSU5UMzJfTUFYIHx8IGFyZyA8IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdWludCAzMjogXCIgKyBhcmcpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzIC0tIHdlIHdhbnQgdGhlIGltcGxpY2l0IGNvbnZlcnNpb24gdG8gc3RyaW5nXG59XG4vKipcbiAqIEFzc2VydCBhIHZhbGlkIHByb3RvYnVmIGZsb2F0IHZhbHVlLlxuICovXG5mdW5jdGlvbiBhc3NlcnRGbG9hdDMyKGFyZykge1xuICBpZiAodHlwZW9mIGFyZyAhPT0gXCJudW1iZXJcIikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBmbG9hdCAzMjogXCIgKyB0eXBlb2YgYXJnKTtcbiAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoYXJnKSkgcmV0dXJuO1xuICBpZiAoYXJnID4gRkxPQVQzMl9NQVggfHwgYXJnIDwgRkxPQVQzMl9NSU4pIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZmxvYXQgMzI6IFwiICsgYXJnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAtLSB3ZSB3YW50IHRoZSBpbXBsaWNpdCBjb252ZXJzaW9uIHRvIHN0cmluZ1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuY29uc3QgZW51bVR5cGVTeW1ib2wgPSBTeW1ib2woXCJAYnVmYnVpbGQvcHJvdG9idWYvZW51bS10eXBlXCIpO1xuLyoqXG4gKiBHZXQgcmVmbGVjdGlvbiBpbmZvcm1hdGlvbiBmcm9tIGEgZ2VuZXJhdGVkIGVudW0uXG4gKiBJZiB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhIGdlbmVyYXRlZFxuICogZW51bSwgaXQgcmFpc2VzIGFuIGVycm9yLlxuICovXG5mdW5jdGlvbiBnZXRFbnVtVHlwZShlbnVtT2JqZWN0KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgY29uc3QgdCA9IGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdO1xuICBhc3NlcnQodCwgXCJtaXNzaW5nIGVudW0gdHlwZSBvbiBlbnVtIG9iamVjdFwiKTtcbiAgcmV0dXJuIHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbn1cbi8qKlxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uIG9uIGEgZ2VuZXJhdGVkIGVudW0uXG4gKi9cbmZ1bmN0aW9uIHNldEVudW1UeXBlKGVudW1PYmplY3QsIHR5cGVOYW1lLCB2YWx1ZXMsIG9wdCkge1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLCBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gIGVudW1PYmplY3RbZW51bVR5cGVTeW1ib2xdID0gbWFrZUVudW1UeXBlKHR5cGVOYW1lLCB2YWx1ZXMubWFwKHYgPT4gKHtcbiAgICBubzogdi5ubyxcbiAgICBuYW1lOiB2Lm5hbWUsXG4gICAgbG9jYWxOYW1lOiBlbnVtT2JqZWN0W3Yubm9dXG4gIH0pKSk7XG59XG4vKipcbiAqIENyZWF0ZSBhIG5ldyBFbnVtVHlwZSB3aXRoIHRoZSBnaXZlbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIG1ha2VFbnVtVHlwZSh0eXBlTmFtZSwgdmFsdWVzLFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuX29wdCkge1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IG51bWJlcnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb25zdCBub3JtYWxWYWx1ZXMgPSBbXTtcbiAgZm9yIChjb25zdCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAvLyBXZSBkbyBub3Qgc3VyZmFjZSBvcHRpb25zIGF0IHRoaXMgdGltZVxuICAgIC8vIGNvbnN0IHZhbHVlOiBFbnVtVmFsdWVJbmZvID0gey4uLnYsIG9wdGlvbnM6IHYub3B0aW9ucyA/PyBlbXB0eVJlYWRvbmx5T2JqZWN0fTtcbiAgICBjb25zdCBuID0gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKTtcbiAgICBub3JtYWxWYWx1ZXMucHVzaChuKTtcbiAgICBuYW1lc1t2YWx1ZS5uYW1lXSA9IG47XG4gICAgbnVtYmVyc1t2YWx1ZS5ub10gPSBuO1xuICB9XG4gIHJldHVybiB7XG4gICAgdHlwZU5hbWUsXG4gICAgdmFsdWVzOiBub3JtYWxWYWx1ZXMsXG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBvcHRpb25zOiBvcHQ/Lm9wdGlvbnMgPz8gT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICBmaW5kTmFtZShuYW1lKSB7XG4gICAgICByZXR1cm4gbmFtZXNbbmFtZV07XG4gICAgfSxcbiAgICBmaW5kTnVtYmVyKG5vKSB7XG4gICAgICByZXR1cm4gbnVtYmVyc1tub107XG4gICAgfVxuICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZW51bSBvYmplY3Qgd2l0aCB0aGUgZ2l2ZW4gdmFsdWVzLlxuICogU2V0cyByZWZsZWN0aW9uIGluZm9ybWF0aW9uLlxuICovXG5mdW5jdGlvbiBtYWtlRW51bSh0eXBlTmFtZSwgdmFsdWVzLCBvcHQpIHtcbiAgY29uc3QgZW51bU9iamVjdCA9IHt9O1xuICBmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykge1xuICAgIGNvbnN0IG4gPSBub3JtYWxpemVFbnVtVmFsdWUodmFsdWUpO1xuICAgIGVudW1PYmplY3Rbbi5sb2NhbE5hbWVdID0gbi5ubztcbiAgICBlbnVtT2JqZWN0W24ubm9dID0gbi5sb2NhbE5hbWU7XG4gIH1cbiAgc2V0RW51bVR5cGUoZW51bU9iamVjdCwgdHlwZU5hbWUsIHZhbHVlcyk7XG4gIHJldHVybiBlbnVtT2JqZWN0O1xufVxuZnVuY3Rpb24gbm9ybWFsaXplRW51bVZhbHVlKHZhbHVlKSB7XG4gIGlmIChcImxvY2FsTmFtZVwiIGluIHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKSwge1xuICAgIGxvY2FsTmFtZTogdmFsdWUubmFtZVxuICB9KTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogTWVzc2FnZSBpcyB0aGUgYmFzZSBjbGFzcyBvZiBldmVyeSBtZXNzYWdlLCBnZW5lcmF0ZWQsIG9yIGNyZWF0ZWQgYXRcbiAqIHJ1bnRpbWUuXG4gKlxuICogSXQgaXMgX25vdF8gc2FmZSB0byBleHRlbmQgdGhpcyBjbGFzcy4gSWYgeW91IHdhbnQgdG8gY3JlYXRlIGEgbWVzc2FnZSBhdFxuICogcnVuIHRpbWUsIHVzZSBwcm90bzMubWFrZU1lc3NhZ2VUeXBlKCkuXG4gKi9cbmNsYXNzIE1lc3NhZ2Uge1xuICAvKipcbiAgICogQ29tcGFyZSB3aXRoIGEgbWVzc2FnZSBvZiB0aGUgc2FtZSB0eXBlLlxuICAgKiBOb3RlIHRoYXQgdGhpcyBmdW5jdGlvbiBkaXNyZWdhcmRzIGV4dGVuc2lvbnMgYW5kIHVua25vd24gZmllbGRzLlxuICAgKi9cbiAgZXF1YWxzKG90aGVyKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5lcXVhbHModGhpcy5nZXRUeXBlKCksIHRoaXMsIG90aGVyKTtcbiAgfVxuICAvKipcbiAgICogQ3JlYXRlIGEgZGVlcCBjb3B5LlxuICAgKi9cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VHlwZSgpLnJ1bnRpbWUudXRpbC5jbG9uZSh0aGlzKTtcbiAgfVxuICAvKipcbiAgICogUGFyc2UgZnJvbSBiaW5hcnkgZGF0YSwgbWVyZ2luZyBmaWVsZHMuXG4gICAqXG4gICAqIFJlcGVhdGVkIGZpZWxkcyBhcmUgYXBwZW5kZWQuIE1hcCBlbnRyaWVzIGFyZSBhZGRlZCwgb3ZlcndyaXRpbmdcbiAgICogZXhpc3Rpbmcga2V5cy5cbiAgICpcbiAgICogSWYgYSBtZXNzYWdlIGZpZWxkIGlzIGFscmVhZHkgcHJlc2VudCwgaXQgd2lsbCBiZSBtZXJnZWQgd2l0aCB0aGVcbiAgICogbmV3IGRhdGEuXG4gICAqL1xuICBmcm9tQmluYXJ5KGJ5dGVzLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxuICAgICAgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmJpbixcbiAgICAgIG9wdCA9IGZvcm1hdC5tYWtlUmVhZE9wdGlvbnMob3B0aW9ucyk7XG4gICAgZm9ybWF0LnJlYWRNZXNzYWdlKHRoaXMsIG9wdC5yZWFkZXJGYWN0b3J5KGJ5dGVzKSwgYnl0ZXMuYnl0ZUxlbmd0aCwgb3B0KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogUGFyc2UgYSBtZXNzYWdlIGZyb20gYSBKU09OIHZhbHVlLlxuICAgKi9cbiAgZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxuICAgICAgZm9ybWF0ID0gdHlwZS5ydW50aW1lLmpzb24sXG4gICAgICBvcHQgPSBmb3JtYXQubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGZvcm1hdC5yZWFkTWVzc2FnZSh0eXBlLCBqc29uVmFsdWUsIG9wdCwgdGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFBhcnNlIGEgbWVzc2FnZSBmcm9tIGEgSlNPTiBzdHJpbmcuXG4gICAqL1xuICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgbGV0IGpzb247XG4gICAgdHJ5IHtcbiAgICAgIGpzb24gPSBKU09OLnBhcnNlKGpzb25TdHJpbmcpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgXCIuY29uY2F0KHRoaXMuZ2V0VHlwZSgpLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogU3RyaW5nKGUpKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmZyb21Kc29uKGpzb24sIG9wdGlvbnMpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYmluYXJ5IGRhdGEuXG4gICAqL1xuICB0b0JpbmFyeShvcHRpb25zKSB7XG4gICAgY29uc3QgdHlwZSA9IHRoaXMuZ2V0VHlwZSgpLFxuICAgICAgYmluID0gdHlwZS5ydW50aW1lLmJpbixcbiAgICAgIG9wdCA9IGJpbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpLFxuICAgICAgd3JpdGVyID0gb3B0LndyaXRlckZhY3RvcnkoKTtcbiAgICBiaW4ud3JpdGVNZXNzYWdlKHRoaXMsIHdyaXRlciwgb3B0KTtcbiAgICByZXR1cm4gd3JpdGVyLmZpbmlzaCgpO1xuICB9XG4gIC8qKlxuICAgKiBTZXJpYWxpemUgdGhlIG1lc3NhZ2UgdG8gYSBKU09OIHZhbHVlLCBhIEphdmFTY3JpcHQgdmFsdWUgdGhhdCBjYW4gYmVcbiAgICogcGFzc2VkIHRvIEpTT04uc3RyaW5naWZ5KCkuXG4gICAqL1xuICB0b0pzb24ob3B0aW9ucykge1xuICAgIGNvbnN0IHR5cGUgPSB0aGlzLmdldFR5cGUoKSxcbiAgICAgIGpzb24gPSB0eXBlLnJ1bnRpbWUuanNvbixcbiAgICAgIG9wdCA9IGpzb24ubWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKTtcbiAgICByZXR1cm4ganNvbi53cml0ZU1lc3NhZ2UodGhpcywgb3B0KTtcbiAgfVxuICAvKipcbiAgICogU2VyaWFsaXplIHRoZSBtZXNzYWdlIHRvIGEgSlNPTiBzdHJpbmcuXG4gICAqL1xuICB0b0pzb25TdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMudG9Kc29uKG9wdGlvbnMpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgbnVsbCwgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnByZXR0eVNwYWNlcykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMCk7XG4gIH1cbiAgLyoqXG4gICAqIE92ZXJyaWRlIGZvciBzZXJpYWxpemF0aW9uIGJlaGF2aW9yLiBUaGlzIHdpbGwgYmUgaW52b2tlZCB3aGVuIGNhbGxpbmdcbiAgICogSlNPTi5zdHJpbmdpZnkgb24gdGhpcyBtZXNzYWdlIChpLmUuIEpTT04uc3RyaW5naWZ5KG1zZykpLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBzZXJpYWxpemUgZ29vZ2xlLnByb3RvYnVmLkFueSB3aXRoIGEgcGFja2VkXG4gICAqIG1lc3NhZ2UgYmVjYXVzZSB0aGUgcHJvdG9idWYgSlNPTiBmb3JtYXQgc3BlY2lmaWVzIHRoYXQgaXQgbmVlZHMgdG8gYmVcbiAgICogdW5wYWNrZWQsIGFuZCB0aGlzIGlzIG9ubHkgcG9zc2libGUgd2l0aCBhIHR5cGUgcmVnaXN0cnkgdG8gbG9vayB1cCB0aGVcbiAgICogbWVzc2FnZSB0eXBlLiAgQXMgYSByZXN1bHQsIGF0dGVtcHRpbmcgdG8gc2VyaWFsaXplIGEgbWVzc2FnZSB3aXRoIHRoaXNcbiAgICogdHlwZSB3aWxsIHRocm93IGFuIEVycm9yLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBpcyBwcm90ZWN0ZWQgYmVjYXVzZSB5b3Ugc2hvdWxkIG5vdCBuZWVkIHRvIGludm9rZSBpdFxuICAgKiBkaXJlY3RseSAtLSBpbnN0ZWFkIHVzZSBKU09OLnN0cmluZ2lmeSBvciB0b0pzb25TdHJpbmcgZm9yXG4gICAqIHN0cmluZ2lmaWVkIEpTT04uICBBbHRlcm5hdGl2ZWx5LCBpZiBhY3R1YWwgSlNPTiBpcyBkZXNpcmVkLCB5b3Ugc2hvdWxkXG4gICAqIHVzZSB0b0pzb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHRoaXMudG9Kc29uKHtcbiAgICAgIGVtaXREZWZhdWx0VmFsdWVzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIHRoZSBNZXNzYWdlVHlwZSBvZiB0aGlzIG1lc3NhZ2UgLSBhIHNpbmdsZXRvbiB0aGF0IHJlcHJlc2VudHNcbiAgICogdGhlIHByb3RvYnVmIG1lc3NhZ2UgZGVjbGFyYXRpb24gYW5kIHByb3ZpZGVzIG1ldGFkYXRhIGZvciByZWZsZWN0aW9uLVxuICAgKiBiYXNlZCBvcGVyYXRpb25zLlxuICAgKi9cbiAgZ2V0VHlwZSgpIHtcbiAgICAvLyBBbnkgY2xhc3MgdGhhdCBleHRlbmRzIE1lc3NhZ2UgX211c3RfIHByb3ZpZGUgYSBjb21wbGV0ZSBzdGF0aWNcbiAgICAvLyBpbXBsZW1lbnRhdGlvbiBvZiBNZXNzYWdlVHlwZS5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuXG4gICAgcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5jb25zdHJ1Y3RvcjtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgbWVzc2FnZSB0eXBlIHVzaW5nIHRoZSBnaXZlbiBydW50aW1lLlxuICovXG5mdW5jdGlvbiBtYWtlTWVzc2FnZVR5cGUocnVudGltZSwgdHlwZU5hbWUsIGZpZWxkcywgb3B0KSB7XG4gIHZhciBfYTtcbiAgY29uc3QgbG9jYWxOYW1lID0gKF9hID0gb3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmxvY2FsTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdHlwZU5hbWUuc3Vic3RyaW5nKHR5cGVOYW1lLmxhc3RJbmRleE9mKFwiLlwiKSArIDEpO1xuICBjb25zdCB0eXBlID0ge1xuICAgIFtsb2NhbE5hbWVdOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgcnVudGltZS51dGlsLmluaXRGaWVsZHModGhpcyk7XG4gICAgICBydW50aW1lLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gICAgfVxuICB9W2xvY2FsTmFtZV07XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZih0eXBlLnByb3RvdHlwZSwgbmV3IE1lc3NhZ2UoKSk7XG4gIE9iamVjdC5hc3NpZ24odHlwZSwge1xuICAgIHJ1bnRpbWUsXG4gICAgdHlwZU5hbWUsXG4gICAgZmllbGRzOiBydW50aW1lLnV0aWwubmV3RmllbGRMaXN0KGZpZWxkcyksXG4gICAgZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIG5ldyB0eXBlKCkuZnJvbUJpbmFyeShieXRlcywgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICAgIHJldHVybiBuZXcgdHlwZSgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgfSxcbiAgICBmcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gbmV3IHR5cGUoKS5mcm9tSnNvblN0cmluZyhqc29uU3RyaW5nLCBvcHRpb25zKTtcbiAgICB9LFxuICAgIGVxdWFscyhhLCBiKSB7XG4gICAgICByZXR1cm4gcnVudGltZS51dGlsLmVxdWFscyh0eXBlLCBhLCBiKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdHlwZTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4vL1xuLy8gUmVkaXN0cmlidXRpb24gYW5kIHVzZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0XG4vLyBtb2RpZmljYXRpb24sIGFyZSBwZXJtaXR0ZWQgcHJvdmlkZWQgdGhhdCB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnMgYXJlXG4vLyBtZXQ6XG4vL1xuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuLy8gbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuLy8gKiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlXG4vLyBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyXG4vLyBpbiB0aGUgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlXG4vLyBkaXN0cmlidXRpb24uXG4vLyAqIE5laXRoZXIgdGhlIG5hbWUgb2YgR29vZ2xlIEluYy4gbm9yIHRoZSBuYW1lcyBvZiBpdHNcbi8vIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHMgZGVyaXZlZCBmcm9tXG4vLyB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuLy9cbi8vIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlNcbi8vIFwiQVMgSVNcIiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1Rcbi8vIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUlxuLy8gQSBQQVJUSUNVTEFSIFBVUlBPU0UgQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBDT1BZUklHSFRcbi8vIE9XTkVSIE9SIENPTlRSSUJVVE9SUyBCRSBMSUFCTEUgRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLFxuLy8gU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVFxuLy8gTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsXG4vLyBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTllcbi8vIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbi8vIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRVxuLy8gT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbi8vXG4vLyBDb2RlIGdlbmVyYXRlZCBieSB0aGUgUHJvdG9jb2wgQnVmZmVyIGNvbXBpbGVyIGlzIG93bmVkIGJ5IHRoZSBvd25lclxuLy8gb2YgdGhlIGlucHV0IGZpbGUgdXNlZCB3aGVuIGdlbmVyYXRpbmcgaXQuICBUaGlzIGNvZGUgaXMgbm90XG4vLyBzdGFuZGFsb25lIGFuZCByZXF1aXJlcyBhIHN1cHBvcnQgbGlicmFyeSB0byBiZSBsaW5rZWQgd2l0aCBpdC4gIFRoaXNcbi8vIHN1cHBvcnQgbGlicmFyeSBpcyBpdHNlbGYgY292ZXJlZCBieSB0aGUgYWJvdmUgbGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIHByZWZlci1jb25zdCxAdHlwZXNjcmlwdC1lc2xpbnQvcmVzdHJpY3QtcGx1cy1vcGVyYW5kcyAqL1xuLyoqXG4gKiBSZWFkIGEgNjQgYml0IHZhcmludCBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBSZXR1cm5zIHR1cGxlOlxuICogWzBdOiBsb3cgYml0c1xuICogWzFdOiBoaWdoIGJpdHNcbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi9ibG9iLzhhNzE5MjdkNzRhNGNlMzRlZmUyZDg3NjlmZGExOThmNTJkMjBkMTIvanMvZXhwZXJpbWVudGFsL3J1bnRpbWUva2VybmVsL2J1ZmZlcl9kZWNvZGVyLmpzI0wxNzVcbiAqL1xuZnVuY3Rpb24gdmFyaW50NjRyZWFkKCkge1xuICBsZXQgbG93Qml0cyA9IDA7XG4gIGxldCBoaWdoQml0cyA9IDA7XG4gIGZvciAobGV0IHNoaWZ0ID0gMDsgc2hpZnQgPCAyODsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgbG93Qml0cyB8PSAoYiAmIDB4N2YpIDw8IHNoaWZ0O1xuICAgIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgICByZXR1cm4gW2xvd0JpdHMsIGhpZ2hCaXRzXTtcbiAgICB9XG4gIH1cbiAgbGV0IG1pZGRsZUJ5dGUgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgLy8gbGFzdCBmb3VyIGJpdHMgb2YgdGhlIGZpcnN0IDMyIGJpdCBudW1iZXJcbiAgbG93Qml0cyB8PSAobWlkZGxlQnl0ZSAmIDB4MGYpIDw8IDI4O1xuICAvLyAzIHVwcGVyIGJpdHMgYXJlIHBhcnQgb2YgdGhlIG5leHQgMzIgYml0IG51bWJlclxuICBoaWdoQml0cyA9IChtaWRkbGVCeXRlICYgMHg3MCkgPj4gNDtcbiAgaWYgKChtaWRkbGVCeXRlICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gIH1cbiAgZm9yIChsZXQgc2hpZnQgPSAzOyBzaGlmdCA8PSAzMTsgc2hpZnQgKz0gNykge1xuICAgIGxldCBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gICAgaGlnaEJpdHMgfD0gKGIgJiAweDdmKSA8PCBzaGlmdDtcbiAgICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgICAgcmV0dXJuIFtsb3dCaXRzLCBoaWdoQml0c107XG4gICAgfVxuICB9XG4gIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xufVxuLyoqXG4gKiBXcml0ZSBhIDY0IGJpdCB2YXJpbnQsIGdpdmVuIGFzIHR3byBKUyBudW1iZXJzLCB0byB0aGUgZ2l2ZW4gYnl0ZXMgYXJyYXkuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC93cml0ZXIuanMjTDM0NFxuICovXG5mdW5jdGlvbiB2YXJpbnQ2NHdyaXRlKGxvLCBoaSwgYnl0ZXMpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCAyODsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBsbyA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwICYmIGhpID09IDApO1xuICAgIGNvbnN0IGJ5dGUgPSAoaGFzTmV4dCA/IHNoaWZ0IHwgMHg4MCA6IHNoaWZ0KSAmIDB4ZmY7XG4gICAgYnl0ZXMucHVzaChieXRlKTtcbiAgICBpZiAoIWhhc05leHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbiAgY29uc3Qgc3BsaXRCaXRzID0gbG8gPj4+IDI4ICYgMHgwZiB8IChoaSAmIDB4MDcpIDw8IDQ7XG4gIGNvbnN0IGhhc01vcmVCaXRzID0gIShoaSA+PiAzID09IDApO1xuICBieXRlcy5wdXNoKChoYXNNb3JlQml0cyA/IHNwbGl0Qml0cyB8IDB4ODAgOiBzcGxpdEJpdHMpICYgMHhmZik7XG4gIGlmICghaGFzTW9yZUJpdHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZm9yIChsZXQgaSA9IDM7IGkgPCAzMTsgaSA9IGkgKyA3KSB7XG4gICAgY29uc3Qgc2hpZnQgPSBoaSA+Pj4gaTtcbiAgICBjb25zdCBoYXNOZXh0ID0gIShzaGlmdCA+Pj4gNyA9PSAwKTtcbiAgICBjb25zdCBieXRlID0gKGhhc05leHQgPyBzaGlmdCB8IDB4ODAgOiBzaGlmdCkgJiAweGZmO1xuICAgIGJ5dGVzLnB1c2goYnl0ZSk7XG4gICAgaWYgKCFoYXNOZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG4gIGJ5dGVzLnB1c2goaGkgPj4+IDMxICYgMHgwMSk7XG59XG4vLyBjb25zdGFudHMgZm9yIGJpbmFyeSBtYXRoXG5jb25zdCBUV09fUFdSXzMyX0RCTCA9IDB4MTAwMDAwMDAwO1xuLyoqXG4gKiBQYXJzZSBkZWNpbWFsIHN0cmluZyBvZiA2NCBiaXQgaW50ZWdlciB2YWx1ZSBhcyB0d28gSlMgbnVtYmVycy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRGcm9tU3RyaW5nKGRlYykge1xuICAvLyBDaGVjayBmb3IgbWludXMgc2lnbi5cbiAgY29uc3QgbWludXMgPSBkZWNbMF0gPT09IFwiLVwiO1xuICBpZiAobWludXMpIHtcbiAgICBkZWMgPSBkZWMuc2xpY2UoMSk7XG4gIH1cbiAgLy8gV29yayA2IGRlY2ltYWwgZGlnaXRzIGF0IGEgdGltZSwgYWN0aW5nIGxpa2Ugd2UncmUgY29udmVydGluZyBiYXNlIDFlNlxuICAvLyBkaWdpdHMgdG8gYmluYXJ5LiBUaGlzIGlzIHNhZmUgdG8gZG8gd2l0aCBmbG9hdGluZyBwb2ludCBtYXRoIGJlY2F1c2VcbiAgLy8gTnVtYmVyLmlzU2FmZUludGVnZXIoQUxMXzMyX0JJVFMgKiAxZTYpID09IHRydWUuXG4gIGNvbnN0IGJhc2UgPSAxZTY7XG4gIGxldCBsb3dCaXRzID0gMDtcbiAgbGV0IGhpZ2hCaXRzID0gMDtcbiAgZnVuY3Rpb24gYWRkMWU2ZGlnaXQoYmVnaW4sIGVuZCkge1xuICAgIC8vIE5vdGU6IE51bWJlcignJykgaXMgMC5cbiAgICBjb25zdCBkaWdpdDFlNiA9IE51bWJlcihkZWMuc2xpY2UoYmVnaW4sIGVuZCkpO1xuICAgIGhpZ2hCaXRzICo9IGJhc2U7XG4gICAgbG93Qml0cyA9IGxvd0JpdHMgKiBiYXNlICsgZGlnaXQxZTY7XG4gICAgLy8gQ2FycnkgYml0cyBmcm9tIGxvd0JpdHMgdG9cbiAgICBpZiAobG93Qml0cyA+PSBUV09fUFdSXzMyX0RCTCkge1xuICAgICAgaGlnaEJpdHMgPSBoaWdoQml0cyArIChsb3dCaXRzIC8gVFdPX1BXUl8zMl9EQkwgfCAwKTtcbiAgICAgIGxvd0JpdHMgPSBsb3dCaXRzICUgVFdPX1BXUl8zMl9EQkw7XG4gICAgfVxuICB9XG4gIGFkZDFlNmRpZ2l0KC0yNCwgLTE4KTtcbiAgYWRkMWU2ZGlnaXQoLTE4LCAtMTIpO1xuICBhZGQxZTZkaWdpdCgtMTIsIC02KTtcbiAgYWRkMWU2ZGlnaXQoLTYpO1xuICByZXR1cm4gbWludXMgPyBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIDogbmV3Qml0cyhsb3dCaXRzLCBoaWdoQml0cyk7XG59XG4vKipcbiAqIExvc3NsZXNzbHkgY29udmVydHMgYSA2NC1iaXQgc2lnbmVkIGludGVnZXIgaW4gMzI6MzIgc3BsaXQgcmVwcmVzZW50YXRpb25cbiAqIGludG8gYSBkZWNpbWFsIHN0cmluZy5cbiAqXG4gKiBDb3B5cmlnaHQgMjAwOCBHb29nbGUgSW5jLiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3Byb3RvY29sYnVmZmVycy9wcm90b2J1Zi1qYXZhc2NyaXB0L2Jsb2IvYTQyOGM1ODI3M2FiYWQwN2M2NjA3MWQ5NzUzYmM0ZDEyODlkZTQyNi9leHBlcmltZW50YWwvcnVudGltZS9pbnQ2NC5qcyNMMTBcbiAqL1xuZnVuY3Rpb24gaW50NjRUb1N0cmluZyhsbywgaGkpIHtcbiAgbGV0IGJpdHMgPSBuZXdCaXRzKGxvLCBoaSk7XG4gIC8vIElmIHdlJ3JlIHRyZWF0aW5nIHRoZSBpbnB1dCBhcyBhIHNpZ25lZCB2YWx1ZSBhbmQgdGhlIGhpZ2ggYml0IGlzIHNldCwgZG9cbiAgLy8gYSBtYW51YWwgdHdvJ3MgY29tcGxlbWVudCBjb252ZXJzaW9uIGJlZm9yZSB0aGUgZGVjaW1hbCBjb252ZXJzaW9uLlxuICBjb25zdCBuZWdhdGl2ZSA9IGJpdHMuaGkgJiAweDgwMDAwMDAwO1xuICBpZiAobmVnYXRpdmUpIHtcbiAgICBiaXRzID0gbmVnYXRlKGJpdHMubG8sIGJpdHMuaGkpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IHVJbnQ2NFRvU3RyaW5nKGJpdHMubG8sIGJpdHMuaGkpO1xuICByZXR1cm4gbmVnYXRpdmUgPyBcIi1cIiArIHJlc3VsdCA6IHJlc3VsdDtcbn1cbi8qKlxuICogTG9zc2xlc3NseSBjb252ZXJ0cyBhIDY0LWJpdCB1bnNpZ25lZCBpbnRlZ2VyIGluIDMyOjMyIHNwbGl0IHJlcHJlc2VudGF0aW9uXG4gKiBpbnRvIGEgZGVjaW1hbCBzdHJpbmcuXG4gKlxuICogQ29weXJpZ2h0IDIwMDggR29vZ2xlIEluYy4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYtamF2YXNjcmlwdC9ibG9iL2E0MjhjNTgyNzNhYmFkMDdjNjYwNzFkOTc1M2JjNGQxMjg5ZGU0MjYvZXhwZXJpbWVudGFsL3J1bnRpbWUvaW50NjQuanMjTDEwXG4gKi9cbmZ1bmN0aW9uIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSkge1xuICAoe1xuICAgIGxvLFxuICAgIGhpXG4gIH0gPSB0b1Vuc2lnbmVkKGxvLCBoaSkpO1xuICAvLyBTa2lwIHRoZSBleHBlbnNpdmUgY29udmVyc2lvbiBpZiB0aGUgbnVtYmVyIGlzIHNtYWxsIGVub3VnaCB0byB1c2UgdGhlXG4gIC8vIGJ1aWx0LWluIGNvbnZlcnNpb25zLlxuICAvLyBOdW1iZXIuTUFYX1NBRkVfSU5URUdFUiA9IDB4MDAxRkZGRkYgRkZGRkZGRkYsIHRodXMgYW55IG51bWJlciB3aXRoXG4gIC8vIGhpZ2hCaXRzIDw9IDB4MUZGRkZGIGNhbiBiZSBzYWZlbHkgZXhwcmVzc2VkIHdpdGggYSBkb3VibGUgYW5kIHJldGFpblxuICAvLyBpbnRlZ2VyIHByZWNpc2lvbi5cbiAgLy8gUHJvdmVuIGJ5OiBOdW1iZXIuaXNTYWZlSW50ZWdlcigweDFGRkZGRiAqIDIqKjMyICsgMHhGRkZGRkZGRikgPT0gdHJ1ZS5cbiAgaWYgKGhpIDw9IDB4MUZGRkZGKSB7XG4gICAgcmV0dXJuIFN0cmluZyhUV09fUFdSXzMyX0RCTCAqIGhpICsgbG8pO1xuICB9XG4gIC8vIFdoYXQgdGhpcyBjb2RlIGlzIGRvaW5nIGlzIGVzc2VudGlhbGx5IGNvbnZlcnRpbmcgdGhlIGlucHV0IG51bWJlciBmcm9tXG4gIC8vIGJhc2UtMiB0byBiYXNlLTFlNywgd2hpY2ggYWxsb3dzIHVzIHRvIHJlcHJlc2VudCB0aGUgNjQtYml0IHJhbmdlIHdpdGhcbiAgLy8gb25seSAzICh2ZXJ5IGxhcmdlKSBkaWdpdHMuIFRob3NlIGRpZ2l0cyBhcmUgdGhlbiB0cml2aWFsIHRvIGNvbnZlcnQgdG9cbiAgLy8gYSBiYXNlLTEwIHN0cmluZy5cbiAgLy8gVGhlIG1hZ2ljIG51bWJlcnMgdXNlZCBoZXJlIGFyZSAtXG4gIC8vIDJeMjQgPSAxNjc3NzIxNiA9ICgxLDY3NzcyMTYpIGluIGJhc2UtMWU3LlxuICAvLyAyXjQ4ID0gMjgxNDc0OTc2NzEwNjU2ID0gKDIsODE0NzQ5Nyw2NzEwNjU2KSBpbiBiYXNlLTFlNy5cbiAgLy8gU3BsaXQgMzI6MzIgcmVwcmVzZW50YXRpb24gaW50byAxNjoyNDoyNCByZXByZXNlbnRhdGlvbiBzbyBvdXJcbiAgLy8gaW50ZXJtZWRpYXRlIGRpZ2l0cyBkb24ndCBvdmVyZmxvdy5cbiAgY29uc3QgbG93ID0gbG8gJiAweEZGRkZGRjtcbiAgY29uc3QgbWlkID0gKGxvID4+PiAyNCB8IGhpIDw8IDgpICYgMHhGRkZGRkY7XG4gIGNvbnN0IGhpZ2ggPSBoaSA+PiAxNiAmIDB4RkZGRjtcbiAgLy8gQXNzZW1ibGUgb3VyIHRocmVlIGJhc2UtMWU3IGRpZ2l0cywgaWdub3JpbmcgY2Fycmllcy4gVGhlIG1heGltdW1cbiAgLy8gdmFsdWUgaW4gYSBkaWdpdCBhdCB0aGlzIHN0ZXAgaXMgcmVwcmVzZW50YWJsZSBhcyBhIDQ4LWJpdCBpbnRlZ2VyLCB3aGljaFxuICAvLyBjYW4gYmUgc3RvcmVkIGluIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgbGV0IGRpZ2l0QSA9IGxvdyArIG1pZCAqIDY3NzcyMTYgKyBoaWdoICogNjcxMDY1NjtcbiAgbGV0IGRpZ2l0QiA9IG1pZCArIGhpZ2ggKiA4MTQ3NDk3O1xuICBsZXQgZGlnaXRDID0gaGlnaCAqIDI7XG4gIC8vIEFwcGx5IGNhcnJpZXMgZnJvbSBBIHRvIEIgYW5kIGZyb20gQiB0byBDLlxuICBjb25zdCBiYXNlID0gMTAwMDAwMDA7XG4gIGlmIChkaWdpdEEgPj0gYmFzZSkge1xuICAgIGRpZ2l0QiArPSBNYXRoLmZsb29yKGRpZ2l0QSAvIGJhc2UpO1xuICAgIGRpZ2l0QSAlPSBiYXNlO1xuICB9XG4gIGlmIChkaWdpdEIgPj0gYmFzZSkge1xuICAgIGRpZ2l0QyArPSBNYXRoLmZsb29yKGRpZ2l0QiAvIGJhc2UpO1xuICAgIGRpZ2l0QiAlPSBiYXNlO1xuICB9XG4gIC8vIElmIGRpZ2l0QyBpcyAwLCB0aGVuIHdlIHNob3VsZCBoYXZlIHJldHVybmVkIGluIHRoZSB0cml2aWFsIGNvZGUgcGF0aFxuICAvLyBhdCB0aGUgdG9wIGZvciBub24tc2FmZSBpbnRlZ2Vycy4gR2l2ZW4gdGhpcywgd2UgY2FuIGFzc3VtZSBib3RoIGRpZ2l0QlxuICAvLyBhbmQgZGlnaXRBIG5lZWQgbGVhZGluZyB6ZXJvcy5cbiAgcmV0dXJuIGRpZ2l0Qy50b1N0cmluZygpICsgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zKGRpZ2l0QikgKyBkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MoZGlnaXRBKTtcbn1cbmZ1bmN0aW9uIHRvVW5zaWduZWQobG8sIGhpKSB7XG4gIHJldHVybiB7XG4gICAgbG86IGxvID4+PiAwLFxuICAgIGhpOiBoaSA+Pj4gMFxuICB9O1xufVxuZnVuY3Rpb24gbmV3Qml0cyhsbywgaGkpIHtcbiAgcmV0dXJuIHtcbiAgICBsbzogbG8gfCAwLFxuICAgIGhpOiBoaSB8IDBcbiAgfTtcbn1cbi8qKlxuICogUmV0dXJucyB0d28ncyBjb21wbGltZW50IG5lZ2F0aW9uIG9mIGlucHV0LlxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9PcGVyYXRvcnMvQml0d2lzZV9PcGVyYXRvcnMjU2lnbmVkXzMyLWJpdF9pbnRlZ2Vyc1xuICovXG5mdW5jdGlvbiBuZWdhdGUobG93Qml0cywgaGlnaEJpdHMpIHtcbiAgaGlnaEJpdHMgPSB+aGlnaEJpdHM7XG4gIGlmIChsb3dCaXRzKSB7XG4gICAgbG93Qml0cyA9IH5sb3dCaXRzICsgMTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBsb3dCaXRzIGlzIDAsIHRoZW4gYml0d2lzZS1ub3QgaXMgMHhGRkZGRkZGRixcbiAgICAvLyBhZGRpbmcgMSB0byB0aGF0LCByZXN1bHRzIGluIDB4MTAwMDAwMDAwLCB3aGljaCBsZWF2ZXNcbiAgICAvLyB0aGUgbG93IGJpdHMgMHgwIGFuZCBzaW1wbHkgYWRkcyBvbmUgdG8gdGhlIGhpZ2ggYml0cy5cbiAgICBoaWdoQml0cyArPSAxO1xuICB9XG4gIHJldHVybiBuZXdCaXRzKGxvd0JpdHMsIGhpZ2hCaXRzKTtcbn1cbi8qKlxuICogUmV0dXJucyBkZWNpbWFsIHJlcHJlc2VudGF0aW9uIG9mIGRpZ2l0MWU3IHdpdGggbGVhZGluZyB6ZXJvcy5cbiAqL1xuY29uc3QgZGVjaW1hbEZyb20xZTdXaXRoTGVhZGluZ1plcm9zID0gZGlnaXQxZTcgPT4ge1xuICBjb25zdCBwYXJ0aWFsID0gU3RyaW5nKGRpZ2l0MWU3KTtcbiAgcmV0dXJuIFwiMDAwMDAwMFwiLnNsaWNlKHBhcnRpYWwubGVuZ3RoKSArIHBhcnRpYWw7XG59O1xuLyoqXG4gKiBXcml0ZSBhIDMyIGJpdCB2YXJpbnQsIHNpZ25lZCBvciB1bnNpZ25lZC4gU2FtZSBhcyBgdmFyaW50NjR3cml0ZSgwLCB2YWx1ZSwgYnl0ZXMpYFxuICpcbiAqIENvcHlyaWdodCAyMDA4IEdvb2dsZSBJbmMuICBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcHJvdG9jb2xidWZmZXJzL3Byb3RvYnVmL2Jsb2IvMWIxODgzM2Y0ZjJhMmY2ODFmNGU0YTI1Y2RmM2IwYTQzMTE1ZWMyNi9qcy9iaW5hcnkvZW5jb2Rlci5qcyNMMTQ0XG4gKi9cbmZ1bmN0aW9uIHZhcmludDMyd3JpdGUodmFsdWUsIGJ5dGVzKSB7XG4gIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgLy8gd3JpdGUgdmFsdWUgYXMgdmFyaW50IDMyXG4gICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgYnl0ZXMucHVzaCh2YWx1ZSAmIDB4N2YgfCAweDgwKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgfVxuICAgIGJ5dGVzLnB1c2godmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgOTsgaSsrKSB7XG4gICAgICBieXRlcy5wdXNoKHZhbHVlICYgMTI3IHwgMTI4KTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4gNztcbiAgICB9XG4gICAgYnl0ZXMucHVzaCgxKTtcbiAgfVxufVxuLyoqXG4gKiBSZWFkIGFuIHVuc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvYmxvYi84YTcxOTI3ZDc0YTRjZTM0ZWZlMmQ4NzY5ZmRhMTk4ZjUyZDIwZDEyL2pzL2V4cGVyaW1lbnRhbC9ydW50aW1lL2tlcm5lbC9idWZmZXJfZGVjb2Rlci5qcyNMMjIwXG4gKi9cbmZ1bmN0aW9uIHZhcmludDMycmVhZCgpIHtcbiAgbGV0IGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgbGV0IHJlc3VsdCA9IGIgJiAweDdmO1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgNztcbiAgaWYgKChiICYgMHg4MCkgPT0gMCkge1xuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIHJlc3VsdCB8PSAoYiAmIDB4N2YpIDw8IDE0O1xuICBpZiAoKGIgJiAweDgwKSA9PSAwKSB7XG4gICAgdGhpcy5hc3NlcnRCb3VuZHMoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHg3ZikgPDwgMjE7XG4gIGlmICgoYiAmIDB4ODApID09IDApIHtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLy8gRXh0cmFjdCBvbmx5IGxhc3QgNCBiaXRzXG4gIGIgPSB0aGlzLmJ1Zlt0aGlzLnBvcysrXTtcbiAgcmVzdWx0IHw9IChiICYgMHgwZikgPDwgMjg7XG4gIGZvciAobGV0IHJlYWRCeXRlcyA9IDU7IChiICYgMHg4MCkgIT09IDAgJiYgcmVhZEJ5dGVzIDwgMTA7IHJlYWRCeXRlcysrKSBiID0gdGhpcy5idWZbdGhpcy5wb3MrK107XG4gIGlmICgoYiAmIDB4ODApICE9IDApIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgdmFyaW50XCIpO1xuICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAvLyBSZXN1bHQgY2FuIGhhdmUgMzIgYml0cywgY29udmVydCBpdCB0byB1bnNpZ25lZFxuICByZXR1cm4gcmVzdWx0ID4+PiAwO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuZnVuY3Rpb24gbWFrZUludDY0U3VwcG9ydCgpIHtcbiAgY29uc3QgZHYgPSBuZXcgRGF0YVZpZXcobmV3IEFycmF5QnVmZmVyKDgpKTtcbiAgLy8gbm90ZSB0aGF0IFNhZmFyaSAxNCBpbXBsZW1lbnRzIEJpZ0ludCwgYnV0IG5vdCB0aGUgRGF0YVZpZXcgbWV0aG9kc1xuICBjb25zdCBvayA9IHR5cGVvZiBCaWdJbnQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuZ2V0QmlnSW50NjQgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgZHYuZ2V0QmlnVWludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LnNldEJpZ0ludDY0ID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIGR2LnNldEJpZ1VpbnQ2NCA9PT0gXCJmdW5jdGlvblwiICYmICh0eXBlb2YgcHJvY2VzcyAhPSBcIm9iamVjdFwiIHx8IHR5cGVvZiBwcm9jZXNzLmVudiAhPSBcIm9iamVjdFwiIHx8IHByb2Nlc3MuZW52LkJVRl9CSUdJTlRfRElTQUJMRSAhPT0gXCIxXCIpO1xuICBpZiAob2spIHtcbiAgICBjb25zdCBNSU4gPSBCaWdJbnQoXCItOTIyMzM3MjAzNjg1NDc3NTgwOFwiKSxcbiAgICAgIE1BWCA9IEJpZ0ludChcIjkyMjMzNzIwMzY4NTQ3NzU4MDdcIiksXG4gICAgICBVTUlOID0gQmlnSW50KFwiMFwiKSxcbiAgICAgIFVNQVggPSBCaWdJbnQoXCIxODQ0Njc0NDA3MzcwOTU1MTYxNVwiKTtcbiAgICByZXR1cm4ge1xuICAgICAgemVybzogQmlnSW50KDApLFxuICAgICAgc3VwcG9ydGVkOiB0cnVlLFxuICAgICAgcGFyc2UodmFsdWUpIHtcbiAgICAgICAgY29uc3QgYmkgPSB0eXBlb2YgdmFsdWUgPT0gXCJiaWdpbnRcIiA/IHZhbHVlIDogQmlnSW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGJpID4gTUFYIHx8IGJpIDwgTUlOKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpO1xuICAgICAgfSxcbiAgICAgIHVQYXJzZSh2YWx1ZSkge1xuICAgICAgICBjb25zdCBiaSA9IHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiID8gdmFsdWUgOiBCaWdJbnQodmFsdWUpO1xuICAgICAgICBpZiAoYmkgPiBVTUFYIHx8IGJpIDwgVU1JTikge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmk7XG4gICAgICB9LFxuICAgICAgZW5jKHZhbHVlKSB7XG4gICAgICAgIGR2LnNldEJpZ0ludDY0KDAsIHRoaXMucGFyc2UodmFsdWUpLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsbzogZHYuZ2V0SW50MzIoMCwgdHJ1ZSksXG4gICAgICAgICAgaGk6IGR2LmdldEludDMyKDQsIHRydWUpXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgdUVuYyh2YWx1ZSkge1xuICAgICAgICBkdi5zZXRCaWdJbnQ2NCgwLCB0aGlzLnVQYXJzZSh2YWx1ZSksIHRydWUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxvOiBkdi5nZXRJbnQzMigwLCB0cnVlKSxcbiAgICAgICAgICBoaTogZHYuZ2V0SW50MzIoNCwgdHJ1ZSlcbiAgICAgICAgfTtcbiAgICAgIH0sXG4gICAgICBkZWMobG8sIGhpKSB7XG4gICAgICAgIGR2LnNldEludDMyKDAsIGxvLCB0cnVlKTtcbiAgICAgICAgZHYuc2V0SW50MzIoNCwgaGksIHRydWUpO1xuICAgICAgICByZXR1cm4gZHYuZ2V0QmlnSW50NjQoMCwgdHJ1ZSk7XG4gICAgICB9LFxuICAgICAgdURlYyhsbywgaGkpIHtcbiAgICAgICAgZHYuc2V0SW50MzIoMCwgbG8sIHRydWUpO1xuICAgICAgICBkdi5zZXRJbnQzMig0LCBoaSwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBkdi5nZXRCaWdVaW50NjQoMCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuICBjb25zdCBhc3NlcnRJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXi0/WzAtOV0rJC8udGVzdCh2YWx1ZSksIFwiaW50NjQgaW52YWxpZDogXCIuY29uY2F0KHZhbHVlKSk7XG4gIGNvbnN0IGFzc2VydFVJbnQ2NFN0cmluZyA9IHZhbHVlID0+IGFzc2VydCgvXlswLTldKyQvLnRlc3QodmFsdWUpLCBcInVpbnQ2NCBpbnZhbGlkOiBcIi5jb25jYXQodmFsdWUpKTtcbiAgcmV0dXJuIHtcbiAgICB6ZXJvOiBcIjBcIixcbiAgICBzdXBwb3J0ZWQ6IGZhbHNlLFxuICAgIHBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0SW50NjRTdHJpbmcodmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG4gICAgdVBhcnNlKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9IFwic3RyaW5nXCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgYXNzZXJ0VUludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuICAgIGVuYyh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydEludDY0U3RyaW5nKHZhbHVlKTtcbiAgICAgIHJldHVybiBpbnQ2NEZyb21TdHJpbmcodmFsdWUpO1xuICAgIH0sXG4gICAgdUVuYyh2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGFzc2VydFVJbnQ2NFN0cmluZyh2YWx1ZSk7XG4gICAgICByZXR1cm4gaW50NjRGcm9tU3RyaW5nKHZhbHVlKTtcbiAgICB9LFxuICAgIGRlYyhsbywgaGkpIHtcbiAgICAgIHJldHVybiBpbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgfSxcbiAgICB1RGVjKGxvLCBoaSkge1xuICAgICAgcmV0dXJuIHVJbnQ2NFRvU3RyaW5nKGxvLCBoaSk7XG4gICAgfVxuICB9O1xufVxuY29uc3QgcHJvdG9JbnQ2NCA9IG1ha2VJbnQ2NFN1cHBvcnQoKTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogU2NhbGFyIHZhbHVlIHR5cGVzLiBUaGlzIGlzIGEgc3Vic2V0IG9mIGZpZWxkIHR5cGVzIGRlY2xhcmVkIGJ5IHByb3RvYnVmXG4gKiBlbnVtIGdvb2dsZS5wcm90b2J1Zi5GaWVsZERlc2NyaXB0b3JQcm90by5UeXBlIFRoZSB0eXBlcyBHUk9VUCBhbmQgTUVTU0FHRVxuICogYXJlIG9taXR0ZWQsIGJ1dCB0aGUgbnVtZXJpY2FsIHZhbHVlcyBhcmUgaWRlbnRpY2FsLlxuICovXG52YXIgU2NhbGFyVHlwZTtcbihmdW5jdGlvbiAoU2NhbGFyVHlwZSkge1xuICAvLyAwIGlzIHJlc2VydmVkIGZvciBlcnJvcnMuXG4gIC8vIE9yZGVyIGlzIHdlaXJkIGZvciBoaXN0b3JpY2FsIHJlYXNvbnMuXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkRPVUJMRVwiXSA9IDFdID0gXCJET1VCTEVcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRkxPQVRcIl0gPSAyXSA9IFwiRkxPQVRcIjtcbiAgLy8gTm90IFppZ1phZyBlbmNvZGVkLiAgTmVnYXRpdmUgbnVtYmVycyB0YWtlIDEwIGJ5dGVzLiAgVXNlIFRZUEVfU0lOVDY0IGlmXG4gIC8vIG5lZ2F0aXZlIHZhbHVlcyBhcmUgbGlrZWx5LlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJJTlQ2NFwiXSA9IDNdID0gXCJJTlQ2NFwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJVSU5UNjRcIl0gPSA0XSA9IFwiVUlOVDY0XCI7XG4gIC8vIE5vdCBaaWdaYWcgZW5jb2RlZC4gIE5lZ2F0aXZlIG51bWJlcnMgdGFrZSAxMCBieXRlcy4gIFVzZSBUWVBFX1NJTlQzMiBpZlxuICAvLyBuZWdhdGl2ZSB2YWx1ZXMgYXJlIGxpa2VseS5cbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiSU5UMzJcIl0gPSA1XSA9IFwiSU5UMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiRklYRUQ2NFwiXSA9IDZdID0gXCJGSVhFRDY0XCI7XG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIkZJWEVEMzJcIl0gPSA3XSA9IFwiRklYRUQzMlwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCT09MXCJdID0gOF0gPSBcIkJPT0xcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU1RSSU5HXCJdID0gOV0gPSBcIlNUUklOR1wiO1xuICAvLyBUYWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgLy8gR3JvdXAgdHlwZSBpcyBkZXByZWNhdGVkIGFuZCBub3Qgc3VwcG9ydGVkIGluIHByb3RvMy4gSG93ZXZlciwgUHJvdG8zXG4gIC8vIGltcGxlbWVudGF0aW9ucyBzaG91bGQgc3RpbGwgYmUgYWJsZSB0byBwYXJzZSB0aGUgZ3JvdXAgd2lyZSBmb3JtYXQgYW5kXG4gIC8vIHRyZWF0IGdyb3VwIGZpZWxkcyBhcyB1bmtub3duIGZpZWxkcy5cbiAgLy8gVFlQRV9HUk9VUCA9IDEwLFxuICAvLyBUWVBFX01FU1NBR0UgPSAxMSwgIC8vIExlbmd0aC1kZWxpbWl0ZWQgYWdncmVnYXRlLlxuICAvLyBOZXcgaW4gdmVyc2lvbiAyLlxuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJCWVRFU1wiXSA9IDEyXSA9IFwiQllURVNcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiVUlOVDMyXCJdID0gMTNdID0gXCJVSU5UMzJcIjtcbiAgLy8gVFlQRV9FTlVNID0gMTQsXG4gIFNjYWxhclR5cGVbU2NhbGFyVHlwZVtcIlNGSVhFRDMyXCJdID0gMTVdID0gXCJTRklYRUQzMlwiO1xuICBTY2FsYXJUeXBlW1NjYWxhclR5cGVbXCJTRklYRUQ2NFwiXSA9IDE2XSA9IFwiU0ZJWEVENjRcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDMyXCJdID0gMTddID0gXCJTSU5UMzJcIjtcbiAgU2NhbGFyVHlwZVtTY2FsYXJUeXBlW1wiU0lOVDY0XCJdID0gMThdID0gXCJTSU5UNjRcIjtcbn0pKFNjYWxhclR5cGUgfHwgKFNjYWxhclR5cGUgPSB7fSkpO1xuLyoqXG4gKiBKYXZhU2NyaXB0IHJlcHJlc2VudGF0aW9uIG9mIGZpZWxkcyB3aXRoIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbiAqIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpLlxuICpcbiAqIFRoaXMgaXMgYSBzdWJzZXQgb2YgZ29vZ2xlLnByb3RvYnVmLkZpZWxkT3B0aW9ucy5KU1R5cGUsIHdoaWNoIGRlZmluZXMgSlNfTk9STUFMLFxuICogSlNfU1RSSU5HLCBhbmQgSlNfTlVNQkVSLiBQcm90b2J1Zi1FUyB1c2VzIEJpZ0ludCBieSBkZWZhdWx0LCBidXQgd2lsbCB1c2VcbiAqIFN0cmluZyBpZiBgW2pzdHlwZSA9IEpTX1NUUklOR11gIGlzIHNwZWNpZmllZC5cbiAqXG4gKiBgYGBwcm90b2J1ZlxuICogdWludDY0IGZpZWxkX2EgPSAxOyAvLyBCaWdJbnRcbiAqIHVpbnQ2NCBmaWVsZF9iID0gMiBbanN0eXBlID0gSlNfTk9STUFMXTsgLy8gQmlnSW50XG4gKiB1aW50NjQgZmllbGRfYiA9IDIgW2pzdHlwZSA9IEpTX05VTUJFUl07IC8vIEJpZ0ludFxuICogdWludDY0IGZpZWxkX2IgPSAyIFtqc3R5cGUgPSBKU19TVFJJTkddOyAvLyBTdHJpbmdcbiAqIGBgYFxuICovXG52YXIgTG9uZ1R5cGU7XG4oZnVuY3Rpb24gKExvbmdUeXBlKSB7XG4gIC8qKlxuICAgKiBVc2UgSmF2YVNjcmlwdCBCaWdJbnQuXG4gICAqL1xuICBMb25nVHlwZVtMb25nVHlwZVtcIkJJR0lOVFwiXSA9IDBdID0gXCJCSUdJTlRcIjtcbiAgLyoqXG4gICAqIFVzZSBKYXZhU2NyaXB0IFN0cmluZy5cbiAgICpcbiAgICogRmllbGQgb3B0aW9uIGBbanN0eXBlID0gSlNfU1RSSU5HXWAuXG4gICAqL1xuICBMb25nVHlwZVtMb25nVHlwZVtcIlNUUklOR1wiXSA9IDFdID0gXCJTVFJJTkdcIjtcbn0pKExvbmdUeXBlIHx8IChMb25nVHlwZSA9IHt9KSk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBib3RoIHNjYWxhciB2YWx1ZXMgYXJlIGVxdWFsLlxuICovXG5mdW5jdGlvbiBzY2FsYXJFcXVhbHModHlwZSwgYSwgYikge1xuICBpZiAoYSA9PT0gYikge1xuICAgIC8vIFRoaXMgY29ycmVjdGx5IG1hdGNoZXMgZXF1YWwgdmFsdWVzIGV4Y2VwdCBCWVRFUyBhbmQgKHBvc3NpYmx5KSA2NC1iaXQgaW50ZWdlcnMuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLy8gU3BlY2lhbCBjYXNlIEJZVEVTIC0gd2UgbmVlZCB0byBjb21wYXJlIGVhY2ggYnl0ZSBpbmRpdmlkdWFsbHlcbiAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5CWVRFUykge1xuICAgIGlmICghKGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB8fCAhKGIgaW5zdGFuY2VvZiBVaW50OEFycmF5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvLyBTcGVjaWFsIGNhc2UgNjQtYml0IGludGVnZXJzIC0gd2Ugc3VwcG9ydCBudW1iZXIsIHN0cmluZyBhbmQgYmlnaW50IHJlcHJlc2VudGF0aW9uLlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVja1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIC8vIExvb3NlIGNvbXBhcmlzb24gd2lsbCBtYXRjaCBiZXR3ZWVuIDBuLCAwIGFuZCBcIjBcIi5cbiAgICAgIHJldHVybiBhID09IGI7XG4gIH1cbiAgLy8gQW55dGhpbmcgdGhhdCBoYXNuJ3QgYmVlbiBjYXVnaHQgYnkgc3RyaWN0IGNvbXBhcmlzb24gb3Igc3BlY2lhbCBjYXNlZFxuICAvLyBCWVRFUyBhbmQgNjQtYml0IGludGVnZXJzIGlzIG5vdCBlcXVhbC5cbiAgcmV0dXJuIGZhbHNlO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSB6ZXJvIHZhbHVlIGZvciB0aGUgZ2l2ZW4gc2NhbGFyIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHNjYWxhclplcm9WYWx1ZSh0eXBlLCBsb25nVHlwZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFNjYWxhclR5cGUuQk9PTDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQ2NDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWVudW0tY29tcGFyaXNvbiAtLSBhY2NlcHRhYmxlIHNpbmNlIGl0J3MgY292ZXJlZCBieSB0ZXN0c1xuICAgICAgcmV0dXJuIGxvbmdUeXBlID09IDAgPyBwcm90b0ludDY0Lnplcm8gOiBcIjBcIjtcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAgIHJldHVybiAwLjA7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KDApO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICBkZWZhdWx0OlxuICAgICAgLy8gSGFuZGxlcyBJTlQzMiwgVUlOVDMyLCBTSU5UMzIsIEZJWEVEMzIsIFNGSVhFRDMyLlxuICAgICAgLy8gV2UgZG8gbm90IHVzZSBpbmRpdmlkdWFsIGNhc2VzIHRvIHNhdmUgYSBmZXcgYnl0ZXMgY29kZSBzaXplLlxuICAgICAgcmV0dXJuIDA7XG4gIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGZvciBhIHplcm8tdmFsdWUuIEZvciBleGFtcGxlLCBhbiBpbnRlZ2VyIGhhcyB0aGUgemVyby12YWx1ZSBgMGAsXG4gKiBhIGJvb2xlYW4gaXMgYGZhbHNlYCwgYSBzdHJpbmcgaXMgYFwiXCJgLCBhbmQgYnl0ZXMgaXMgYW4gZW1wdHkgVWludDhBcnJheS5cbiAqXG4gKiBJbiBwcm90bzMsIHplcm8tdmFsdWVzIGFyZSBub3Qgd3JpdHRlbiB0byB0aGUgd2lyZSwgdW5sZXNzIHRoZSBmaWVsZCBpc1xuICogb3B0aW9uYWwgb3IgcmVwZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzU2NhbGFyWmVyb1ZhbHVlKHR5cGUsIHZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSBmYWxzZTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgcmV0dXJuIHZhbHVlID09PSBcIlwiO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgJiYgIXZhbHVlLmJ5dGVMZW5ndGg7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB2YWx1ZSA9PSAwO1xuICAgIC8vIExvb3NlIGNvbXBhcmlzb24gbWF0Y2hlcyAwbiwgMCBhbmQgXCIwXCJcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9yZXN0cmljdC1wbHVzLW9wZXJhbmRzICovXG4vKipcbiAqIFByb3RvYnVmIGJpbmFyeSBmb3JtYXQgd2lyZSB0eXBlcy5cbiAqXG4gKiBBIHdpcmUgdHlwZSBwcm92aWRlcyBqdXN0IGVub3VnaCBpbmZvcm1hdGlvbiB0byBmaW5kIHRoZSBsZW5ndGggb2YgdGhlXG4gKiBmb2xsb3dpbmcgdmFsdWUuXG4gKlxuICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL3Byb3RvY29sLWJ1ZmZlcnMvZG9jcy9lbmNvZGluZyNzdHJ1Y3R1cmVcbiAqL1xudmFyIFdpcmVUeXBlO1xuKGZ1bmN0aW9uIChXaXJlVHlwZSkge1xuICAvKipcbiAgICogVXNlZCBmb3IgaW50MzIsIGludDY0LCB1aW50MzIsIHVpbnQ2NCwgc2ludDMyLCBzaW50NjQsIGJvb2wsIGVudW1cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiVmFyaW50XCJdID0gMF0gPSBcIlZhcmludFwiO1xuICAvKipcbiAgICogVXNlZCBmb3IgZml4ZWQ2NCwgc2ZpeGVkNjQsIGRvdWJsZS5cbiAgICogQWx3YXlzIDggYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDY0XCJdID0gMV0gPSBcIkJpdDY0XCI7XG4gIC8qKlxuICAgKiBVc2VkIGZvciBzdHJpbmcsIGJ5dGVzLCBlbWJlZGRlZCBtZXNzYWdlcywgcGFja2VkIHJlcGVhdGVkIGZpZWxkc1xuICAgKlxuICAgKiBPbmx5IHJlcGVhdGVkIG51bWVyaWMgdHlwZXMgKHR5cGVzIHdoaWNoIHVzZSB0aGUgdmFyaW50LCAzMi1iaXQsXG4gICAqIG9yIDY0LWJpdCB3aXJlIHR5cGVzKSBjYW4gYmUgcGFja2VkLiBJbiBwcm90bzMsIHN1Y2ggZmllbGRzIGFyZVxuICAgKiBwYWNrZWQgYnkgZGVmYXVsdC5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiTGVuZ3RoRGVsaW1pdGVkXCJdID0gMl0gPSBcIkxlbmd0aERlbGltaXRlZFwiO1xuICAvKipcbiAgICogU3RhcnQgb2YgYSB0YWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZSwgc3VjaCBhcyBhIHByb3RvMiBncm91cCwgb3IgYSBtZXNzYWdlXG4gICAqIGluIGVkaXRpb25zIHdpdGggbWVzc2FnZV9lbmNvZGluZyA9IERFTElNSVRFRC5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiU3RhcnRHcm91cFwiXSA9IDNdID0gXCJTdGFydEdyb3VwXCI7XG4gIC8qKlxuICAgKiBFbmQgb2YgYSB0YWctZGVsaW1pdGVkIGFnZ3JlZ2F0ZS5cbiAgICovXG4gIFdpcmVUeXBlW1dpcmVUeXBlW1wiRW5kR3JvdXBcIl0gPSA0XSA9IFwiRW5kR3JvdXBcIjtcbiAgLyoqXG4gICAqIFVzZWQgZm9yIGZpeGVkMzIsIHNmaXhlZDMyLCBmbG9hdC5cbiAgICogQWx3YXlzIDQgYnl0ZXMgd2l0aCBsaXR0bGUtZW5kaWFuIGJ5dGUgb3JkZXIuXG4gICAqL1xuICBXaXJlVHlwZVtXaXJlVHlwZVtcIkJpdDMyXCJdID0gNV0gPSBcIkJpdDMyXCI7XG59KShXaXJlVHlwZSB8fCAoV2lyZVR5cGUgPSB7fSkpO1xuY2xhc3MgQmluYXJ5V3JpdGVyIHtcbiAgY29uc3RydWN0b3IodGV4dEVuY29kZXIpIHtcbiAgICAvKipcbiAgICAgKiBQcmV2aW91cyBmb3JrIHN0YXRlcy5cbiAgICAgKi9cbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgdGhpcy50ZXh0RW5jb2RlciA9IHRleHRFbmNvZGVyICE9PSBudWxsICYmIHRleHRFbmNvZGVyICE9PSB2b2lkIDAgPyB0ZXh0RW5jb2RlciA6IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gICAgdGhpcy5idWYgPSBbXTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJuIGFsbCBieXRlcyB3cml0dGVuIGFuZCByZXNldCB0aGlzIHdyaXRlci5cbiAgICovXG4gIGZpbmlzaCgpIHtcbiAgICB0aGlzLmNodW5rcy5wdXNoKG5ldyBVaW50OEFycmF5KHRoaXMuYnVmKSk7IC8vIGZsdXNoIHRoZSBidWZmZXJcbiAgICBsZXQgbGVuID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuY2h1bmtzLmxlbmd0aDsgaSsrKSBsZW4gKz0gdGhpcy5jaHVua3NbaV0ubGVuZ3RoO1xuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmNodW5rcy5sZW5ndGg7IGkrKykge1xuICAgICAgYnl0ZXMuc2V0KHRoaXMuY2h1bmtzW2ldLCBvZmZzZXQpO1xuICAgICAgb2Zmc2V0ICs9IHRoaXMuY2h1bmtzW2ldLmxlbmd0aDtcbiAgICB9XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICByZXR1cm4gYnl0ZXM7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IGEgbmV3IGZvcmsgZm9yIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBsaWtlIGEgbWVzc2FnZVxuICAgKiBvciBhIHBhY2tlZCByZXBlYXRlZCBmaWVsZC5cbiAgICpcbiAgICogTXVzdCBiZSBqb2luZWQgbGF0ZXIgd2l0aCBgam9pbigpYC5cbiAgICovXG4gIGZvcmsoKSB7XG4gICAgdGhpcy5zdGFjay5wdXNoKHtcbiAgICAgIGNodW5rczogdGhpcy5jaHVua3MsXG4gICAgICBidWY6IHRoaXMuYnVmXG4gICAgfSk7XG4gICAgdGhpcy5jaHVua3MgPSBbXTtcbiAgICB0aGlzLmJ1ZiA9IFtdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBKb2luIHRoZSBsYXN0IGZvcmsuIFdyaXRlIGl0cyBsZW5ndGggYW5kIGJ5dGVzLCB0aGVuXG4gICAqIHJldHVybiB0byB0aGUgcHJldmlvdXMgc3RhdGUuXG4gICAqL1xuICBqb2luKCkge1xuICAgIC8vIGdldCBjaHVuayBvZiBmb3JrXG4gICAgbGV0IGNodW5rID0gdGhpcy5maW5pc2goKTtcbiAgICAvLyByZXN0b3JlIHByZXZpb3VzIHN0YXRlXG4gICAgbGV0IHByZXYgPSB0aGlzLnN0YWNrLnBvcCgpO1xuICAgIGlmICghcHJldikgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBzdGF0ZSwgZm9yayBzdGFjayBlbXB0eVwiKTtcbiAgICB0aGlzLmNodW5rcyA9IHByZXYuY2h1bmtzO1xuICAgIHRoaXMuYnVmID0gcHJldi5idWY7XG4gICAgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgIHRoaXMudWludDMyKGNodW5rLmJ5dGVMZW5ndGgpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlcyBhIHRhZyAoZmllbGQgbnVtYmVyIGFuZCB3aXJlIHR5cGUpLlxuICAgKlxuICAgKiBFcXVpdmFsZW50IHRvIGB1aW50MzIoIChmaWVsZE5vIDw8IDMgfCB0eXBlKSA+Pj4gMCApYC5cbiAgICpcbiAgICogR2VuZXJhdGVkIGNvZGUgc2hvdWxkIGNvbXB1dGUgdGhlIHRhZyBhaGVhZCBvZiB0aW1lIGFuZCBjYWxsIGB1aW50MzIoKWAuXG4gICAqL1xuICB0YWcoZmllbGRObywgdHlwZSkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigoZmllbGRObyA8PCAzIHwgdHlwZSkgPj4+IDApO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGNodW5rIG9mIHJhdyBieXRlcy5cbiAgICovXG4gIHJhdyhjaHVuaykge1xuICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2h1bmtzLnB1c2gobmV3IFVpbnQ4QXJyYXkodGhpcy5idWYpKTtcbiAgICAgIHRoaXMuYnVmID0gW107XG4gICAgfVxuICAgIHRoaXMuY2h1bmtzLnB1c2goY2h1bmspO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGB1aW50MzJgIHZhbHVlLCBhbiB1bnNpZ25lZCAzMiBiaXQgdmFyaW50LlxuICAgKi9cbiAgdWludDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICAvLyB3cml0ZSB2YWx1ZSBhcyB2YXJpbnQgMzIsIGlubGluZWQgZm9yIHNwZWVkXG4gICAgd2hpbGUgKHZhbHVlID4gMHg3Zikge1xuICAgICAgdGhpcy5idWYucHVzaCh2YWx1ZSAmIDB4N2YgfCAweDgwKTtcbiAgICAgIHZhbHVlID0gdmFsdWUgPj4+IDc7XG4gICAgfVxuICAgIHRoaXMuYnVmLnB1c2godmFsdWUpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBpbnQzMmAgdmFsdWUsIGEgc2lnbmVkIDMyIGJpdCB2YXJpbnQuXG4gICAqL1xuICBpbnQzMih2YWx1ZSkge1xuICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGJvb2xgIHZhbHVlLCBhIHZhcmlhbnQuXG4gICAqL1xuICBib29sKHZhbHVlKSB7XG4gICAgdGhpcy5idWYucHVzaCh2YWx1ZSA/IDEgOiAwKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgYnl0ZXNgIHZhbHVlLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgKi9cbiAgYnl0ZXModmFsdWUpIHtcbiAgICB0aGlzLnVpbnQzMih2YWx1ZS5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgIHJldHVybiB0aGlzLnJhdyh2YWx1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHN0cmluZ2AgdmFsdWUsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICovXG4gIHN0cmluZyh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IHRoaXMudGV4dEVuY29kZXIuZW5jb2RlKHZhbHVlKTtcbiAgICB0aGlzLnVpbnQzMihjaHVuay5ieXRlTGVuZ3RoKTsgLy8gd3JpdGUgbGVuZ3RoIG9mIGNodW5rIGFzIHZhcmludFxuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGZsb2F0YCB2YWx1ZSwgMzItYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGZsb2F0KHZhbHVlKSB7XG4gICAgYXNzZXJ0RmxvYXQzMih2YWx1ZSk7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoNCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQzMigwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZG91YmxlYCB2YWx1ZSwgYSA2NC1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgZG91YmxlKHZhbHVlKSB7XG4gICAgbGV0IGNodW5rID0gbmV3IFVpbnQ4QXJyYXkoOCk7XG4gICAgbmV3IERhdGFWaWV3KGNodW5rLmJ1ZmZlcikuc2V0RmxvYXQ2NCgwLCB2YWx1ZSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMucmF3KGNodW5rKTtcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgZml4ZWQzMmAgdmFsdWUsIGFuIHVuc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAqL1xuICBmaXhlZDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0VUludDMyKHZhbHVlKTtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg0KTtcbiAgICBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKS5zZXRVaW50MzIoMCwgdmFsdWUsIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHNmaXhlZDMyYCB2YWx1ZSwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCAzMi1iaXQgaW50ZWdlci5cbiAgICovXG4gIHNmaXhlZDMyKHZhbHVlKSB7XG4gICAgYXNzZXJ0SW50MzIodmFsdWUpO1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDQpO1xuICAgIG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLnNldEludDMyKDAsIHZhbHVlLCB0cnVlKTtcbiAgICByZXR1cm4gdGhpcy5yYXcoY2h1bmspO1xuICB9XG4gIC8qKlxuICAgKiBXcml0ZSBhIGBzaW50MzJgIHZhbHVlLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQzMih2YWx1ZSkge1xuICAgIGFzc2VydEludDMyKHZhbHVlKTtcbiAgICAvLyB6aWd6YWcgZW5jb2RlXG4gICAgdmFsdWUgPSAodmFsdWUgPDwgMSBeIHZhbHVlID4+IDMxKSA+Pj4gMDtcbiAgICB2YXJpbnQzMndyaXRlKHZhbHVlLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhIHNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0LWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgc2ZpeGVkNjQodmFsdWUpIHtcbiAgICBsZXQgY2h1bmsgPSBuZXcgVWludDhBcnJheSg4KSxcbiAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoY2h1bmsuYnVmZmVyKSxcbiAgICAgIHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpO1xuICAgIHZpZXcuc2V0SW50MzIoMCwgdGMubG8sIHRydWUpO1xuICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGZpeGVkNjRgIHZhbHVlLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQ2NCh2YWx1ZSkge1xuICAgIGxldCBjaHVuayA9IG5ldyBVaW50OEFycmF5KDgpLFxuICAgICAgdmlldyA9IG5ldyBEYXRhVmlldyhjaHVuay5idWZmZXIpLFxuICAgICAgdGMgPSBwcm90b0ludDY0LnVFbmModmFsdWUpO1xuICAgIHZpZXcuc2V0SW50MzIoMCwgdGMubG8sIHRydWUpO1xuICAgIHZpZXcuc2V0SW50MzIoNCwgdGMuaGksIHRydWUpO1xuICAgIHJldHVybiB0aGlzLnJhdyhjaHVuayk7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYGludDY0YCB2YWx1ZSwgYSBzaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIGludDY0KHZhbHVlKSB7XG4gICAgbGV0IHRjID0gcHJvdG9JbnQ2NC5lbmModmFsdWUpO1xuICAgIHZhcmludDY0d3JpdGUodGMubG8sIHRjLmhpLCB0aGlzLmJ1Zik7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgLyoqXG4gICAqIFdyaXRlIGEgYHNpbnQ2NGAgdmFsdWUsIGEgc2lnbmVkLCB6aWctemFnLWVuY29kZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQ2NCh2YWx1ZSkge1xuICAgIGxldCB0YyA9IHByb3RvSW50NjQuZW5jKHZhbHVlKSxcbiAgICAgIC8vIHppZ3phZyBlbmNvZGVcbiAgICAgIHNpZ24gPSB0Yy5oaSA+PiAzMSxcbiAgICAgIGxvID0gdGMubG8gPDwgMSBeIHNpZ24sXG4gICAgICBoaSA9ICh0Yy5oaSA8PCAxIHwgdGMubG8gPj4+IDMxKSBeIHNpZ247XG4gICAgdmFyaW50NjR3cml0ZShsbywgaGksIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuICAvKipcbiAgICogV3JpdGUgYSBgdWludDY0YCB2YWx1ZSwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHVpbnQ2NCh2YWx1ZSkge1xuICAgIGxldCB0YyA9IHByb3RvSW50NjQudUVuYyh2YWx1ZSk7XG4gICAgdmFyaW50NjR3cml0ZSh0Yy5sbywgdGMuaGksIHRoaXMuYnVmKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxufVxuY2xhc3MgQmluYXJ5UmVhZGVyIHtcbiAgY29uc3RydWN0b3IoYnVmLCB0ZXh0RGVjb2Rlcikge1xuICAgIHRoaXMudmFyaW50NjQgPSB2YXJpbnQ2NHJlYWQ7IC8vIGRpcnR5IGNhc3QgZm9yIGB0aGlzYFxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBgdWludDMyYCBmaWVsZCwgYW4gdW5zaWduZWQgMzIgYml0IHZhcmludC5cbiAgICAgKi9cbiAgICB0aGlzLnVpbnQzMiA9IHZhcmludDMycmVhZDsgLy8gZGlydHkgY2FzdCBmb3IgYHRoaXNgIGFuZCBhY2Nlc3MgdG8gcHJvdGVjdGVkIGBidWZgXG4gICAgdGhpcy5idWYgPSBidWY7XG4gICAgdGhpcy5sZW4gPSBidWYubGVuZ3RoO1xuICAgIHRoaXMucG9zID0gMDtcbiAgICB0aGlzLnZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmLmJ1ZmZlciwgYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlTGVuZ3RoKTtcbiAgICB0aGlzLnRleHREZWNvZGVyID0gdGV4dERlY29kZXIgIT09IG51bGwgJiYgdGV4dERlY29kZXIgIT09IHZvaWQgMCA/IHRleHREZWNvZGVyIDogbmV3IFRleHREZWNvZGVyKCk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWRzIGEgdGFnIC0gZmllbGQgbnVtYmVyIGFuZCB3aXJlIHR5cGUuXG4gICAqL1xuICB0YWcoKSB7XG4gICAgbGV0IHRhZyA9IHRoaXMudWludDMyKCksXG4gICAgICBmaWVsZE5vID0gdGFnID4+PiAzLFxuICAgICAgd2lyZVR5cGUgPSB0YWcgJiA3O1xuICAgIGlmIChmaWVsZE5vIDw9IDAgfHwgd2lyZVR5cGUgPCAwIHx8IHdpcmVUeXBlID4gNSkgdGhyb3cgbmV3IEVycm9yKFwiaWxsZWdhbCB0YWc6IGZpZWxkIG5vIFwiICsgZmllbGRObyArIFwiIHdpcmUgdHlwZSBcIiArIHdpcmVUeXBlKTtcbiAgICByZXR1cm4gW2ZpZWxkTm8sIHdpcmVUeXBlXTtcbiAgfVxuICAvKipcbiAgICogU2tpcCBvbmUgZWxlbWVudCBhbmQgcmV0dXJuIHRoZSBza2lwcGVkIGRhdGEuXG4gICAqXG4gICAqIFdoZW4gc2tpcHBpbmcgU3RhcnRHcm91cCwgcHJvdmlkZSB0aGUgdGFncyBmaWVsZCBudW1iZXIgdG8gY2hlY2sgZm9yXG4gICAqIG1hdGNoaW5nIGZpZWxkIG51bWJlciBpbiB0aGUgRW5kR3JvdXAgdGFnLlxuICAgKi9cbiAgc2tpcCh3aXJlVHlwZSwgZmllbGRObykge1xuICAgIGxldCBzdGFydCA9IHRoaXMucG9zO1xuICAgIHN3aXRjaCAod2lyZVR5cGUpIHtcbiAgICAgIGNhc2UgV2lyZVR5cGUuVmFyaW50OlxuICAgICAgICB3aGlsZSAodGhpcy5idWZbdGhpcy5wb3MrK10gJiAweDgwKSB7XG4gICAgICAgICAgLy8gaWdub3JlXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbiAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgY2FzZSBXaXJlVHlwZS5CaXQ2NDpcbiAgICAgICAgdGhpcy5wb3MgKz0gNDtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICBjYXNlIFdpcmVUeXBlLkJpdDMyOlxuICAgICAgICB0aGlzLnBvcyArPSA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2lyZVR5cGUuTGVuZ3RoRGVsaW1pdGVkOlxuICAgICAgICBsZXQgbGVuID0gdGhpcy51aW50MzIoKTtcbiAgICAgICAgdGhpcy5wb3MgKz0gbGVuO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgV2lyZVR5cGUuU3RhcnRHcm91cDpcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGNvbnN0IFtmbiwgd3RdID0gdGhpcy50YWcoKTtcbiAgICAgICAgICBpZiAod3QgPT09IFdpcmVUeXBlLkVuZEdyb3VwKSB7XG4gICAgICAgICAgICBpZiAoZmllbGRObyAhPT0gdW5kZWZpbmVkICYmIGZuICE9PSBmaWVsZE5vKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW5kIGdyb3VwIHRhZ1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnNraXAod3QsIGZuKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbnQgc2tpcCB3aXJlIHR5cGUgXCIgKyB3aXJlVHlwZSk7XG4gICAgfVxuICAgIHRoaXMuYXNzZXJ0Qm91bmRzKCk7XG4gICAgcmV0dXJuIHRoaXMuYnVmLnN1YmFycmF5KHN0YXJ0LCB0aGlzLnBvcyk7XG4gIH1cbiAgLyoqXG4gICAqIFRocm93cyBlcnJvciBpZiBwb3NpdGlvbiBpbiBieXRlIGFycmF5IGlzIG91dCBvZiByYW5nZS5cbiAgICovXG4gIGFzc2VydEJvdW5kcygpIHtcbiAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmxlbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJwcmVtYXR1cmUgRU9GXCIpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGludDMyYCBmaWVsZCwgYSBzaWduZWQgMzIgYml0IHZhcmludC5cbiAgICovXG4gIGludDMyKCkge1xuICAgIHJldHVybiB0aGlzLnVpbnQzMigpIHwgMDtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzaW50MzJgIGZpZWxkLCBhIHNpZ25lZCwgemlnemFnLWVuY29kZWQgMzItYml0IHZhcmludC5cbiAgICovXG4gIHNpbnQzMigpIHtcbiAgICBsZXQgenplID0gdGhpcy51aW50MzIoKTtcbiAgICAvLyBkZWNvZGUgemlnemFnXG4gICAgcmV0dXJuIHp6ZSA+Pj4gMSBeIC0oenplICYgMSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgaW50NjRgIGZpZWxkLCBhIHNpZ25lZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgaW50NjQoKSB7XG4gICAgcmV0dXJuIHByb3RvSW50NjQuZGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgdWludDY0YCBmaWVsZCwgYW4gdW5zaWduZWQgNjQtYml0IHZhcmludC5cbiAgICovXG4gIHVpbnQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKC4uLnRoaXMudmFyaW50NjQoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgc2ludDY0YCBmaWVsZCwgYSBzaWduZWQsIHppZy16YWctZW5jb2RlZCA2NC1iaXQgdmFyaW50LlxuICAgKi9cbiAgc2ludDY0KCkge1xuICAgIGxldCBbbG8sIGhpXSA9IHRoaXMudmFyaW50NjQoKTtcbiAgICAvLyBkZWNvZGUgemlnIHphZ1xuICAgIGxldCBzID0gLShsbyAmIDEpO1xuICAgIGxvID0gKGxvID4+PiAxIHwgKGhpICYgMSkgPDwgMzEpIF4gcztcbiAgICBoaSA9IGhpID4+PiAxIF4gcztcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC5kZWMobG8sIGhpKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBib29sYCBmaWVsZCwgYSB2YXJpYW50LlxuICAgKi9cbiAgYm9vbCgpIHtcbiAgICBsZXQgW2xvLCBoaV0gPSB0aGlzLnZhcmludDY0KCk7XG4gICAgcmV0dXJuIGxvICE9PSAwIHx8IGhpICE9PSAwO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZpeGVkMzJgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDMyLWJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQzMigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldFVpbnQzMigodGhpcy5wb3MgKz0gNCkgLSA0LCB0cnVlKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBzZml4ZWQzMmAgZmllbGQsIGEgc2lnbmVkLCBmaXhlZC1sZW5ndGggMzItYml0IGludGVnZXIuXG4gICAqL1xuICBzZml4ZWQzMigpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEludDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGZpeGVkNjRgIGZpZWxkLCBhbiB1bnNpZ25lZCwgZml4ZWQtbGVuZ3RoIDY0IGJpdCBpbnRlZ2VyLlxuICAgKi9cbiAgZml4ZWQ2NCgpIHtcbiAgICByZXR1cm4gcHJvdG9JbnQ2NC51RGVjKHRoaXMuc2ZpeGVkMzIoKSwgdGhpcy5zZml4ZWQzMigpKTtcbiAgfVxuICAvKipcbiAgICogUmVhZCBhIGBmaXhlZDY0YCBmaWVsZCwgYSBzaWduZWQsIGZpeGVkLWxlbmd0aCA2NC1iaXQgaW50ZWdlci5cbiAgICovXG4gIHNmaXhlZDY0KCkge1xuICAgIHJldHVybiBwcm90b0ludDY0LmRlYyh0aGlzLnNmaXhlZDMyKCksIHRoaXMuc2ZpeGVkMzIoKSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgZmxvYXRgIGZpZWxkLCAzMi1iaXQgZmxvYXRpbmcgcG9pbnQgbnVtYmVyLlxuICAgKi9cbiAgZmxvYXQoKSB7XG4gICAgcmV0dXJuIHRoaXMudmlldy5nZXRGbG9hdDMyKCh0aGlzLnBvcyArPSA0KSAtIDQsIHRydWUpO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYGRvdWJsZWAgZmllbGQsIGEgNjQtYml0IGZsb2F0aW5nIHBvaW50IG51bWJlci5cbiAgICovXG4gIGRvdWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LmdldEZsb2F0NjQoKHRoaXMucG9zICs9IDgpIC0gOCwgdHJ1ZSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlYWQgYSBgYnl0ZXNgIGZpZWxkLCBsZW5ndGgtZGVsaW1pdGVkIGFyYml0cmFyeSBkYXRhLlxuICAgKi9cbiAgYnl0ZXMoKSB7XG4gICAgbGV0IGxlbiA9IHRoaXMudWludDMyKCksXG4gICAgICBzdGFydCA9IHRoaXMucG9zO1xuICAgIHRoaXMucG9zICs9IGxlbjtcbiAgICB0aGlzLmFzc2VydEJvdW5kcygpO1xuICAgIHJldHVybiB0aGlzLmJ1Zi5zdWJhcnJheShzdGFydCwgc3RhcnQgKyBsZW4pO1xuICB9XG4gIC8qKlxuICAgKiBSZWFkIGEgYHN0cmluZ2AgZmllbGQsIGxlbmd0aC1kZWxpbWl0ZWQgZGF0YSBjb252ZXJ0ZWQgdG8gVVRGLTggdGV4dC5cbiAgICovXG4gIHN0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUodGhpcy5ieXRlcygpKTtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgZXh0ZW5zaW9uIHVzaW5nIHRoZSBnaXZlbiBydW50aW1lLlxuICovXG5mdW5jdGlvbiBtYWtlRXh0ZW5zaW9uKHJ1bnRpbWUsIHR5cGVOYW1lLCBleHRlbmRlZSwgZmllbGQpIHtcbiAgbGV0IGZpO1xuICByZXR1cm4ge1xuICAgIHR5cGVOYW1lLFxuICAgIGV4dGVuZGVlLFxuICAgIGdldCBmaWVsZCgpIHtcbiAgICAgIGlmICghZmkpIHtcbiAgICAgICAgY29uc3QgaSA9IHR5cGVvZiBmaWVsZCA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZCgpIDogZmllbGQ7XG4gICAgICAgIGkubmFtZSA9IHR5cGVOYW1lLnNwbGl0KFwiLlwiKS5wb3AoKTtcbiAgICAgICAgaS5qc29uTmFtZSA9IFwiW1wiLmNvbmNhdCh0eXBlTmFtZSwgXCJdXCIpO1xuICAgICAgICBmaSA9IHJ1bnRpbWUudXRpbC5uZXdGaWVsZExpc3QoW2ldKS5saXN0KClbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gZmk7XG4gICAgfSxcbiAgICBydW50aW1lXG4gIH07XG59XG4vKipcbiAqIENyZWF0ZSBhIGNvbnRhaW5lciB0aGF0IGFsbG93cyB1cyB0byByZWFkIGV4dGVuc2lvbiBmaWVsZHMgaW50byBpdCB3aXRoIHRoZVxuICogc2FtZSBsb2dpYyBhcyByZWd1bGFyIGZpZWxkcy5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXh0ZW5zaW9uQ29udGFpbmVyKGV4dGVuc2lvbikge1xuICBjb25zdCBsb2NhbE5hbWUgPSBleHRlbnNpb24uZmllbGQubG9jYWxOYW1lO1xuICBjb25zdCBjb250YWluZXIgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBjb250YWluZXJbbG9jYWxOYW1lXSA9IGluaXRFeHRlbnNpb25GaWVsZChleHRlbnNpb24pO1xuICByZXR1cm4gW2NvbnRhaW5lciwgKCkgPT4gY29udGFpbmVyW2xvY2FsTmFtZV1dO1xufVxuZnVuY3Rpb24gaW5pdEV4dGVuc2lvbkZpZWxkKGV4dCkge1xuICBjb25zdCBmaWVsZCA9IGV4dC5maWVsZDtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChmaWVsZC5kZWZhdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gZmllbGQuZGVmYXVsdDtcbiAgfVxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGZpZWxkLlQudmFsdWVzWzBdLm5vO1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIHJldHVybiBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVCwgZmllbGQuTCk7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jYXNlLWRlY2xhcmF0aW9uc1xuICAgICAgY29uc3QgVCA9IGZpZWxkLlQsXG4gICAgICAgIHZhbHVlID0gbmV3IFQoKTtcbiAgICAgIHJldHVybiBULmZpZWxkV3JhcHBlciA/IFQuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKHZhbHVlKSA6IHZhbHVlO1xuICAgIGNhc2UgXCJtYXBcIjpcbiAgICAgIHRocm93IFwibWFwIGZpZWxkcyBhcmUgbm90IGFsbG93ZWQgdG8gYmUgZXh0ZW5zaW9uc1wiO1xuICB9XG59XG4vKipcbiAqIEhlbHBlciB0byBmaWx0ZXIgdW5rbm93biBmaWVsZHMsIG9wdGltaXplZCBiYXNlZCBvbiBmaWVsZCB0eXBlLlxuICovXG5mdW5jdGlvbiBmaWx0ZXJVbmtub3duRmllbGRzKHVua25vd25GaWVsZHMsIGZpZWxkKSB7XG4gIGlmICghZmllbGQucmVwZWF0ZWQgJiYgKGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgfHwgZmllbGQua2luZCA9PSBcInNjYWxhclwiKSkge1xuICAgIC8vIHNpbmd1bGFyIHNjYWxhciBmaWVsZHMgZG8gbm90IG1lcmdlLCB3ZSBwaWNrIHRoZSBsYXN0XG4gICAgZm9yIChsZXQgaSA9IHVua25vd25GaWVsZHMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGlmICh1bmtub3duRmllbGRzW2ldLm5vID09IGZpZWxkLm5vKSB7XG4gICAgICAgIHJldHVybiBbdW5rbm93bkZpZWxkc1tpXV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gdW5rbm93bkZpZWxkcy5maWx0ZXIodWYgPT4gdWYubm8gPT09IGZpZWxkLm5vKTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudCwgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVubmVjZXNzYXJ5LWNvbmRpdGlvbiwgcHJlZmVyLWNvbnN0ICovXG4vLyBsb29rdXAgdGFibGUgZnJvbSBiYXNlNjQgY2hhcmFjdGVyIHRvIGJ5dGVcbmxldCBlbmNUYWJsZSA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrL1wiLnNwbGl0KFwiXCIpO1xuLy8gbG9va3VwIHRhYmxlIGZyb20gYmFzZTY0IGNoYXJhY3RlciAqY29kZSogdG8gYnl0ZSBiZWNhdXNlIGxvb2t1cCBieSBudW1iZXIgaXMgZmFzdFxubGV0IGRlY1RhYmxlID0gW107XG5mb3IgKGxldCBpID0gMDsgaSA8IGVuY1RhYmxlLmxlbmd0aDsgaSsrKSBkZWNUYWJsZVtlbmNUYWJsZVtpXS5jaGFyQ29kZUF0KDApXSA9IGk7XG4vLyBzdXBwb3J0IGJhc2U2NHVybCB2YXJpYW50c1xuZGVjVGFibGVbXCItXCIuY2hhckNvZGVBdCgwKV0gPSBlbmNUYWJsZS5pbmRleE9mKFwiK1wiKTtcbmRlY1RhYmxlW1wiX1wiLmNoYXJDb2RlQXQoMCldID0gZW5jVGFibGUuaW5kZXhPZihcIi9cIik7XG5jb25zdCBwcm90b0Jhc2U2NCA9IHtcbiAgLyoqXG4gICAqIERlY29kZXMgYSBiYXNlNjQgc3RyaW5nIHRvIGEgYnl0ZSBhcnJheS5cbiAgICpcbiAgICogLSBpZ25vcmVzIHdoaXRlLXNwYWNlLCBpbmNsdWRpbmcgbGluZSBicmVha3MgYW5kIHRhYnNcbiAgICogLSBhbGxvd3MgaW5uZXIgcGFkZGluZyAoY2FuIGRlY29kZSBjb25jYXRlbmF0ZWQgYmFzZTY0IHN0cmluZ3MpXG4gICAqIC0gZG9lcyBub3QgcmVxdWlyZSBwYWRkaW5nXG4gICAqIC0gdW5kZXJzdGFuZHMgYmFzZTY0dXJsIGVuY29kaW5nOlxuICAgKiAgIFwiLVwiIGluc3RlYWQgb2YgXCIrXCIsXG4gICAqICAgXCJfXCIgaW5zdGVhZCBvZiBcIi9cIixcbiAgICogICBubyBwYWRkaW5nXG4gICAqL1xuICBkZWMoYmFzZTY0U3RyKSB7XG4gICAgLy8gZXN0aW1hdGUgYnl0ZSBzaXplLCBub3QgYWNjb3VudGluZyBmb3IgaW5uZXIgcGFkZGluZyBhbmQgd2hpdGVzcGFjZVxuICAgIGxldCBlcyA9IGJhc2U2NFN0ci5sZW5ndGggKiAzIC8gNDtcbiAgICBpZiAoYmFzZTY0U3RyW2Jhc2U2NFN0ci5sZW5ndGggLSAyXSA9PSBcIj1cIikgZXMgLT0gMjtlbHNlIGlmIChiYXNlNjRTdHJbYmFzZTY0U3RyLmxlbmd0aCAtIDFdID09IFwiPVwiKSBlcyAtPSAxO1xuICAgIGxldCBieXRlcyA9IG5ldyBVaW50OEFycmF5KGVzKSxcbiAgICAgIGJ5dGVQb3MgPSAwLFxuICAgICAgLy8gcG9zaXRpb24gaW4gYnl0ZSBhcnJheVxuICAgICAgZ3JvdXBQb3MgPSAwLFxuICAgICAgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICBiLFxuICAgICAgLy8gY3VycmVudCBieXRlXG4gICAgICBwID0gMDsgLy8gcHJldmlvdXMgYnl0ZVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmFzZTY0U3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiID0gZGVjVGFibGVbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldO1xuICAgICAgaWYgKGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzd2l0Y2ggKGJhc2U2NFN0cltpXSkge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmUgVFM3MDI5OiBGYWxsdGhyb3VnaCBjYXNlIGluIHN3aXRjaFxuICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICBncm91cFBvcyA9IDA7XG4gICAgICAgICAgLy8gcmVzZXQgc3RhdGUgd2hlbiBwYWRkaW5nIGZvdW5kXG4gICAgICAgICAgLy8gQHRzLWlnbm9yZSBUUzcwMjk6IEZhbGx0aHJvdWdoIGNhc2UgaW4gc3dpdGNoXG4gICAgICAgICAgY2FzZSBcIlxcblwiOlxuICAgICAgICAgIGNhc2UgXCJcXHJcIjpcbiAgICAgICAgICBjYXNlIFwiXFx0XCI6XG4gICAgICAgICAgY2FzZSBcIiBcIjpcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIC8vIHNraXAgd2hpdGUtc3BhY2UsIGFuZCBwYWRkaW5nXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IEVycm9yKFwiaW52YWxpZCBiYXNlNjQgc3RyaW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgc3dpdGNoIChncm91cFBvcykge1xuICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IHAgPDwgMiB8IChiICYgNDgpID4+IDQ7XG4gICAgICAgICAgcCA9IGI7XG4gICAgICAgICAgZ3JvdXBQb3MgPSAyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgYnl0ZXNbYnl0ZVBvcysrXSA9IChwICYgMTUpIDw8IDQgfCAoYiAmIDYwKSA+PiAyO1xuICAgICAgICAgIHAgPSBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIGJ5dGVzW2J5dGVQb3MrK10gPSAocCAmIDMpIDw8IDYgfCBiO1xuICAgICAgICAgIGdyb3VwUG9zID0gMDtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGdyb3VwUG9zID09IDEpIHRocm93IEVycm9yKFwiaW52YWxpZCBiYXNlNjQgc3RyaW5nLlwiKTtcbiAgICByZXR1cm4gYnl0ZXMuc3ViYXJyYXkoMCwgYnl0ZVBvcyk7XG4gIH0sXG4gIC8qKlxuICAgKiBFbmNvZGUgYSBieXRlIGFycmF5IHRvIGEgYmFzZTY0IHN0cmluZy5cbiAgICovXG4gIGVuYyhieXRlcykge1xuICAgIGxldCBiYXNlNjQgPSBcIlwiLFxuICAgICAgZ3JvdXBQb3MgPSAwLFxuICAgICAgLy8gcG9zaXRpb24gaW4gYmFzZTY0IGdyb3VwXG4gICAgICBiLFxuICAgICAgLy8gY3VycmVudCBieXRlXG4gICAgICBwID0gMDsgLy8gY2Fycnkgb3ZlciBmcm9tIHByZXZpb3VzIGJ5dGVcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBiID0gYnl0ZXNbaV07XG4gICAgICBzd2l0Y2ggKGdyb3VwUG9zKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbYiA+PiAyXTtcbiAgICAgICAgICBwID0gKGIgJiAzKSA8PCA0O1xuICAgICAgICAgIGdyb3VwUG9zID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwIHwgYiA+PiA0XTtcbiAgICAgICAgICBwID0gKGIgJiAxNSkgPDwgMjtcbiAgICAgICAgICBncm91cFBvcyA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBiYXNlNjQgKz0gZW5jVGFibGVbcCB8IGIgPj4gNl07XG4gICAgICAgICAgYmFzZTY0ICs9IGVuY1RhYmxlW2IgJiA2M107XG4gICAgICAgICAgZ3JvdXBQb3MgPSAwO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBhZGQgb3V0cHV0IHBhZGRpbmdcbiAgICBpZiAoZ3JvdXBQb3MpIHtcbiAgICAgIGJhc2U2NCArPSBlbmNUYWJsZVtwXTtcbiAgICAgIGJhc2U2NCArPSBcIj1cIjtcbiAgICAgIGlmIChncm91cFBvcyA9PSAxKSBiYXNlNjQgKz0gXCI9XCI7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNjQ7XG4gIH1cbn07XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHJpZXZlIGFuIGV4dGVuc2lvbiB2YWx1ZSBmcm9tIGEgbWVzc2FnZS5cbiAqXG4gKiBUaGUgZnVuY3Rpb24gbmV2ZXIgcmV0dXJucyB1bmRlZmluZWQuIFVzZSBoYXNFeHRlbnNpb24oKSB0byBjaGVjayB3aGV0aGVyIGFuXG4gKiBleHRlbnNpb24gaXMgc2V0LiBJZiB0aGUgZXh0ZW5zaW9uIGlzIG5vdCBzZXQsIHRoaXMgZnVuY3Rpb24gcmV0dXJucyB0aGVcbiAqIGRlZmF1bHQgdmFsdWUgKGlmIG9uZSB3YXMgc3BlY2lmaWVkIGluIHRoZSBwcm90b2J1ZiBzb3VyY2UpLCBvciB0aGUgemVybyB2YWx1ZVxuICogKGZvciBleGFtcGxlIGAwYCBmb3IgbnVtZXJpYyB0eXBlcywgYFtdYCBmb3IgcmVwZWF0ZWQgZXh0ZW5zaW9uIGZpZWxkcywgYW5kXG4gKiBhbiBlbXB0eSBtZXNzYWdlIGluc3RhbmNlIGZvciBtZXNzYWdlIGZpZWxkcykuXG4gKlxuICogRXh0ZW5zaW9ucyBhcmUgc3RvcmVkIGFzIHVua25vd24gZmllbGRzIG9uIGEgbWVzc2FnZS4gVG8gbXV0YXRlIGFuIGV4dGVuc2lvblxuICogdmFsdWUsIG1ha2Ugc3VyZSB0byBzdG9yZSB0aGUgbmV3IHZhbHVlIHdpdGggc2V0RXh0ZW5zaW9uKCkgYWZ0ZXIgbXV0YXRpbmcuXG4gKlxuICogSWYgdGhlIGV4dGVuc2lvbiBkb2VzIG5vdCBleHRlbmQgdGhlIGdpdmVuIG1lc3NhZ2UsIGFuIGVycm9yIGlzIHJhaXNlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbiwgb3B0aW9ucykge1xuICBhc3NlcnRFeHRlbmRlZShleHRlbnNpb24sIG1lc3NhZ2UpO1xuICBjb25zdCBvcHQgPSBleHRlbnNpb24ucnVudGltZS5iaW4ubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCB1ZnMgPSBmaWx0ZXJVbmtub3duRmllbGRzKG1lc3NhZ2UuZ2V0VHlwZSgpLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpLCBleHRlbnNpb24uZmllbGQpO1xuICBjb25zdCBbY29udGFpbmVyLCBnZXRdID0gY3JlYXRlRXh0ZW5zaW9uQ29udGFpbmVyKGV4dGVuc2lvbik7XG4gIGZvciAoY29uc3QgdWYgb2YgdWZzKSB7XG4gICAgZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLnJlYWRGaWVsZChjb250YWluZXIsIG9wdC5yZWFkZXJGYWN0b3J5KHVmLmRhdGEpLCBleHRlbnNpb24uZmllbGQsIHVmLndpcmVUeXBlLCBvcHQpO1xuICB9XG4gIHJldHVybiBnZXQoKTtcbn1cbi8qKlxuICogU2V0IGFuIGV4dGVuc2lvbiB2YWx1ZSBvbiBhIG1lc3NhZ2UuIElmIHRoZSBtZXNzYWdlIGFscmVhZHkgaGFzIGEgdmFsdWUgZm9yXG4gKiB0aGlzIGV4dGVuc2lvbiwgdGhlIHZhbHVlIGlzIHJlcGxhY2VkLlxuICpcbiAqIElmIHRoZSBleHRlbnNpb24gZG9lcyBub3QgZXh0ZW5kIHRoZSBnaXZlbiBtZXNzYWdlLCBhbiBlcnJvciBpcyByYWlzZWQuXG4gKi9cbmZ1bmN0aW9uIHNldEV4dGVuc2lvbihtZXNzYWdlLCBleHRlbnNpb24sIHZhbHVlLCBvcHRpb25zKSB7XG4gIGFzc2VydEV4dGVuZGVlKGV4dGVuc2lvbiwgbWVzc2FnZSk7XG4gIGNvbnN0IHJlYWRPcHQgPSBleHRlbnNpb24ucnVudGltZS5iaW4ubWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpO1xuICBjb25zdCB3cml0ZU9wdCA9IGV4dGVuc2lvbi5ydW50aW1lLmJpbi5tYWtlV3JpdGVPcHRpb25zKG9wdGlvbnMpO1xuICBpZiAoaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dGVuc2lvbikpIHtcbiAgICBjb25zdCB1ZnMgPSBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5saXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKS5maWx0ZXIodWYgPT4gdWYubm8gIT0gZXh0ZW5zaW9uLmZpZWxkLm5vKTtcbiAgICBtZXNzYWdlLmdldFR5cGUoKS5ydW50aW1lLmJpbi5kaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKTtcbiAgICBmb3IgKGNvbnN0IHVmIG9mIHVmcykge1xuICAgICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQobWVzc2FnZSwgdWYubm8sIHVmLndpcmVUeXBlLCB1Zi5kYXRhKTtcbiAgICB9XG4gIH1cbiAgY29uc3Qgd3JpdGVyID0gd3JpdGVPcHQud3JpdGVyRmFjdG9yeSgpO1xuICBsZXQgZiA9IGV4dGVuc2lvbi5maWVsZDtcbiAgLy8gSW1wbGljaXQgcHJlc2VuY2UgZG9lcyBub3QgYXBwbHkgdG8gZXh0ZW5zaW9ucywgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9wcm90b2NvbGJ1ZmZlcnMvcHJvdG9idWYvaXNzdWVzLzgyMzRcbiAgLy8gV2UgcGF0Y2ggdGhlIGZpZWxkIGluZm8gdG8gdXNlIGV4cGxpY2l0IHByZXNlbmNlOlxuICBpZiAoIWYub3B0ICYmICFmLnJlcGVhdGVkICYmIChmLmtpbmQgPT0gXCJlbnVtXCIgfHwgZi5raW5kID09IFwic2NhbGFyXCIpKSB7XG4gICAgZiA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZXh0ZW5zaW9uLmZpZWxkKSwge1xuICAgICAgb3B0OiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgZXh0ZW5zaW9uLnJ1bnRpbWUuYmluLndyaXRlRmllbGQoZiwgdmFsdWUsIHdyaXRlciwgd3JpdGVPcHQpO1xuICBjb25zdCByZWFkZXIgPSByZWFkT3B0LnJlYWRlckZhY3Rvcnkod3JpdGVyLmZpbmlzaCgpKTtcbiAgd2hpbGUgKHJlYWRlci5wb3MgPCByZWFkZXIubGVuKSB7XG4gICAgY29uc3QgW25vLCB3aXJlVHlwZV0gPSByZWFkZXIudGFnKCk7XG4gICAgY29uc3QgZGF0YSA9IHJlYWRlci5za2lwKHdpcmVUeXBlLCBubyk7XG4gICAgbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW4ub25Vbmtub3duRmllbGQobWVzc2FnZSwgbm8sIHdpcmVUeXBlLCBkYXRhKTtcbiAgfVxufVxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIGFuIGV4dGVuc2lvbiBpcyBzZXQgb24gYSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBoYXNFeHRlbnNpb24obWVzc2FnZSwgZXh0ZW5zaW9uKSB7XG4gIGNvbnN0IG1lc3NhZ2VUeXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gIHJldHVybiBleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT09IG1lc3NhZ2VUeXBlLnR5cGVOYW1lICYmICEhbWVzc2FnZVR5cGUucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkuZmluZCh1ZiA9PiB1Zi5ubyA9PSBleHRlbnNpb24uZmllbGQubm8pO1xufVxuZnVuY3Rpb24gYXNzZXJ0RXh0ZW5kZWUoZXh0ZW5zaW9uLCBtZXNzYWdlKSB7XG4gIGFzc2VydChleHRlbnNpb24uZXh0ZW5kZWUudHlwZU5hbWUgPT0gbWVzc2FnZS5nZXRUeXBlKCkudHlwZU5hbWUsIFwiZXh0ZW5zaW9uIFwiLmNvbmNhdChleHRlbnNpb24udHlwZU5hbWUsIFwiIGNhbiBvbmx5IGJlIGFwcGxpZWQgdG8gbWVzc2FnZSBcIikuY29uY2F0KGV4dGVuc2lvbi5leHRlbmRlZS50eXBlTmFtZSkpO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGZpZWxkIGlzIHNldC5cbiAqL1xuZnVuY3Rpb24gaXNGaWVsZFNldChmaWVsZCwgdGFyZ2V0KSB7XG4gIGNvbnN0IGxvY2FsTmFtZSA9IGZpZWxkLmxvY2FsTmFtZTtcbiAgaWYgKGZpZWxkLnJlcGVhdGVkKSB7XG4gICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdLmxlbmd0aCA+IDA7XG4gIH1cbiAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgcmV0dXJuIHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdLmNhc2UgPT09IGxvY2FsTmFtZTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3NcbiAgfVxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIGlmIChmaWVsZC5vcHQgfHwgZmllbGQucmVxKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IHByZXNlbmNlXG4gICAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgLy8gaW1wbGljaXQgcHJlc2VuY2VcbiAgICAgIGlmIChmaWVsZC5raW5kID09IFwiZW51bVwiKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRbbG9jYWxOYW1lXSAhPT0gZmllbGQuVC52YWx1ZXNbMF0ubm87XG4gICAgICB9XG4gICAgICByZXR1cm4gIWlzU2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlQsIHRhcmdldFtsb2NhbE5hbWVdKTtcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgcmV0dXJuIHRhcmdldFtsb2NhbE5hbWVdICE9PSB1bmRlZmluZWQ7XG4gICAgY2FzZSBcIm1hcFwiOlxuICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRhcmdldFtsb2NhbE5hbWVdKS5sZW5ndGggPiAwO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudFxuICB9XG59XG4vKipcbiAqIFJlc2V0cyB0aGUgZmllbGQsIHNvIHRoYXQgaXNGaWVsZFNldCgpIHdpbGwgcmV0dXJuIGZhbHNlLlxuICovXG5mdW5jdGlvbiBjbGVhckZpZWxkKGZpZWxkLCB0YXJnZXQpIHtcbiAgY29uc3QgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICBjb25zdCBpbXBsaWNpdFByZXNlbmNlID0gIWZpZWxkLm9wdCAmJiAhZmllbGQucmVxO1xuICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IFtdO1xuICB9IGVsc2UgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgdGFyZ2V0W2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0gPSB7XG4gICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgY2FzZSBcIm1hcFwiOlxuICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHt9O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gaW1wbGljaXRQcmVzZW5jZSA/IGZpZWxkLlQudmFsdWVzWzBdLm5vIDogdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBpbXBsaWNpdFByZXNlbmNlID8gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLlQsIGZpZWxkLkwpIDogdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gdW5kZWZpbmVkO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQ2hlY2sgd2hldGhlciB0aGUgZ2l2ZW4gb2JqZWN0IGlzIGFueSBzdWJ0eXBlIG9mIE1lc3NhZ2Ugb3IgaXMgYSBzcGVjaWZpY1xuICogTWVzc2FnZSBieSBwYXNzaW5nIHRoZSB0eXBlLlxuICpcbiAqIEp1c3QgbGlrZSBgaW5zdGFuY2VvZmAsIGBpc01lc3NhZ2VgIG5hcnJvd3MgdGhlIHR5cGUuIFRoZSBhZHZhbnRhZ2Ugb2ZcbiAqIGBpc01lc3NhZ2VgIGlzIHRoYXQgaXQgY29tcGFyZXMgaWRlbnRpdHkgYnkgdGhlIG1lc3NhZ2UgdHlwZSBuYW1lLCBub3QgYnlcbiAqIGNsYXNzIGlkZW50aXR5LiBUaGlzIG1ha2VzIGl0IHJvYnVzdCBhZ2FpbnN0IHRoZSBkdWFsIHBhY2thZ2UgaGF6YXJkIGFuZFxuICogc2ltaWxhciBzaXR1YXRpb25zLCB3aGVyZSB0aGUgc2FtZSBtZXNzYWdlIGlzIGR1cGxpY2F0ZWQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBpcyBfbW9zdGx5XyBlcXVpdmFsZW50IHRvIHRoZSBgaW5zdGFuY2VvZmAgb3BlcmF0b3IuIEZvclxuICogZXhhbXBsZSwgYGlzTWVzc2FnZShmb28sIE15TWVzc2FnZSlgIGlzIHRoZSBzYW1lIGFzIGBmb28gaW5zdGFuY2VvZiBNeU1lc3NhZ2VgLFxuICogYW5kIGBpc01lc3NhZ2UoZm9vKWAgaXMgdGhlIHNhbWUgYXMgYGZvbyBpbnN0YW5jZW9mIE1lc3NhZ2VgLiBJbiBtb3N0IGNhc2VzLFxuICogYGlzTWVzc2FnZWAgc2hvdWxkIGJlIHByZWZlcnJlZCBvdmVyIGBpbnN0YW5jZW9mYC5cbiAqXG4gKiBIb3dldmVyLCBkdWUgdG8gdGhlIGZhY3QgdGhhdCBgaXNNZXNzYWdlYCBkb2VzIG5vdCB1c2UgY2xhc3MgaWRlbnRpdHksIHRoZXJlXG4gKiBhcmUgc3VidGxlIGRpZmZlcmVuY2VzIGJldHdlZW4gdGhpcyBmdW5jdGlvbiBhbmQgYGluc3RhbmNlb2ZgLiBOb3RhYmx5LFxuICogY2FsbGluZyBgaXNNZXNzYWdlYCBvbiBhbiBleHBsaWNpdCB0eXBlIG9mIE1lc3NhZ2Ugd2lsbCByZXR1cm4gZmFsc2UuXG4gKi9cbmZ1bmN0aW9uIGlzTWVzc2FnZShhcmcsIHR5cGUpIHtcbiAgaWYgKGFyZyA9PT0gbnVsbCB8fCB0eXBlb2YgYXJnICE9IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgaWYgKCFPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhNZXNzYWdlLnByb3RvdHlwZSkuZXZlcnkobSA9PiBtIGluIGFyZyAmJiB0eXBlb2YgYXJnW21dID09IFwiZnVuY3Rpb25cIikpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgY29uc3QgYWN0dWFsVHlwZSA9IGFyZy5nZXRUeXBlKCk7XG4gIGlmIChhY3R1YWxUeXBlID09PSBudWxsIHx8IHR5cGVvZiBhY3R1YWxUeXBlICE9IFwiZnVuY3Rpb25cIiB8fCAhKFwidHlwZU5hbWVcIiBpbiBhY3R1YWxUeXBlKSB8fCB0eXBlb2YgYWN0dWFsVHlwZS50eXBlTmFtZSAhPSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlID09PSB1bmRlZmluZWQgPyB0cnVlIDogYWN0dWFsVHlwZS50eXBlTmFtZSA9PSB0eXBlLnR5cGVOYW1lO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyoqXG4gKiBXcmFwIGEgcHJpbWl0aXZlIG1lc3NhZ2UgZmllbGQgdmFsdWUgaW4gaXRzIGNvcnJlc3BvbmRpbmcgd3JhcHBlclxuICogbWVzc2FnZS4gVGhpcyBmdW5jdGlvbiBpcyBpZGVtcG90ZW50LlxuICovXG5mdW5jdGlvbiB3cmFwRmllbGQodHlwZSwgdmFsdWUpIHtcbiAgaWYgKGlzTWVzc2FnZSh2YWx1ZSkgfHwgIXR5cGUuZmllbGRXcmFwcGVyKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIHJldHVybiB0eXBlLmZpZWxkV3JhcHBlci53cmFwRmllbGQodmFsdWUpO1xufVxuKHtcbiAgXCJnb29nbGUucHJvdG9idWYuRG91YmxlVmFsdWVcIjogU2NhbGFyVHlwZS5ET1VCTEUsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkZsb2F0VmFsdWVcIjogU2NhbGFyVHlwZS5GTE9BVCxcbiAgXCJnb29nbGUucHJvdG9idWYuSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDY0LFxuICBcImdvb2dsZS5wcm90b2J1Zi5VSW50NjRWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQ2NCxcbiAgXCJnb29nbGUucHJvdG9idWYuSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLklOVDMyLFxuICBcImdvb2dsZS5wcm90b2J1Zi5VSW50MzJWYWx1ZVwiOiBTY2FsYXJUeXBlLlVJTlQzMixcbiAgXCJnb29nbGUucHJvdG9idWYuQm9vbFZhbHVlXCI6IFNjYWxhclR5cGUuQk9PTCxcbiAgXCJnb29nbGUucHJvdG9idWYuU3RyaW5nVmFsdWVcIjogU2NhbGFyVHlwZS5TVFJJTkcsXG4gIFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIjogU2NhbGFyVHlwZS5CWVRFU1xufSk7XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1jYXNlLWRlY2xhcmF0aW9ucyxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFyZ3VtZW50LEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLW1lbWJlci1hY2Nlc3MsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1jYWxsICovXG4vLyBEZWZhdWx0IG9wdGlvbnMgZm9yIHBhcnNpbmcgSlNPTi5cbmNvbnN0IGpzb25SZWFkRGVmYXVsdHMgPSB7XG4gIGlnbm9yZVVua25vd25GaWVsZHM6IGZhbHNlXG59O1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBzZXJpYWxpemluZyB0byBKU09OLlxuY29uc3QganNvbldyaXRlRGVmYXVsdHMgPSB7XG4gIGVtaXREZWZhdWx0VmFsdWVzOiBmYWxzZSxcbiAgZW51bUFzSW50ZWdlcjogZmFsc2UsXG4gIHVzZVByb3RvRmllbGROYW1lOiBmYWxzZSxcbiAgcHJldHR5U3BhY2VzOiAwXG59O1xuZnVuY3Rpb24gbWFrZVJlYWRPcHRpb25zJDEob3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucyA/IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwganNvblJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDoganNvblJlYWREZWZhdWx0cztcbn1cbmZ1bmN0aW9uIG1ha2VXcml0ZU9wdGlvbnMkMShvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBqc29uV3JpdGVEZWZhdWx0cyksIG9wdGlvbnMpIDoganNvbldyaXRlRGVmYXVsdHM7XG59XG5jb25zdCB0b2tlbk51bGwgPSBTeW1ib2woKTtcbmNvbnN0IHRva2VuSWdub3JlZFVua25vd25FbnVtID0gU3ltYm9sKCk7XG5mdW5jdGlvbiBtYWtlSnNvbkZvcm1hdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBtYWtlUmVhZE9wdGlvbnM6IG1ha2VSZWFkT3B0aW9ucyQxLFxuICAgIG1ha2VXcml0ZU9wdGlvbnM6IG1ha2VXcml0ZU9wdGlvbnMkMSxcbiAgICByZWFkTWVzc2FnZSh0eXBlLCBqc29uLCBvcHRpb25zLCBtZXNzYWdlKSB7XG4gICAgICBpZiAoanNvbiA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoanNvbikgfHwgdHlwZW9mIGpzb24gIT0gXCJvYmplY3RcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uKSkpO1xuICAgICAgfVxuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6IG5ldyB0eXBlKCk7XG4gICAgICBjb25zdCBvbmVvZlNlZW4gPSBuZXcgTWFwKCk7XG4gICAgICBjb25zdCByZWdpc3RyeSA9IG9wdGlvbnMudHlwZVJlZ2lzdHJ5O1xuICAgICAgZm9yIChjb25zdCBbanNvbktleSwganNvblZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhqc29uKSkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IHR5cGUuZmllbGRzLmZpbmRKc29uTmFtZShqc29uS2V5KTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgaWYgKGZpZWxkLm9uZW9mKSB7XG4gICAgICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgICAgICAgICAvLyBzZWUgY29uZm9ybWFuY2UgdGVzdCBSZXF1aXJlZC5Qcm90bzMuSnNvbklucHV0Lk9uZW9mRmllbGROdWxse0ZpcnN0LFNlY29uZH1cbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzZWVuID0gb25lb2ZTZWVuLmdldChmaWVsZC5vbmVvZik7XG4gICAgICAgICAgICBpZiAoc2VlbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIgZnJvbSBKU09OOiBtdWx0aXBsZSBrZXlzIGZvciBvbmVvZiBcXFwiXCIpLmNvbmNhdChmaWVsZC5vbmVvZi5uYW1lLCBcIlxcXCIgcHJlc2VudDogXFxcIlwiKS5jb25jYXQoc2VlbiwgXCJcXFwiLCBcXFwiXCIpLmNvbmNhdChqc29uS2V5LCBcIlxcXCJcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb25lb2ZTZWVuLnNldChmaWVsZC5vbmVvZiwganNvbktleSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlYWRGaWVsZCQxKG1lc3NhZ2UsIGpzb25WYWx1ZSwgZmllbGQsIG9wdGlvbnMsIHR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgIGlmICgocmVnaXN0cnkgPT09IG51bGwgfHwgcmVnaXN0cnkgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlZ2lzdHJ5LmZpbmRFeHRlbnNpb24pICYmIGpzb25LZXkuc3RhcnRzV2l0aChcIltcIikgJiYganNvbktleS5lbmRzV2l0aChcIl1cIikpIHtcbiAgICAgICAgICAgIGNvbnN0IGV4dCA9IHJlZ2lzdHJ5LmZpbmRFeHRlbnNpb24oanNvbktleS5zdWJzdHJpbmcoMSwganNvbktleS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICBpZiAoZXh0ICYmIGV4dC5leHRlbmRlZS50eXBlTmFtZSA9PSB0eXBlLnR5cGVOYW1lKSB7XG4gICAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY29uc3QgW2NvbnRhaW5lciwgZ2V0XSA9IGNyZWF0ZUV4dGVuc2lvbkNvbnRhaW5lcihleHQpO1xuICAgICAgICAgICAgICByZWFkRmllbGQkMShjb250YWluZXIsIGpzb25WYWx1ZSwgZXh0LmZpZWxkLCBvcHRpb25zLCBleHQpO1xuICAgICAgICAgICAgICAvLyBXZSBwYXNzIG9uIHRoZSBvcHRpb25zIGFzIEJpbmFyeVJlYWRPcHRpb25zL0JpbmFyeVdyaXRlT3B0aW9ucyxcbiAgICAgICAgICAgICAgLy8gc28gdGhhdCB1c2VycyBjYW4gYnJpbmcgdGhlaXIgb3duIGJpbmFyeSByZWFkZXIgYW5kIHdyaXRlciBmYWN0b3JpZXNcbiAgICAgICAgICAgICAgLy8gaWYgbmVjZXNzYXJ5LlxuICAgICAgICAgICAgICBzZXRFeHRlbnNpb24obWVzc2FnZSwgZXh0LCBnZXQoKSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghZm91bmQgJiYgIW9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBtZXNzYWdlIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IGtleSBcXFwiXCIpLmNvbmNhdChqc29uS2V5LCBcIlxcXCIgaXMgdW5rbm93blwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9LFxuICAgIHdyaXRlTWVzc2FnZShtZXNzYWdlLCBvcHRpb25zKSB7XG4gICAgICBjb25zdCB0eXBlID0gbWVzc2FnZS5nZXRUeXBlKCk7XG4gICAgICBjb25zdCBqc29uID0ge307XG4gICAgICBsZXQgZmllbGQ7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKGZpZWxkIG9mIHR5cGUuZmllbGRzLmJ5TnVtYmVyKCkpIHtcbiAgICAgICAgICBpZiAoIWlzRmllbGRTZXQoZmllbGQsIG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gICAgICAgICAgICBpZiAoZmllbGQucmVxKSB7XG4gICAgICAgICAgICAgIHRocm93IFwicmVxdWlyZWQgZmllbGQgbm90IHNldFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFjYW5FbWl0RmllbGREZWZhdWx0VmFsdWUoZmllbGQpKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLm9uZW9mID8gbWVzc2FnZVtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdLnZhbHVlIDogbWVzc2FnZVtmaWVsZC5sb2NhbE5hbWVdO1xuICAgICAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHdyaXRlRmllbGQkMShmaWVsZCwgdmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICAgIGlmIChqc29uVmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAganNvbltvcHRpb25zLnVzZVByb3RvRmllbGROYW1lID8gZmllbGQubmFtZSA6IGZpZWxkLmpzb25OYW1lXSA9IGpzb25WYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVnaXN0cnkgPSBvcHRpb25zLnR5cGVSZWdpc3RyeTtcbiAgICAgICAgaWYgKHJlZ2lzdHJ5ID09PSBudWxsIHx8IHJlZ2lzdHJ5ID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWdpc3RyeS5maW5kRXh0ZW5zaW9uRm9yKSB7XG4gICAgICAgICAgZm9yIChjb25zdCB1ZiBvZiB0eXBlLnJ1bnRpbWUuYmluLmxpc3RVbmtub3duRmllbGRzKG1lc3NhZ2UpKSB7XG4gICAgICAgICAgICBjb25zdCBleHQgPSByZWdpc3RyeS5maW5kRXh0ZW5zaW9uRm9yKHR5cGUudHlwZU5hbWUsIHVmLm5vKTtcbiAgICAgICAgICAgIGlmIChleHQgJiYgaGFzRXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCkpIHtcbiAgICAgICAgICAgICAgLy8gV2UgcGFzcyBvbiB0aGUgb3B0aW9ucyBhcyBCaW5hcnlSZWFkT3B0aW9ucywgc28gdGhhdCB1c2VycyBjYW4gYnJpbmcgdGhlaXIgb3duXG4gICAgICAgICAgICAgIC8vIGJpbmFyeSByZWFkZXIgZmFjdG9yeSBpZiBuZWNlc3NhcnkuXG4gICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZ2V0RXh0ZW5zaW9uKG1lc3NhZ2UsIGV4dCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgIGNvbnN0IGpzb25WYWx1ZSA9IHdyaXRlRmllbGQkMShleHQuZmllbGQsIHZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgaWYgKGpzb25WYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAganNvbltleHQuZmllbGQuanNvbk5hbWVdID0ganNvblZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IG0gPSBmaWVsZCA/IFwiY2Fubm90IGVuY29kZSBmaWVsZCBcIi5jb25jYXQodHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiB0byBKU09OXCIpIDogXCJjYW5ub3QgZW5jb2RlIG1lc3NhZ2UgXCIuY29uY2F0KHR5cGUudHlwZU5hbWUsIFwiIHRvIEpTT05cIik7XG4gICAgICAgIGNvbnN0IHIgPSBlIGluc3RhbmNlb2YgRXJyb3IgPyBlLm1lc3NhZ2UgOiBTdHJpbmcoZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtICsgKHIubGVuZ3RoID4gMCA/IFwiOiBcIi5jb25jYXQocikgOiBcIlwiKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICB9LFxuICAgIHJlYWRTY2FsYXIodHlwZSwganNvbiwgbG9uZ1R5cGUpIHtcbiAgICAgIC8vIFRoZSBzaWduYXR1cmUgb2Ygb3VyIGludGVybmFsIGZ1bmN0aW9uIGhhcyBjaGFuZ2VkLiBGb3IgYmFja3dhcmRzLVxuICAgICAgLy8gY29tcGF0aWJpbGl0eSwgd2Ugc3VwcG9ydCB0aGUgb2xkIGZvcm0gdGhhdCBpcyBwYXJ0IG9mIHRoZSBwdWJsaWMgQVBJXG4gICAgICAvLyB0aHJvdWdoIHRoZSBpbnRlcmZhY2UgSnNvbkZvcm1hdC5cbiAgICAgIHJldHVybiByZWFkU2NhbGFyJDEodHlwZSwganNvbiwgbG9uZ1R5cGUgIT09IG51bGwgJiYgbG9uZ1R5cGUgIT09IHZvaWQgMCA/IGxvbmdUeXBlIDogTG9uZ1R5cGUuQklHSU5ULCB0cnVlKTtcbiAgICB9LFxuICAgIHdyaXRlU2NhbGFyKHR5cGUsIHZhbHVlLCBlbWl0RGVmYXVsdFZhbHVlcykge1xuICAgICAgLy8gVGhlIHNpZ25hdHVyZSBvZiBvdXIgaW50ZXJuYWwgZnVuY3Rpb24gaGFzIGNoYW5nZWQuIEZvciBiYWNrd2FyZHMtXG4gICAgICAvLyBjb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2YgdGhlIHB1YmxpYyBBUElcbiAgICAgIC8vIHRocm91Z2ggdGhlIGludGVyZmFjZSBKc29uRm9ybWF0LlxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChlbWl0RGVmYXVsdFZhbHVlcyB8fCBpc1NjYWxhclplcm9WYWx1ZSh0eXBlLCB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyJDEodHlwZSwgdmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9LFxuICAgIGRlYnVnOiBkZWJ1Z0pzb25WYWx1ZVxuICB9O1xufVxuZnVuY3Rpb24gZGVidWdKc29uVmFsdWUoanNvbikge1xuICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBcIm51bGxcIjtcbiAgfVxuICBzd2l0Y2ggKHR5cGVvZiBqc29uKSB7XG4gICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoanNvbikgPyBcImFycmF5XCIgOiBcIm9iamVjdFwiO1xuICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgIHJldHVybiBqc29uLmxlbmd0aCA+IDEwMCA/IFwic3RyaW5nXCIgOiBcIlxcXCJcIi5jb25jYXQoanNvbi5zcGxpdCgnXCInKS5qb2luKCdcXFxcXCInKSwgXCJcXFwiXCIpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gU3RyaW5nKGpzb24pO1xuICB9XG59XG4vLyBSZWFkIGEgSlNPTiB2YWx1ZSBmb3IgYSBmaWVsZC5cbi8vIFRoZSBcInBhcmVudFR5cGVcIiBhcmd1bWVudCBpcyBvbmx5IHVzZWQgdG8gcHJvdmlkZSBjb250ZXh0IGluIGVycm9ycy5cbmZ1bmN0aW9uIHJlYWRGaWVsZCQxKHRhcmdldCwganNvblZhbHVlLCBmaWVsZCwgb3B0aW9ucywgcGFyZW50VHlwZSkge1xuICBsZXQgbG9jYWxOYW1lID0gZmllbGQubG9jYWxOYW1lO1xuICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICBhc3NlcnQoZmllbGQua2luZCAhPSBcIm1hcFwiKTtcbiAgICBpZiAoanNvblZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghQXJyYXkuaXNBcnJheShqc29uVmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKSk7XG4gICAgfVxuICAgIGNvbnN0IHRhcmdldEFycmF5ID0gdGFyZ2V0W2xvY2FsTmFtZV07XG4gICAgZm9yIChjb25zdCBqc29uSXRlbSBvZiBqc29uVmFsdWUpIHtcbiAgICAgIGlmIChqc29uSXRlbSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZGVjb2RlIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uSXRlbSkpKTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgIHRhcmdldEFycmF5LnB1c2goZmllbGQuVC5mcm9tSnNvbihqc29uSXRlbSwgb3B0aW9ucykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgIGNvbnN0IGVudW1WYWx1ZSA9IHJlYWRFbnVtKGZpZWxkLlQsIGpzb25JdGVtLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIHRydWUpO1xuICAgICAgICAgIGlmIChlbnVtVmFsdWUgIT09IHRva2VuSWdub3JlZFVua25vd25FbnVtKSB7XG4gICAgICAgICAgICB0YXJnZXRBcnJheS5wdXNoKGVudW1WYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRhcmdldEFycmF5LnB1c2gocmVhZFNjYWxhciQxKGZpZWxkLlQsIGpzb25JdGVtLCBmaWVsZC5MLCB0cnVlKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25JdGVtKSk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yICYmIGUubWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoZmllbGQua2luZCA9PSBcIm1hcFwiKSB7XG4gICAgaWYgKGpzb25WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGpzb25WYWx1ZSAhPSBcIm9iamVjdFwiIHx8IEFycmF5LmlzQXJyYXkoanNvblZhbHVlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSkpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRNYXAgPSB0YXJnZXRbbG9jYWxOYW1lXTtcbiAgICBmb3IgKGNvbnN0IFtqc29uTWFwS2V5LCBqc29uTWFwVmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGpzb25WYWx1ZSkpIHtcbiAgICAgIGlmIChqc29uTWFwVmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IG1hcCB2YWx1ZSBudWxsXCIpKTtcbiAgICAgIH1cbiAgICAgIGxldCBrZXk7XG4gICAgICB0cnkge1xuICAgICAgICBrZXkgPSByZWFkTWFwS2V5KGZpZWxkLkssIGpzb25NYXBLZXkpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBtYXAga2V5IGZvciBmaWVsZCBcIi5jb25jYXQocGFyZW50VHlwZS50eXBlTmFtZSwgXCIuXCIpLmNvbmNhdChmaWVsZC5uYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvblZhbHVlKSk7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBtICs9IFwiOiBcIi5jb25jYXQoZS5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gZmllbGQuVi5ULmZyb21Kc29uKGpzb25NYXBWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgY29uc3QgZW51bVZhbHVlID0gcmVhZEVudW0oZmllbGQuVi5ULCBqc29uTWFwVmFsdWUsIG9wdGlvbnMuaWdub3JlVW5rbm93bkZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgaWYgKGVudW1WYWx1ZSAhPT0gdG9rZW5JZ25vcmVkVW5rbm93bkVudW0pIHtcbiAgICAgICAgICAgIHRhcmdldE1hcFtrZXldID0gZW51bVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0YXJnZXRNYXBba2V5XSA9IHJlYWRTY2FsYXIkMShmaWVsZC5WLlQsIGpzb25NYXBWYWx1ZSwgTG9uZ1R5cGUuQklHSU5ULCB0cnVlKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsZXQgbSA9IFwiY2Fubm90IGRlY29kZSBtYXAgdmFsdWUgZm9yIGZpZWxkIFwiLmNvbmNhdChwYXJlbnRUeXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIGZyb20gSlNPTjogXCIpLmNvbmNhdChkZWJ1Z0pzb25WYWx1ZShqc29uVmFsdWUpKTtcbiAgICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgbSArPSBcIjogXCIuY29uY2F0KGUubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoZmllbGQub25lb2YpIHtcbiAgICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdID0ge1xuICAgICAgICBjYXNlOiBsb2NhbE5hbWVcbiAgICAgIH07XG4gICAgICBsb2NhbE5hbWUgPSBcInZhbHVlXCI7XG4gICAgfVxuICAgIHN3aXRjaCAoZmllbGQua2luZCkge1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgY29uc3QgbWVzc2FnZVR5cGUgPSBmaWVsZC5UO1xuICAgICAgICBpZiAoanNvblZhbHVlID09PSBudWxsICYmIG1lc3NhZ2VUeXBlLnR5cGVOYW1lICE9IFwiZ29vZ2xlLnByb3RvYnVmLlZhbHVlXCIpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGN1cnJlbnRWYWx1ZSA9IHRhcmdldFtsb2NhbE5hbWVdO1xuICAgICAgICBpZiAoaXNNZXNzYWdlKGN1cnJlbnRWYWx1ZSkpIHtcbiAgICAgICAgICBjdXJyZW50VmFsdWUuZnJvbUpzb24oanNvblZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IGN1cnJlbnRWYWx1ZSA9IG1lc3NhZ2VUeXBlLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgaWYgKG1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlciAmJiAhZmllbGQub25lb2YpIHtcbiAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gbWVzc2FnZVR5cGUuZmllbGRXcmFwcGVyLnVud3JhcEZpZWxkKGN1cnJlbnRWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgY29uc3QgZW51bVZhbHVlID0gcmVhZEVudW0oZmllbGQuVCwganNvblZhbHVlLCBvcHRpb25zLmlnbm9yZVVua25vd25GaWVsZHMsIGZhbHNlKTtcbiAgICAgICAgc3dpdGNoIChlbnVtVmFsdWUpIHtcbiAgICAgICAgICBjYXNlIHRva2VuTnVsbDpcbiAgICAgICAgICAgIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIHRva2VuSWdub3JlZFVua25vd25FbnVtOlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gZW51bVZhbHVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGFyVmFsdWUgPSByZWFkU2NhbGFyJDEoZmllbGQuVCwganNvblZhbHVlLCBmaWVsZC5MLCBmYWxzZSk7XG4gICAgICAgICAgc3dpdGNoIChzY2FsYXJWYWx1ZSkge1xuICAgICAgICAgICAgY2FzZSB0b2tlbk51bGw6XG4gICAgICAgICAgICAgIGNsZWFyRmllbGQoZmllbGQsIHRhcmdldCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBzY2FsYXJWYWx1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgbGV0IG0gPSBcImNhbm5vdCBkZWNvZGUgZmllbGQgXCIuY29uY2F0KHBhcmVudFR5cGUudHlwZU5hbWUsIFwiLlwiKS5jb25jYXQoZmllbGQubmFtZSwgXCIgZnJvbSBKU09OOiBcIikuY29uY2F0KGRlYnVnSnNvblZhbHVlKGpzb25WYWx1ZSkpO1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG0gKz0gXCI6IFwiLmNvbmNhdChlLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWFkTWFwS2V5KHR5cGUsIGpzb24pIHtcbiAgaWYgKHR5cGUgPT09IFNjYWxhclR5cGUuQk9PTCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrXG4gICAgc3dpdGNoIChqc29uKSB7XG4gICAgICBjYXNlIFwidHJ1ZVwiOlxuICAgICAgICBqc29uID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZmFsc2VcIjpcbiAgICAgICAganNvbiA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlYWRTY2FsYXIkMSh0eXBlLCBqc29uLCBMb25nVHlwZS5CSUdJTlQsIHRydWUpLnRvU3RyaW5nKCk7XG59XG5mdW5jdGlvbiByZWFkU2NhbGFyJDEodHlwZSwganNvbiwgbG9uZ1R5cGUsIG51bGxBc1plcm9WYWx1ZSkge1xuICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgIGlmIChudWxsQXNaZXJvVmFsdWUpIHtcbiAgICAgIHJldHVybiBzY2FsYXJaZXJvVmFsdWUodHlwZSwgbG9uZ1R5cGUpO1xuICAgIH1cbiAgICByZXR1cm4gdG9rZW5OdWxsO1xuICB9XG4gIC8vIGV2ZXJ5IHZhbGlkIGNhc2UgaW4gdGhlIHN3aXRjaCBiZWxvdyByZXR1cm5zLCBhbmQgZXZlcnkgZmFsbFxuICAvLyB0aHJvdWdoIGlzIHJlZ2FyZGVkIGFzIGEgZmFpbHVyZS5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgLy8gZmxvYXQsIGRvdWJsZTogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgbnVtYmVyIG9yIG9uZSBvZiB0aGUgc3BlY2lhbCBzdHJpbmcgdmFsdWVzIFwiTmFOXCIsIFwiSW5maW5pdHlcIiwgYW5kIFwiLUluZmluaXR5XCIuXG4gICAgLy8gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuIEV4cG9uZW50IG5vdGF0aW9uIGlzIGFsc28gYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICBpZiAoanNvbiA9PT0gXCJOYU5cIikgcmV0dXJuIE51bWJlci5OYU47XG4gICAgICBpZiAoanNvbiA9PT0gXCJJbmZpbml0eVwiKSByZXR1cm4gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZO1xuICAgICAgaWYgKGpzb24gPT09IFwiLUluZmluaXR5XCIpIHJldHVybiBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgICBpZiAoanNvbiA9PT0gXCJcIikge1xuICAgICAgICAvLyBlbXB0eSBzdHJpbmcgaXMgbm90IGEgbnVtYmVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwic3RyaW5nXCIgJiYganNvbi50cmltKCkubGVuZ3RoICE9PSBqc29uLmxlbmd0aCkge1xuICAgICAgICAvLyBleHRyYSB3aGl0ZXNwYWNlXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJudW1iZXJcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNvbnN0IGZsb2F0ID0gTnVtYmVyKGpzb24pO1xuICAgICAgaWYgKE51bWJlci5pc05hTihmbG9hdCkpIHtcbiAgICAgICAgLy8gbm90IGEgbnVtYmVyXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoZmxvYXQpKSB7XG4gICAgICAgIC8vIGluZmluaXR5IGFuZCAtaW5maW5pdHkgYXJlIGhhbmRsZWQgYnkgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFib3ZlLCBzbyB0aGlzIGlzIGFuIGVycm9yXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGUgPT0gU2NhbGFyVHlwZS5GTE9BVCkgYXNzZXJ0RmxvYXQzMihmbG9hdCk7XG4gICAgICByZXR1cm4gZmxvYXQ7XG4gICAgLy8gaW50MzIsIGZpeGVkMzIsIHVpbnQzMjogSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBudW1iZXIuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNJTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgICAgbGV0IGludDMyO1xuICAgICAgaWYgKHR5cGVvZiBqc29uID09IFwibnVtYmVyXCIpIGludDMyID0ganNvbjtlbHNlIGlmICh0eXBlb2YganNvbiA9PSBcInN0cmluZ1wiICYmIGpzb24ubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoanNvbi50cmltKCkubGVuZ3RoID09PSBqc29uLmxlbmd0aCkgaW50MzIgPSBOdW1iZXIoanNvbik7XG4gICAgICB9XG4gICAgICBpZiAoaW50MzIgPT09IHVuZGVmaW5lZCkgYnJlYWs7XG4gICAgICBpZiAodHlwZSA9PSBTY2FsYXJUeXBlLlVJTlQzMiB8fCB0eXBlID09IFNjYWxhclR5cGUuRklYRUQzMikgYXNzZXJ0VUludDMyKGludDMyKTtlbHNlIGFzc2VydEludDMyKGludDMyKTtcbiAgICAgIHJldHVybiBpbnQzMjtcbiAgICAvLyBpbnQ2NCwgZml4ZWQ2NCwgdWludDY0OiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIHN0cmluZy4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgaWYgKHR5cGVvZiBqc29uICE9IFwibnVtYmVyXCIgJiYgdHlwZW9mIGpzb24gIT0gXCJzdHJpbmdcIikgYnJlYWs7XG4gICAgICBjb25zdCBsb25nID0gcHJvdG9JbnQ2NC5wYXJzZShqc29uKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIHJldHVybiBsb25nVHlwZSA/IGxvbmcudG9TdHJpbmcoKSA6IGxvbmc7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPSBcIm51bWJlclwiICYmIHR5cGVvZiBqc29uICE9IFwic3RyaW5nXCIpIGJyZWFrO1xuICAgICAgY29uc3QgdUxvbmcgPSBwcm90b0ludDY0LnVQYXJzZShqc29uKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIHJldHVybiBsb25nVHlwZSA/IHVMb25nLnRvU3RyaW5nKCkgOiB1TG9uZztcbiAgICAvLyBib29sOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgaWYgKHR5cGVvZiBqc29uICE9PSBcImJvb2xlYW5cIikgYnJlYWs7XG4gICAgICByZXR1cm4ganNvbjtcbiAgICAvLyBzdHJpbmc6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNUUklORzpcbiAgICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIEEgc3RyaW5nIG11c3QgYWx3YXlzIGNvbnRhaW4gVVRGLTggZW5jb2RlZCBvciA3LWJpdCBBU0NJSS5cbiAgICAgIC8vIFdlIHZhbGlkYXRlIHdpdGggZW5jb2RlVVJJQ29tcG9uZW50LCB3aGljaCBhcHBlYXJzIHRvIGJlIHRoZSBmYXN0ZXN0IHdpZGVseSBhdmFpbGFibGUgb3B0aW9uLlxuICAgICAgdHJ5IHtcbiAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KGpzb24pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIFVURjhcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4ganNvbjtcbiAgICAvLyBieXRlczogSlNPTiB2YWx1ZSB3aWxsIGJlIHRoZSBkYXRhIGVuY29kZWQgYXMgYSBzdHJpbmcgdXNpbmcgc3RhbmRhcmQgYmFzZTY0IGVuY29kaW5nIHdpdGggcGFkZGluZ3MuXG4gICAgLy8gRWl0aGVyIHN0YW5kYXJkIG9yIFVSTC1zYWZlIGJhc2U2NCBlbmNvZGluZyB3aXRoL3dpdGhvdXQgcGFkZGluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CWVRFUzpcbiAgICAgIGlmIChqc29uID09PSBcIlwiKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoMCk7XG4gICAgICBpZiAodHlwZW9mIGpzb24gIT09IFwic3RyaW5nXCIpIGJyZWFrO1xuICAgICAgcmV0dXJuIHByb3RvQmFzZTY0LmRlYyhqc29uKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoKTtcbn1cbmZ1bmN0aW9uIHJlYWRFbnVtKHR5cGUsIGpzb24sIGlnbm9yZVVua25vd25GaWVsZHMsIG51bGxBc1plcm9WYWx1ZSkge1xuICBpZiAoanNvbiA9PT0gbnVsbCkge1xuICAgIGlmICh0eXBlLnR5cGVOYW1lID09IFwiZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVwiKSB7XG4gICAgICByZXR1cm4gMDsgLy8gZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZS5OVUxMX1ZBTFVFID0gMFxuICAgIH1cbiAgICByZXR1cm4gbnVsbEFzWmVyb1ZhbHVlID8gdHlwZS52YWx1ZXNbMF0ubm8gOiB0b2tlbk51bGw7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zd2l0Y2gtZXhoYXVzdGl2ZW5lc3MtY2hlY2tcbiAgc3dpdGNoICh0eXBlb2YganNvbikge1xuICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGpzb24pKSB7XG4gICAgICAgIHJldHVybiBqc29uO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgY29uc3QgdmFsdWUgPSB0eXBlLmZpbmROYW1lKGpzb24pO1xuICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLm5vO1xuICAgICAgfVxuICAgICAgaWYgKGlnbm9yZVVua25vd25GaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHRva2VuSWdub3JlZFVua25vd25FbnVtO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBlbnVtIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIiBmcm9tIEpTT046IFwiKS5jb25jYXQoZGVidWdKc29uVmFsdWUoanNvbikpKTtcbn1cbi8vIERlY2lkZSB3aGV0aGVyIGFuIHVuc2V0IGZpZWxkIHNob3VsZCBiZSBlbWl0dGVkIHdpdGggSlNPTiB3cml0ZSBvcHRpb24gYGVtaXREZWZhdWx0VmFsdWVzYFxuZnVuY3Rpb24gY2FuRW1pdEZpZWxkRGVmYXVsdFZhbHVlKGZpZWxkKSB7XG4gIGlmIChmaWVsZC5yZXBlYXRlZCB8fCBmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICAvLyBtYXBzIGFyZSB7fSwgcmVwZWF0ZWQgZmllbGRzIGFyZSBbXVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChmaWVsZC5vbmVvZikge1xuICAgIC8vIG9uZW9mIGZpZWxkcyBhcmUgbmV2ZXIgZW1pdHRlZFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZmllbGQua2luZCA9PSBcIm1lc3NhZ2VcIikge1xuICAgIC8vIHNpbmd1bGFyIG1lc3NhZ2UgZmllbGQgYXJlIGFsbG93ZWQgdG8gZW1pdCBKU09OIG51bGwsIGJ1dCB3ZSBkbyBub3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICBpZiAoZmllbGQub3B0IHx8IGZpZWxkLnJlcSkge1xuICAgIC8vIHRoZSBmaWVsZCB1c2VzIGV4cGxpY2l0IHByZXNlbmNlLCBzbyB3ZSBjYW5ub3QgZW1pdCBhIHplcm8gdmFsdWVcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB3cml0ZUZpZWxkJDEoZmllbGQsIHZhbHVlLCBvcHRpb25zKSB7XG4gIGlmIChmaWVsZC5raW5kID09IFwibWFwXCIpIHtcbiAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCk7XG4gICAgY29uc3QganNvbk9iaiA9IHt9O1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh2YWx1ZSk7XG4gICAgc3dpdGNoIChmaWVsZC5WLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gd3JpdGVTY2FsYXIkMShmaWVsZC5WLlQsIGVudHJ5VmFsdWUpOyAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICBmb3IgKGNvbnN0IFtlbnRyeUtleSwgZW50cnlWYWx1ZV0gb2YgZW50cmllcykge1xuICAgICAgICAgIC8vIEpTT04gc3RhbmRhcmQgYWxsb3dzIG9ubHkgKGRvdWJsZSBxdW90ZWQpIHN0cmluZyBhcyBwcm9wZXJ0eSBrZXlcbiAgICAgICAgICBqc29uT2JqW2VudHJ5S2V5LnRvU3RyaW5nKCldID0gZW50cnlWYWx1ZS50b0pzb24ob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICBjb25zdCBlbnVtVHlwZSA9IGZpZWxkLlYuVDtcbiAgICAgICAgZm9yIChjb25zdCBbZW50cnlLZXksIGVudHJ5VmFsdWVdIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAvLyBKU09OIHN0YW5kYXJkIGFsbG93cyBvbmx5IChkb3VibGUgcXVvdGVkKSBzdHJpbmcgYXMgcHJvcGVydHkga2V5XG4gICAgICAgICAganNvbk9ialtlbnRyeUtleS50b1N0cmluZygpXSA9IHdyaXRlRW51bShlbnVtVHlwZSwgZW50cnlWYWx1ZSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMuZW1pdERlZmF1bHRWYWx1ZXMgfHwgZW50cmllcy5sZW5ndGggPiAwID8ganNvbk9iaiA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoZmllbGQucmVwZWF0ZWQpIHtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgIGNvbnN0IGpzb25BcnIgPSBbXTtcbiAgICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGpzb25BcnIucHVzaCh3cml0ZVNjYWxhciQxKGZpZWxkLlQsIHZhbHVlW2ldKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAganNvbkFyci5wdXNoKHdyaXRlRW51bShmaWVsZC5ULCB2YWx1ZVtpXSwgb3B0aW9ucy5lbnVtQXNJbnRlZ2VyKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAganNvbkFyci5wdXNoKHZhbHVlW2ldLnRvSnNvbihvcHRpb25zKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zLmVtaXREZWZhdWx0VmFsdWVzIHx8IGpzb25BcnIubGVuZ3RoID4gMCA/IGpzb25BcnIgOiB1bmRlZmluZWQ7XG4gIH1cbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgcmV0dXJuIHdyaXRlU2NhbGFyJDEoZmllbGQuVCwgdmFsdWUpO1xuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICByZXR1cm4gd3JpdGVFbnVtKGZpZWxkLlQsIHZhbHVlLCBvcHRpb25zLmVudW1Bc0ludGVnZXIpO1xuICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICByZXR1cm4gd3JhcEZpZWxkKGZpZWxkLlQsIHZhbHVlKS50b0pzb24ob3B0aW9ucyk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlRW51bSh0eXBlLCB2YWx1ZSwgZW51bUFzSW50ZWdlcikge1xuICB2YXIgX2E7XG4gIGFzc2VydCh0eXBlb2YgdmFsdWUgPT0gXCJudW1iZXJcIik7XG4gIGlmICh0eXBlLnR5cGVOYW1lID09IFwiZ29vZ2xlLnByb3RvYnVmLk51bGxWYWx1ZVwiKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGVudW1Bc0ludGVnZXIpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgY29uc3QgdmFsID0gdHlwZS5maW5kTnVtYmVyKHZhbHVlKTtcbiAgcmV0dXJuIChfYSA9IHZhbCA9PT0gbnVsbCB8fCB2YWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZhbC5uYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2YWx1ZTsgLy8gaWYgd2UgZG9uJ3Qga25vdyB0aGUgZW51bSB2YWx1ZSwganVzdCByZXR1cm4gdGhlIG51bWJlclxufVxuZnVuY3Rpb24gd3JpdGVTY2FsYXIkMSh0eXBlLCB2YWx1ZSkge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAvLyBpbnQzMiwgZml4ZWQzMiwgdWludDMyOiBKU09OIHZhbHVlIHdpbGwgYmUgYSBkZWNpbWFsIG51bWJlci4gRWl0aGVyIG51bWJlcnMgb3Igc3RyaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwibnVtYmVyXCIpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIC8vIGZsb2F0LCBkb3VibGU6IEpTT04gdmFsdWUgd2lsbCBiZSBhIG51bWJlciBvciBvbmUgb2YgdGhlIHNwZWNpYWwgc3RyaW5nIHZhbHVlcyBcIk5hTlwiLCBcIkluZmluaXR5XCIsIGFuZCBcIi1JbmZpbml0eVwiLlxuICAgIC8vIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLiBFeHBvbmVudCBub3RhdGlvbiBpcyBhbHNvIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5GTE9BVDpcbiAgICAvLyBhc3NlcnRGbG9hdDMyKHZhbHVlKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuRE9VQkxFOlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIGlmIChOdW1iZXIuaXNOYU4odmFsdWUpKSByZXR1cm4gXCJOYU5cIjtcbiAgICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyLlBPU0lUSVZFX0lORklOSVRZKSByZXR1cm4gXCJJbmZpbml0eVwiO1xuICAgICAgaWYgKHZhbHVlID09PSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFkpIHJldHVybiBcIi1JbmZpbml0eVwiO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIC8vIHN0cmluZzpcbiAgICBjYXNlIFNjYWxhclR5cGUuU1RSSU5HOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiKTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAvLyBib29sOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcImJvb2xlYW5cIik7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgLy8gSlNPTiB2YWx1ZSB3aWxsIGJlIGEgZGVjaW1hbCBzdHJpbmcuIEVpdGhlciBudW1iZXJzIG9yIHN0cmluZ3MgYXJlIGFjY2VwdGVkLlxuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UNjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLklOVDY0OlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQ2NDpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDY0OlxuICAgICAgYXNzZXJ0KHR5cGVvZiB2YWx1ZSA9PSBcImJpZ2ludFwiIHx8IHR5cGVvZiB2YWx1ZSA9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PSBcIm51bWJlclwiKTtcbiAgICAgIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuICAgIC8vIGJ5dGVzOiBKU09OIHZhbHVlIHdpbGwgYmUgdGhlIGRhdGEgZW5jb2RlZCBhcyBhIHN0cmluZyB1c2luZyBzdGFuZGFyZCBiYXNlNjQgZW5jb2Rpbmcgd2l0aCBwYWRkaW5ncy5cbiAgICAvLyBFaXRoZXIgc3RhbmRhcmQgb3IgVVJMLXNhZmUgYmFzZTY0IGVuY29kaW5nIHdpdGgvd2l0aG91dCBwYWRkaW5ncyBhcmUgYWNjZXB0ZWQuXG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgICAgYXNzZXJ0KHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSk7XG4gICAgICByZXR1cm4gcHJvdG9CYXNlNjQuZW5jKHZhbHVlKTtcbiAgfVxufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgcHJlZmVyLWNvbnN0LG5vLWNhc2UtZGVjbGFyYXRpb25zLEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnksQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hcmd1bWVudCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtY2FsbCxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLXJldHVybiAqL1xuY29uc3QgdW5rbm93bkZpZWxkc1N5bWJvbCA9IFN5bWJvbChcIkBidWZidWlsZC9wcm90b2J1Zi91bmtub3duLWZpZWxkc1wiKTtcbi8vIERlZmF1bHQgb3B0aW9ucyBmb3IgcGFyc2luZyBiaW5hcnkgZGF0YS5cbmNvbnN0IHJlYWREZWZhdWx0cyA9IHtcbiAgcmVhZFVua25vd25GaWVsZHM6IHRydWUsXG4gIHJlYWRlckZhY3Rvcnk6IGJ5dGVzID0+IG5ldyBCaW5hcnlSZWFkZXIoYnl0ZXMpXG59O1xuLy8gRGVmYXVsdCBvcHRpb25zIGZvciBzZXJpYWxpemluZyBiaW5hcnkgZGF0YS5cbmNvbnN0IHdyaXRlRGVmYXVsdHMgPSB7XG4gIHdyaXRlVW5rbm93bkZpZWxkczogdHJ1ZSxcbiAgd3JpdGVyRmFjdG9yeTogKCkgPT4gbmV3IEJpbmFyeVdyaXRlcigpXG59O1xuZnVuY3Rpb24gbWFrZVJlYWRPcHRpb25zKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG9wdGlvbnMgPyBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlYWREZWZhdWx0cyksIG9wdGlvbnMpIDogcmVhZERlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZVdyaXRlT3B0aW9ucyhvcHRpb25zKSB7XG4gIHJldHVybiBvcHRpb25zID8gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB3cml0ZURlZmF1bHRzKSwgb3B0aW9ucykgOiB3cml0ZURlZmF1bHRzO1xufVxuZnVuY3Rpb24gbWFrZUJpbmFyeUZvcm1hdCgpIHtcbiAgcmV0dXJuIHtcbiAgICBtYWtlUmVhZE9wdGlvbnMsXG4gICAgbWFrZVdyaXRlT3B0aW9ucyxcbiAgICBsaXN0VW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogW107XG4gICAgfSxcbiAgICBkaXNjYXJkVW5rbm93bkZpZWxkcyhtZXNzYWdlKSB7XG4gICAgICBkZWxldGUgbWVzc2FnZVt1bmtub3duRmllbGRzU3ltYm9sXTtcbiAgICB9LFxuICAgIHdyaXRlVW5rbm93bkZpZWxkcyhtZXNzYWdlLCB3cml0ZXIpIHtcbiAgICAgIGNvbnN0IG0gPSBtZXNzYWdlO1xuICAgICAgY29uc3QgYyA9IG1bdW5rbm93bkZpZWxkc1N5bWJvbF07XG4gICAgICBpZiAoYykge1xuICAgICAgICBmb3IgKGNvbnN0IGYgb2YgYykge1xuICAgICAgICAgIHdyaXRlci50YWcoZi5ubywgZi53aXJlVHlwZSkucmF3KGYuZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIG9uVW5rbm93bkZpZWxkKG1lc3NhZ2UsIG5vLCB3aXJlVHlwZSwgZGF0YSkge1xuICAgICAgY29uc3QgbSA9IG1lc3NhZ2U7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobVt1bmtub3duRmllbGRzU3ltYm9sXSkpIHtcbiAgICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXSA9IFtdO1xuICAgICAgfVxuICAgICAgbVt1bmtub3duRmllbGRzU3ltYm9sXS5wdXNoKHtcbiAgICAgICAgbm8sXG4gICAgICAgIHdpcmVUeXBlLFxuICAgICAgICBkYXRhXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHJlYWRNZXNzYWdlKG1lc3NhZ2UsIHJlYWRlciwgbGVuZ3RoT3JFbmRUYWdGaWVsZE5vLCBvcHRpb25zLCBkZWxpbWl0ZWRNZXNzYWdlRW5jb2RpbmcpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKTtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3RyaWN0LWJvb2xlYW4tZXhwcmVzc2lvbnNcbiAgICAgIGNvbnN0IGVuZCA9IGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyA/IHJlYWRlci5sZW4gOiByZWFkZXIucG9zICsgbGVuZ3RoT3JFbmRUYWdGaWVsZE5vO1xuICAgICAgbGV0IGZpZWxkTm8sIHdpcmVUeXBlO1xuICAgICAgd2hpbGUgKHJlYWRlci5wb3MgPCBlbmQpIHtcbiAgICAgICAgW2ZpZWxkTm8sIHdpcmVUeXBlXSA9IHJlYWRlci50YWcoKTtcbiAgICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyA9PT0gdHJ1ZSAmJiB3aXJlVHlwZSA9PSBXaXJlVHlwZS5FbmRHcm91cCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpZWxkID0gdHlwZS5maWVsZHMuZmluZChmaWVsZE5vKTtcbiAgICAgICAgaWYgKCFmaWVsZCkge1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSByZWFkZXIuc2tpcCh3aXJlVHlwZSwgZmllbGRObyk7XG4gICAgICAgICAgaWYgKG9wdGlvbnMucmVhZFVua25vd25GaWVsZHMpIHtcbiAgICAgICAgICAgIHRoaXMub25Vbmtub3duRmllbGQobWVzc2FnZSwgZmllbGRObywgd2lyZVR5cGUsIGRhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZWFkRmllbGQobWVzc2FnZSwgcmVhZGVyLCBmaWVsZCwgd2lyZVR5cGUsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKGRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyAmJiAoXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICAgICAgd2lyZVR5cGUgIT0gV2lyZVR5cGUuRW5kR3JvdXAgfHwgZmllbGRObyAhPT0gbGVuZ3RoT3JFbmRUYWdGaWVsZE5vKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVuZCBncm91cCB0YWdcIik7XG4gICAgICB9XG4gICAgfSxcbiAgICByZWFkRmllbGQsXG4gICAgd3JpdGVNZXNzYWdlKG1lc3NhZ2UsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgY29uc3QgdHlwZSA9IG1lc3NhZ2UuZ2V0VHlwZSgpO1xuICAgICAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlLmZpZWxkcy5ieU51bWJlcigpKSB7XG4gICAgICAgIGlmICghaXNGaWVsZFNldChmaWVsZCwgbWVzc2FnZSkpIHtcbiAgICAgICAgICBpZiAoZmllbGQucmVxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjYW5ub3QgZW5jb2RlIGZpZWxkIFwiLmNvbmNhdCh0eXBlLnR5cGVOYW1lLCBcIi5cIikuY29uY2F0KGZpZWxkLm5hbWUsIFwiIHRvIGJpbmFyeTogcmVxdWlyZWQgZmllbGQgbm90IHNldFwiKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gZmllbGQub25lb2YgPyBtZXNzYWdlW2ZpZWxkLm9uZW9mLmxvY2FsTmFtZV0udmFsdWUgOiBtZXNzYWdlW2ZpZWxkLmxvY2FsTmFtZV07XG4gICAgICAgIHdyaXRlRmllbGQoZmllbGQsIHZhbHVlLCB3cml0ZXIsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMud3JpdGVVbmtub3duRmllbGRzKSB7XG4gICAgICAgIHRoaXMud3JpdGVVbmtub3duRmllbGRzKG1lc3NhZ2UsIHdyaXRlcik7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JpdGVyO1xuICAgIH0sXG4gICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucykge1xuICAgICAgLy8gVGhlIGJlaGF2aW9yIG9mIG91ciBpbnRlcm5hbCBmdW5jdGlvbiBoYXMgY2hhbmdlZCwgaXQgZG9lcyBubyBsb25nZXJcbiAgICAgIC8vIGFjY2VwdCBgdW5kZWZpbmVkYCB2YWx1ZXMgZm9yIHNpbmd1bGFyIHNjYWxhciBhbmQgbWFwLlxuICAgICAgLy8gRm9yIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5LCB3ZSBzdXBwb3J0IHRoZSBvbGQgZm9ybSB0aGF0IGlzIHBhcnQgb2ZcbiAgICAgIC8vIHRoZSBwdWJsaWMgQVBJIHRocm91Z2ggdGhlIGludGVyZmFjZSBCaW5hcnlGb3JtYXQuXG4gICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgd3JpdGVGaWVsZChmaWVsZCwgdmFsdWUsIHdyaXRlciwgb3B0aW9ucyk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gcmVhZEZpZWxkKHRhcmdldCxcbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAtLSBgYW55YCBpcyB0aGUgYmVzdCBjaG9pY2UgZm9yIGR5bmFtaWMgYWNjZXNzXG5yZWFkZXIsIGZpZWxkLCB3aXJlVHlwZSwgb3B0aW9ucykge1xuICBsZXQge1xuICAgIHJlcGVhdGVkLFxuICAgIGxvY2FsTmFtZVxuICB9ID0gZmllbGQ7XG4gIGlmIChmaWVsZC5vbmVvZikge1xuICAgIHRhcmdldCA9IHRhcmdldFtmaWVsZC5vbmVvZi5sb2NhbE5hbWVdO1xuICAgIGlmICh0YXJnZXQuY2FzZSAhPSBsb2NhbE5hbWUpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXQudmFsdWU7XG4gICAgfVxuICAgIHRhcmdldC5jYXNlID0gbG9jYWxOYW1lO1xuICAgIGxvY2FsTmFtZSA9IFwidmFsdWVcIjtcbiAgfVxuICBzd2l0Y2ggKGZpZWxkLmtpbmQpIHtcbiAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgY2FzZSBcImVudW1cIjpcbiAgICAgIGNvbnN0IHNjYWxhclR5cGUgPSBmaWVsZC5raW5kID09IFwiZW51bVwiID8gU2NhbGFyVHlwZS5JTlQzMiA6IGZpZWxkLlQ7XG4gICAgICBsZXQgcmVhZCA9IHJlYWRTY2FsYXI7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1lbnVtLWNvbXBhcmlzb24gLS0gYWNjZXB0YWJsZSBzaW5jZSBpdCdzIGNvdmVyZWQgYnkgdGVzdHNcbiAgICAgIGlmIChmaWVsZC5raW5kID09IFwic2NhbGFyXCIgJiYgZmllbGQuTCA+IDApIHtcbiAgICAgICAgcmVhZCA9IHJlYWRTY2FsYXJMVFN0cmluZztcbiAgICAgIH1cbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICBsZXQgYXJyID0gdGFyZ2V0W2xvY2FsTmFtZV07IC8vIHNhZmUgdG8gYXNzdW1lIHByZXNlbmNlIG9mIGFycmF5LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgICAgY29uc3QgaXNQYWNrZWQgPSB3aXJlVHlwZSA9PSBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQgJiYgc2NhbGFyVHlwZSAhPSBTY2FsYXJUeXBlLlNUUklORyAmJiBzY2FsYXJUeXBlICE9IFNjYWxhclR5cGUuQllURVM7XG4gICAgICAgIGlmIChpc1BhY2tlZCkge1xuICAgICAgICAgIGxldCBlID0gcmVhZGVyLnVpbnQzMigpICsgcmVhZGVyLnBvcztcbiAgICAgICAgICB3aGlsZSAocmVhZGVyLnBvcyA8IGUpIHtcbiAgICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFyci5wdXNoKHJlYWQocmVhZGVyLCBzY2FsYXJUeXBlKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdID0gcmVhZChyZWFkZXIsIHNjYWxhclR5cGUpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gZmllbGQuVDtcbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBhcnJheSwgb25lb2YgY2Fubm90IGNvbnRhaW4gcmVwZWF0ZWQgdmFsdWVzXG4gICAgICAgIHRhcmdldFtsb2NhbE5hbWVdLnB1c2gocmVhZE1lc3NhZ2VGaWVsZChyZWFkZXIsIG5ldyBtZXNzYWdlVHlwZSgpLCBvcHRpb25zLCBmaWVsZCkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTWVzc2FnZSh0YXJnZXRbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgdGFyZ2V0W2xvY2FsTmFtZV0sIG9wdGlvbnMsIGZpZWxkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0YXJnZXRbbG9jYWxOYW1lXSA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgbWVzc2FnZVR5cGUoKSwgb3B0aW9ucywgZmllbGQpO1xuICAgICAgICAgIGlmIChtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIgJiYgIWZpZWxkLm9uZW9mICYmICFmaWVsZC5yZXBlYXRlZCkge1xuICAgICAgICAgICAgdGFyZ2V0W2xvY2FsTmFtZV0gPSBtZXNzYWdlVHlwZS5maWVsZFdyYXBwZXIudW53cmFwRmllbGQodGFyZ2V0W2xvY2FsTmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBcIm1hcFwiOlxuICAgICAgbGV0IFttYXBLZXksIG1hcFZhbF0gPSByZWFkTWFwRW50cnkoZmllbGQsIHJlYWRlciwgb3B0aW9ucyk7XG4gICAgICAvLyBzYWZlIHRvIGFzc3VtZSBwcmVzZW5jZSBvZiBtYXAgb2JqZWN0LCBvbmVvZiBjYW5ub3QgY29udGFpbiByZXBlYXRlZCB2YWx1ZXNcbiAgICAgIHRhcmdldFtsb2NhbE5hbWVdW21hcEtleV0gPSBtYXBWYWw7XG4gICAgICBicmVhaztcbiAgfVxufVxuLy8gUmVhZCBhIG1lc3NhZ2UsIGF2b2lkaW5nIE1lc3NhZ2VUeXBlLmZyb21CaW5hcnkoKSB0byByZS11c2UgdGhlXG4vLyBCaW5hcnlSZWFkT3B0aW9ucyBhbmQgdGhlIElCaW5hcnlSZWFkZXIuXG5mdW5jdGlvbiByZWFkTWVzc2FnZUZpZWxkKHJlYWRlciwgbWVzc2FnZSwgb3B0aW9ucywgZmllbGQpIHtcbiAgY29uc3QgZm9ybWF0ID0gbWVzc2FnZS5nZXRUeXBlKCkucnVudGltZS5iaW47XG4gIGNvbnN0IGRlbGltaXRlZCA9IGZpZWxkID09PSBudWxsIHx8IGZpZWxkID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmaWVsZC5kZWxpbWl0ZWQ7XG4gIGZvcm1hdC5yZWFkTWVzc2FnZShtZXNzYWdlLCByZWFkZXIsIGRlbGltaXRlZCA/IGZpZWxkLm5vIDogcmVhZGVyLnVpbnQzMigpLFxuICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9zdHJpY3QtYm9vbGVhbi1leHByZXNzaW9uc1xuICBvcHRpb25zLCBkZWxpbWl0ZWQpO1xuICByZXR1cm4gbWVzc2FnZTtcbn1cbi8vIFJlYWQgYSBtYXAgZmllbGQsIGV4cGVjdGluZyBrZXkgZmllbGQgPSAxLCB2YWx1ZSBmaWVsZCA9IDJcbmZ1bmN0aW9uIHJlYWRNYXBFbnRyeShmaWVsZCwgcmVhZGVyLCBvcHRpb25zKSB7XG4gIGNvbnN0IGxlbmd0aCA9IHJlYWRlci51aW50MzIoKSxcbiAgICBlbmQgPSByZWFkZXIucG9zICsgbGVuZ3RoO1xuICBsZXQga2V5LCB2YWw7XG4gIHdoaWxlIChyZWFkZXIucG9zIDwgZW5kKSB7XG4gICAgY29uc3QgW2ZpZWxkTm9dID0gcmVhZGVyLnRhZygpO1xuICAgIHN3aXRjaCAoZmllbGRObykge1xuICAgICAgY2FzZSAxOlxuICAgICAgICBrZXkgPSByZWFkU2NhbGFyKHJlYWRlciwgZmllbGQuSyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRTY2FsYXIocmVhZGVyLCBmaWVsZC5WLlQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRlci5pbnQzMigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIHZhbCA9IHJlYWRNZXNzYWdlRmllbGQocmVhZGVyLCBuZXcgZmllbGQuVi5UKCksIG9wdGlvbnMsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGtleSA9PT0gdW5kZWZpbmVkKSB7XG4gICAga2V5ID0gc2NhbGFyWmVyb1ZhbHVlKGZpZWxkLkssIExvbmdUeXBlLkJJR0lOVCk7XG4gIH1cbiAgaWYgKHR5cGVvZiBrZXkgIT0gXCJzdHJpbmdcIiAmJiB0eXBlb2Yga2V5ICE9IFwibnVtYmVyXCIpIHtcbiAgICBrZXkgPSBrZXkudG9TdHJpbmcoKTtcbiAgfVxuICBpZiAodmFsID09PSB1bmRlZmluZWQpIHtcbiAgICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICB2YWwgPSBzY2FsYXJaZXJvVmFsdWUoZmllbGQuVi5ULCBMb25nVHlwZS5CSUdJTlQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgIHZhbCA9IGZpZWxkLlYuVC52YWx1ZXNbMF0ubm87XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgdmFsID0gbmV3IGZpZWxkLlYuVCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFtrZXksIHZhbF07XG59XG4vLyBSZWFkIGEgc2NhbGFyIHZhbHVlLCBidXQgcmV0dXJuIDY0IGJpdCBpbnRlZ3JhbCB0eXBlcyAoaW50NjQsIHVpbnQ2NCxcbi8vIHNpbnQ2NCwgZml4ZWQ2NCwgc2ZpeGVkNjQpIGFzIHN0cmluZyBpbnN0ZWFkIG9mIGJpZ2ludC5cbmZ1bmN0aW9uIHJlYWRTY2FsYXJMVFN0cmluZyhyZWFkZXIsIHR5cGUpIHtcbiAgY29uc3QgdiA9IHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKTtcbiAgcmV0dXJuIHR5cGVvZiB2ID09IFwiYmlnaW50XCIgPyB2LnRvU3RyaW5nKCkgOiB2O1xufVxuLy8gRG9lcyBub3QgdXNlIHNjYWxhclR5cGVJbmZvKCkgZm9yIGJldHRlciBwZXJmb3JtYW5jZS5cbmZ1bmN0aW9uIHJlYWRTY2FsYXIocmVhZGVyLCB0eXBlKSB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICByZXR1cm4gcmVhZGVyLnN0cmluZygpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgcmV0dXJuIHJlYWRlci5ib29sKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkRPVUJMRTpcbiAgICAgIHJldHVybiByZWFkZXIuZG91YmxlKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZMT0FUOlxuICAgICAgcmV0dXJuIHJlYWRlci5mbG9hdCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICAgIHJldHVybiByZWFkZXIuaW50MzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLmludDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlVJTlQ2NDpcbiAgICAgIHJldHVybiByZWFkZXIudWludDY0KCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLmZpeGVkNjQoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuQllURVM6XG4gICAgICByZXR1cm4gcmVhZGVyLmJ5dGVzKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVEMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLmZpeGVkMzIoKTtcbiAgICBjYXNlIFNjYWxhclR5cGUuU0ZJWEVEMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnNmaXhlZDMyKCk7XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgcmV0dXJuIHJlYWRlci5zZml4ZWQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UNjQ6XG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQ2NCgpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5VSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnVpbnQzMigpO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5TSU5UMzI6XG4gICAgICByZXR1cm4gcmVhZGVyLnNpbnQzMigpO1xuICB9XG59XG5mdW5jdGlvbiB3cml0ZUZpZWxkKGZpZWxkLCB2YWx1ZSwgd3JpdGVyLCBvcHRpb25zKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgY29uc3QgcmVwZWF0ZWQgPSBmaWVsZC5yZXBlYXRlZDtcbiAgc3dpdGNoIChmaWVsZC5raW5kKSB7XG4gICAgY2FzZSBcInNjYWxhclwiOlxuICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICBsZXQgc2NhbGFyVHlwZSA9IGZpZWxkLmtpbmQgPT0gXCJlbnVtXCIgPyBTY2FsYXJUeXBlLklOVDMyIDogZmllbGQuVDtcbiAgICAgIGlmIChyZXBlYXRlZCkge1xuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZSkpO1xuICAgICAgICBpZiAoZmllbGQucGFja2VkKSB7XG4gICAgICAgICAgd3JpdGVQYWNrZWQod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBzY2FsYXJUeXBlLCBmaWVsZC5ubywgaXRlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZVNjYWxhcih3cml0ZXIsIHNjYWxhclR5cGUsIGZpZWxkLm5vLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgaWYgKHJlcGVhdGVkKSB7XG4gICAgICAgIGFzc2VydChBcnJheS5pc0FycmF5KHZhbHVlKSk7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB2YWx1ZSkge1xuICAgICAgICAgIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIGl0ZW0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3cml0ZU1lc3NhZ2VGaWVsZCh3cml0ZXIsIG9wdGlvbnMsIGZpZWxkLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWFwXCI6XG4gICAgICBhc3NlcnQodHlwZW9mIHZhbHVlID09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT0gbnVsbCk7XG4gICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXModmFsdWUpKSB7XG4gICAgICAgIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWwpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gIH1cbn1cbmZ1bmN0aW9uIHdyaXRlTWFwRW50cnkod3JpdGVyLCBvcHRpb25zLCBmaWVsZCwga2V5LCB2YWx1ZSkge1xuICB3cml0ZXIudGFnKGZpZWxkLm5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpO1xuICB3cml0ZXIuZm9yaygpO1xuICAvLyBqYXZhc2NyaXB0IG9ubHkgYWxsb3dzIG51bWJlciBvciBzdHJpbmcgZm9yIG9iamVjdCBwcm9wZXJ0aWVzXG4gIC8vIHdlIGNvbnZlcnQgZnJvbSBvdXIgcmVwcmVzZW50YXRpb24gdG8gdGhlIHByb3RvYnVmIHR5cGVcbiAgbGV0IGtleVZhbHVlID0ga2V5O1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSB3ZSBkZWxpYmVyYXRlbHkgaGFuZGxlIGp1c3QgdGhlIHNwZWNpYWwgY2FzZXMgZm9yIG1hcCBrZXlzXG4gIHN3aXRjaCAoZmllbGQuSykge1xuICAgIGNhc2UgU2NhbGFyVHlwZS5JTlQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuVUlOVDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuU0lOVDMyOlxuICAgICAga2V5VmFsdWUgPSBOdW1iZXIucGFyc2VJbnQoa2V5KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5CT09MOlxuICAgICAgYXNzZXJ0KGtleSA9PSBcInRydWVcIiB8fCBrZXkgPT0gXCJmYWxzZVwiKTtcbiAgICAgIGtleVZhbHVlID0ga2V5ID09IFwidHJ1ZVwiO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgLy8gd3JpdGUga2V5LCBleHBlY3Rpbmcga2V5IGZpZWxkIG51bWJlciA9IDFcbiAgd3JpdGVTY2FsYXIod3JpdGVyLCBmaWVsZC5LLCAxLCBrZXlWYWx1ZSk7XG4gIC8vIHdyaXRlIHZhbHVlLCBleHBlY3RpbmcgdmFsdWUgZmllbGQgbnVtYmVyID0gMlxuICBzd2l0Y2ggKGZpZWxkLlYua2luZCkge1xuICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgIHdyaXRlU2NhbGFyKHdyaXRlciwgZmllbGQuVi5ULCAyLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgd3JpdGVTY2FsYXIod3JpdGVyLCBTY2FsYXJUeXBlLklOVDMyLCAyLCB2YWx1ZSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgYXNzZXJ0KHZhbHVlICE9PSB1bmRlZmluZWQpO1xuICAgICAgd3JpdGVyLnRhZygyLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmJ5dGVzKHZhbHVlLnRvQmluYXJ5KG9wdGlvbnMpKTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHdyaXRlci5qb2luKCk7XG59XG4vLyBWYWx1ZSBtdXN0IG5vdCBiZSB1bmRlZmluZWRcbmZ1bmN0aW9uIHdyaXRlTWVzc2FnZUZpZWxkKHdyaXRlciwgb3B0aW9ucywgZmllbGQsIHZhbHVlKSB7XG4gIGNvbnN0IG1lc3NhZ2UgPSB3cmFwRmllbGQoZmllbGQuVCwgdmFsdWUpO1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N0cmljdC1ib29sZWFuLWV4cHJlc3Npb25zXG4gIGlmIChmaWVsZC5kZWxpbWl0ZWQpIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLlN0YXJ0R3JvdXApLnJhdyhtZXNzYWdlLnRvQmluYXJ5KG9wdGlvbnMpKS50YWcoZmllbGQubm8sIFdpcmVUeXBlLkVuZEdyb3VwKTtlbHNlIHdyaXRlci50YWcoZmllbGQubm8sIFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZCkuYnl0ZXMobWVzc2FnZS50b0JpbmFyeShvcHRpb25zKSk7XG59XG5mdW5jdGlvbiB3cml0ZVNjYWxhcih3cml0ZXIsIHR5cGUsIGZpZWxkTm8sIHZhbHVlKSB7XG4gIGFzc2VydCh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbiAgbGV0IFt3aXJlVHlwZSwgbWV0aG9kXSA9IHNjYWxhclR5cGVJbmZvKHR5cGUpO1xuICB3cml0ZXIudGFnKGZpZWxkTm8sIHdpcmVUeXBlKVttZXRob2RdKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHdyaXRlUGFja2VkKHdyaXRlciwgdHlwZSwgZmllbGRObywgdmFsdWUpIHtcbiAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd3JpdGVyLnRhZyhmaWVsZE5vLCBXaXJlVHlwZS5MZW5ndGhEZWxpbWl0ZWQpLmZvcmsoKTtcbiAgbGV0IFssIG1ldGhvZF0gPSBzY2FsYXJUeXBlSW5mbyh0eXBlKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgIHdyaXRlclttZXRob2RdKHZhbHVlW2ldKTtcbiAgfVxuICB3cml0ZXIuam9pbigpO1xufVxuLyoqXG4gKiBHZXQgaW5mb3JtYXRpb24gZm9yIHdyaXRpbmcgYSBzY2FsYXIgdmFsdWUuXG4gKlxuICogUmV0dXJucyB0dXBsZTpcbiAqIFswXTogYXBwcm9wcmlhdGUgV2lyZVR5cGVcbiAqIFsxXTogbmFtZSBvZiB0aGUgYXBwcm9wcmlhdGUgbWV0aG9kIG9mIElCaW5hcnlXcml0ZXJcbiAqIFsyXTogd2hldGhlciB0aGUgZ2l2ZW4gdmFsdWUgaXMgYSBkZWZhdWx0IHZhbHVlIGZvciBwcm90bzMgc2VtYW50aWNzXG4gKlxuICogSWYgYXJndW1lbnQgYHZhbHVlYCBpcyBvbWl0dGVkLCBbMl0gaXMgYWx3YXlzIGZhbHNlLlxuICovXG4vLyBUT0RPIHJlcGxhY2UgY2FsbC1zaXRlcyB3cml0ZVNjYWxhcigpIGFuZCB3cml0ZVBhY2tlZCgpLCB0aGVuIHJlbW92ZVxuZnVuY3Rpb24gc2NhbGFyVHlwZUluZm8odHlwZSkge1xuICBsZXQgd2lyZVR5cGUgPSBXaXJlVHlwZS5WYXJpbnQ7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIElOVDMyLCBVSU5UMzIsIFNJTlQzMiBhcmUgY292ZXJlZCBieSB0aGUgZGVmYXVsdHNcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTY2FsYXJUeXBlLkJZVEVTOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TVFJJTkc6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkxlbmd0aERlbGltaXRlZDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5ET1VCTEU6XG4gICAgY2FzZSBTY2FsYXJUeXBlLkZJWEVENjQ6XG4gICAgY2FzZSBTY2FsYXJUeXBlLlNGSVhFRDY0OlxuICAgICAgd2lyZVR5cGUgPSBXaXJlVHlwZS5CaXQ2NDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU2NhbGFyVHlwZS5GSVhFRDMyOlxuICAgIGNhc2UgU2NhbGFyVHlwZS5TRklYRUQzMjpcbiAgICBjYXNlIFNjYWxhclR5cGUuRkxPQVQ6XG4gICAgICB3aXJlVHlwZSA9IFdpcmVUeXBlLkJpdDMyO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgY29uc3QgbWV0aG9kID0gU2NhbGFyVHlwZVt0eXBlXS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gW3dpcmVUeXBlLCBtZXRob2RdO1xufVxuXG4vLyBDb3B5cmlnaHQgMjAyMS0yMDI0IEJ1ZiBUZWNobm9sb2dpZXMsIEluYy5cbi8vXG4vLyBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuLy8geW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuLy8gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4vL1xuLy8gICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbi8vXG4vLyBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4vLyBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4vLyBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbi8vIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbi8vIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSxAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW5zYWZlLWFzc2lnbm1lbnQsQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1tZW1iZXItYWNjZXNzLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtcmV0dXJuLEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXJndW1lbnQsbm8tY2FzZS1kZWNsYXJhdGlvbnMgKi9cbmZ1bmN0aW9uIG1ha2VVdGlsQ29tbW9uKCkge1xuICByZXR1cm4ge1xuICAgIHNldEVudW1UeXBlLFxuICAgIGluaXRQYXJ0aWFsKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICBpZiAoc291cmNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdHlwZSA9IHRhcmdldC5nZXRUeXBlKCk7XG4gICAgICBmb3IgKGNvbnN0IG1lbWJlciBvZiB0eXBlLmZpZWxkcy5ieU1lbWJlcigpKSB7XG4gICAgICAgIGNvbnN0IGxvY2FsTmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsXG4gICAgICAgICAgdCA9IHRhcmdldCxcbiAgICAgICAgICBzID0gc291cmNlO1xuICAgICAgICBpZiAoc1tsb2NhbE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAvLyBUT0RPIGlmIHNvdXJjZSBpcyBhIE1lc3NhZ2UgaW5zdGFuY2UsIHdlIHNob3VsZCB1c2UgaXNGaWVsZFNldCgpIGhlcmUgdG8gc3VwcG9ydCBmdXR1cmUgZmllbGQgcHJlc2VuY2VcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcIm9uZW9mXCI6XG4gICAgICAgICAgICBjb25zdCBzayA9IHNbbG9jYWxOYW1lXS5jYXNlO1xuICAgICAgICAgICAgaWYgKHNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VGaWVsZCA9IG1lbWJlci5maW5kRmllbGQoc2spO1xuICAgICAgICAgICAgbGV0IHZhbCA9IHNbbG9jYWxOYW1lXS52YWx1ZTtcbiAgICAgICAgICAgIGlmIChzb3VyY2VGaWVsZCAmJiBzb3VyY2VGaWVsZC5raW5kID09IFwibWVzc2FnZVwiICYmICFpc01lc3NhZ2UodmFsLCBzb3VyY2VGaWVsZC5UKSkge1xuICAgICAgICAgICAgICB2YWwgPSBuZXcgc291cmNlRmllbGQuVCh2YWwpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzb3VyY2VGaWVsZCAmJiBzb3VyY2VGaWVsZC5raW5kID09PSBcInNjYWxhclwiICYmIHNvdXJjZUZpZWxkLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgdmFsID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0ge1xuICAgICAgICAgICAgICBjYXNlOiBzayxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgbGV0IGNvcHkgPSBzW2xvY2FsTmFtZV07XG4gICAgICAgICAgICBpZiAobWVtYmVyLlQgPT09IFNjYWxhclR5cGUuQllURVMpIHtcbiAgICAgICAgICAgICAgY29weSA9IG1lbWJlci5yZXBlYXRlZCA/IGNvcHkubWFwKHRvVThBcnIpIDogdG9VOEFycihjb3B5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKG1lbWJlci5WLmtpbmQpIHtcbiAgICAgICAgICAgICAgY2FzZSBcInNjYWxhclwiOlxuICAgICAgICAgICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICAgICAgICAgIGlmIChtZW1iZXIuVi5UID09PSBTY2FsYXJUeXBlLkJZVEVTKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhzW2xvY2FsTmFtZV0pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXVtrXSA9IHRvVThBcnIodik7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24odFtsb2NhbE5hbWVdLCBzW2xvY2FsTmFtZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBtZXNzYWdlVHlwZSA9IG1lbWJlci5WLlQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrIG9mIE9iamVjdC5rZXlzKHNbbG9jYWxOYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgIGxldCB2YWwgPSBzW2xvY2FsTmFtZV1ba107XG4gICAgICAgICAgICAgICAgICBpZiAoIW1lc3NhZ2VUeXBlLmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBvbmx5IHRha2UgcGFydGlhbCBpbnB1dCBmb3IgbWVzc2FnZXMgdGhhdCBhcmUgbm90IGEgd3JhcHBlciB0eXBlLlxuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgdGhvc2UgbWVzc2FnZXMsIHdlIHJlY3Vyc2l2ZWx5IG5vcm1hbGl6ZSB0aGUgcGFydGlhbCBpbnB1dC5cbiAgICAgICAgICAgICAgICAgICAgdmFsID0gbmV3IG1lc3NhZ2VUeXBlKHZhbCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV1ba10gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIGNvbnN0IG10ID0gbWVtYmVyLlQ7XG4gICAgICAgICAgICBpZiAobWVtYmVyLnJlcGVhdGVkKSB7XG4gICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IHNbbG9jYWxOYW1lXS5tYXAodmFsID0+IGlzTWVzc2FnZSh2YWwsIG10KSA/IHZhbCA6IG5ldyBtdCh2YWwpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHNbbG9jYWxOYW1lXTtcbiAgICAgICAgICAgICAgaWYgKG10LmZpZWxkV3JhcHBlcikge1xuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4ndCB1c2UgQnl0ZXNWYWx1ZS50eXBlTmFtZSBhcyB0aGF0IHdpbGwgY3JlYXRlIGEgY2lyY3VsYXIgaW1wb3J0XG4gICAgICAgICAgICAgICAgbXQudHlwZU5hbWUgPT09IFwiZ29vZ2xlLnByb3RvYnVmLkJ5dGVzVmFsdWVcIikge1xuICAgICAgICAgICAgICAgICAgdFtsb2NhbE5hbWVdID0gdG9VOEFycih2YWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0W2xvY2FsTmFtZV0gPSB2YWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRbbG9jYWxOYW1lXSA9IGlzTWVzc2FnZSh2YWwsIG10KSA/IHZhbCA6IG5ldyBtdCh2YWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgLy8gVE9ETyB1c2UgaXNGaWVsZFNldCgpIGhlcmUgdG8gc3VwcG9ydCBmdXR1cmUgZmllbGQgcHJlc2VuY2VcbiAgICBlcXVhbHModHlwZSwgYSwgYikge1xuICAgICAgaWYgKGEgPT09IGIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoIWEgfHwgIWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHR5cGUuZmllbGRzLmJ5TWVtYmVyKCkuZXZlcnkobSA9PiB7XG4gICAgICAgIGNvbnN0IHZhID0gYVttLmxvY2FsTmFtZV07XG4gICAgICAgIGNvbnN0IHZiID0gYlttLmxvY2FsTmFtZV07XG4gICAgICAgIGlmIChtLnJlcGVhdGVkKSB7XG4gICAgICAgICAgaWYgKHZhLmxlbmd0aCAhPT0gdmIubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvc3dpdGNoLWV4aGF1c3RpdmVuZXNzLWNoZWNrIC0tIHJlcGVhdGVkIGZpZWxkcyBhcmUgbmV2ZXIgXCJtYXBcIlxuICAgICAgICAgIHN3aXRjaCAobS5raW5kKSB7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICByZXR1cm4gdmEuZXZlcnkoKGEsIGkpID0+IG0uVC5lcXVhbHMoYSwgdmJbaV0pKTtcbiAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMobS5ULCBhLCB2YltpXSkpO1xuICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgcmV0dXJuIHZhLmV2ZXJ5KChhLCBpKSA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgYSwgdmJbaV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicmVwZWF0ZWQgY2Fubm90IGNvbnRhaW4gXCIuY29uY2F0KG0ua2luZCkpO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAobS5raW5kKSB7XG4gICAgICAgICAgY2FzZSBcIm1lc3NhZ2VcIjpcbiAgICAgICAgICAgIHJldHVybiBtLlQuZXF1YWxzKHZhLCB2Yik7XG4gICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgIHJldHVybiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmEsIHZiKTtcbiAgICAgICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKG0uVCwgdmEsIHZiKTtcbiAgICAgICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgICAgIGlmICh2YS5jYXNlICE9PSB2Yi5jYXNlKSB7XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHMgPSBtLmZpbmRGaWVsZCh2YS5jYXNlKTtcbiAgICAgICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L3N3aXRjaC1leGhhdXN0aXZlbmVzcy1jaGVjayAtLSBvbmVvZiBmaWVsZHMgYXJlIG5ldmVyIFwibWFwXCJcbiAgICAgICAgICAgIHN3aXRjaCAocy5raW5kKSB7XG4gICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMuVC5lcXVhbHModmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgICAgY2FzZSBcImVudW1cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKFNjYWxhclR5cGUuSU5UMzIsIHZhLnZhbHVlLCB2Yi52YWx1ZSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gc2NhbGFyRXF1YWxzKHMuVCwgdmEudmFsdWUsIHZiLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm9uZW9mIGNhbm5vdCBjb250YWluIFwiLmNvbmNhdChzLmtpbmQpKTtcbiAgICAgICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmEpLmNvbmNhdChPYmplY3Qua2V5cyh2YikpO1xuICAgICAgICAgICAgc3dpdGNoIChtLlYua2luZCkge1xuICAgICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VUeXBlID0gbS5WLlQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoayA9PiBtZXNzYWdlVHlwZS5lcXVhbHModmFba10sIHZiW2tdKSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJlbnVtXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoayA9PiBzY2FsYXJFcXVhbHMoU2NhbGFyVHlwZS5JTlQzMiwgdmFba10sIHZiW2tdKSk7XG4gICAgICAgICAgICAgIGNhc2UgXCJzY2FsYXJcIjpcbiAgICAgICAgICAgICAgICBjb25zdCBzY2FsYXJUeXBlID0gbS5WLlQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtleXMuZXZlcnkoayA9PiBzY2FsYXJFcXVhbHMoc2NhbGFyVHlwZSwgdmFba10sIHZiW2tdKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyBUT0RPIHVzZSBpc0ZpZWxkU2V0KCkgaGVyZSB0byBzdXBwb3J0IGZ1dHVyZSBmaWVsZCBwcmVzZW5jZVxuICAgIGNsb25lKG1lc3NhZ2UpIHtcbiAgICAgIGNvbnN0IHR5cGUgPSBtZXNzYWdlLmdldFR5cGUoKSxcbiAgICAgICAgdGFyZ2V0ID0gbmV3IHR5cGUoKSxcbiAgICAgICAgYW55ID0gdGFyZ2V0O1xuICAgICAgZm9yIChjb25zdCBtZW1iZXIgb2YgdHlwZS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBtZXNzYWdlW21lbWJlci5sb2NhbE5hbWVdO1xuICAgICAgICBsZXQgY29weTtcbiAgICAgICAgaWYgKG1lbWJlci5yZXBlYXRlZCkge1xuICAgICAgICAgIGNvcHkgPSBzb3VyY2UubWFwKGNsb25lU2luZ3VsYXJGaWVsZCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVtYmVyLmtpbmQgPT0gXCJtYXBcIikge1xuICAgICAgICAgIGNvcHkgPSBhbnlbbWVtYmVyLmxvY2FsTmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2XSBvZiBPYmplY3QuZW50cmllcyhzb3VyY2UpKSB7XG4gICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZVNpbmd1bGFyRmllbGQodik7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKG1lbWJlci5raW5kID09IFwib25lb2ZcIikge1xuICAgICAgICAgIGNvbnN0IGYgPSBtZW1iZXIuZmluZEZpZWxkKHNvdXJjZS5jYXNlKTtcbiAgICAgICAgICBjb3B5ID0gZiA/IHtcbiAgICAgICAgICAgIGNhc2U6IHNvdXJjZS5jYXNlLFxuICAgICAgICAgICAgdmFsdWU6IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UudmFsdWUpXG4gICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgIGNhc2U6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29weSA9IGNsb25lU2luZ3VsYXJGaWVsZChzb3VyY2UpO1xuICAgICAgICB9XG4gICAgICAgIGFueVttZW1iZXIubG9jYWxOYW1lXSA9IGNvcHk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHVmIG9mIHR5cGUucnVudGltZS5iaW4ubGlzdFVua25vd25GaWVsZHMobWVzc2FnZSkpIHtcbiAgICAgICAgdHlwZS5ydW50aW1lLmJpbi5vblVua25vd25GaWVsZChhbnksIHVmLm5vLCB1Zi53aXJlVHlwZSwgdWYuZGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0O1xuICAgIH1cbiAgfTtcbn1cbi8vIGNsb25lIGEgc2luZ2xlIGZpZWxkIHZhbHVlIC0gaS5lLiB0aGUgZWxlbWVudCB0eXBlIG9mIHJlcGVhdGVkIGZpZWxkcywgdGhlIHZhbHVlIHR5cGUgb2YgbWFwc1xuZnVuY3Rpb24gY2xvbmVTaW5ndWxhckZpZWxkKHZhbHVlKSB7XG4gIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGlmIChpc01lc3NhZ2UodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLmNsb25lKCk7XG4gIH1cbiAgaWYgKHZhbHVlIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIGNvbnN0IGMgPSBuZXcgVWludDhBcnJheSh2YWx1ZS5ieXRlTGVuZ3RoKTtcbiAgICBjLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIGM7XG4gIH1cbiAgcmV0dXJuIHZhbHVlO1xufVxuLy8gY29udmVydHMgYW55IEFycmF5TGlrZTxudW1iZXI+IHRvIFVpbnQ4QXJyYXkgaWYgbmVjZXNzYXJ5LlxuZnVuY3Rpb24gdG9VOEFycihpbnB1dCkge1xuICByZXR1cm4gaW5wdXQgaW5zdGFuY2VvZiBVaW50OEFycmF5ID8gaW5wdXQgOiBuZXcgVWludDhBcnJheShpbnB1dCk7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5mdW5jdGlvbiBtYWtlUHJvdG9SdW50aW1lKHN5bnRheCwgbmV3RmllbGRMaXN0LCBpbml0RmllbGRzKSB7XG4gIHJldHVybiB7XG4gICAgc3ludGF4LFxuICAgIGpzb246IG1ha2VKc29uRm9ybWF0KCksXG4gICAgYmluOiBtYWtlQmluYXJ5Rm9ybWF0KCksXG4gICAgdXRpbDogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBtYWtlVXRpbENvbW1vbigpKSwge1xuICAgICAgbmV3RmllbGRMaXN0LFxuICAgICAgaW5pdEZpZWxkc1xuICAgIH0pLFxuICAgIG1ha2VNZXNzYWdlVHlwZSh0eXBlTmFtZSwgZmllbGRzLCBvcHQpIHtcbiAgICAgIHJldHVybiBtYWtlTWVzc2FnZVR5cGUodGhpcywgdHlwZU5hbWUsIGZpZWxkcywgb3B0KTtcbiAgICB9LFxuICAgIG1ha2VFbnVtLFxuICAgIG1ha2VFbnVtVHlwZSxcbiAgICBnZXRFbnVtVHlwZSxcbiAgICBtYWtlRXh0ZW5zaW9uKHR5cGVOYW1lLCBleHRlbmRlZSwgZmllbGQpIHtcbiAgICAgIHJldHVybiBtYWtlRXh0ZW5zaW9uKHRoaXMsIHR5cGVOYW1lLCBleHRlbmRlZSwgZmllbGQpO1xuICAgIH1cbiAgfTtcbn1cblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbmNsYXNzIEludGVybmFsRmllbGRMaXN0IHtcbiAgY29uc3RydWN0b3IoZmllbGRzLCBub3JtYWxpemVyKSB7XG4gICAgdGhpcy5fZmllbGRzID0gZmllbGRzO1xuICAgIHRoaXMuX25vcm1hbGl6ZXIgPSBub3JtYWxpemVyO1xuICB9XG4gIGZpbmRKc29uTmFtZShqc29uTmFtZSkge1xuICAgIGlmICghdGhpcy5qc29uTmFtZXMpIHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgZiBvZiB0aGlzLmxpc3QoKSkge1xuICAgICAgICB0W2YuanNvbk5hbWVdID0gdFtmLm5hbWVdID0gZjtcbiAgICAgIH1cbiAgICAgIHRoaXMuanNvbk5hbWVzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuanNvbk5hbWVzW2pzb25OYW1lXTtcbiAgfVxuICBmaW5kKGZpZWxkTm8pIHtcbiAgICBpZiAoIXRoaXMubnVtYmVycykge1xuICAgICAgY29uc3QgdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBmIG9mIHRoaXMubGlzdCgpKSB7XG4gICAgICAgIHRbZi5ub10gPSBmO1xuICAgICAgfVxuICAgICAgdGhpcy5udW1iZXJzID0gdDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc1tmaWVsZE5vXTtcbiAgfVxuICBsaXN0KCkge1xuICAgIGlmICghdGhpcy5hbGwpIHtcbiAgICAgIHRoaXMuYWxsID0gdGhpcy5fbm9ybWFsaXplcih0aGlzLl9maWVsZHMpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hbGw7XG4gIH1cbiAgYnlOdW1iZXIoKSB7XG4gICAgaWYgKCF0aGlzLm51bWJlcnNBc2MpIHtcbiAgICAgIHRoaXMubnVtYmVyc0FzYyA9IHRoaXMubGlzdCgpLmNvbmNhdCgpLnNvcnQoKGEsIGIpID0+IGEubm8gLSBiLm5vKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubnVtYmVyc0FzYztcbiAgfVxuICBieU1lbWJlcigpIHtcbiAgICBpZiAoIXRoaXMubWVtYmVycykge1xuICAgICAgdGhpcy5tZW1iZXJzID0gW107XG4gICAgICBjb25zdCBhID0gdGhpcy5tZW1iZXJzO1xuICAgICAgbGV0IG87XG4gICAgICBmb3IgKGNvbnN0IGYgb2YgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgaWYgKGYub25lb2YpIHtcbiAgICAgICAgICBpZiAoZi5vbmVvZiAhPT0gbykge1xuICAgICAgICAgICAgbyA9IGYub25lb2Y7XG4gICAgICAgICAgICBhLnB1c2gobyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGEucHVzaChmKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZW1iZXJzO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFJldHVybnMgdGhlIG5hbWUgb2YgYSBwcm90b2J1ZiBlbGVtZW50IGluIGdlbmVyYXRlZCBjb2RlLlxuICpcbiAqIEZpZWxkIG5hbWVzIC0gaW5jbHVkaW5nIG9uZW9mcyAtIGFyZSBjb252ZXJ0ZWQgdG8gbG93ZXJDYW1lbENhc2UuIEZvclxuICogbWVzc2FnZXMsIGVudW1lcmF0aW9ucyBhbmQgc2VydmljZXMsIHRoZSBwYWNrYWdlIG5hbWUgaXMgc3RyaXBwZWQgZnJvbVxuICogdGhlIHR5cGUgbmFtZS4gRm9yIG5lc3RlZCBtZXNzYWdlcyBhbmQgZW51bWVyYXRpb25zLCB0aGUgbmFtZXMgYXJlIGpvaW5lZFxuICogd2l0aCBhbiB1bmRlcnNjb3JlLiBGb3IgbWV0aG9kcywgdGhlIGZpcnN0IGNoYXJhY3RlciBpcyBtYWRlIGxvd2VyY2FzZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIHRoZSBuYW1lIG9mIGEgZmllbGQgaW4gZ2VuZXJhdGVkIGNvZGUuXG4gKi9cbmZ1bmN0aW9uIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgaW5PbmVvZikge1xuICBjb25zdCBuYW1lID0gcHJvdG9DYW1lbENhc2UocHJvdG9OYW1lKTtcbiAgaWYgKGluT25lb2YpIHtcbiAgICAvLyBvbmVvZiBtZW1iZXIgbmFtZXMgYXJlIG5vdCBwcm9wZXJ0aWVzLCBidXQgdmFsdWVzIG9mIHRoZSBgY2FzZWAgcHJvcGVydHkuXG4gICAgcmV0dXJuIG5hbWU7XG4gIH1cbiAgcmV0dXJuIHNhZmVPYmplY3RQcm9wZXJ0eShzYWZlTWVzc2FnZVByb3BlcnR5KG5hbWUpKTtcbn1cbi8qKlxuICogUmV0dXJucyB0aGUgbmFtZSBvZiBhIG9uZW9mIGdyb3VwIGluIGdlbmVyYXRlZCBjb2RlLlxuICovXG5mdW5jdGlvbiBsb2NhbE9uZW9mTmFtZShwcm90b05hbWUpIHtcbiAgcmV0dXJuIGxvY2FsRmllbGROYW1lKHByb3RvTmFtZSwgZmFsc2UpO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRoZSBKU09OIG5hbWUgZm9yIGEgcHJvdG9idWYgZmllbGQsIGV4YWN0bHkgbGlrZSBwcm90b2MgZG9lcy5cbiAqL1xuY29uc3QgZmllbGRKc29uTmFtZSA9IHByb3RvQ2FtZWxDYXNlO1xuLyoqXG4gKiBDb252ZXJ0cyBzbmFrZV9jYXNlIHRvIHByb3RvQ2FtZWxDYXNlIGFjY29yZGluZyB0byB0aGUgY29udmVudGlvblxuICogdXNlZCBieSBwcm90b2MgdG8gY29udmVydCBhIGZpZWxkIG5hbWUgdG8gYSBKU09OIG5hbWUuXG4gKi9cbmZ1bmN0aW9uIHByb3RvQ2FtZWxDYXNlKHNuYWtlQ2FzZSkge1xuICBsZXQgY2FwTmV4dCA9IGZhbHNlO1xuICBjb25zdCBiID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc25ha2VDYXNlLmxlbmd0aDsgaSsrKSB7XG4gICAgbGV0IGMgPSBzbmFrZUNhc2UuY2hhckF0KGkpO1xuICAgIHN3aXRjaCAoYykge1xuICAgICAgY2FzZSBcIl9cIjpcbiAgICAgICAgY2FwTmV4dCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIjBcIjpcbiAgICAgIGNhc2UgXCIxXCI6XG4gICAgICBjYXNlIFwiMlwiOlxuICAgICAgY2FzZSBcIjNcIjpcbiAgICAgIGNhc2UgXCI0XCI6XG4gICAgICBjYXNlIFwiNVwiOlxuICAgICAgY2FzZSBcIjZcIjpcbiAgICAgIGNhc2UgXCI3XCI6XG4gICAgICBjYXNlIFwiOFwiOlxuICAgICAgY2FzZSBcIjlcIjpcbiAgICAgICAgYi5wdXNoKGMpO1xuICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGNhcE5leHQpIHtcbiAgICAgICAgICBjYXBOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgYyA9IGMudG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBiLnB1c2goYyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYi5qb2luKFwiXCIpO1xufVxuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHJlc2VydmVkT2JqZWN0UHJvcGVydGllcyA9IG5ldyBTZXQoW1xuLy8gbmFtZXMgcmVzZXJ2ZWQgYnkgSmF2YVNjcmlwdFxuXCJjb25zdHJ1Y3RvclwiLCBcInRvU3RyaW5nXCIsIFwidG9KU09OXCIsIFwidmFsdWVPZlwiXSk7XG4vKipcbiAqIE5hbWVzIHRoYXQgY2Fubm90IGJlIHVzZWQgZm9yIG9iamVjdCBwcm9wZXJ0aWVzIGJlY2F1c2UgdGhleSBhcmUgcmVzZXJ2ZWRcbiAqIGJ5IHRoZSBydW50aW1lLlxuICovXG5jb25zdCByZXNlcnZlZE1lc3NhZ2VQcm9wZXJ0aWVzID0gbmV3IFNldChbXG4vLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZVxuXCJnZXRUeXBlXCIsIFwiY2xvbmVcIiwgXCJlcXVhbHNcIiwgXCJmcm9tQmluYXJ5XCIsIFwiZnJvbUpzb25cIiwgXCJmcm9tSnNvblN0cmluZ1wiLCBcInRvQmluYXJ5XCIsIFwidG9Kc29uXCIsIFwidG9Kc29uU3RyaW5nXCIsXG4vLyBuYW1lcyByZXNlcnZlZCBieSB0aGUgcnVudGltZSBmb3IgdGhlIGZ1dHVyZVxuXCJ0b09iamVjdFwiXSk7XG5jb25zdCBmYWxsYmFjayA9IG5hbWUgPT4gXCJcIi5jb25jYXQobmFtZSwgXCIkXCIpO1xuLyoqXG4gKiBXaWxsIHdyYXAgbmFtZXMgdGhhdCBhcmUgT2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzIG9yIG5hbWVzIHJlc2VydmVkXG4gKiBmb3IgYE1lc3NhZ2Vgcy5cbiAqL1xuY29uc3Qgc2FmZU1lc3NhZ2VQcm9wZXJ0eSA9IG5hbWUgPT4ge1xuICBpZiAocmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcy5oYXMobmFtZSkpIHtcbiAgICByZXR1cm4gZmFsbGJhY2sobmFtZSk7XG4gIH1cbiAgcmV0dXJuIG5hbWU7XG59O1xuLyoqXG4gKiBOYW1lcyB0aGF0IGNhbm5vdCBiZSB1c2VkIGZvciBvYmplY3QgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgYXJlIHJlc2VydmVkXG4gKiBieSBidWlsdC1pbiBKYXZhU2NyaXB0IHByb3BlcnRpZXMuXG4gKi9cbmNvbnN0IHNhZmVPYmplY3RQcm9wZXJ0eSA9IG5hbWUgPT4ge1xuICBpZiAocmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzLmhhcyhuYW1lKSkge1xuICAgIHJldHVybiBmYWxsYmFjayhuYW1lKTtcbiAgfVxuICByZXR1cm4gbmFtZTtcbn07XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG5jbGFzcyBJbnRlcm5hbE9uZW9mSW5mbyB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICB0aGlzLmtpbmQgPSBcIm9uZW9mXCI7XG4gICAgdGhpcy5yZXBlYXRlZCA9IGZhbHNlO1xuICAgIHRoaXMucGFja2VkID0gZmFsc2U7XG4gICAgdGhpcy5vcHQgPSBmYWxzZTtcbiAgICB0aGlzLnJlcSA9IGZhbHNlO1xuICAgIHRoaXMuZGVmYXVsdCA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLmZpZWxkcyA9IFtdO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE9uZW9mTmFtZShuYW1lKTtcbiAgfVxuICBhZGRGaWVsZChmaWVsZCkge1xuICAgIGFzc2VydChmaWVsZC5vbmVvZiA9PT0gdGhpcywgXCJmaWVsZCBcIi5jb25jYXQoZmllbGQubmFtZSwgXCIgbm90IG9uZSBvZiBcIikuY29uY2F0KHRoaXMubmFtZSkpO1xuICAgIHRoaXMuZmllbGRzLnB1c2goZmllbGQpO1xuICB9XG4gIGZpbmRGaWVsZChsb2NhbE5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX2xvb2t1cCkge1xuICAgICAgdGhpcy5fbG9va3VwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5maWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy5fbG9va3VwW3RoaXMuZmllbGRzW2ldLmxvY2FsTmFtZV0gPSB0aGlzLmZpZWxkc1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2xvb2t1cFtsb2NhbE5hbWVdO1xuICB9XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIENvbnZlcnQgYSBjb2xsZWN0aW9uIG9mIGZpZWxkIGluZm8gdG8gYW4gYXJyYXkgb2Ygbm9ybWFsaXplZCBGaWVsZEluZm8uXG4gKlxuICogVGhlIGFyZ3VtZW50IGBwYWNrZWRCeURlZmF1bHRgIHNwZWNpZmllcyB3aGV0aGVyIGZpZWxkcyB0aGF0IGRvIG5vdCBzcGVjaWZ5XG4gKiBgcGFja2VkYCBzaG91bGQgYmUgcGFja2VkIChwcm90bzMpIG9yIHVucGFja2VkIChwcm90bzIpLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVGaWVsZEluZm9zKGZpZWxkSW5mb3MsIHBhY2tlZEJ5RGVmYXVsdCkge1xuICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZjtcbiAgY29uc3QgciA9IFtdO1xuICBsZXQgbztcbiAgZm9yIChjb25zdCBmaWVsZCBvZiB0eXBlb2YgZmllbGRJbmZvcyA9PSBcImZ1bmN0aW9uXCIgPyBmaWVsZEluZm9zKCkgOiBmaWVsZEluZm9zKSB7XG4gICAgY29uc3QgZiA9IGZpZWxkO1xuICAgIGYubG9jYWxOYW1lID0gbG9jYWxGaWVsZE5hbWUoZmllbGQubmFtZSwgZmllbGQub25lb2YgIT09IHVuZGVmaW5lZCk7XG4gICAgZi5qc29uTmFtZSA9IChfYSA9IGZpZWxkLmpzb25OYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBmaWVsZEpzb25OYW1lKGZpZWxkLm5hbWUpO1xuICAgIGYucmVwZWF0ZWQgPSAoX2IgPSBmaWVsZC5yZXBlYXRlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gICAgaWYgKGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIikge1xuICAgICAgZi5MID0gKF9jID0gZmllbGQuTCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogTG9uZ1R5cGUuQklHSU5UO1xuICAgIH1cbiAgICBmLmRlbGltaXRlZCA9IChfZCA9IGZpZWxkLmRlbGltaXRlZCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogZmFsc2U7XG4gICAgZi5yZXEgPSAoX2UgPSBmaWVsZC5yZXEpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IGZhbHNlO1xuICAgIGYub3B0ID0gKF9mID0gZmllbGQub3B0KSAhPT0gbnVsbCAmJiBfZiAhPT0gdm9pZCAwID8gX2YgOiBmYWxzZTtcbiAgICBpZiAoZmllbGQucGFja2VkID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgZi5wYWNrZWQgPSBmaWVsZC5raW5kID09IFwiZW51bVwiIHx8IGZpZWxkLmtpbmQgPT0gXCJzY2FsYXJcIiAmJiBmaWVsZC5UICE9IFNjYWxhclR5cGUuQllURVMgJiYgZmllbGQuVCAhPSBTY2FsYXJUeXBlLlNUUklORztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gV2UgZG8gbm90IHN1cmZhY2Ugb3B0aW9ucyBhdCB0aGlzIHRpbWVcbiAgICAvLyBmLm9wdGlvbnMgPSBmaWVsZC5vcHRpb25zID8/IGVtcHR5UmVhZG9ubHlPYmplY3Q7XG4gICAgaWYgKGZpZWxkLm9uZW9mICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IG9vbmFtZSA9IHR5cGVvZiBmaWVsZC5vbmVvZiA9PSBcInN0cmluZ1wiID8gZmllbGQub25lb2YgOiBmaWVsZC5vbmVvZi5uYW1lO1xuICAgICAgaWYgKCFvIHx8IG8ubmFtZSAhPSBvb25hbWUpIHtcbiAgICAgICAgbyA9IG5ldyBJbnRlcm5hbE9uZW9mSW5mbyhvb25hbWUpO1xuICAgICAgfVxuICAgICAgZi5vbmVvZiA9IG87XG4gICAgICBvLmFkZEZpZWxkKGYpO1xuICAgIH1cbiAgICByLnB1c2goZik7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbi8vIENvcHlyaWdodCAyMDIxLTIwMjQgQnVmIFRlY2hub2xvZ2llcywgSW5jLlxuLy9cbi8vIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4vLyB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4vLyBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbi8vXG4vLyAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuLy9cbi8vIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbi8vIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbi8vIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuLy8gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuLy8gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4vKipcbiAqIFByb3ZpZGVzIGZ1bmN0aW9uYWxpdHkgZm9yIG1lc3NhZ2VzIGRlZmluZWQgd2l0aCB0aGUgcHJvdG8zIHN5bnRheC5cbiAqL1xuY29uc3QgcHJvdG8zID0gbWFrZVByb3RvUnVudGltZShcInByb3RvM1wiLCBmaWVsZHMgPT4ge1xuICByZXR1cm4gbmV3IEludGVybmFsRmllbGRMaXN0KGZpZWxkcywgc291cmNlID0+IG5vcm1hbGl6ZUZpZWxkSW5mb3Moc291cmNlKSk7XG59LFxuLy8gVE9ETyBtZXJnZSB3aXRoIHByb3RvMiBhbmQgaW5pdEV4dGVuc2lvbkZpZWxkLCBhbHNvIHNlZSBpbml0UGFydGlhbCwgZXF1YWxzLCBjbG9uZVxudGFyZ2V0ID0+IHtcbiAgZm9yIChjb25zdCBtZW1iZXIgb2YgdGFyZ2V0LmdldFR5cGUoKS5maWVsZHMuYnlNZW1iZXIoKSkge1xuICAgIGlmIChtZW1iZXIub3B0KSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IG1lbWJlci5sb2NhbE5hbWUsXG4gICAgICB0ID0gdGFyZ2V0O1xuICAgIGlmIChtZW1iZXIucmVwZWF0ZWQpIHtcbiAgICAgIHRbbmFtZV0gPSBbXTtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKG1lbWJlci5raW5kKSB7XG4gICAgICBjYXNlIFwib25lb2ZcIjpcbiAgICAgICAgdFtuYW1lXSA9IHtcbiAgICAgICAgICBjYXNlOiB1bmRlZmluZWRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgICB0W25hbWVdID0gMDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwibWFwXCI6XG4gICAgICAgIHRbbmFtZV0gPSB7fTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwic2NhbGFyXCI6XG4gICAgICAgIHRbbmFtZV0gPSBzY2FsYXJaZXJvVmFsdWUobWVtYmVyLlQsIG1lbWJlci5MKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59KTtcblxuLy8gQ29weXJpZ2h0IDIwMjEtMjAyNCBCdWYgVGVjaG5vbG9naWVzLCBJbmMuXG4vL1xuLy8gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbi8vIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbi8vIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuLy9cbi8vICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4vL1xuLy8gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuLy8gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuLy8gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4vLyBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4vLyBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbi8qKlxuICogQSBUaW1lc3RhbXAgcmVwcmVzZW50cyBhIHBvaW50IGluIHRpbWUgaW5kZXBlbmRlbnQgb2YgYW55IHRpbWUgem9uZSBvciBsb2NhbFxuICogY2FsZW5kYXIsIGVuY29kZWQgYXMgYSBjb3VudCBvZiBzZWNvbmRzIGFuZCBmcmFjdGlvbnMgb2Ygc2Vjb25kcyBhdFxuICogbmFub3NlY29uZCByZXNvbHV0aW9uLiBUaGUgY291bnQgaXMgcmVsYXRpdmUgdG8gYW4gZXBvY2ggYXQgVVRDIG1pZG5pZ2h0IG9uXG4gKiBKYW51YXJ5IDEsIDE5NzAsIGluIHRoZSBwcm9sZXB0aWMgR3JlZ29yaWFuIGNhbGVuZGFyIHdoaWNoIGV4dGVuZHMgdGhlXG4gKiBHcmVnb3JpYW4gY2FsZW5kYXIgYmFja3dhcmRzIHRvIHllYXIgb25lLlxuICpcbiAqIEFsbCBtaW51dGVzIGFyZSA2MCBzZWNvbmRzIGxvbmcuIExlYXAgc2Vjb25kcyBhcmUgXCJzbWVhcmVkXCIgc28gdGhhdCBubyBsZWFwXG4gKiBzZWNvbmQgdGFibGUgaXMgbmVlZGVkIGZvciBpbnRlcnByZXRhdGlvbiwgdXNpbmcgYSBbMjQtaG91ciBsaW5lYXJcbiAqIHNtZWFyXShodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS90aW1lL3NtZWFyKS5cbiAqXG4gKiBUaGUgcmFuZ2UgaXMgZnJvbSAwMDAxLTAxLTAxVDAwOjAwOjAwWiB0byA5OTk5LTEyLTMxVDIzOjU5OjU5Ljk5OTk5OTk5OVouIEJ5XG4gKiByZXN0cmljdGluZyB0byB0aGF0IHJhbmdlLCB3ZSBlbnN1cmUgdGhhdCB3ZSBjYW4gY29udmVydCB0byBhbmQgZnJvbSBbUkZDXG4gKiAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGRhdGUgc3RyaW5ncy5cbiAqXG4gKiAjIEV4YW1wbGVzXG4gKlxuICogRXhhbXBsZSAxOiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIFBPU0lYIGB0aW1lKClgLlxuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcyh0aW1lKE5VTEwpKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKDApO1xuICpcbiAqIEV4YW1wbGUgMjogQ29tcHV0ZSBUaW1lc3RhbXAgZnJvbSBQT1NJWCBgZ2V0dGltZW9mZGF5KClgLlxuICpcbiAqICAgICBzdHJ1Y3QgdGltZXZhbCB0djtcbiAqICAgICBnZXR0aW1lb2ZkYXkoJnR2LCBOVUxMKTtcbiAqXG4gKiAgICAgVGltZXN0YW1wIHRpbWVzdGFtcDtcbiAqICAgICB0aW1lc3RhbXAuc2V0X3NlY29uZHModHYudHZfc2VjKTtcbiAqICAgICB0aW1lc3RhbXAuc2V0X25hbm9zKHR2LnR2X3VzZWMgKiAxMDAwKTtcbiAqXG4gKiBFeGFtcGxlIDM6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gV2luMzIgYEdldFN5c3RlbVRpbWVBc0ZpbGVUaW1lKClgLlxuICpcbiAqICAgICBGSUxFVElNRSBmdDtcbiAqICAgICBHZXRTeXN0ZW1UaW1lQXNGaWxlVGltZSgmZnQpO1xuICogICAgIFVJTlQ2NCB0aWNrcyA9ICgoKFVJTlQ2NClmdC5kd0hpZ2hEYXRlVGltZSkgPDwgMzIpIHwgZnQuZHdMb3dEYXRlVGltZTtcbiAqXG4gKiAgICAgLy8gQSBXaW5kb3dzIHRpY2sgaXMgMTAwIG5hbm9zZWNvbmRzLiBXaW5kb3dzIGVwb2NoIDE2MDEtMDEtMDFUMDA6MDA6MDBaXG4gKiAgICAgLy8gaXMgMTE2NDQ0NzM2MDAgc2Vjb25kcyBiZWZvcmUgVW5peCBlcG9jaCAxOTcwLTAxLTAxVDAwOjAwOjAwWi5cbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wO1xuICogICAgIHRpbWVzdGFtcC5zZXRfc2Vjb25kcygoSU5UNjQpICgodGlja3MgLyAxMDAwMDAwMCkgLSAxMTY0NDQ3MzYwMExMKSk7XG4gKiAgICAgdGltZXN0YW1wLnNldF9uYW5vcygoSU5UMzIpICgodGlja3MgJSAxMDAwMDAwMCkgKiAxMDApKTtcbiAqXG4gKiBFeGFtcGxlIDQ6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gSmF2YSBgU3lzdGVtLmN1cnJlbnRUaW1lTWlsbGlzKClgLlxuICpcbiAqICAgICBsb25nIG1pbGxpcyA9IFN5c3RlbS5jdXJyZW50VGltZU1pbGxpcygpO1xuICpcbiAqICAgICBUaW1lc3RhbXAgdGltZXN0YW1wID0gVGltZXN0YW1wLm5ld0J1aWxkZXIoKS5zZXRTZWNvbmRzKG1pbGxpcyAvIDEwMDApXG4gKiAgICAgICAgIC5zZXROYW5vcygoaW50KSAoKG1pbGxpcyAlIDEwMDApICogMTAwMDAwMCkpLmJ1aWxkKCk7XG4gKlxuICogRXhhbXBsZSA1OiBDb21wdXRlIFRpbWVzdGFtcCBmcm9tIEphdmEgYEluc3RhbnQubm93KClgLlxuICpcbiAqICAgICBJbnN0YW50IG5vdyA9IEluc3RhbnQubm93KCk7XG4gKlxuICogICAgIFRpbWVzdGFtcCB0aW1lc3RhbXAgPVxuICogICAgICAgICBUaW1lc3RhbXAubmV3QnVpbGRlcigpLnNldFNlY29uZHMobm93LmdldEVwb2NoU2Vjb25kKCkpXG4gKiAgICAgICAgICAgICAuc2V0TmFub3Mobm93LmdldE5hbm8oKSkuYnVpbGQoKTtcbiAqXG4gKiBFeGFtcGxlIDY6IENvbXB1dGUgVGltZXN0YW1wIGZyb20gY3VycmVudCB0aW1lIGluIFB5dGhvbi5cbiAqXG4gKiAgICAgdGltZXN0YW1wID0gVGltZXN0YW1wKClcbiAqICAgICB0aW1lc3RhbXAuR2V0Q3VycmVudFRpbWUoKVxuICpcbiAqICMgSlNPTiBNYXBwaW5nXG4gKlxuICogSW4gSlNPTiBmb3JtYXQsIHRoZSBUaW1lc3RhbXAgdHlwZSBpcyBlbmNvZGVkIGFzIGEgc3RyaW5nIGluIHRoZVxuICogW1JGQyAzMzM5XShodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjMzMzOS50eHQpIGZvcm1hdC4gVGhhdCBpcywgdGhlXG4gKiBmb3JtYXQgaXMgXCJ7eWVhcn0te21vbnRofS17ZGF5fVR7aG91cn06e21pbn06e3NlY31bLntmcmFjX3NlY31dWlwiXG4gKiB3aGVyZSB7eWVhcn0gaXMgYWx3YXlzIGV4cHJlc3NlZCB1c2luZyBmb3VyIGRpZ2l0cyB3aGlsZSB7bW9udGh9LCB7ZGF5fSxcbiAqIHtob3VyfSwge21pbn0sIGFuZCB7c2VjfSBhcmUgemVyby1wYWRkZWQgdG8gdHdvIGRpZ2l0cyBlYWNoLiBUaGUgZnJhY3Rpb25hbFxuICogc2Vjb25kcywgd2hpY2ggY2FuIGdvIHVwIHRvIDkgZGlnaXRzIChpLmUuIHVwIHRvIDEgbmFub3NlY29uZCByZXNvbHV0aW9uKSxcbiAqIGFyZSBvcHRpb25hbC4gVGhlIFwiWlwiIHN1ZmZpeCBpbmRpY2F0ZXMgdGhlIHRpbWV6b25lIChcIlVUQ1wiKTsgdGhlIHRpbWV6b25lXG4gKiBpcyByZXF1aXJlZC4gQSBwcm90bzMgSlNPTiBzZXJpYWxpemVyIHNob3VsZCBhbHdheXMgdXNlIFVUQyAoYXMgaW5kaWNhdGVkIGJ5XG4gKiBcIlpcIikgd2hlbiBwcmludGluZyB0aGUgVGltZXN0YW1wIHR5cGUgYW5kIGEgcHJvdG8zIEpTT04gcGFyc2VyIHNob3VsZCBiZVxuICogYWJsZSB0byBhY2NlcHQgYm90aCBVVEMgYW5kIG90aGVyIHRpbWV6b25lcyAoYXMgaW5kaWNhdGVkIGJ5IGFuIG9mZnNldCkuXG4gKlxuICogRm9yIGV4YW1wbGUsIFwiMjAxNy0wMS0xNVQwMTozMDoxNS4wMVpcIiBlbmNvZGVzIDE1LjAxIHNlY29uZHMgcGFzdFxuICogMDE6MzAgVVRDIG9uIEphbnVhcnkgMTUsIDIwMTcuXG4gKlxuICogSW4gSmF2YVNjcmlwdCwgb25lIGNhbiBjb252ZXJ0IGEgRGF0ZSBvYmplY3QgdG8gdGhpcyBmb3JtYXQgdXNpbmcgdGhlXG4gKiBzdGFuZGFyZFxuICogW3RvSVNPU3RyaW5nKCldKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL0RhdGUvdG9JU09TdHJpbmcpXG4gKiBtZXRob2QuIEluIFB5dGhvbiwgYSBzdGFuZGFyZCBgZGF0ZXRpbWUuZGF0ZXRpbWVgIG9iamVjdCBjYW4gYmUgY29udmVydGVkXG4gKiB0byB0aGlzIGZvcm1hdCB1c2luZ1xuICogW2BzdHJmdGltZWBdKGh0dHBzOi8vZG9jcy5weXRob24ub3JnLzIvbGlicmFyeS90aW1lLmh0bWwjdGltZS5zdHJmdGltZSkgd2l0aFxuICogdGhlIHRpbWUgZm9ybWF0IHNwZWMgJyVZLSVtLSVkVCVIOiVNOiVTLiVmWicuIExpa2V3aXNlLCBpbiBKYXZhLCBvbmUgY2FuIHVzZVxuICogdGhlIEpvZGEgVGltZSdzIFtgSVNPRGF0ZVRpbWVGb3JtYXQuZGF0ZVRpbWUoKWBdKFxuICogaHR0cDovL2pvZGEtdGltZS5zb3VyY2Vmb3JnZS5uZXQvYXBpZG9jcy9vcmcvam9kYS90aW1lL2Zvcm1hdC9JU09EYXRlVGltZUZvcm1hdC5odG1sI2RhdGVUaW1lKClcbiAqICkgdG8gb2J0YWluIGEgZm9ybWF0dGVyIGNhcGFibGUgb2YgZ2VuZXJhdGluZyB0aW1lc3RhbXBzIGluIHRoaXMgZm9ybWF0LlxuICpcbiAqXG4gKiBAZ2VuZXJhdGVkIGZyb20gbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wXG4gKi9cbmNsYXNzIFRpbWVzdGFtcCBleHRlbmRzIE1lc3NhZ2Uge1xuICBjb25zdHJ1Y3RvcihkYXRhKSB7XG4gICAgc3VwZXIoKTtcbiAgICAvKipcbiAgICAgKiBSZXByZXNlbnRzIHNlY29uZHMgb2YgVVRDIHRpbWUgc2luY2UgVW5peCBlcG9jaFxuICAgICAqIDE5NzAtMDEtMDFUMDA6MDA6MDBaLiBNdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG9cbiAgICAgKiA5OTk5LTEyLTMxVDIzOjU5OjU5WiBpbmNsdXNpdmUuXG4gICAgICpcbiAgICAgKiBAZ2VuZXJhdGVkIGZyb20gZmllbGQ6IGludDY0IHNlY29uZHMgPSAxO1xuICAgICAqL1xuICAgIHRoaXMuc2Vjb25kcyA9IHByb3RvSW50NjQuemVybztcbiAgICAvKipcbiAgICAgKiBOb24tbmVnYXRpdmUgZnJhY3Rpb25zIG9mIGEgc2Vjb25kIGF0IG5hbm9zZWNvbmQgcmVzb2x1dGlvbi4gTmVnYXRpdmVcbiAgICAgKiBzZWNvbmQgdmFsdWVzIHdpdGggZnJhY3Rpb25zIG11c3Qgc3RpbGwgaGF2ZSBub24tbmVnYXRpdmUgbmFub3MgdmFsdWVzXG4gICAgICogdGhhdCBjb3VudCBmb3J3YXJkIGluIHRpbWUuIE11c3QgYmUgZnJvbSAwIHRvIDk5OSw5OTksOTk5XG4gICAgICogaW5jbHVzaXZlLlxuICAgICAqXG4gICAgICogQGdlbmVyYXRlZCBmcm9tIGZpZWxkOiBpbnQzMiBuYW5vcyA9IDI7XG4gICAgICovXG4gICAgdGhpcy5uYW5vcyA9IDA7XG4gICAgcHJvdG8zLnV0aWwuaW5pdFBhcnRpYWwoZGF0YSwgdGhpcyk7XG4gIH1cbiAgZnJvbUpzb24oanNvbiwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YganNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiY2Fubm90IGRlY29kZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogXCIuY29uY2F0KHByb3RvMy5qc29uLmRlYnVnKGpzb24pKSk7XG4gICAgfVxuICAgIGNvbnN0IG1hdGNoZXMgPSBqc29uLm1hdGNoKC9eKFswLTldezR9KS0oWzAtOV17Mn0pLShbMC05XXsyfSlUKFswLTldezJ9KTooWzAtOV17Mn0pOihbMC05XXsyfSkoPzpafFxcLihbMC05XXszLDl9KVp8KFsrLV1bMC05XVswLTldOlswLTldWzAtOV0pKSQvKTtcbiAgICBpZiAoIW1hdGNoZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IGludmFsaWQgUkZDIDMzMzkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBjb25zdCBtcyA9IERhdGUucGFyc2UobWF0Y2hlc1sxXSArIFwiLVwiICsgbWF0Y2hlc1syXSArIFwiLVwiICsgbWF0Y2hlc1szXSArIFwiVFwiICsgbWF0Y2hlc1s0XSArIFwiOlwiICsgbWF0Y2hlc1s1XSArIFwiOlwiICsgbWF0Y2hlc1s2XSArIChtYXRjaGVzWzhdID8gbWF0Y2hlc1s4XSA6IFwiWlwiKSk7XG4gICAgaWYgKE51bWJlci5pc05hTihtcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCBmcm9tIEpTT046IGludmFsaWQgUkZDIDMzMzkgc3RyaW5nXCIpO1xuICAgIH1cbiAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZWNvZGUgbWVzc2FnZSBnb29nbGUucHJvdG9idWYuVGltZXN0YW1wIGZyb20gSlNPTjogbXVzdCBiZSBmcm9tIDAwMDEtMDEtMDFUMDA6MDA6MDBaIHRvIDk5OTktMTItMzFUMjM6NTk6NTlaIGluY2x1c2l2ZVwiKTtcbiAgICB9XG4gICAgdGhpcy5zZWNvbmRzID0gcHJvdG9JbnQ2NC5wYXJzZShtcyAvIDEwMDApO1xuICAgIHRoaXMubmFub3MgPSAwO1xuICAgIGlmIChtYXRjaGVzWzddKSB7XG4gICAgICB0aGlzLm5hbm9zID0gcGFyc2VJbnQoXCIxXCIgKyBtYXRjaGVzWzddICsgXCIwXCIucmVwZWF0KDkgLSBtYXRjaGVzWzddLmxlbmd0aCkpIC0gMTAwMDAwMDAwMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgdG9Kc29uKG9wdGlvbnMpIHtcbiAgICBjb25zdCBtcyA9IE51bWJlcih0aGlzLnNlY29uZHMpICogMTAwMDtcbiAgICBpZiAobXMgPCBEYXRlLnBhcnNlKFwiMDAwMS0wMS0wMVQwMDowMDowMFpcIikgfHwgbXMgPiBEYXRlLnBhcnNlKFwiOTk5OS0xMi0zMVQyMzo1OTo1OVpcIikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB0byBKU09OOiBtdXN0IGJlIGZyb20gMDAwMS0wMS0wMVQwMDowMDowMFogdG8gOTk5OS0xMi0zMVQyMzo1OTo1OVogaW5jbHVzaXZlXCIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5uYW5vcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBlbmNvZGUgZ29vZ2xlLnByb3RvYnVmLlRpbWVzdGFtcCB0byBKU09OOiBuYW5vcyBtdXN0IG5vdCBiZSBuZWdhdGl2ZVwiKTtcbiAgICB9XG4gICAgbGV0IHogPSBcIlpcIjtcbiAgICBpZiAodGhpcy5uYW5vcyA+IDApIHtcbiAgICAgIGNvbnN0IG5hbm9zU3RyID0gKHRoaXMubmFub3MgKyAxMDAwMDAwMDAwKS50b1N0cmluZygpLnN1YnN0cmluZygxKTtcbiAgICAgIGlmIChuYW5vc1N0ci5zdWJzdHJpbmcoMykgPT09IFwiMDAwMDAwXCIpIHtcbiAgICAgICAgeiA9IFwiLlwiICsgbmFub3NTdHIuc3Vic3RyaW5nKDAsIDMpICsgXCJaXCI7XG4gICAgICB9IGVsc2UgaWYgKG5hbm9zU3RyLnN1YnN0cmluZyg2KSA9PT0gXCIwMDBcIikge1xuICAgICAgICB6ID0gXCIuXCIgKyBuYW5vc1N0ci5zdWJzdHJpbmcoMCwgNikgKyBcIlpcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHogPSBcIi5cIiArIG5hbm9zU3RyICsgXCJaXCI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShtcykudG9JU09TdHJpbmcoKS5yZXBsYWNlKFwiLjAwMFpcIiwgeik7XG4gIH1cbiAgdG9EYXRlKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOdW1iZXIodGhpcy5zZWNvbmRzKSAqIDEwMDAgKyBNYXRoLmNlaWwodGhpcy5uYW5vcyAvIDEwMDAwMDApKTtcbiAgfVxuICBzdGF0aWMgbm93KCkge1xuICAgIHJldHVybiBUaW1lc3RhbXAuZnJvbURhdGUobmV3IERhdGUoKSk7XG4gIH1cbiAgc3RhdGljIGZyb21EYXRlKGRhdGUpIHtcbiAgICBjb25zdCBtcyA9IGRhdGUuZ2V0VGltZSgpO1xuICAgIHJldHVybiBuZXcgVGltZXN0YW1wKHtcbiAgICAgIHNlY29uZHM6IHByb3RvSW50NjQucGFyc2UoTWF0aC5mbG9vcihtcyAvIDEwMDApKSxcbiAgICAgIG5hbm9zOiBtcyAlIDEwMDAgKiAxMDAwMDAwXG4gICAgfSk7XG4gIH1cbiAgc3RhdGljIGZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21CaW5hcnkoYnl0ZXMsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBmcm9tSnNvbihqc29uVmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uKGpzb25WYWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgc3RhdGljIGZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFRpbWVzdGFtcCgpLmZyb21Kc29uU3RyaW5nKGpzb25TdHJpbmcsIG9wdGlvbnMpO1xuICB9XG4gIHN0YXRpYyBlcXVhbHMoYSwgYikge1xuICAgIHJldHVybiBwcm90bzMudXRpbC5lcXVhbHMoVGltZXN0YW1wLCBhLCBiKTtcbiAgfVxufVxuVGltZXN0YW1wLnJ1bnRpbWUgPSBwcm90bzM7XG5UaW1lc3RhbXAudHlwZU5hbWUgPSBcImdvb2dsZS5wcm90b2J1Zi5UaW1lc3RhbXBcIjtcblRpbWVzdGFtcC5maWVsZHMgPSBwcm90bzMudXRpbC5uZXdGaWVsZExpc3QoKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2Vjb25kc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwibmFub3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59XSk7XG5cbmNvbnN0IE1ldHJpY3NCYXRjaCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk1ldHJpY3NCYXRjaFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RyX2RhdGFcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidGltZV9zZXJpZXNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRpbWVTZXJpZXNNZXRyaWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImV2ZW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRXZlbnRNZXRyaWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUaW1lU2VyaWVzTWV0cmljID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVGltZVNlcmllc01ldHJpY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJsYWJlbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9pZGVudGl0eVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwic2FtcGxlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogTWV0cmljU2FtcGxlLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJyaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IE1ldHJpY1NhbXBsZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0Lk1ldHJpY1NhbXBsZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidmFsdWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMlxuICAvKiBTY2FsYXJUeXBlLkZMT0FUICovXG59XSk7XG5jb25zdCBFdmVudE1ldHJpYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkV2ZW50TWV0cmljXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImxhYmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzdGFydF90aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImVuZF90aW1lc3RhbXBfbXNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIm5vcm1hbGl6ZWRfc3RhcnRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXBcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwibm9ybWFsaXplZF9lbmRfdGltZXN0YW1wXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lc3RhbXAsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufV0pO1xuY29uc3QgQmFja3VwQ29kZWNQb2xpY3kkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQmFja3VwQ29kZWNQb2xpY3lcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUFJFRkVSX1JFR1JFU1NJT05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJTSU1VTENBU1RcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJSRUdSRVNTSU9OXCJcbn1dKTtcbmNvbnN0IFRyYWNrVHlwZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVHJhY2tUeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkFVRElPXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiVklERU9cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEQVRBXCJcbn1dKTtcbmNvbnN0IFRyYWNrU291cmNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5UcmFja1NvdXJjZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiQ0FNRVJBXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiTUlDUk9QSE9ORVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlNDUkVFTl9TSEFSRVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIlNDUkVFTl9TSEFSRV9BVURJT1wiXG59XSk7XG5jb25zdCBWaWRlb1F1YWxpdHkkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuVmlkZW9RdWFsaXR5XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkxPV1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk1FRElVTVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkhJR0hcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJPRkZcIlxufV0pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHkkMSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQ29ubmVjdGlvblF1YWxpdHlcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUE9PUlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkdPT0RcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJFWENFTExFTlRcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJMT1NUXCJcbn1dKTtcbmNvbnN0IENsaWVudENvbmZpZ1NldHRpbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNsaWVudENvbmZpZ1NldHRpbmdcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVU5TRVRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJESVNBQkxFRFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkVOQUJMRURcIlxufV0pO1xuY29uc3QgRGlzY29ubmVjdFJlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRGlzY29ubmVjdFJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJVTktOT1dOX1JFQVNPTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkNMSUVOVF9JTklUSUFURURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJEVVBMSUNBVEVfSURFTlRJVFlcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJTRVJWRVJfU0hVVERPV05cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJQQVJUSUNJUEFOVF9SRU1PVkVEXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiUk9PTV9ERUxFVEVEXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiU1RBVEVfTUlTTUFUQ0hcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJKT0lOX0ZBSUxVUkVcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJNSUdSQVRJT05cIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJTSUdOQUxfQ0xPU0VcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiUk9PTV9DTE9TRURcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiVVNFUl9VTkFWQUlMQUJMRVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJVU0VSX1JFSkVDVEVEXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcIlNJUF9UUlVOS19GQUlMVVJFXCJcbn1dKTtcbmNvbnN0IFJlY29ubmVjdFJlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUmVjb25uZWN0UmVhc29uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlJSX1VOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiUlJfUFVCTElTSEVSX0ZBSUxFRFwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlJSX1NVQlNDUklCRVJfRkFJTEVEXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiUlJfU1dJVENIX0NBTkRJREFURVwiXG59XSk7XG5jb25zdCBTdWJzY3JpcHRpb25FcnJvciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU3Vic2NyaXB0aW9uRXJyb3JcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiU0VfVU5LTk9XTlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlNFX0NPREVDX1VOU1VQUE9SVEVEXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiU0VfVFJBQ0tfTk9URk9VTkRcIlxufV0pO1xuY29uc3QgQXVkaW9UcmFja0ZlYXR1cmUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkF1ZGlvVHJhY2tGZWF0dXJlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlRGX1NURVJFT1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlRGX05PX0RUWFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlRGX0FVVE9fR0FJTl9DT05UUk9MXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiVEZfRUNIT19DQU5DRUxMQVRJT05cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJURl9OT0lTRV9TVVBQUkVTU0lPTlwiXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIlRGX0VOSEFOQ0VEX05PSVNFX0NBTkNFTExBVElPTlwiXG59XSk7XG5jb25zdCBSb29tJDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Sb29tXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJlbXB0eV90aW1lb3V0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxNCxcbiAgbmFtZTogXCJkZXBhcnR1cmVfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJtYXhfcGFydGljaXBhbnRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImNyZWF0aW9uX3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJjcmVhdGlvbl90aW1lX21zXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJ0dXJuX3Bhc3N3b3JkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZW5hYmxlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIm51bV9wYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm51bV9wdWJsaXNoZXJzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJhY3RpdmVfcmVjb3JkaW5nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lZFZlcnNpb25cbn1dKTtcbmNvbnN0IENvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ29kZWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibWltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImZtdHBfbGluZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBQYXJ0aWNpcGFudFBlcm1pc3Npb24gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFBlcm1pc3Npb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY2FuX3N1YnNjcmliZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJjYW5fcHVibGlzaFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjYW5fcHVibGlzaF9kYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImNhbl9wdWJsaXNoX3NvdXJjZXNcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShUcmFja1NvdXJjZSksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImhpZGRlblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJyZWNvcmRlclwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiY2FuX3VwZGF0ZV9tZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiYWdlbnRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcImNhbl9zdWJzY3JpYmVfbWV0cmljc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImlkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhdGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fU3RhdGUpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyYWNrc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImpvaW5lZF9hdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcImpvaW5lZF9hdF9tc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJwZXJtaXNzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFBlcm1pc3Npb25cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMyxcbiAgbmFtZTogXCJpc19wdWJsaXNoZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImtpbmRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShQYXJ0aWNpcGFudEluZm9fS2luZClcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn0sIHtcbiAgbm86IDE2LFxuICBuYW1lOiBcImRpc2Nvbm5lY3RfcmVhc29uXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoRGlzY29ubmVjdFJlYXNvbilcbn0sIHtcbiAgbm86IDE4LFxuICBuYW1lOiBcImtpbmRfZGV0YWlsc1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFBhcnRpY2lwYW50SW5mb19LaW5kRGV0YWlsKSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50SW5mb19TdGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUGFydGljaXBhbnRJbmZvLlN0YXRlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkpPSU5JTkdcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJKT0lORURcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJBQ1RJVkVcIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJESVNDT05ORUNURURcIlxufV0pO1xuY29uc3QgUGFydGljaXBhbnRJbmZvX0tpbmQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlBhcnRpY2lwYW50SW5mby5LaW5kXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlNUQU5EQVJEXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiSU5HUkVTU1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkVHUkVTU1wiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlNJUFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIkFHRU5UXCJcbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50SW5mb19LaW5kRGV0YWlsID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5QYXJ0aWNpcGFudEluZm8uS2luZERldGFpbFwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJDTE9VRF9BR0VOVFwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIkZPUldBUkRFRFwiXG59XSk7XG5jb25zdCBFbmNyeXB0aW9uX1R5cGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkVuY3J5cHRpb24uVHlwZVwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJOT05FXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiR0NNXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiQ1VTVE9NXCJcbn1dKTtcbmNvbnN0IFNpbXVsY2FzdENvZGVjSW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpbXVsY2FzdENvZGVjSW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBUcmFja0luZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja0luZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFRyYWNrVHlwZSlcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm11dGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJzaW11bGNhc3RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwic291cmNlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJtaW1lX3R5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwibWlkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcImNvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2ltdWxjYXN0Q29kZWNJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwic3RlcmVvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJkaXNhYmxlX3JlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwiZW5jcnlwdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEVuY3J5cHRpb25fVHlwZSlcbn0sIHtcbiAgbm86IDE3LFxuICBuYW1lOiBcInN0cmVhbVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUaW1lZFZlcnNpb25cbn0sIHtcbiAgbm86IDE5LFxuICBuYW1lOiBcImF1ZGlvX2ZlYXR1cmVzXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQXVkaW9UcmFja0ZlYXR1cmUpLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMjAsXG4gIG5hbWU6IFwiYmFja3VwX2NvZGVjX3BvbGljeVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEJhY2t1cENvZGVjUG9saWN5JDEpXG59XSk7XG5jb25zdCBWaWRlb0xheWVyID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVmlkZW9MYXllclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJiaXRyYXRlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInNzcmNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IERhdGFQYWNrZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhUGFja2V0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImtpbmRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShEYXRhUGFja2V0X0tpbmQpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZGVzdGluYXRpb25faWRlbnRpdGllc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ1c2VyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVc2VyUGFja2V0LFxuICBvbmVvZjogXCJ2YWx1ZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInNwZWFrZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEFjdGl2ZVNwZWFrZXJVcGRhdGUsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic2lwX2R0bWZcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpcERUTUYsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwidHJhbnNjcmlwdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhbnNjcmlwdGlvbixcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJtZXRyaWNzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNZXRyaWNzQmF0Y2gsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiY2hhdF9tZXNzYWdlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDaGF0TWVzc2FnZSxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwicnBjX3JlcXVlc3RcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY1JlcXVlc3QsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInJwY19hY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY0FjayxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMTIsXG4gIG5hbWU6IFwicnBjX3Jlc3BvbnNlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBScGNSZXNwb25zZSxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic3RyZWFtX2hlYWRlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YVN0cmVhbV9IZWFkZXIsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInN0cmVhbV9jaHVua1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGF0YVN0cmVhbV9DaHVuayxcbiAgb25lb2Y6IFwidmFsdWVcIlxufSwge1xuICBubzogMTUsXG4gIG5hbWU6IFwic3RyZWFtX3RyYWlsZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fVHJhaWxlcixcbiAgb25lb2Y6IFwidmFsdWVcIlxufV0pO1xuY29uc3QgRGF0YVBhY2tldF9LaW5kID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5EYXRhUGFja2V0LktpbmRcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiUkVMSUFCTEVcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJMT1NTWVwiXG59XSk7XG5jb25zdCBBY3RpdmVTcGVha2VyVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQWN0aXZlU3BlYWtlclVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzcGVha2Vyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3BlYWtlckluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTcGVha2VySW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNwZWFrZXJJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImxldmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhY3RpdmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFVzZXJQYWNrZXQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Vc2VyUGFja2V0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInBhcnRpY2lwYW50X3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcInBhcnRpY2lwYW50X2lkZW50aXR5XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicGF5bG9hZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxMlxuICAvKiBTY2FsYXJUeXBlLkJZVEVTICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRlc3RpbmF0aW9uX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGVzdGluYXRpb25faWRlbnRpdGllc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ0b3BpY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcInN0YXJ0X3RpbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNCxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJlbmRfdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0LFxuICBvcHQ6IHRydWVcbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm5vbmNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn1dKTtcbmNvbnN0IFNpcERUTUYgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaXBEVE1GXCIsICgpID0+IFt7XG4gIG5vOiAzLFxuICBuYW1lOiBcImNvZGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiZGlnaXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgVHJhbnNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYW5zY3JpcHRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhbnNjcmliZWRfcGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0cmFja19pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInNlZ21lbnRzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFuc2NyaXB0aW9uU2VnbWVudCxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFRyYW5zY3JpcHRpb25TZWdtZW50ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhbnNjcmlwdGlvblNlZ21lbnRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhcnRfdGltZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA0XG4gIC8qIFNjYWxhclR5cGUuVUlOVDY0ICovXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImVuZF90aW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDRcbiAgLyogU2NhbGFyVHlwZS5VSU5UNjQgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZmluYWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwibGFuZ3VhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgQ2hhdE1lc3NhZ2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5DaGF0TWVzc2FnZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZWRpdF90aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMyxcbiAgb3B0OiB0cnVlXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJkZWxldGVkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImdlbmVyYXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgUnBjUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY1JlcXVlc3RcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtZXRob2RcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXlsb2FkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicmVzcG9uc2VfdGltZW91dF9tc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJ2ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59XSk7XG5jb25zdCBScGNBY2sgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNBY2tcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVxdWVzdF9pZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBScGNSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJwY1Jlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlcXVlc3RfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXlsb2FkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9uZW9mOiBcInZhbHVlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiZXJyb3JcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJwY0Vycm9yJDEsXG4gIG9uZW9mOiBcInZhbHVlXCJcbn1dKTtcbmNvbnN0IFJwY0Vycm9yJDEgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5ScGNFcnJvclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkYXRhXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn1dKTtcbmNvbnN0IFBhcnRpY2lwYW50VHJhY2tzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGFydGljaXBhbnRUcmFja3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU2VydmVySW5mbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNlcnZlckluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiZWRpdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFNlcnZlckluZm9fRWRpdGlvbilcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInByb3RvY29sXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJyZWdpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJub2RlX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwiZGVidWdfaW5mb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA3LFxuICBuYW1lOiBcImFnZW50X3Byb3RvY29sXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufV0pO1xuY29uc3QgU2VydmVySW5mb19FZGl0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5TZXJ2ZXJJbmZvLkVkaXRpb25cIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiU3RhbmRhcmRcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJDbG91ZFwiXG59XSk7XG5jb25zdCBDbGllbnRJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQ2xpZW50SW5mb1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzZGtcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRJbmZvX1NESylcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInByb3RvY29sXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDVcbiAgLyogU2NhbGFyVHlwZS5JTlQzMiAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJvc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm9zX3ZlcnNpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNixcbiAgbmFtZTogXCJkZXZpY2VfbW9kZWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJicm93c2VyXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiYnJvd3Nlcl92ZXJzaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwiYWRkcmVzc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJuZXR3b3JrXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcIm90aGVyX3Nka3NcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgQ2xpZW50SW5mb19TREsgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LkNsaWVudEluZm8uU0RLXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlVOS05PV05cIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJKU1wiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIlNXSUZUXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiQU5EUk9JRFwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcIkZMVVRURVJcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJHT1wiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcIlVOSVRZXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiUkVBQ1RfTkFUSVZFXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiUlVTVFwiXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcIlBZVEhPTlwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJDUFBcIlxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwiVU5JVFlfV0VCXCJcbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcIk5PREVcIlxufV0pO1xuY29uc3QgQ2xpZW50Q29uZmlndXJhdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkNsaWVudENvbmZpZ3VyYXRpb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidmlkZW9cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvQ29uZmlndXJhdGlvblxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzY3JlZW5cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvQ29uZmlndXJhdGlvblxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJyZXN1bWVfY29ubmVjdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENsaWVudENvbmZpZ1NldHRpbmcpXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcImRpc2FibGVkX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogRGlzYWJsZWRDb2RlY3Ncbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiZm9yY2VfcmVsYXlcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufV0pO1xuY29uc3QgVmlkZW9Db25maWd1cmF0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVmlkZW9Db25maWd1cmF0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImhhcmR3YXJlX2VuY29kZXJcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShDbGllbnRDb25maWdTZXR0aW5nKVxufV0pO1xuY29uc3QgRGlzYWJsZWRDb2RlY3MgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EaXNhYmxlZENvZGVjc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwdWJsaXNoXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFRpbWVkVmVyc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRpbWVkVmVyc2lvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1bml4X21pY3JvXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aWNrc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn1dKTtcbmNvbnN0IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuRGF0YVN0cmVhbS5PcGVyYXRpb25UeXBlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkNSRUFURVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlVQREFURVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIkRFTEVURVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIlJFQUNUSU9OXCJcbn1dKTtcbmNvbnN0IERhdGFTdHJlYW1fVGV4dEhlYWRlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uVGV4dEhlYWRlclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJvcGVyYXRpb25fdHlwZVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZSlcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwicmVwbHlfdG9fc3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYXR0YWNoZWRfc3RyZWFtX2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJnZW5lcmF0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dLCB7XG4gIGxvY2FsTmFtZTogXCJEYXRhU3RyZWFtX1RleHRIZWFkZXJcIlxufSk7XG5jb25zdCBEYXRhU3RyZWFtX0J5dGVIZWFkZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLkJ5dGVIZWFkZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwibmFtZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSwge1xuICBsb2NhbE5hbWU6IFwiRGF0YVN0cmVhbV9CeXRlSGVhZGVyXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9IZWFkZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLkhlYWRlclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzdHJlYW1faWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRvcGljXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwibWltZV90eXBlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidG90YWxfbGVuZ3RoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDQsXG4gIG9wdDogdHJ1ZVxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJlbmNyeXB0aW9uX3R5cGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImF0dHJpYnV0ZXNcIixcbiAga2luZDogXCJtYXBcIixcbiAgSzogOSxcbiAgVjoge1xuICAgIGtpbmQ6IFwic2NhbGFyXCIsXG4gICAgVDogOVxuICAgIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG4gIH1cbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwidGV4dF9oZWFkZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fVGV4dEhlYWRlcixcbiAgb25lb2Y6IFwiY29udGVudF9oZWFkZXJcIlxufSwge1xuICBubzogMTAsXG4gIG5hbWU6IFwiYnl0ZV9oZWFkZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IERhdGFTdHJlYW1fQnl0ZUhlYWRlcixcbiAgb25lb2Y6IFwiY29udGVudF9oZWFkZXJcIlxufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fSGVhZGVyXCJcbn0pO1xuY29uc3QgRGF0YVN0cmVhbV9DaHVuayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkRhdGFTdHJlYW0uQ2h1bmtcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2h1bmtfaW5kZXhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNFxuICAvKiBTY2FsYXJUeXBlLlVJTlQ2NCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJjb250ZW50XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEyXG4gIC8qIFNjYWxhclR5cGUuQllURVMgKi9cbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwidmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwiaXZcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTIsXG4gIG9wdDogdHJ1ZVxufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fQ2h1bmtcIlxufSk7XG5jb25zdCBEYXRhU3RyZWFtX1RyYWlsZXIgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5EYXRhU3RyZWFtLlRyYWlsZXJcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicmVhc29uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYXR0cmlidXRlc1wiLFxuICBraW5kOiBcIm1hcFwiLFxuICBLOiA5LFxuICBWOiB7XG4gICAga2luZDogXCJzY2FsYXJcIixcbiAgICBUOiA5XG4gICAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbiAgfVxufV0sIHtcbiAgbG9jYWxOYW1lOiBcIkRhdGFTdHJlYW1fVHJhaWxlclwiXG59KTtcbmNvbnN0IFNpZ25hbFRhcmdldCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuU2lnbmFsVGFyZ2V0XCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIlBVQkxJU0hFUlwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlNVQlNDUklCRVJcIlxufV0pO1xuY29uc3QgU3RyZWFtU3RhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZUVudW0oXCJsaXZla2l0LlN0cmVhbVN0YXRlXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkFDVElWRVwiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIlBBVVNFRFwiXG59XSk7XG5jb25zdCBDYW5kaWRhdGVQcm90b2NvbCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuQ2FuZGlkYXRlUHJvdG9jb2xcIiwgW3tcbiAgbm86IDAsXG4gIG5hbWU6IFwiVURQXCJcbn0sIHtcbiAgbm86IDEsXG4gIG5hbWU6IFwiVENQXCJcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiVExTXCJcbn1dKTtcbmNvbnN0IFNpZ25hbFJlcXVlc3QgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TaWduYWxSZXF1ZXN0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbnN3ZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyaWNrbGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwiYWRkX3RyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBBZGRUcmFja1JlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJtdXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVTdWJzY3JpcHRpb24sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJ0cmFja19zZXR0aW5nXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVUcmFja1NldHRpbmdzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwibGVhdmVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IExlYXZlUmVxdWVzdCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMCxcbiAgbmFtZTogXCJ1cGRhdGVfbGF5ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBVcGRhdGVWaWRlb0xheWVycyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJzdWJzY3JpcHRpb25fcGVybWlzc2lvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzeW5jX3N0YXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTeW5jU3RhdGUsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic2ltdWxhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpbXVsYXRlU2NlbmFyaW8sXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwicGluZ1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInVwZGF0ZV9tZXRhZGF0YVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJwaW5nX3JlcVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGluZyxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNyxcbiAgbmFtZTogXCJ1cGRhdGVfYXVkaW9fdHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJ1cGRhdGVfdmlkZW9fdHJhY2tcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFVwZGF0ZUxvY2FsVmlkZW9UcmFjayxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59XSk7XG5jb25zdCBTaWduYWxSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpZ25hbFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImpvaW5cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IEpvaW5SZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwib2ZmZXJcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNlc3Npb25EZXNjcmlwdGlvbixcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInRyaWNrbGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyaWNrbGVSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDUsXG4gIG5hbWU6IFwidXBkYXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBQYXJ0aWNpcGFudFVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInRyYWNrX3B1Ymxpc2hlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQdWJsaXNoZWRSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiA4LFxuICBuYW1lOiBcImxlYXZlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBMZWF2ZVJlcXVlc3QsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJtdXRlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBNdXRlVHJhY2tSZXF1ZXN0LFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInNwZWFrZXJzX2NoYW5nZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJzQ2hhbmdlZCxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMSxcbiAgbmFtZTogXCJyb29tX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbVVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJjb25uZWN0aW9uX3F1YWxpdHlcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENvbm5lY3Rpb25RdWFsaXR5VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDEzLFxuICBuYW1lOiBcInN0cmVhbV9zdGF0ZV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN0cmVhbVN0YXRlVXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0eV91cGRhdGVcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRRdWFsaXR5VXBkYXRlLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn0sIHtcbiAgbm86IDE1LFxuICBuYW1lOiBcInN1YnNjcmlwdGlvbl9wZXJtaXNzaW9uX3VwZGF0ZVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxNixcbiAgbmFtZTogXCJyZWZyZXNoX3Rva2VuXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTcsXG4gIG5hbWU6IFwidHJhY2tfdW5wdWJsaXNoZWRcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAxOCxcbiAgbmFtZTogXCJwb25nXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMTksXG4gIG5hbWU6IFwicmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZWNvbm5lY3RSZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMCxcbiAgbmFtZTogXCJwb25nX3Jlc3BcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBvbmcsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjEsXG4gIG5hbWU6IFwic3Vic2NyaXB0aW9uX3Jlc3BvbnNlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpcHRpb25SZXNwb25zZSxcbiAgb25lb2Y6IFwibWVzc2FnZVwiXG59LCB7XG4gIG5vOiAyMixcbiAgbmFtZTogXCJyZXF1ZXN0X3Jlc3BvbnNlXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBSZXF1ZXN0UmVzcG9uc2UsXG4gIG9uZW9mOiBcIm1lc3NhZ2VcIlxufSwge1xuICBubzogMjMsXG4gIG5hbWU6IFwidHJhY2tfc3Vic2NyaWJlZFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tTdWJzY3JpYmVkLFxuICBvbmVvZjogXCJtZXNzYWdlXCJcbn1dKTtcbmNvbnN0IFNpbXVsY2FzdENvZGVjID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2ltdWxjYXN0Q29kZWNcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiY29kZWNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJjaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgQWRkVHJhY2tSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuQWRkVHJhY2tSZXF1ZXN0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJ0eXBlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tUeXBlKVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwibXV0ZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZGlzYWJsZV9kdHhcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwic291cmNlXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVHJhY2tTb3VyY2UpXG59LCB7XG4gIG5vOiA5LFxuICBuYW1lOiBcImxheWVyc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVmlkZW9MYXllcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInNpbXVsY2FzdF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNpbXVsY2FzdENvZGVjLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMTEsXG4gIG5hbWU6IFwic2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEyLFxuICBuYW1lOiBcInN0ZXJlb1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwiZGlzYWJsZV9yZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn0sIHtcbiAgbm86IDE0LFxuICBuYW1lOiBcImVuY3J5cHRpb25cIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShFbmNyeXB0aW9uX1R5cGUpXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJzdHJlYW1cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMTYsXG4gIG5hbWU6IFwiYmFja3VwX2NvZGVjX3BvbGljeVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEJhY2t1cENvZGVjUG9saWN5JDEpXG59XSk7XG5jb25zdCBUcmlja2xlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyaWNrbGVSZXF1ZXN0XCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNhbmRpZGF0ZUluaXRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0YXJnZXRcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTaWduYWxUYXJnZXQpXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImZpbmFsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59XSk7XG5jb25zdCBNdXRlVHJhY2tSZXF1ZXN0ID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuTXV0ZVRyYWNrUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJzaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJtdXRlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgSm9pblJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuSm9pblJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJvb21cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJvb20kMVxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJwYXJ0aWNpcGFudFwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm90aGVyX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUGFydGljaXBhbnRJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZXJ2ZXJfdmVyc2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcImljZV9zZXJ2ZXJzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBJQ0VTZXJ2ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmliZXJfcHJpbWFyeVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJhbHRlcm5hdGl2ZV91cmxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogOCxcbiAgbmFtZTogXCJjbGllbnRfY29uZmlndXJhdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ2xpZW50Q29uZmlndXJhdGlvblxufSwge1xuICBubzogOSxcbiAgbmFtZTogXCJzZXJ2ZXJfcmVnaW9uXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDEwLFxuICBuYW1lOiBcInBpbmdfdGltZW91dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA1XG4gIC8qIFNjYWxhclR5cGUuSU5UMzIgKi9cbn0sIHtcbiAgbm86IDExLFxuICBuYW1lOiBcInBpbmdfaW50ZXJ2YWxcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNVxuICAvKiBTY2FsYXJUeXBlLklOVDMyICovXG59LCB7XG4gIG5vOiAxMixcbiAgbmFtZTogXCJzZXJ2ZXJfaW5mb1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2VydmVySW5mb1xufSwge1xuICBubzogMTMsXG4gIG5hbWU6IFwic2lmX3RyYWlsZXJcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTJcbiAgLyogU2NhbGFyVHlwZS5CWVRFUyAqL1xufSwge1xuICBubzogMTQsXG4gIG5hbWU6IFwiZW5hYmxlZF9wdWJsaXNoX2NvZGVjc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogQ29kZWMsXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAxNSxcbiAgbmFtZTogXCJmYXN0X3B1Ymxpc2hcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFJlY29ubmVjdFJlc3BvbnNlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVjb25uZWN0UmVzcG9uc2VcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiaWNlX3NlcnZlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IElDRVNlcnZlcixcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiY2xpZW50X2NvbmZpZ3VyYXRpb25cIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IENsaWVudENvbmZpZ3VyYXRpb25cbn1dKTtcbmNvbnN0IFRyYWNrUHVibGlzaGVkUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5UcmFja1B1Ymxpc2hlZFJlc3BvbnNlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImNpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRyYWNrXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja0luZm9cbn1dKTtcbmNvbnN0IFRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrVW5wdWJsaXNoZWRSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgU2Vzc2lvbkRlc2NyaXB0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU2Vzc2lvbkRlc2NyaXB0aW9uXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInR5cGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJzZHBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgUGFydGljaXBhbnRVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5QYXJ0aWNpcGFudFVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudHNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50SW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFVwZGF0ZVN1YnNjcmlwdGlvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVN1YnNjcmlwdGlvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmliZVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF90cmFja3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFBhcnRpY2lwYW50VHJhY2tzLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgVXBkYXRlVHJhY2tTZXR0aW5ncyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZVRyYWNrU2V0dGluZ3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwidHJhY2tfc2lkc1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJkaXNhYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIndpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcImhlaWdodFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogNyxcbiAgbmFtZTogXCJmcHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwicHJpb3JpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IFVwZGF0ZUxvY2FsQXVkaW9UcmFjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZUxvY2FsQXVkaW9UcmFja1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJmZWF0dXJlc1wiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKEF1ZGlvVHJhY2tGZWF0dXJlKSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFVwZGF0ZUxvY2FsVmlkZW9UcmFjayA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlVwZGF0ZUxvY2FsVmlkZW9UcmFja1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ3aWR0aFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAxM1xuICAvKiBTY2FsYXJUeXBlLlVJTlQzMiAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJoZWlnaHRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IExlYXZlUmVxdWVzdCA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LkxlYXZlUmVxdWVzdFwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjYW5fcmVjb25uZWN0XCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJlYXNvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKERpc2Nvbm5lY3RSZWFzb24pXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImFjdGlvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKExlYXZlUmVxdWVzdF9BY3Rpb24pXG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInJlZ2lvbnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFJlZ2lvblNldHRpbmdzXG59XSk7XG5jb25zdCBMZWF2ZVJlcXVlc3RfQWN0aW9uID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VFbnVtKFwibGl2ZWtpdC5MZWF2ZVJlcXVlc3QuQWN0aW9uXCIsIFt7XG4gIG5vOiAwLFxuICBuYW1lOiBcIkRJU0NPTk5FQ1RcIlxufSwge1xuICBubzogMSxcbiAgbmFtZTogXCJSRVNVTUVcIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJSRUNPTk5FQ1RcIlxufV0pO1xuY29uc3QgVXBkYXRlVmlkZW9MYXllcnMgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5VcGRhdGVWaWRlb0xheWVyc1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJsYXllcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFZpZGVvTGF5ZXIsXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBVcGRhdGVQYXJ0aWNpcGFudE1ldGFkYXRhID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJtZXRhZGF0YVwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIm5hbWVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJhdHRyaWJ1dGVzXCIsXG4gIGtpbmQ6IFwibWFwXCIsXG4gIEs6IDksXG4gIFY6IHtcbiAgICBraW5kOiBcInNjYWxhclwiLFxuICAgIFQ6IDlcbiAgICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xuICB9XG59LCB7XG4gIG5vOiA0LFxuICBuYW1lOiBcInJlcXVlc3RfaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn1dKTtcbmNvbnN0IElDRVNlcnZlciA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LklDRVNlcnZlclwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1cmxzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDksXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVzZXJuYW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiY3JlZGVudGlhbFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5jb25zdCBTcGVha2Vyc0NoYW5nZWQgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TcGVha2Vyc0NoYW5nZWRcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcnNcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFNwZWFrZXJJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgUm9vbVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJvb21VcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicm9vbVwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUm9vbSQxXG59XSk7XG5jb25zdCBDb25uZWN0aW9uUXVhbGl0eUluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eUluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwicXVhbGl0eVwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKENvbm5lY3Rpb25RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInNjb3JlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDJcbiAgLyogU2NhbGFyVHlwZS5GTE9BVCAqL1xufV0pO1xuY29uc3QgQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Db25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ1cGRhdGVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBDb25uZWN0aW9uUXVhbGl0eUluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTdHJlYW1TdGF0ZUluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdHJlYW1TdGF0ZUluZm9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3RhdGVcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdHJlYW1TdGF0ZSlcbn1dKTtcbmNvbnN0IFN0cmVhbVN0YXRlVXBkYXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3RyZWFtU3RhdGVVcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3RyZWFtX3N0YXRlc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3RyZWFtU3RhdGVJbmZvLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3Vic2NyaWJlZFF1YWxpdHkgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpYmVkUXVhbGl0eVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJxdWFsaXR5XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoVmlkZW9RdWFsaXR5JDEpXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcImVuYWJsZWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOFxuICAvKiBTY2FsYXJUeXBlLkJPT0wgKi9cbn1dKTtcbmNvbnN0IFN1YnNjcmliZWRDb2RlYyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRDb2RlY1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJjb2RlY1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInF1YWxpdGllc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU3Vic2NyaWJlZFF1YWxpdHksXG4gIHJlcGVhdGVkOiB0cnVlXG59XSk7XG5jb25zdCBTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmliZWRfcXVhbGl0aWVzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTdWJzY3JpYmVkUXVhbGl0eSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwic3Vic2NyaWJlZF9jb2RlY3NcIixcbiAga2luZDogXCJtZXNzYWdlXCIsXG4gIFQ6IFN1YnNjcmliZWRDb2RlYyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFRyYWNrUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlRyYWNrUGVybWlzc2lvblwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJwYXJ0aWNpcGFudF9zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJhbGxfdHJhY2tzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDhcbiAgLyogU2NhbGFyVHlwZS5CT09MICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInRyYWNrX3NpZHNcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOSxcbiAgcmVwZWF0ZWQ6IHRydWVcbn0sIHtcbiAgbm86IDQsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfaWRlbnRpdHlcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uUGVybWlzc2lvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwiYWxsX3BhcnRpY2lwYW50c1wiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJ0cmFja19wZXJtaXNzaW9uc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVHJhY2tQZXJtaXNzaW9uLFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicGFydGljaXBhbnRfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwidHJhY2tfc2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiYWxsb3dlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4XG4gIC8qIFNjYWxhclR5cGUuQk9PTCAqL1xufV0pO1xuY29uc3QgU3luY1N0YXRlID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuU3luY1N0YXRlXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImFuc3dlclwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogU2Vzc2lvbkRlc2NyaXB0aW9uXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInN1YnNjcmlwdGlvblwiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogVXBkYXRlU3Vic2NyaXB0aW9uXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcInB1Ymxpc2hfdHJhY2tzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlLFxuICByZXBlYXRlZDogdHJ1ZVxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJkYXRhX2NoYW5uZWxzXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBEYXRhQ2hhbm5lbEluZm8sXG4gIHJlcGVhdGVkOiB0cnVlXG59LCB7XG4gIG5vOiA1LFxuICBuYW1lOiBcIm9mZmVyXCIsXG4gIGtpbmQ6IFwibWVzc2FnZVwiLFxuICBUOiBTZXNzaW9uRGVzY3JpcHRpb25cbn0sIHtcbiAgbm86IDYsXG4gIG5hbWU6IFwidHJhY2tfc2lkc19kaXNhYmxlZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5LFxuICByZXBlYXRlZDogdHJ1ZVxufV0pO1xuY29uc3QgRGF0YUNoYW5uZWxJbmZvID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuRGF0YUNoYW5uZWxJbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImxhYmVsXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDlcbiAgLyogU2NhbGFyVHlwZS5TVFJJTkcgKi9cbn0sIHtcbiAgbm86IDIsXG4gIG5hbWU6IFwiaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogMTNcbiAgLyogU2NhbGFyVHlwZS5VSU5UMzIgKi9cbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwidGFyZ2V0XCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoU2lnbmFsVGFyZ2V0KVxufV0pO1xuY29uc3QgU2ltdWxhdGVTY2VuYXJpbyA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlNpbXVsYXRlU2NlbmFyaW9cIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwic3BlYWtlcl91cGRhdGVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogNSxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogMixcbiAgbmFtZTogXCJub2RlX2ZhaWx1cmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogMyxcbiAgbmFtZTogXCJtaWdyYXRpb25cIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNCxcbiAgbmFtZTogXCJzZXJ2ZXJfbGVhdmVcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOCxcbiAgb25lb2Y6IFwic2NlbmFyaW9cIlxufSwge1xuICBubzogNSxcbiAgbmFtZTogXCJzd2l0Y2hfY2FuZGlkYXRlX3Byb3RvY29sXCIsXG4gIGtpbmQ6IFwiZW51bVwiLFxuICBUOiBwcm90bzMuZ2V0RW51bVR5cGUoQ2FuZGlkYXRlUHJvdG9jb2wpLFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59LCB7XG4gIG5vOiA2LFxuICBuYW1lOiBcInN1YnNjcmliZXJfYmFuZHdpZHRoXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDMsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDcsXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDgsXG4gIG5hbWU6IFwiZGlzY29ubmVjdF9zaWduYWxfb25fcmVzdW1lX25vX21lc3NhZ2VzXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDgsXG4gIG9uZW9mOiBcInNjZW5hcmlvXCJcbn0sIHtcbiAgbm86IDksXG4gIG5hbWU6IFwibGVhdmVfcmVxdWVzdF9mdWxsX3JlY29ubmVjdFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA4LFxuICBvbmVvZjogXCJzY2VuYXJpb1wiXG59XSk7XG5jb25zdCBQaW5nID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUGluZ1wiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJ0dFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn1dKTtcbmNvbnN0IFBvbmcgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5Qb25nXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcImxhc3RfcGluZ190aW1lc3RhbXBcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogM1xuICAvKiBTY2FsYXJUeXBlLklOVDY0ICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInRpbWVzdGFtcFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiAzXG4gIC8qIFNjYWxhclR5cGUuSU5UNjQgKi9cbn1dKTtcbmNvbnN0IFJlZ2lvblNldHRpbmdzID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuUmVnaW9uU2V0dGluZ3NcIiwgKCkgPT4gW3tcbiAgbm86IDEsXG4gIG5hbWU6IFwicmVnaW9uc1wiLFxuICBraW5kOiBcIm1lc3NhZ2VcIixcbiAgVDogUmVnaW9uSW5mbyxcbiAgcmVwZWF0ZWQ6IHRydWVcbn1dKTtcbmNvbnN0IFJlZ2lvbkluZm8gPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5SZWdpb25JbmZvXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInJlZ2lvblwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInVybFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcImRpc3RhbmNlXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDNcbiAgLyogU2NhbGFyVHlwZS5JTlQ2NCAqL1xufV0pO1xuY29uc3QgU3Vic2NyaXB0aW9uUmVzcG9uc2UgPSAvKiBAX19QVVJFX18gKi9wcm90bzMubWFrZU1lc3NhZ2VUeXBlKFwibGl2ZWtpdC5TdWJzY3JpcHRpb25SZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJ0cmFja19zaWRcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufSwge1xuICBubzogMixcbiAgbmFtZTogXCJlcnJcIixcbiAga2luZDogXCJlbnVtXCIsXG4gIFQ6IHByb3RvMy5nZXRFbnVtVHlwZShTdWJzY3JpcHRpb25FcnJvcilcbn1dKTtcbmNvbnN0IFJlcXVlc3RSZXNwb25zZSA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlTWVzc2FnZVR5cGUoXCJsaXZla2l0LlJlcXVlc3RSZXNwb25zZVwiLCAoKSA9PiBbe1xuICBubzogMSxcbiAgbmFtZTogXCJyZXF1ZXN0X2lkXCIsXG4gIGtpbmQ6IFwic2NhbGFyXCIsXG4gIFQ6IDEzXG4gIC8qIFNjYWxhclR5cGUuVUlOVDMyICovXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcInJlYXNvblwiLFxuICBraW5kOiBcImVudW1cIixcbiAgVDogcHJvdG8zLmdldEVudW1UeXBlKFJlcXVlc3RSZXNwb25zZV9SZWFzb24pXG59LCB7XG4gIG5vOiAzLFxuICBuYW1lOiBcIm1lc3NhZ2VcIixcbiAga2luZDogXCJzY2FsYXJcIixcbiAgVDogOVxuICAvKiBTY2FsYXJUeXBlLlNUUklORyAqL1xufV0pO1xuY29uc3QgUmVxdWVzdFJlc3BvbnNlX1JlYXNvbiA9IC8qIEBfX1BVUkVfXyAqL3Byb3RvMy5tYWtlRW51bShcImxpdmVraXQuUmVxdWVzdFJlc3BvbnNlLlJlYXNvblwiLCBbe1xuICBubzogMCxcbiAgbmFtZTogXCJPS1wiXG59LCB7XG4gIG5vOiAxLFxuICBuYW1lOiBcIk5PVF9GT1VORFwiXG59LCB7XG4gIG5vOiAyLFxuICBuYW1lOiBcIk5PVF9BTExPV0VEXCJcbn0sIHtcbiAgbm86IDMsXG4gIG5hbWU6IFwiTElNSVRfRVhDRUVERURcIlxufV0pO1xuY29uc3QgVHJhY2tTdWJzY3JpYmVkID0gLyogQF9fUFVSRV9fICovcHJvdG8zLm1ha2VNZXNzYWdlVHlwZShcImxpdmVraXQuVHJhY2tTdWJzY3JpYmVkXCIsICgpID0+IFt7XG4gIG5vOiAxLFxuICBuYW1lOiBcInRyYWNrX3NpZFwiLFxuICBraW5kOiBcInNjYWxhclwiLFxuICBUOiA5XG4gIC8qIFNjYWxhclR5cGUuU1RSSU5HICovXG59XSk7XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tQ2pzICh4KSB7XG5cdHJldHVybiB4ICYmIHguX19lc01vZHVsZSAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoeCwgJ2RlZmF1bHQnKSA/IHhbJ2RlZmF1bHQnXSA6IHg7XG59XG5cbnZhciBsb2dsZXZlbCQxID0ge2V4cG9ydHM6IHt9fTtcblxuLypcbiogbG9nbGV2ZWwgLSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWxcbipcbiogQ29weXJpZ2h0IChjKSAyMDEzIFRpbSBQZXJyeVxuKiBMaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4qL1xudmFyIGxvZ2xldmVsID0gbG9nbGV2ZWwkMS5leHBvcnRzO1xudmFyIGhhc1JlcXVpcmVkTG9nbGV2ZWw7XG5mdW5jdGlvbiByZXF1aXJlTG9nbGV2ZWwoKSB7XG4gIGlmIChoYXNSZXF1aXJlZExvZ2xldmVsKSByZXR1cm4gbG9nbGV2ZWwkMS5leHBvcnRzO1xuICBoYXNSZXF1aXJlZExvZ2xldmVsID0gMTtcbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcbiAgICAoZnVuY3Rpb24gKHJvb3QsIGRlZmluaXRpb24pIHtcblxuICAgICAgaWYgKG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZGVmaW5pdGlvbigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm9vdC5sb2cgPSBkZWZpbml0aW9uKCk7XG4gICAgICB9XG4gICAgfSkobG9nbGV2ZWwsIGZ1bmN0aW9uICgpIHtcblxuICAgICAgLy8gU2xpZ2h0bHkgZHViaW91cyB0cmlja3MgdG8gY3V0IGRvd24gbWluaW1pemVkIGZpbGUgc2l6ZVxuICAgICAgdmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIHZhciB1bmRlZmluZWRUeXBlID0gXCJ1bmRlZmluZWRcIjtcbiAgICAgIHZhciBpc0lFID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSAmJiB0eXBlb2Ygd2luZG93Lm5hdmlnYXRvciAhPT0gdW5kZWZpbmVkVHlwZSAmJiAvVHJpZGVudFxcL3xNU0lFIC8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCk7XG4gICAgICB2YXIgbG9nTWV0aG9kcyA9IFtcInRyYWNlXCIsIFwiZGVidWdcIiwgXCJpbmZvXCIsIFwid2FyblwiLCBcImVycm9yXCJdO1xuICAgICAgdmFyIF9sb2dnZXJzQnlOYW1lID0ge307XG4gICAgICB2YXIgZGVmYXVsdExvZ2dlciA9IG51bGw7XG5cbiAgICAgIC8vIENyb3NzLWJyb3dzZXIgYmluZCBlcXVpdmFsZW50IHRoYXQgd29ya3MgYXQgbGVhc3QgYmFjayB0byBJRTZcbiAgICAgIGZ1bmN0aW9uIGJpbmRNZXRob2Qob2JqLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIHZhciBtZXRob2QgPSBvYmpbbWV0aG9kTmFtZV07XG4gICAgICAgIGlmICh0eXBlb2YgbWV0aG9kLmJpbmQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICByZXR1cm4gbWV0aG9kLmJpbmQob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLmNhbGwobWV0aG9kLCBvYmopO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIE1pc3NpbmcgYmluZCBzaGltIG9yIElFOCArIE1vZGVybml6ciwgZmFsbGJhY2sgdG8gd3JhcHBpbmdcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuYXBwbHkobWV0aG9kLCBbb2JqLCBhcmd1bWVudHNdKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRyYWNlKCkgZG9lc24ndCBwcmludCB0aGUgbWVzc2FnZSBpbiBJRSwgc28gZm9yIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIHdyYXAgaXRcbiAgICAgIGZ1bmN0aW9uIHRyYWNlRm9ySUUoKSB7XG4gICAgICAgIGlmIChjb25zb2xlLmxvZykge1xuICAgICAgICAgIGlmIChjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gSW4gb2xkIElFLCBuYXRpdmUgY29uc29sZSBtZXRob2RzIHRoZW1zZWx2ZXMgZG9uJ3QgaGF2ZSBhcHBseSgpLlxuICAgICAgICAgICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmFwcGx5KGNvbnNvbGUubG9nLCBbY29uc29sZSwgYXJndW1lbnRzXSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb25zb2xlLnRyYWNlKSBjb25zb2xlLnRyYWNlKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIHRoZSBiZXN0IGxvZ2dpbmcgbWV0aG9kIHBvc3NpYmxlIGZvciB0aGlzIGVudlxuICAgICAgLy8gV2hlcmV2ZXIgcG9zc2libGUgd2Ugd2FudCB0byBiaW5kLCBub3Qgd3JhcCwgdG8gcHJlc2VydmUgc3RhY2sgdHJhY2VzXG4gICAgICBmdW5jdGlvbiByZWFsTWV0aG9kKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgaWYgKG1ldGhvZE5hbWUgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICBtZXRob2ROYW1lID0gJ2xvZyc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBObyBtZXRob2QgcG9zc2libGUsIGZvciBub3cgLSBmaXhlZCBsYXRlciBieSBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzXG4gICAgICAgIH0gZWxzZSBpZiAobWV0aG9kTmFtZSA9PT0gJ3RyYWNlJyAmJiBpc0lFKSB7XG4gICAgICAgICAgcmV0dXJuIHRyYWNlRm9ySUU7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZVttZXRob2ROYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGJpbmRNZXRob2QoY29uc29sZSwgbWV0aG9kTmFtZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29uc29sZS5sb2cgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBiaW5kTWV0aG9kKGNvbnNvbGUsICdsb2cnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm4gbm9vcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGVzZSBwcml2YXRlIGZ1bmN0aW9ucyBhbHdheXMgbmVlZCBgdGhpc2AgdG8gYmUgc2V0IHByb3Blcmx5XG5cbiAgICAgIGZ1bmN0aW9uIHJlcGxhY2VMb2dnaW5nTWV0aG9kcygpIHtcbiAgICAgICAgLypqc2hpbnQgdmFsaWR0aGlzOnRydWUgKi9cbiAgICAgICAgdmFyIGxldmVsID0gdGhpcy5nZXRMZXZlbCgpO1xuXG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGFjdHVhbCBtZXRob2RzLlxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxvZ01ldGhvZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgbWV0aG9kTmFtZSA9IGxvZ01ldGhvZHNbaV07XG4gICAgICAgICAgdGhpc1ttZXRob2ROYW1lXSA9IGkgPCBsZXZlbCA/IG5vb3AgOiB0aGlzLm1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgbGV2ZWwsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZWZpbmUgbG9nLmxvZyBhcyBhbiBhbGlhcyBmb3IgbG9nLmRlYnVnXG4gICAgICAgIHRoaXMubG9nID0gdGhpcy5kZWJ1ZztcblxuICAgICAgICAvLyBSZXR1cm4gYW55IGltcG9ydGFudCB3YXJuaW5ncy5cbiAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlID09PSB1bmRlZmluZWRUeXBlICYmIGxldmVsIDwgdGhpcy5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgcmV0dXJuIFwiTm8gY29uc29sZSBhdmFpbGFibGUgZm9yIGxvZ2dpbmdcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBJbiBvbGQgSUUgdmVyc2lvbnMsIHRoZSBjb25zb2xlIGlzbid0IHByZXNlbnQgdW50aWwgeW91IGZpcnN0IG9wZW4gaXQuXG4gICAgICAvLyBXZSBidWlsZCByZWFsTWV0aG9kKCkgcmVwbGFjZW1lbnRzIGhlcmUgdGhhdCByZWdlbmVyYXRlIGxvZ2dpbmcgbWV0aG9kc1xuICAgICAgZnVuY3Rpb24gZW5hYmxlTG9nZ2luZ1doZW5Db25zb2xlQXJyaXZlcyhtZXRob2ROYW1lKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSB1bmRlZmluZWRUeXBlKSB7XG4gICAgICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIHRoaXNbbWV0aG9kTmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIC8vIEJ5IGRlZmF1bHQsIHdlIHVzZSBjbG9zZWx5IGJvdW5kIHJlYWwgbWV0aG9kcyB3aGVyZXZlciBwb3NzaWJsZSwgYW5kXG4gICAgICAvLyBvdGhlcndpc2Ugd2Ugd2FpdCBmb3IgYSBjb25zb2xlIHRvIGFwcGVhciwgYW5kIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgZnVuY3Rpb24gZGVmYXVsdE1ldGhvZEZhY3RvcnkobWV0aG9kTmFtZSwgX2xldmVsLCBfbG9nZ2VyTmFtZSkge1xuICAgICAgICAvKmpzaGludCB2YWxpZHRoaXM6dHJ1ZSAqL1xuICAgICAgICByZXR1cm4gcmVhbE1ldGhvZChtZXRob2ROYW1lKSB8fCBlbmFibGVMb2dnaW5nV2hlbkNvbnNvbGVBcnJpdmVzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBMb2dnZXIobmFtZSwgZmFjdG9yeSkge1xuICAgICAgICAvLyBQcml2YXRlIGluc3RhbmNlIHZhcmlhYmxlcy5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGxldmVsIGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IGxvZ2dlciAob3IgYSBnbG9iYWwgZGVmYXVsdCkuIFdlXG4gICAgICAgICAqIGNhY2hlIHRoaXMgaGVyZSByYXRoZXIgdGhhbiBkZWxlZ2F0aW5nIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBzdGF5c1xuICAgICAgICAgKiBpbiBzeW5jIHdpdGggdGhlIGFjdHVhbCBsb2dnaW5nIG1ldGhvZHMgdGhhdCB3ZSBoYXZlIGluc3RhbGxlZCAodGhlXG4gICAgICAgICAqIHBhcmVudCBjb3VsZCBjaGFuZ2UgbGV2ZWxzIGJ1dCB3ZSBtaWdodCBub3QgaGF2ZSByZWJ1aWx0IHRoZSBsb2dnZXJzXG4gICAgICAgICAqIGluIHRoaXMgY2hpbGQgeWV0KS5cbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBpbmhlcml0ZWRMZXZlbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBkZWZhdWx0IGxldmVsIGZvciB0aGlzIGxvZ2dlciwgaWYgYW55LiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgICAqIGBpbmhlcml0ZWRMZXZlbGAuXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ8bnVsbH1cbiAgICAgICAgICovXG4gICAgICAgIHZhciBkZWZhdWx0TGV2ZWw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHVzZXItc3BlY2lmaWMgbGV2ZWwgZm9yIHRoaXMgbG9nZ2VyLiBJZiBzZXQsIHRoaXMgb3ZlcnJpZGVzXG4gICAgICAgICAqIGBkZWZhdWx0TGV2ZWxgLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfG51bGx9XG4gICAgICAgICAqL1xuICAgICAgICB2YXIgdXNlckxldmVsO1xuICAgICAgICB2YXIgc3RvcmFnZUtleSA9IFwibG9nbGV2ZWxcIjtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgc3RvcmFnZUtleSArPSBcIjpcIiArIG5hbWU7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5hbWUgPT09IFwic3ltYm9sXCIpIHtcbiAgICAgICAgICBzdG9yYWdlS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIHBlcnNpc3RMZXZlbElmUG9zc2libGUobGV2ZWxOdW0pIHtcbiAgICAgICAgICB2YXIgbGV2ZWxOYW1lID0gKGxvZ01ldGhvZHNbbGV2ZWxOdW1dIHx8ICdzaWxlbnQnKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG5cbiAgICAgICAgICAvLyBVc2UgbG9jYWxTdG9yYWdlIGlmIGF2YWlsYWJsZVxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlW3N0b3JhZ2VLZXldID0gbGV2ZWxOYW1lO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9XCIgKyBsZXZlbE5hbWUgKyBcIjtcIjtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ2V0UGVyc2lzdGVkTGV2ZWwoKSB7XG4gICAgICAgICAgdmFyIHN0b3JlZExldmVsO1xuICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSB1bmRlZmluZWRUeXBlIHx8ICFzdG9yYWdlS2V5KSByZXR1cm47XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gd2luZG93LmxvY2FsU3RvcmFnZVtzdG9yYWdlS2V5XTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG5cbiAgICAgICAgICAvLyBGYWxsYmFjayB0byBjb29raWVzIGlmIGxvY2FsIHN0b3JhZ2UgZ2l2ZXMgdXMgbm90aGluZ1xuICAgICAgICAgIGlmICh0eXBlb2Ygc3RvcmVkTGV2ZWwgPT09IHVuZGVmaW5lZFR5cGUpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHZhciBjb29raWUgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llO1xuICAgICAgICAgICAgICB2YXIgY29va2llTmFtZSA9IGVuY29kZVVSSUNvbXBvbmVudChzdG9yYWdlS2V5KTtcbiAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uID0gY29va2llLmluZGV4T2YoY29va2llTmFtZSArIFwiPVwiKTtcbiAgICAgICAgICAgICAgaWYgKGxvY2F0aW9uICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHN0b3JlZExldmVsID0gL14oW147XSspLy5leGVjKGNvb2tpZS5zbGljZShsb2NhdGlvbiArIGNvb2tpZU5hbWUubGVuZ3RoICsgMSkpWzFdO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChpZ25vcmUpIHt9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gSWYgdGhlIHN0b3JlZCBsZXZlbCBpcyBub3QgdmFsaWQsIHRyZWF0IGl0IGFzIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cbiAgICAgICAgICBpZiAoc2VsZi5sZXZlbHNbc3RvcmVkTGV2ZWxdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN0b3JlZExldmVsID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gc3RvcmVkTGV2ZWw7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gY2xlYXJQZXJzaXN0ZWRMZXZlbCgpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gdW5kZWZpbmVkVHlwZSB8fCAhc3RvcmFnZUtleSkgcmV0dXJuO1xuXG4gICAgICAgICAgLy8gVXNlIGxvY2FsU3RvcmFnZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHN0b3JhZ2VLZXkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGlnbm9yZSkge31cblxuICAgICAgICAgIC8vIFVzZSBzZXNzaW9uIGNvb2tpZSBhcyBmYWxsYmFja1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB3aW5kb3cuZG9jdW1lbnQuY29va2llID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0b3JhZ2VLZXkpICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgVVRDXCI7XG4gICAgICAgICAgfSBjYXRjaCAoaWdub3JlKSB7fVxuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG5vcm1hbGl6ZUxldmVsKGlucHV0KSB7XG4gICAgICAgICAgdmFyIGxldmVsID0gaW5wdXQ7XG4gICAgICAgICAgaWYgKHR5cGVvZiBsZXZlbCA9PT0gXCJzdHJpbmdcIiAmJiBzZWxmLmxldmVsc1tsZXZlbC50b1VwcGVyQ2FzZSgpXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsZXZlbCA9IHNlbGYubGV2ZWxzW2xldmVsLnRvVXBwZXJDYXNlKCldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGxldmVsID09PSBcIm51bWJlclwiICYmIGxldmVsID49IDAgJiYgbGV2ZWwgPD0gc2VsZi5sZXZlbHMuU0lMRU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJsb2cuc2V0TGV2ZWwoKSBjYWxsZWQgd2l0aCBpbnZhbGlkIGxldmVsOiBcIiArIGlucHV0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgKlxuICAgICAgICAgKiBQdWJsaWMgbG9nZ2VyIEFQSSAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwgZm9yIGRldGFpbHNcbiAgICAgICAgICpcbiAgICAgICAgICovXG5cbiAgICAgICAgc2VsZi5uYW1lID0gbmFtZTtcbiAgICAgICAgc2VsZi5sZXZlbHMgPSB7XG4gICAgICAgICAgXCJUUkFDRVwiOiAwLFxuICAgICAgICAgIFwiREVCVUdcIjogMSxcbiAgICAgICAgICBcIklORk9cIjogMixcbiAgICAgICAgICBcIldBUk5cIjogMyxcbiAgICAgICAgICBcIkVSUk9SXCI6IDQsXG4gICAgICAgICAgXCJTSUxFTlRcIjogNVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLm1ldGhvZEZhY3RvcnkgPSBmYWN0b3J5IHx8IGRlZmF1bHRNZXRob2RGYWN0b3J5O1xuICAgICAgICBzZWxmLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmICh1c2VyTGV2ZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHVzZXJMZXZlbDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlZmF1bHRMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdExldmVsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gaW5oZXJpdGVkTGV2ZWw7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBzZWxmLnNldExldmVsID0gZnVuY3Rpb24gKGxldmVsLCBwZXJzaXN0KSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmIChwZXJzaXN0ICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgLy8gZGVmYXVsdHMgdG8gdHJ1ZVxuICAgICAgICAgICAgcGVyc2lzdExldmVsSWZQb3NzaWJsZSh1c2VyTGV2ZWwpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIE5PVEU6IGluIHYyLCB0aGlzIHNob3VsZCBjYWxsIHJlYnVpbGQoKSwgd2hpY2ggdXBkYXRlcyBjaGlsZHJlbi5cbiAgICAgICAgICByZXR1cm4gcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuc2V0RGVmYXVsdExldmVsID0gZnVuY3Rpb24gKGxldmVsKSB7XG4gICAgICAgICAgZGVmYXVsdExldmVsID0gbm9ybWFsaXplTGV2ZWwobGV2ZWwpO1xuICAgICAgICAgIGlmICghZ2V0UGVyc2lzdGVkTGV2ZWwoKSkge1xuICAgICAgICAgICAgc2VsZi5zZXRMZXZlbChsZXZlbCwgZmFsc2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc2VsZi5yZXNldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHVzZXJMZXZlbCA9IG51bGw7XG4gICAgICAgICAgY2xlYXJQZXJzaXN0ZWRMZXZlbCgpO1xuICAgICAgICAgIHJlcGxhY2VMb2dnaW5nTWV0aG9kcy5jYWxsKHNlbGYpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLmVuYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5UUkFDRSwgcGVyc2lzdCk7XG4gICAgICAgIH07XG4gICAgICAgIHNlbGYuZGlzYWJsZUFsbCA9IGZ1bmN0aW9uIChwZXJzaXN0KSB7XG4gICAgICAgICAgc2VsZi5zZXRMZXZlbChzZWxmLmxldmVscy5TSUxFTlQsIHBlcnNpc3QpO1xuICAgICAgICB9O1xuICAgICAgICBzZWxmLnJlYnVpbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgIT09IHNlbGYpIHtcbiAgICAgICAgICAgIGluaGVyaXRlZExldmVsID0gbm9ybWFsaXplTGV2ZWwoZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVwbGFjZUxvZ2dpbmdNZXRob2RzLmNhbGwoc2VsZik7XG4gICAgICAgICAgaWYgKGRlZmF1bHRMb2dnZXIgPT09IHNlbGYpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGNoaWxkTmFtZSBpbiBfbG9nZ2Vyc0J5TmFtZSkge1xuICAgICAgICAgICAgICBfbG9nZ2Vyc0J5TmFtZVtjaGlsZE5hbWVdLnJlYnVpbGQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBhbGwgdGhlIGludGVybmFsIGxldmVscy5cbiAgICAgICAgaW5oZXJpdGVkTGV2ZWwgPSBub3JtYWxpemVMZXZlbChkZWZhdWx0TG9nZ2VyID8gZGVmYXVsdExvZ2dlci5nZXRMZXZlbCgpIDogXCJXQVJOXCIpO1xuICAgICAgICB2YXIgaW5pdGlhbExldmVsID0gZ2V0UGVyc2lzdGVkTGV2ZWwoKTtcbiAgICAgICAgaWYgKGluaXRpYWxMZXZlbCAhPSBudWxsKSB7XG4gICAgICAgICAgdXNlckxldmVsID0gbm9ybWFsaXplTGV2ZWwoaW5pdGlhbExldmVsKTtcbiAgICAgICAgfVxuICAgICAgICByZXBsYWNlTG9nZ2luZ01ldGhvZHMuY2FsbChzZWxmKTtcbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAqXG4gICAgICAgKiBUb3AtbGV2ZWwgQVBJXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICAgIGRlZmF1bHRMb2dnZXIgPSBuZXcgTG9nZ2VyKCk7XG4gICAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlciA9IGZ1bmN0aW9uIGdldExvZ2dlcihuYW1lKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gXCJzeW1ib2xcIiAmJiB0eXBlb2YgbmFtZSAhPT0gXCJzdHJpbmdcIiB8fCBuYW1lID09PSBcIlwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIllvdSBtdXN0IHN1cHBseSBhIG5hbWUgd2hlbiBjcmVhdGluZyBhIGxvZ2dlci5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdO1xuICAgICAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgICAgIGxvZ2dlciA9IF9sb2dnZXJzQnlOYW1lW25hbWVdID0gbmV3IExvZ2dlcihuYW1lLCBkZWZhdWx0TG9nZ2VyLm1ldGhvZEZhY3RvcnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXI7XG4gICAgICB9O1xuXG4gICAgICAvLyBHcmFiIHRoZSBjdXJyZW50IGdsb2JhbCBsb2cgdmFyaWFibGUgaW4gY2FzZSBvZiBvdmVyd3JpdGVcbiAgICAgIHZhciBfbG9nID0gdHlwZW9mIHdpbmRvdyAhPT0gdW5kZWZpbmVkVHlwZSA/IHdpbmRvdy5sb2cgOiB1bmRlZmluZWQ7XG4gICAgICBkZWZhdWx0TG9nZ2VyLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSB1bmRlZmluZWRUeXBlICYmIHdpbmRvdy5sb2cgPT09IGRlZmF1bHRMb2dnZXIpIHtcbiAgICAgICAgICB3aW5kb3cubG9nID0gX2xvZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcjtcbiAgICAgIH07XG4gICAgICBkZWZhdWx0TG9nZ2VyLmdldExvZ2dlcnMgPSBmdW5jdGlvbiBnZXRMb2dnZXJzKCkge1xuICAgICAgICByZXR1cm4gX2xvZ2dlcnNCeU5hbWU7XG4gICAgICB9O1xuXG4gICAgICAvLyBFUzYgZGVmYXVsdCBleHBvcnQsIGZvciBjb21wYXRpYmlsaXR5XG4gICAgICBkZWZhdWx0TG9nZ2VyWydkZWZhdWx0J10gPSBkZWZhdWx0TG9nZ2VyO1xuICAgICAgcmV0dXJuIGRlZmF1bHRMb2dnZXI7XG4gICAgfSk7XG4gIH0pKGxvZ2xldmVsJDEpO1xuICByZXR1cm4gbG9nbGV2ZWwkMS5leHBvcnRzO1xufVxuXG52YXIgbG9nbGV2ZWxFeHBvcnRzID0gcmVxdWlyZUxvZ2xldmVsKCk7XG5cbnZhciBMb2dMZXZlbDtcbihmdW5jdGlvbiAoTG9nTGV2ZWwpIHtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJ0cmFjZVwiXSA9IDBdID0gXCJ0cmFjZVwiO1xuICBMb2dMZXZlbFtMb2dMZXZlbFtcImRlYnVnXCJdID0gMV0gPSBcImRlYnVnXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiaW5mb1wiXSA9IDJdID0gXCJpbmZvXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wid2FyblwiXSA9IDNdID0gXCJ3YXJuXCI7XG4gIExvZ0xldmVsW0xvZ0xldmVsW1wiZXJyb3JcIl0gPSA0XSA9IFwiZXJyb3JcIjtcbiAgTG9nTGV2ZWxbTG9nTGV2ZWxbXCJzaWxlbnRcIl0gPSA1XSA9IFwic2lsZW50XCI7XG59KShMb2dMZXZlbCB8fCAoTG9nTGV2ZWwgPSB7fSkpO1xudmFyIExvZ2dlck5hbWVzO1xuKGZ1bmN0aW9uIChMb2dnZXJOYW1lcykge1xuICBMb2dnZXJOYW1lc1tcIkRlZmF1bHRcIl0gPSBcImxpdmVraXRcIjtcbiAgTG9nZ2VyTmFtZXNbXCJSb29tXCJdID0gXCJsaXZla2l0LXJvb21cIjtcbiAgTG9nZ2VyTmFtZXNbXCJQYXJ0aWNpcGFudFwiXSA9IFwibGl2ZWtpdC1wYXJ0aWNpcGFudFwiO1xuICBMb2dnZXJOYW1lc1tcIlRyYWNrXCJdID0gXCJsaXZla2l0LXRyYWNrXCI7XG4gIExvZ2dlck5hbWVzW1wiUHVibGljYXRpb25cIl0gPSBcImxpdmVraXQtdHJhY2stcHVibGljYXRpb25cIjtcbiAgTG9nZ2VyTmFtZXNbXCJFbmdpbmVcIl0gPSBcImxpdmVraXQtZW5naW5lXCI7XG4gIExvZ2dlck5hbWVzW1wiU2lnbmFsXCJdID0gXCJsaXZla2l0LXNpZ25hbFwiO1xuICBMb2dnZXJOYW1lc1tcIlBDTWFuYWdlclwiXSA9IFwibGl2ZWtpdC1wYy1tYW5hZ2VyXCI7XG4gIExvZ2dlck5hbWVzW1wiUENUcmFuc3BvcnRcIl0gPSBcImxpdmVraXQtcGMtdHJhbnNwb3J0XCI7XG4gIExvZ2dlck5hbWVzW1wiRTJFRVwiXSA9IFwibGstZTJlZVwiO1xufSkoTG9nZ2VyTmFtZXMgfHwgKExvZ2dlck5hbWVzID0ge30pKTtcbmxldCBsaXZla2l0TG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcignbGl2ZWtpdCcpO1xuY29uc3QgbGl2ZWtpdExvZ2dlcnMgPSBPYmplY3QudmFsdWVzKExvZ2dlck5hbWVzKS5tYXAobmFtZSA9PiBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKG5hbWUpKTtcbmxpdmVraXRMb2dnZXIuc2V0RGVmYXVsdExldmVsKExvZ0xldmVsLmluZm8pO1xuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0TG9nZ2VyKG5hbWUpIHtcbiAgY29uc3QgbG9nZ2VyID0gbG9nbGV2ZWxFeHBvcnRzLmdldExvZ2dlcihuYW1lKTtcbiAgbG9nZ2VyLnNldERlZmF1bHRMZXZlbChsaXZla2l0TG9nZ2VyLmdldExldmVsKCkpO1xuICByZXR1cm4gbG9nZ2VyO1xufVxuZnVuY3Rpb24gc2V0TG9nTGV2ZWwobGV2ZWwsIGxvZ2dlck5hbWUpIHtcbiAgaWYgKGxvZ2dlck5hbWUpIHtcbiAgICBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKGxvZ2dlck5hbWUpLnNldExldmVsKGxldmVsKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGNvbnN0IGxvZ2dlciBvZiBsaXZla2l0TG9nZ2Vycykge1xuICAgICAgbG9nZ2VyLnNldExldmVsKGxldmVsKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogdXNlIHRoaXMgdG8gaG9vayBpbnRvIHRoZSBsb2dnaW5nIGZ1bmN0aW9uIHRvIGFsbG93IHNlbmRpbmcgaW50ZXJuYWwgbGl2ZWtpdCBsb2dzIHRvIHRoaXJkIHBhcnR5IHNlcnZpY2VzXG4gKiBpZiBzZXQsIHRoZSBicm93c2VyIGxvZ3Mgd2lsbCBsb3NlIHRoZWlyIHN0YWNrdHJhY2UgaW5mb3JtYXRpb24gKHNlZSBodHRwczovL2dpdGh1Yi5jb20vcGltdGVycnkvbG9nbGV2ZWwjd3JpdGluZy1wbHVnaW5zKVxuICovXG5mdW5jdGlvbiBzZXRMb2dFeHRlbnNpb24oZXh0ZW5zaW9uLCBsb2dnZXIpIHtcbiAgY29uc3QgbG9nZ2VycyA9IGxvZ2dlciA/IFtsb2dnZXJdIDogbGl2ZWtpdExvZ2dlcnM7XG4gIGxvZ2dlcnMuZm9yRWFjaChsb2dSID0+IHtcbiAgICBjb25zdCBvcmlnaW5hbEZhY3RvcnkgPSBsb2dSLm1ldGhvZEZhY3Rvcnk7XG4gICAgbG9nUi5tZXRob2RGYWN0b3J5ID0gKG1ldGhvZE5hbWUsIGNvbmZpZ0xldmVsLCBsb2dnZXJOYW1lKSA9PiB7XG4gICAgICBjb25zdCByYXdNZXRob2QgPSBvcmlnaW5hbEZhY3RvcnkobWV0aG9kTmFtZSwgY29uZmlnTGV2ZWwsIGxvZ2dlck5hbWUpO1xuICAgICAgY29uc3QgbG9nTGV2ZWwgPSBMb2dMZXZlbFttZXRob2ROYW1lXTtcbiAgICAgIGNvbnN0IG5lZWRMb2cgPSBsb2dMZXZlbCA+PSBjb25maWdMZXZlbCAmJiBsb2dMZXZlbCA8IExvZ0xldmVsLnNpbGVudDtcbiAgICAgIHJldHVybiAobXNnLCBjb250ZXh0KSA9PiB7XG4gICAgICAgIGlmIChjb250ZXh0KSByYXdNZXRob2QobXNnLCBjb250ZXh0KTtlbHNlIHJhd01ldGhvZChtc2cpO1xuICAgICAgICBpZiAobmVlZExvZykge1xuICAgICAgICAgIGV4dGVuc2lvbihsb2dMZXZlbCwgbXNnLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9O1xuICAgIGxvZ1Iuc2V0TGV2ZWwobG9nUi5nZXRMZXZlbCgpKTtcbiAgfSk7XG59XG5jb25zdCB3b3JrZXJMb2dnZXIgPSBsb2dsZXZlbEV4cG9ydHMuZ2V0TG9nZ2VyKCdsay1lMmVlJyk7XG5cbmNvbnN0IG1heFJldHJ5RGVsYXkgPSA3MDAwO1xuY29uc3QgREVGQVVMVF9SRVRSWV9ERUxBWVNfSU5fTVMgPSBbMCwgMzAwLCAyICogMiAqIDMwMCwgMyAqIDMgKiAzMDAsIDQgKiA0ICogMzAwLCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5LCBtYXhSZXRyeURlbGF5XTtcbmNsYXNzIERlZmF1bHRSZWNvbm5lY3RQb2xpY3kge1xuICBjb25zdHJ1Y3RvcihyZXRyeURlbGF5cykge1xuICAgIHRoaXMuX3JldHJ5RGVsYXlzID0gcmV0cnlEZWxheXMgIT09IHVuZGVmaW5lZCA/IFsuLi5yZXRyeURlbGF5c10gOiBERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUztcbiAgfVxuICBuZXh0UmV0cnlEZWxheUluTXMoY29udGV4dCkge1xuICAgIGlmIChjb250ZXh0LnJldHJ5Q291bnQgPj0gdGhpcy5fcmV0cnlEZWxheXMubGVuZ3RoKSByZXR1cm4gbnVsbDtcbiAgICBjb25zdCByZXRyeURlbGF5ID0gdGhpcy5fcmV0cnlEZWxheXNbY29udGV4dC5yZXRyeUNvdW50XTtcbiAgICBpZiAoY29udGV4dC5yZXRyeUNvdW50IDw9IDEpIHJldHVybiByZXRyeURlbGF5O1xuICAgIHJldHVybiByZXRyeURlbGF5ICsgTWF0aC5yYW5kb20oKSAqIDEwMDA7XG4gIH1cbn1cblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBSZWZsZWN0LCBQcm9taXNlLCBTdXBwcmVzc2VkRXJyb3IsIFN5bWJvbCwgSXRlcmF0b3IgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fdmFsdWVzKG8pIHtcclxuICAgIHZhciBzID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5pdGVyYXRvciwgbSA9IHMgJiYgb1tzXSwgaSA9IDA7XHJcbiAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgIGlmIChvICYmIHR5cGVvZiBvLmxlbmd0aCA9PT0gXCJudW1iZXJcIikgcmV0dXJuIHtcclxuICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChvICYmIGkgPj0gby5sZW5ndGgpIG8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIHJldHVybiB7IHZhbHVlOiBvICYmIG9baSsrXSwgZG9uZTogIW8gfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihzID8gXCJPYmplY3QgaXMgbm90IGl0ZXJhYmxlLlwiIDogXCJTeW1ib2wuaXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxudmFyIGV2ZW50cyA9IHtleHBvcnRzOiB7fX07XG5cbnZhciBoYXNSZXF1aXJlZEV2ZW50cztcbmZ1bmN0aW9uIHJlcXVpcmVFdmVudHMoKSB7XG4gIGlmIChoYXNSZXF1aXJlZEV2ZW50cykgcmV0dXJuIGV2ZW50cy5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEV2ZW50cyA9IDE7XG4gIHZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGw7XG4gIHZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nID8gUi5hcHBseSA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9O1xuICB2YXIgUmVmbGVjdE93bktleXM7XG4gIGlmIChSICYmIHR5cGVvZiBSLm93bktleXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5cztcbiAgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpO1xuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIGNvbnNvbGUud2Fybih3YXJuaW5nKTtcbiAgfVxuICB2YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xuICB9O1xuICBmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gICAgRXZlbnRFbWl0dGVyLmluaXQuY2FsbCh0aGlzKTtcbiAgfVxuICBldmVudHMuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiAgZXZlbnRzLmV4cG9ydHMub25jZSA9IG9uY2U7XG5cbiAgLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG4gIEV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzQ291bnQgPSAwO1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbiAgLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4gIC8vIGFkZGVkIHRvIGl0LiBUaGlzIGlzIGEgdXNlZnVsIGRlZmF1bHQgd2hpY2ggaGVscHMgZmluZGluZyBtZW1vcnkgbGVha3MuXG4gIHZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG4gIGZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBGdW5jdGlvbi4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGxpc3RlbmVyKTtcbiAgICB9XG4gIH1cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbiAoYXJnKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZyAhPT0gJ251bWJlcicgfHwgYXJnIDwgMCB8fCBOdW1iZXJJc05hTihhcmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgICB9XG4gICAgICBkZWZhdWx0TWF4TGlzdGVuZXJzID0gYXJnO1xuICAgIH1cbiAgfSk7XG4gIEV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgIH1cbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuICAvLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbiBzZXRNYXhMaXN0ZW5lcnMobikge1xuICAgIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICAgIH1cbiAgICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBmdW5jdGlvbiBfZ2V0TWF4TGlzdGVuZXJzKHRoYXQpIHtcbiAgICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpIHJldHVybiBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICAgIHJldHVybiBfZ2V0TWF4TGlzdGVuZXJzKHRoaXMpO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgICB2YXIgYXJncyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSBhcmdzLnB1c2goYXJndW1lbnRzW2ldKTtcbiAgICB2YXIgZG9FcnJvciA9IHR5cGUgPT09ICdlcnJvcic7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIGRvRXJyb3IgPSBkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkO2Vsc2UgaWYgKCFkb0Vycm9yKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gICAgaWYgKGRvRXJyb3IpIHtcbiAgICAgIHZhciBlcjtcbiAgICAgIGlmIChhcmdzLmxlbmd0aCA+IDApIGVyID0gYXJnc1swXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIC8vIE5vdGU6IFRoZSBjb21tZW50cyBvbiB0aGUgYHRocm93YCBsaW5lcyBhcmUgaW50ZW50aW9uYWwsIHRoZXkgc2hvd1xuICAgICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICAgIH1cbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIGZhbHNlO1xuICAgIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBmdW5jdGlvbiBfYWRkTGlzdGVuZXIodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lciwgcHJlcGVuZCkge1xuICAgIHZhciBtO1xuICAgIHZhciBldmVudHM7XG4gICAgdmFyIGV4aXN0aW5nO1xuICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIubGlzdGVuZXIgPyBsaXN0ZW5lci5saXN0ZW5lciA6IGxpc3RlbmVyKTtcblxuICAgICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgICB9XG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgICB9XG4gICAgaWYgKGV4aXN0aW5nID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICAgICsrdGFyZ2V0Ll9ldmVudHNDb3VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgICAgfSBlbHNlIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgICBtID0gX2dldE1heExpc3RlbmVycyh0YXJnZXQpO1xuICAgICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgICAvLyBObyBlcnJvciBjb2RlIGZvciB0aGlzIHNpbmNlIGl0IGlzIGEgV2FybmluZ1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgKyAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgKyAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgICAgdy5uYW1lID0gJ01heExpc3RlbmVyc0V4Y2VlZGVkV2FybmluZyc7XG4gICAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgICAgdy5jb3VudCA9IGV4aXN0aW5nLmxlbmd0aDtcbiAgICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfTtcbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZExpc3RlbmVyID0gZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gIH07XG4gIGZ1bmN0aW9uIG9uY2VXcmFwcGVyKCkge1xuICAgIGlmICghdGhpcy5maXJlZCkge1xuICAgICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgICB0aGlzLmZpcmVkID0gdHJ1ZTtcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmFwcGx5KHRoaXMudGFyZ2V0LCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICAgIHZhciBzdGF0ZSA9IHtcbiAgICAgIGZpcmVkOiBmYWxzZSxcbiAgICAgIHdyYXBGbjogdW5kZWZpbmVkLFxuICAgICAgdGFyZ2V0OiB0YXJnZXQsXG4gICAgICB0eXBlOiB0eXBlLFxuICAgICAgbGlzdGVuZXI6IGxpc3RlbmVyXG4gICAgfTtcbiAgICB2YXIgd3JhcHBlZCA9IG9uY2VXcmFwcGVyLmJpbmQoc3RhdGUpO1xuICAgIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICAgIHJldHVybiB3cmFwcGVkO1xuICB9XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgdmFyIGxpc3QsIGV2ZW50cywgcG9zaXRpb24sIGksIG9yaWdpbmFsTGlzdGVuZXI7XG4gICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG4gICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKSByZXR1cm4gdGhpcztcbiAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2Uge1xuICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdC5saXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcG9zaXRpb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8IGxpc3RbaV0ubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocG9zaXRpb24gPCAwKSByZXR1cm4gdGhpcztcbiAgICAgIGlmIChwb3NpdGlvbiA9PT0gMCkgbGlzdC5zaGlmdCgpO2Vsc2Uge1xuICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgfVxuICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSBldmVudHNbdHlwZV0gPSBsaXN0WzBdO1xuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgb3JpZ2luYWxMaXN0ZW5lciB8fCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG4gICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKSB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO2Vsc2UgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICB2YXIga2V5O1xuICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgZm9yIChpID0gbGlzdGVuZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG4gIGZ1bmN0aW9uIF9saXN0ZW5lcnModGFyZ2V0LCB0eXBlLCB1bndyYXApIHtcbiAgICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSByZXR1cm4gW107XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG4gICAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZCkgcmV0dXJuIFtdO1xuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuICAgIHJldHVybiB1bndyYXAgPyB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbiAgfVxuICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gICAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgdHJ1ZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG4gIH07XG4gIEV2ZW50RW1pdHRlci5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gKGVtaXR0ZXIsIHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIubGlzdGVuZXJDb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQuY2FsbChlbWl0dGVyLCB0eXBlKTtcbiAgICB9XG4gIH07XG4gIEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG4gIGZ1bmN0aW9uIGxpc3RlbmVyQ291bnQodHlwZSkge1xuICAgIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdE93bktleXModGhpcy5fZXZlbnRzKSA6IFtdO1xuICB9O1xuICBmdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICAgIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbjsgKytpKSBjb3B5W2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBjb3B5O1xuICB9XG4gIGZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICAgIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKykgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gICAgbGlzdC5wb3AoKTtcbiAgfVxuICBmdW5jdGlvbiB1bndyYXBMaXN0ZW5lcnMoYXJyKSB7XG4gICAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgICAgcmV0W2ldID0gYXJyW2ldLmxpc3RlbmVyIHx8IGFycltpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuICBmdW5jdGlvbiBvbmNlKGVtaXR0ZXIsIG5hbWUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcihuYW1lLCByZXNvbHZlcik7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW1pdHRlci5yZW1vdmVMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZShbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgfVxuICAgICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7XG4gICAgICAgIG9uY2U6IHRydWVcbiAgICAgIH0pO1xuICAgICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgICAgYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgZXJyb3JMaXN0ZW5lciwge1xuICAgICAgICAgIG9uY2U6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCAnZXJyb3InLCBoYW5kbGVyLCBmbGFncyk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgICAgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyKG5hbWUsIGZ1bmN0aW9uIHdyYXBMaXN0ZW5lcihhcmcpIHtcbiAgICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgICBpZiAoZmxhZ3Mub25jZSkge1xuICAgICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxpc3RlbmVyKGFyZyk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiZW1pdHRlclwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBFdmVudEVtaXR0ZXIuIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBlbWl0dGVyKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGV2ZW50cy5leHBvcnRzO1xufVxuXG52YXIgZXZlbnRzRXhwb3J0cyA9IHJlcXVpcmVFdmVudHMoKTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxubGV0IGxvZ0Rpc2FibGVkXyA9IHRydWU7XG5sZXQgZGVwcmVjYXRpb25XYXJuaW5nc18gPSB0cnVlO1xuXG4vKipcbiAqIEV4dHJhY3QgYnJvd3NlciB2ZXJzaW9uIG91dCBvZiB0aGUgcHJvdmlkZWQgdXNlciBhZ2VudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHshc3RyaW5nfSB1YXN0cmluZyB1c2VyQWdlbnQgc3RyaW5nLlxuICogQHBhcmFtIHshc3RyaW5nfSBleHByIFJlZ3VsYXIgZXhwcmVzc2lvbiB1c2VkIGFzIG1hdGNoIGNyaXRlcmlhLlxuICogQHBhcmFtIHshbnVtYmVyfSBwb3MgcG9zaXRpb24gaW4gdGhlIHZlcnNpb24gc3RyaW5nIHRvIGJlIHJldHVybmVkLlxuICogQHJldHVybiB7IW51bWJlcn0gYnJvd3NlciB2ZXJzaW9uLlxuICovXG5mdW5jdGlvbiBleHRyYWN0VmVyc2lvbih1YXN0cmluZywgZXhwciwgcG9zKSB7XG4gIGNvbnN0IG1hdGNoID0gdWFzdHJpbmcubWF0Y2goZXhwcik7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaC5sZW5ndGggPj0gcG9zICYmIHBhcnNlSW50KG1hdGNoW3Bvc10sIDEwKTtcbn1cblxuLy8gV3JhcHMgdGhlIHBlZXJjb25uZWN0aW9uIGV2ZW50IGV2ZW50TmFtZVRvV3JhcCBpbiBhIGZ1bmN0aW9uXG4vLyB3aGljaCByZXR1cm5zIHRoZSBtb2RpZmllZCBldmVudCBvYmplY3QgKG9yIGZhbHNlIHRvIHByZXZlbnRcbi8vIHRoZSBldmVudCkuXG5mdW5jdGlvbiB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csIGV2ZW50TmFtZVRvV3JhcCwgd3JhcHBlcikge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIGNvbnN0IG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSBwcm90by5hZGRFdmVudExpc3RlbmVyO1xuICBwcm90by5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUV2ZW50TmFtZSwgY2IpIHtcbiAgICBpZiAobmF0aXZlRXZlbnROYW1lICE9PSBldmVudE5hbWVUb1dyYXApIHtcbiAgICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHdyYXBwZWRDYWxsYmFjayA9IGUgPT4ge1xuICAgICAgY29uc3QgbW9kaWZpZWRFdmVudCA9IHdyYXBwZXIoZSk7XG4gICAgICBpZiAobW9kaWZpZWRFdmVudCkge1xuICAgICAgICBpZiAoY2IuaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICBjYi5oYW5kbGVFdmVudChtb2RpZmllZEV2ZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYihtb2RpZmllZEV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5fZXZlbnRNYXAgPSB0aGlzLl9ldmVudE1hcCB8fCB7fTtcbiAgICBpZiAoIXRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0gPSBuZXcgTWFwKCk7XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uc2V0KGNiLCB3cmFwcGVkQ2FsbGJhY2spO1xuICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIFtuYXRpdmVFdmVudE5hbWUsIHdyYXBwZWRDYWxsYmFja10pO1xuICB9O1xuICBjb25zdCBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbiAgcHJvdG8ucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChuYXRpdmVFdmVudE5hbWUsIGNiKSB7XG4gICAgaWYgKG5hdGl2ZUV2ZW50TmFtZSAhPT0gZXZlbnROYW1lVG9XcmFwIHx8ICF0aGlzLl9ldmVudE1hcCB8fCAhdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLl9ldmVudE1hcFtldmVudE5hbWVUb1dyYXBdLmhhcyhjYikpIHtcbiAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGNvbnN0IHVud3JhcHBlZENiID0gdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5nZXQoY2IpO1xuICAgIHRoaXMuX2V2ZW50TWFwW2V2ZW50TmFtZVRvV3JhcF0uZGVsZXRlKGNiKTtcbiAgICBpZiAodGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXS5zaXplID09PSAwKSB7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRNYXBbZXZlbnROYW1lVG9XcmFwXTtcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMuX2V2ZW50TWFwKS5sZW5ndGggPT09IDApIHtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudE1hcDtcbiAgICB9XG4gICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgW25hdGl2ZUV2ZW50TmFtZSwgdW53cmFwcGVkQ2JdKTtcbiAgfTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3RvLCAnb24nICsgZXZlbnROYW1lVG9XcmFwLCB7XG4gICAgZ2V0KCkge1xuICAgICAgcmV0dXJuIHRoaXNbJ19vbicgKyBldmVudE5hbWVUb1dyYXBdO1xuICAgIH0sXG4gICAgc2V0KGNiKSB7XG4gICAgICBpZiAodGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCwgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0pO1xuICAgICAgICBkZWxldGUgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF07XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZVRvV3JhcCwgdGhpc1snX29uJyArIGV2ZW50TmFtZVRvV3JhcF0gPSBjYik7XG4gICAgICB9XG4gICAgfSxcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICB9KTtcbn1cbmZ1bmN0aW9uIGRpc2FibGVMb2coYm9vbCkge1xuICBpZiAodHlwZW9mIGJvb2wgIT09ICdib29sZWFuJykge1xuICAgIHJldHVybiBuZXcgRXJyb3IoJ0FyZ3VtZW50IHR5cGU6ICcgKyB0eXBlb2YgYm9vbCArICcuIFBsZWFzZSB1c2UgYSBib29sZWFuLicpO1xuICB9XG4gIGxvZ0Rpc2FibGVkXyA9IGJvb2w7XG4gIHJldHVybiBib29sID8gJ2FkYXB0ZXIuanMgbG9nZ2luZyBkaXNhYmxlZCcgOiAnYWRhcHRlci5qcyBsb2dnaW5nIGVuYWJsZWQnO1xufVxuXG4vKipcbiAqIERpc2FibGUgb3IgZW5hYmxlIGRlcHJlY2F0aW9uIHdhcm5pbmdzXG4gKiBAcGFyYW0geyFib29sZWFufSBib29sIHNldCB0byB0cnVlIHRvIGRpc2FibGUgd2FybmluZ3MuXG4gKi9cbmZ1bmN0aW9uIGRpc2FibGVXYXJuaW5ncyhib29sKSB7XG4gIGlmICh0eXBlb2YgYm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgcmV0dXJuIG5ldyBFcnJvcignQXJndW1lbnQgdHlwZTogJyArIHR5cGVvZiBib29sICsgJy4gUGxlYXNlIHVzZSBhIGJvb2xlYW4uJyk7XG4gIH1cbiAgZGVwcmVjYXRpb25XYXJuaW5nc18gPSAhYm9vbDtcbiAgcmV0dXJuICdhZGFwdGVyLmpzIGRlcHJlY2F0aW9uIHdhcm5pbmdzICcgKyAoYm9vbCA/ICdkaXNhYmxlZCcgOiAnZW5hYmxlZCcpO1xufVxuZnVuY3Rpb24gbG9nKCkge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICBpZiAobG9nRGlzYWJsZWRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIGNvbnNvbGUubG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFNob3dzIGEgZGVwcmVjYXRpb24gd2FybmluZyBzdWdnZXN0aW5nIHRoZSBtb2Rlcm4gYW5kIHNwZWMtY29tcGF0aWJsZSBBUEkuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQob2xkTWV0aG9kLCBuZXdNZXRob2QpIHtcbiAgaWYgKCFkZXByZWNhdGlvbldhcm5pbmdzXykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zb2xlLndhcm4ob2xkTWV0aG9kICsgJyBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlICcgKyBuZXdNZXRob2QgKyAnIGluc3RlYWQuJyk7XG59XG5cbi8qKlxuICogQnJvd3NlciBkZXRlY3Rvci5cbiAqXG4gKiBAcmV0dXJuIHtvYmplY3R9IHJlc3VsdCBjb250YWluaW5nIGJyb3dzZXIgYW5kIHZlcnNpb25cbiAqICAgICBwcm9wZXJ0aWVzLlxuICovXG5mdW5jdGlvbiBkZXRlY3RCcm93c2VyKHdpbmRvdykge1xuICAvLyBSZXR1cm5lZCByZXN1bHQgb2JqZWN0LlxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgYnJvd3NlcjogbnVsbCxcbiAgICB2ZXJzaW9uOiBudWxsXG4gIH07XG5cbiAgLy8gRmFpbCBlYXJseSBpZiBpdCdzIG5vdCBhIGJyb3dzZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnIHx8ICF3aW5kb3cubmF2aWdhdG9yIHx8ICF3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkge1xuICAgIHJlc3VsdC5icm93c2VyID0gJ05vdCBhIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbnN0IHtcbiAgICBuYXZpZ2F0b3JcbiAgfSA9IHdpbmRvdztcblxuICAvLyBQcmVmZXIgbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEuXG4gIGlmIChuYXZpZ2F0b3IudXNlckFnZW50RGF0YSAmJiBuYXZpZ2F0b3IudXNlckFnZW50RGF0YS5icmFuZHMpIHtcbiAgICBjb25zdCBjaHJvbWl1bSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhLmJyYW5kcy5maW5kKGJyYW5kID0+IHtcbiAgICAgIHJldHVybiBicmFuZC5icmFuZCA9PT0gJ0Nocm9taXVtJztcbiAgICB9KTtcbiAgICBpZiAoY2hyb21pdW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGJyb3dzZXI6ICdjaHJvbWUnLFxuICAgICAgICB2ZXJzaW9uOiBwYXJzZUludChjaHJvbWl1bS52ZXJzaW9uLCAxMClcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIGlmIChuYXZpZ2F0b3IubW96R2V0VXNlck1lZGlhKSB7XG4gICAgLy8gRmlyZWZveC5cbiAgICByZXN1bHQuYnJvd3NlciA9ICdmaXJlZm94JztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9GaXJlZm94XFwvKFxcZCspXFwuLywgMSk7XG4gIH0gZWxzZSBpZiAobmF2aWdhdG9yLndlYmtpdEdldFVzZXJNZWRpYSB8fCB3aW5kb3cuaXNTZWN1cmVDb250ZXh0ID09PSBmYWxzZSAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyBDaHJvbWUsIENocm9taXVtLCBXZWJ2aWV3LCBPcGVyYS5cbiAgICAvLyBWZXJzaW9uIG1hdGNoZXMgQ2hyb21lL1dlYlJUQyB2ZXJzaW9uLlxuICAgIC8vIENocm9tZSA3NCByZW1vdmVkIHdlYmtpdEdldFVzZXJNZWRpYSBvbiBodHRwIGFzIHdlbGwgc28gd2UgbmVlZCB0aGVcbiAgICAvLyBtb3JlIGNvbXBsaWNhdGVkIGZhbGxiYWNrIHRvIHdlYmtpdFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgIHJlc3VsdC5icm93c2VyID0gJ2Nocm9tZSc7XG4gICAgcmVzdWx0LnZlcnNpb24gPSBleHRyYWN0VmVyc2lvbihuYXZpZ2F0b3IudXNlckFnZW50LCAvQ2hyb20oZXxpdW0pXFwvKFxcZCspXFwuLywgMik7XG4gIH0gZWxzZSBpZiAod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goL0FwcGxlV2ViS2l0XFwvKFxcZCspXFwuLykpIHtcbiAgICAvLyBTYWZhcmkuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnc2FmYXJpJztcbiAgICByZXN1bHQudmVyc2lvbiA9IGV4dHJhY3RWZXJzaW9uKG5hdmlnYXRvci51c2VyQWdlbnQsIC9BcHBsZVdlYktpdFxcLyhcXGQrKVxcLi8sIDEpO1xuICAgIHJlc3VsdC5zdXBwb3J0c1VuaWZpZWRQbGFuID0gd2luZG93LlJUQ1J0cFRyYW5zY2VpdmVyICYmICdjdXJyZW50RGlyZWN0aW9uJyBpbiB3aW5kb3cuUlRDUnRwVHJhbnNjZWl2ZXIucHJvdG90eXBlO1xuICB9IGVsc2Uge1xuICAgIC8vIERlZmF1bHQgZmFsbHRocm91Z2g6IG5vdCBzdXBwb3J0ZWQuXG4gICAgcmVzdWx0LmJyb3dzZXIgPSAnTm90IGEgc3VwcG9ydGVkIGJyb3dzZXIuJztcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHNvbWV0aGluZyBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHsqfSB2YWwgVGhlIHNvbWV0aGluZyB5b3Ugd2FudCB0byBjaGVjay5cbiAqIEByZXR1cm4gdHJ1ZSBpZiB2YWwgaXMgYW4gb2JqZWN0LCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IE9iamVjdF0nO1xufVxuXG4vKipcbiAqIFJlbW92ZSBhbGwgZW1wdHkgb2JqZWN0cyBhbmQgdW5kZWZpbmVkIHZhbHVlc1xuICogZnJvbSBhIG5lc3RlZCBvYmplY3QgLS0gYW4gZW5oYW5jZWQgYW5kIHZhbmlsbGEgdmVyc2lvblxuICogb2YgTG9kYXNoJ3MgYGNvbXBhY3RgLlxuICovXG5mdW5jdGlvbiBjb21wYWN0T2JqZWN0KGRhdGEpIHtcbiAgaWYgKCFpc09iamVjdChkYXRhKSkge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhkYXRhKS5yZWR1Y2UoZnVuY3Rpb24gKGFjY3VtdWxhdG9yLCBrZXkpIHtcbiAgICBjb25zdCBpc09iaiA9IGlzT2JqZWN0KGRhdGFba2V5XSk7XG4gICAgY29uc3QgdmFsdWUgPSBpc09iaiA/IGNvbXBhY3RPYmplY3QoZGF0YVtrZXldKSA6IGRhdGFba2V5XTtcbiAgICBjb25zdCBpc0VtcHR5T2JqZWN0ID0gaXNPYmogJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgaXNFbXB0eU9iamVjdCkge1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihhY2N1bXVsYXRvciwge1xuICAgICAgW2tleV06IHZhbHVlXG4gICAgfSk7XG4gIH0sIHt9KTtcbn1cblxuLyogaXRlcmF0ZXMgdGhlIHN0YXRzIGdyYXBoIHJlY3Vyc2l2ZWx5LiAqL1xuZnVuY3Rpb24gd2Fsa1N0YXRzKHN0YXRzLCBiYXNlLCByZXN1bHRTZXQpIHtcbiAgaWYgKCFiYXNlIHx8IHJlc3VsdFNldC5oYXMoYmFzZS5pZCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgcmVzdWx0U2V0LnNldChiYXNlLmlkLCBiYXNlKTtcbiAgT2JqZWN0LmtleXMoYmFzZSkuZm9yRWFjaChuYW1lID0+IHtcbiAgICBpZiAobmFtZS5lbmRzV2l0aCgnSWQnKSkge1xuICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoYmFzZVtuYW1lXSksIHJlc3VsdFNldCk7XG4gICAgfSBlbHNlIGlmIChuYW1lLmVuZHNXaXRoKCdJZHMnKSkge1xuICAgICAgYmFzZVtuYW1lXS5mb3JFYWNoKGlkID0+IHtcbiAgICAgICAgd2Fsa1N0YXRzKHN0YXRzLCBzdGF0cy5nZXQoaWQpLCByZXN1bHRTZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyogZmlsdGVyIGdldFN0YXRzIGZvciBhIHNlbmRlci9yZWNlaXZlciB0cmFjay4gKi9cbmZ1bmN0aW9uIGZpbHRlclN0YXRzKHJlc3VsdCwgdHJhY2ssIG91dGJvdW5kKSB7XG4gIGNvbnN0IHN0cmVhbVN0YXRzVHlwZSA9IG91dGJvdW5kID8gJ291dGJvdW5kLXJ0cCcgOiAnaW5ib3VuZC1ydHAnO1xuICBjb25zdCBmaWx0ZXJlZFJlc3VsdCA9IG5ldyBNYXAoKTtcbiAgaWYgKHRyYWNrID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZpbHRlcmVkUmVzdWx0O1xuICB9XG4gIGNvbnN0IHRyYWNrU3RhdHMgPSBbXTtcbiAgcmVzdWx0LmZvckVhY2godmFsdWUgPT4ge1xuICAgIGlmICh2YWx1ZS50eXBlID09PSAndHJhY2snICYmIHZhbHVlLnRyYWNrSWRlbnRpZmllciA9PT0gdHJhY2suaWQpIHtcbiAgICAgIHRyYWNrU3RhdHMucHVzaCh2YWx1ZSk7XG4gICAgfVxuICB9KTtcbiAgdHJhY2tTdGF0cy5mb3JFYWNoKHRyYWNrU3RhdCA9PiB7XG4gICAgcmVzdWx0LmZvckVhY2goc3RhdHMgPT4ge1xuICAgICAgaWYgKHN0YXRzLnR5cGUgPT09IHN0cmVhbVN0YXRzVHlwZSAmJiBzdGF0cy50cmFja0lkID09PSB0cmFja1N0YXQuaWQpIHtcbiAgICAgICAgd2Fsa1N0YXRzKHJlc3VsdCwgc3RhdHMsIGZpbHRlcmVkUmVzdWx0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBmaWx0ZXJlZFJlc3VsdDtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmNvbnN0IGxvZ2dpbmcgPSBsb2c7XG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhJDIod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgaWYgKCFuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGNvbnN0cmFpbnRzVG9DaHJvbWVfID0gZnVuY3Rpb24gKGMpIHtcbiAgICBpZiAodHlwZW9mIGMgIT09ICdvYmplY3QnIHx8IGMubWFuZGF0b3J5IHx8IGMub3B0aW9uYWwpIHtcbiAgICAgIHJldHVybiBjO1xuICAgIH1cbiAgICBjb25zdCBjYyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIGlmIChrZXkgPT09ICdyZXF1aXJlJyB8fCBrZXkgPT09ICdhZHZhbmNlZCcgfHwga2V5ID09PSAnbWVkaWFTb3VyY2UnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHIgPSB0eXBlb2YgY1trZXldID09PSAnb2JqZWN0JyA/IGNba2V5XSA6IHtcbiAgICAgICAgaWRlYWw6IGNba2V5XVxuICAgICAgfTtcbiAgICAgIGlmIChyLmV4YWN0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHIuZXhhY3QgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHIubWluID0gci5tYXggPSByLmV4YWN0O1xuICAgICAgfVxuICAgICAgY29uc3Qgb2xkbmFtZV8gPSBmdW5jdGlvbiAocHJlZml4LCBuYW1lKSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICByZXR1cm4gcHJlZml4ICsgbmFtZS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hbWUgPT09ICdkZXZpY2VJZCcgPyAnc291cmNlSWQnIDogbmFtZTtcbiAgICAgIH07XG4gICAgICBpZiAoci5pZGVhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNjLm9wdGlvbmFsID0gY2Mub3B0aW9uYWwgfHwgW107XG4gICAgICAgIGxldCBvYyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHIuaWRlYWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJ21pbicsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgICBvYyA9IHt9O1xuICAgICAgICAgIG9jW29sZG5hbWVfKCdtYXgnLCBrZXkpXSA9IHIuaWRlYWw7XG4gICAgICAgICAgY2Mub3B0aW9uYWwucHVzaChvYyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2Nbb2xkbmFtZV8oJycsIGtleSldID0gci5pZGVhbDtcbiAgICAgICAgICBjYy5vcHRpb25hbC5wdXNoKG9jKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHIuZXhhY3QgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygci5leGFjdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgY2MubWFuZGF0b3J5ID0gY2MubWFuZGF0b3J5IHx8IHt9O1xuICAgICAgICBjYy5tYW5kYXRvcnlbb2xkbmFtZV8oJycsIGtleSldID0gci5leGFjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFsnbWluJywgJ21heCddLmZvckVhY2gobWl4ID0+IHtcbiAgICAgICAgICBpZiAoclttaXhdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeSA9IGNjLm1hbmRhdG9yeSB8fCB7fTtcbiAgICAgICAgICAgIGNjLm1hbmRhdG9yeVtvbGRuYW1lXyhtaXgsIGtleSldID0gclttaXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKGMuYWR2YW5jZWQpIHtcbiAgICAgIGNjLm9wdGlvbmFsID0gKGNjLm9wdGlvbmFsIHx8IFtdKS5jb25jYXQoYy5hZHZhbmNlZCk7XG4gICAgfVxuICAgIHJldHVybiBjYztcbiAgfTtcbiAgY29uc3Qgc2hpbUNvbnN0cmFpbnRzXyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgZnVuYykge1xuICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDYxKSB7XG4gICAgICByZXR1cm4gZnVuYyhjb25zdHJhaW50cyk7XG4gICAgfVxuICAgIGNvbnN0cmFpbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShjb25zdHJhaW50cykpO1xuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBjb25zdCByZW1hcCA9IGZ1bmN0aW9uIChvYmosIGEsIGIpIHtcbiAgICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XG4gICAgICAgICAgb2JqW2JdID0gb2JqW2FdO1xuICAgICAgICAgIGRlbGV0ZSBvYmpbYV07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBjb25zdHJhaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgIHJlbWFwKGNvbnN0cmFpbnRzLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ2dvb2dBdXRvR2FpbkNvbnRyb2wnKTtcbiAgICAgIHJlbWFwKGNvbnN0cmFpbnRzLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdnb29nTm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy5hdWRpbyk7XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cyAmJiB0eXBlb2YgY29uc3RyYWludHMudmlkZW8gPT09ICdvYmplY3QnKSB7XG4gICAgICAvLyBTaGltIGZhY2luZ01vZGUgZm9yIG1vYmlsZSAmIHN1cmZhY2UgcHJvLlxuICAgICAgbGV0IGZhY2UgPSBjb25zdHJhaW50cy52aWRlby5mYWNpbmdNb2RlO1xuICAgICAgZmFjZSA9IGZhY2UgJiYgKHR5cGVvZiBmYWNlID09PSAnb2JqZWN0JyA/IGZhY2UgOiB7XG4gICAgICAgIGlkZWFsOiBmYWNlXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzID0gYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDY2O1xuICAgICAgaWYgKGZhY2UgJiYgKGZhY2UuZXhhY3QgPT09ICd1c2VyJyB8fCBmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICd1c2VyJyB8fCBmYWNlLmlkZWFsID09PSAnZW52aXJvbm1lbnQnKSAmJiAhKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0U3VwcG9ydGVkQ29uc3RyYWludHMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpLmZhY2luZ01vZGUgJiYgIWdldFN1cHBvcnRlZEZhY2luZ01vZGVMaWVzKSkge1xuICAgICAgICBkZWxldGUgY29uc3RyYWludHMudmlkZW8uZmFjaW5nTW9kZTtcbiAgICAgICAgbGV0IG1hdGNoZXM7XG4gICAgICAgIGlmIChmYWNlLmV4YWN0ID09PSAnZW52aXJvbm1lbnQnIHx8IGZhY2UuaWRlYWwgPT09ICdlbnZpcm9ubWVudCcpIHtcbiAgICAgICAgICBtYXRjaGVzID0gWydiYWNrJywgJ3JlYXInXTtcbiAgICAgICAgfSBlbHNlIGlmIChmYWNlLmV4YWN0ID09PSAndXNlcicgfHwgZmFjZS5pZGVhbCA9PT0gJ3VzZXInKSB7XG4gICAgICAgICAgbWF0Y2hlcyA9IFsnZnJvbnQnXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2hlcykge1xuICAgICAgICAgIC8vIExvb2sgZm9yIG1hdGNoZXMgaW4gbGFiZWwsIG9yIHVzZSBsYXN0IGNhbSBmb3IgYmFjayAodHlwaWNhbCkuXG4gICAgICAgICAgcmV0dXJuIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpLnRoZW4oZGV2aWNlcyA9PiB7XG4gICAgICAgICAgICBkZXZpY2VzID0gZGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09ICd2aWRlb2lucHV0Jyk7XG4gICAgICAgICAgICBsZXQgZGV2ID0gZGV2aWNlcy5maW5kKGQgPT4gbWF0Y2hlcy5zb21lKG1hdGNoID0+IGQubGFiZWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhtYXRjaCkpKTtcbiAgICAgICAgICAgIGlmICghZGV2ICYmIGRldmljZXMubGVuZ3RoICYmIG1hdGNoZXMuaW5jbHVkZXMoJ2JhY2snKSkge1xuICAgICAgICAgICAgICBkZXYgPSBkZXZpY2VzW2RldmljZXMubGVuZ3RoIC0gMV07IC8vIG1vcmUgbGlrZWx5IHRoZSBiYWNrIGNhbVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRldikge1xuICAgICAgICAgICAgICBjb25zdHJhaW50cy52aWRlby5kZXZpY2VJZCA9IGZhY2UuZXhhY3QgPyB7XG4gICAgICAgICAgICAgICAgZXhhY3Q6IGRldi5kZXZpY2VJZFxuICAgICAgICAgICAgICB9IDoge1xuICAgICAgICAgICAgICAgIGlkZWFsOiBkZXYuZGV2aWNlSWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gY29uc3RyYWludHNUb0Nocm9tZV8oY29uc3RyYWludHMudmlkZW8pO1xuICAgICAgICAgICAgbG9nZ2luZygnY2hyb21lOiAnICsgSlNPTi5zdHJpbmdpZnkoY29uc3RyYWludHMpKTtcbiAgICAgICAgICAgIHJldHVybiBmdW5jKGNvbnN0cmFpbnRzKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBjb25zdHJhaW50c1RvQ2hyb21lXyhjb25zdHJhaW50cy52aWRlbyk7XG4gICAgfVxuICAgIGxvZ2dpbmcoJ2Nocm9tZTogJyArIEpTT04uc3RyaW5naWZ5KGNvbnN0cmFpbnRzKSk7XG4gICAgcmV0dXJuIGZ1bmMoY29uc3RyYWludHMpO1xuICB9O1xuICBjb25zdCBzaGltRXJyb3JfID0gZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2NCkge1xuICAgICAgcmV0dXJuIGU7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB7XG4gICAgICAgIFBlcm1pc3Npb25EZW5pZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIFBlcm1pc3Npb25EaXNtaXNzZWRFcnJvcjogJ05vdEFsbG93ZWRFcnJvcicsXG4gICAgICAgIEludmFsaWRTdGF0ZUVycm9yOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgRGV2aWNlc05vdEZvdW5kRXJyb3I6ICdOb3RGb3VuZEVycm9yJyxcbiAgICAgICAgQ29uc3RyYWludE5vdFNhdGlzZmllZEVycm9yOiAnT3ZlcmNvbnN0cmFpbmVkRXJyb3InLFxuICAgICAgICBUcmFja1N0YXJ0RXJyb3I6ICdOb3RSZWFkYWJsZUVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VGYWlsZWREdWVUb1NodXRkb3duOiAnTm90QWxsb3dlZEVycm9yJyxcbiAgICAgICAgTWVkaWFEZXZpY2VLaWxsU3dpdGNoT246ICdOb3RBbGxvd2VkRXJyb3InLFxuICAgICAgICBUYWJDYXB0dXJlRXJyb3I6ICdBYm9ydEVycm9yJyxcbiAgICAgICAgU2NyZWVuQ2FwdHVyZUVycm9yOiAnQWJvcnRFcnJvcicsXG4gICAgICAgIERldmljZUNhcHR1cmVFcnJvcjogJ0Fib3J0RXJyb3InXG4gICAgICB9W2UubmFtZV0gfHwgZS5uYW1lLFxuICAgICAgbWVzc2FnZTogZS5tZXNzYWdlLFxuICAgICAgY29uc3RyYWludDogZS5jb25zdHJhaW50IHx8IGUuY29uc3RyYWludE5hbWUsXG4gICAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmFtZSArICh0aGlzLm1lc3NhZ2UgJiYgJzogJykgKyB0aGlzLm1lc3NhZ2U7XG4gICAgICB9XG4gICAgfTtcbiAgfTtcbiAgY29uc3QgZ2V0VXNlck1lZGlhXyA9IGZ1bmN0aW9uIChjb25zdHJhaW50cywgb25TdWNjZXNzLCBvbkVycm9yKSB7XG4gICAgc2hpbUNvbnN0cmFpbnRzXyhjb25zdHJhaW50cywgYyA9PiB7XG4gICAgICBuYXZpZ2F0b3Iud2Via2l0R2V0VXNlck1lZGlhKGMsIG9uU3VjY2VzcywgZSA9PiB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihzaGltRXJyb3JfKGUpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBnZXRVc2VyTWVkaWFfLmJpbmQobmF2aWdhdG9yKTtcblxuICAvLyBFdmVuIHRob3VnaCBDaHJvbWUgNDUgaGFzIG5hdmlnYXRvci5tZWRpYURldmljZXMgYW5kIGEgZ2V0VXNlck1lZGlhXG4gIC8vIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBQcm9taXNlLCBpdCBkb2VzIG5vdCBhY2NlcHQgc3BlYy1zdHlsZVxuICAvLyBjb25zdHJhaW50cy5cbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKSB7XG4gICAgY29uc3Qgb3JpZ0dldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY3MpIHtcbiAgICAgIHJldHVybiBzaGltQ29uc3RyYWludHNfKGNzLCBjID0+IG9yaWdHZXRVc2VyTWVkaWEoYykudGhlbihzdHJlYW0gPT4ge1xuICAgICAgICBpZiAoYy5hdWRpbyAmJiAhc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoIHx8IGMudmlkZW8gJiYgIXN0cmVhbS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCkge1xuICAgICAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCcnLCAnTm90Rm91bmRFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJlYW07XG4gICAgICB9LCBlID0+IFByb21pc2UucmVqZWN0KHNoaW1FcnJvcl8oZSkpKSk7XG4gICAgfTtcbiAgfVxufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbU1lZGlhU3RyZWFtKHdpbmRvdykge1xuICB3aW5kb3cuTWVkaWFTdHJlYW0gPSB3aW5kb3cuTWVkaWFTdHJlYW0gfHwgd2luZG93LndlYmtpdE1lZGlhU3RyZWFtO1xufVxuZnVuY3Rpb24gc2hpbU9uVHJhY2skMSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAhKCdvbnRyYWNrJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnb250cmFjaycsIHtcbiAgICAgIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29udHJhY2s7XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29udHJhY2spIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb250cmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29udHJhY2sgPSBmKTtcbiAgICAgIH0sXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuX29udHJhY2twb2x5KSB7XG4gICAgICAgIHRoaXMuX29udHJhY2twb2x5ID0gZSA9PiB7XG4gICAgICAgICAgLy8gb25hZGRzdHJlYW0gZG9lcyBub3QgZmlyZSB3aGVuIGEgdHJhY2sgaXMgYWRkZWQgdG8gYW4gZXhpc3RpbmdcbiAgICAgICAgICAvLyBzdHJlYW0uIEJ1dCBzdHJlYW0ub25hZGR0cmFjayBpcyBpbXBsZW1lbnRlZCBzbyB3ZSB1c2UgdGhhdC5cbiAgICAgICAgICBlLnN0cmVhbS5hZGRFdmVudExpc3RlbmVyKCdhZGR0cmFjaycsIHRlID0+IHtcbiAgICAgICAgICAgIGxldCByZWNlaXZlcjtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycykge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZmluZChyID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gdGUudHJhY2suaWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgICAgdHJhY2s6IHRlLnRyYWNrXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgndHJhY2snKTtcbiAgICAgICAgICAgIGV2ZW50LnRyYWNrID0gdGUudHJhY2s7XG4gICAgICAgICAgICBldmVudC5yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgICAgICAgICAgZXZlbnQudHJhbnNjZWl2ZXIgPSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtcyA9IFtlLnN0cmVhbV07XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIGUuc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVjZWl2ZXJzKSB7XG4gICAgICAgICAgICAgIHJlY2VpdmVyID0gdGhpcy5nZXRSZWNlaXZlcnMoKS5maW5kKHIgPT4gci50cmFjayAmJiByLnRyYWNrLmlkID09PSB0cmFjay5pZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWNlaXZlciA9IHtcbiAgICAgICAgICAgICAgICB0cmFja1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ3RyYWNrJyk7XG4gICAgICAgICAgICBldmVudC50cmFjayA9IHRyYWNrO1xuICAgICAgICAgICAgZXZlbnQucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgICAgICAgICAgIGV2ZW50LnRyYW5zY2VpdmVyID0ge1xuICAgICAgICAgICAgICByZWNlaXZlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbXMgPSBbZS5zdHJlYW1dO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbnRyYWNrcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBldmVuIGlmIFJUQ1J0cFRyYW5zY2VpdmVyIGlzIGluIHdpbmRvdywgaXQgaXMgb25seSB1c2VkIGFuZFxuICAgIC8vIGVtaXR0ZWQgaW4gdW5pZmllZC1wbGFuLiBVbmZvcnR1bmF0ZWx5IHRoaXMgbWVhbnMgd2UgbmVlZFxuICAgIC8vIHRvIHVuY29uZGl0aW9uYWxseSB3cmFwIHRoZSBldmVudC5cbiAgICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICd0cmFjaycsIGUgPT4ge1xuICAgICAgaWYgKCFlLnRyYW5zY2VpdmVyKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgIHJlY2VpdmVyOiBlLnJlY2VpdmVyXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzaGltR2V0U2VuZGVyc1dpdGhEdG1mKHdpbmRvdykge1xuICAvLyBPdmVycmlkZXMgYWRkVHJhY2svcmVtb3ZlVHJhY2ssIGRlcGVuZHMgb24gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2suXG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgISgnZ2V0U2VuZGVycycgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpIHtcbiAgICBjb25zdCBzaGltU2VuZGVyV2l0aER0bWYgPSBmdW5jdGlvbiAocGMsIHRyYWNrKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0cmFjayxcbiAgICAgICAgZ2V0IGR0bWYoKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2R0bWYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHBjLmNyZWF0ZURUTUZTZW5kZXIodHJhY2spO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5fZHRtZiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0aGlzLl9kdG1mO1xuICAgICAgICB9LFxuICAgICAgICBfcGM6IHBjXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhdWdtZW50IGFkZFRyYWNrIHdoZW4gZ2V0U2VuZGVycyBpcyBub3QgYXZhaWxhYmxlLlxuICAgIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzKSB7XG4gICAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgICB0aGlzLl9zZW5kZXJzID0gdGhpcy5fc2VuZGVycyB8fCBbXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NlbmRlcnMuc2xpY2UoKTsgLy8gcmV0dXJuIGEgY29weSBvZiB0aGUgaW50ZXJuYWwgc3RhdGUuXG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjayh0cmFjaywgc3RyZWFtKSB7XG4gICAgICAgIGxldCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgaWYgKCFzZW5kZXIpIHtcbiAgICAgICAgICBzZW5kZXIgPSBzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spO1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzZW5kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgICAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICAgICAgb3JpZ1JlbW92ZVRyYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpO1xuICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRTdHJlYW0gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFN0cmVhbSA9IGZ1bmN0aW9uIGFkZFN0cmVhbShzdHJlYW0pIHtcbiAgICAgIHRoaXMuX3NlbmRlcnMgPSB0aGlzLl9zZW5kZXJzIHx8IFtdO1xuICAgICAgb3JpZ0FkZFN0cmVhbS5hcHBseSh0aGlzLCBbc3RyZWFtXSk7XG4gICAgICBzdHJlYW0uZ2V0VHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICAgIHRoaXMuX3NlbmRlcnMucHVzaChzaGltU2VuZGVyV2l0aER0bWYodGhpcywgdHJhY2spKTtcbiAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgICAgdGhpcy5fc2VuZGVycyA9IHRoaXMuX3NlbmRlcnMgfHwgW107XG4gICAgICBvcmlnUmVtb3ZlU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcy5fc2VuZGVycy5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgICBpZiAoc2VuZGVyKSB7XG4gICAgICAgICAgLy8gcmVtb3ZlIHNlbmRlclxuICAgICAgICAgIHRoaXMuX3NlbmRlcnMuc3BsaWNlKHRoaXMuX3NlbmRlcnMuaW5kZXhPZihzZW5kZXIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgJ2dldFNlbmRlcnMnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgJ2NyZWF0ZURUTUZTZW5kZXInIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUgJiYgd2luZG93LlJUQ1J0cFNlbmRlciAmJiAhKCdkdG1mJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFNlbmRlcnMgPSBmdW5jdGlvbiBnZXRTZW5kZXJzKCkge1xuICAgICAgY29uc3Qgc2VuZGVycyA9IG9yaWdHZXRTZW5kZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHNlbmRlcnM7XG4gICAgfTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUsICdkdG1mJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fZHRtZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgaWYgKHRoaXMudHJhY2sua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgdGhpcy5fZHRtZiA9IHRoaXMuX3BjLmNyZWF0ZURUTUZTZW5kZXIodGhpcy50cmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2R0bWYgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZHRtZjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHMod2luZG93KSB7XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUnRwU2VuZGVyICYmIHdpbmRvdy5SVENSdHBSZWNlaXZlcikpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIHNlbmRlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgICBpZiAob3JpZ0dldFNlbmRlcnMpIHtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycyA9IGZ1bmN0aW9uIGdldFNlbmRlcnMoKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICAgIHNlbmRlcnMuZm9yRWFjaChzZW5kZXIgPT4gc2VuZGVyLl9wYyA9IHRoaXMpO1xuICAgICAgICByZXR1cm4gc2VuZGVycztcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9yaWdBZGRUcmFjayA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2s7XG4gICAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKCkge1xuICAgICAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9O1xuICAgIH1cbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgICAgY29uc3Qgc2VuZGVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+XG4gICAgICAvKiBOb3RlOiB0aGlzIHdpbGwgaW5jbHVkZSBzdGF0cyBvZiBhbGwgc2VuZGVycyB0aGF0XG4gICAgICAgKiAgIHNlbmQgYSB0cmFjayB3aXRoIHRoZSBzYW1lIGlkIGFzIHNlbmRlci50cmFjayBhc1xuICAgICAgICogICBpdCBpcyBub3QgcG9zc2libGUgdG8gaWRlbnRpZnkgdGhlIFJUQ1J0cFNlbmRlci5cbiAgICAgICAqL1xuICAgICAgZmlsdGVyU3RhdHMocmVzdWx0LCBzZW5kZXIudHJhY2ssIHRydWUpKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gc2hpbSByZWNlaXZlciBzdGF0cy5cbiAgaWYgKCEoJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlKSkge1xuICAgIGNvbnN0IG9yaWdHZXRSZWNlaXZlcnMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFJlY2VpdmVycztcbiAgICBpZiAob3JpZ0dldFJlY2VpdmVycykge1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICAgIGNvbnN0IHJlY2VpdmVycyA9IG9yaWdHZXRSZWNlaXZlcnMuYXBwbHkodGhpcywgW10pO1xuICAgICAgICByZWNlaXZlcnMuZm9yRWFjaChyZWNlaXZlciA9PiByZWNlaXZlci5fcGMgPSB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICAgIH07XG4gICAgfVxuICAgIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgICBlLnJlY2VpdmVyLl9wYyA9IGUuc3JjRWxlbWVudDtcbiAgICAgIHJldHVybiBlO1xuICAgIH0pO1xuICAgIHdpbmRvdy5SVENSdHBSZWNlaXZlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICAgIGNvbnN0IHJlY2VpdmVyID0gdGhpcztcbiAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpLnRoZW4ocmVzdWx0ID0+IGZpbHRlclN0YXRzKHJlc3VsdCwgcmVjZWl2ZXIudHJhY2ssIGZhbHNlKSk7XG4gICAgfTtcbiAgfVxuICBpZiAoISgnZ2V0U3RhdHMnIGluIHdpbmRvdy5SVENSdHBTZW5kZXIucHJvdG90eXBlICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIFJUQ1BlZXJDb25uZWN0aW9uLmdldFN0YXRzKHRyYWNrKS5cbiAgY29uc3Qgb3JpZ0dldFN0YXRzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uIGdldFN0YXRzKCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gaW5zdGFuY2VvZiB3aW5kb3cuTWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgY29uc3QgdHJhY2sgPSBhcmd1bWVudHNbMF07XG4gICAgICBsZXQgc2VuZGVyO1xuICAgICAgbGV0IHJlY2VpdmVyO1xuICAgICAgbGV0IGVycjtcbiAgICAgIHRoaXMuZ2V0U2VuZGVycygpLmZvckVhY2gocyA9PiB7XG4gICAgICAgIGlmIChzLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgIGlmIChzZW5kZXIpIHtcbiAgICAgICAgICAgIGVyciA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRlciA9IHM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0UmVjZWl2ZXJzKCkuZm9yRWFjaChyID0+IHtcbiAgICAgICAgaWYgKHIudHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgICAgICBlcnIgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWNlaXZlciA9IHI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByLnRyYWNrID09PSB0cmFjaztcbiAgICAgIH0pO1xuICAgICAgaWYgKGVyciB8fCBzZW5kZXIgJiYgcmVjZWl2ZXIpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGFyZSBtb3JlIHRoYW4gb25lIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgICB9IGVsc2UgaWYgKHNlbmRlcikge1xuICAgICAgICByZXR1cm4gc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICB9IGVsc2UgaWYgKHJlY2VpdmVyKSB7XG4gICAgICAgIHJldHVybiByZWNlaXZlci5nZXRTdGF0cygpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBET01FeGNlcHRpb24oJ1RoZXJlIGlzIG5vIHNlbmRlciBvciByZWNlaXZlciBmb3IgdGhlIHRyYWNrLicsICdJbnZhbGlkQWNjZXNzRXJyb3InKSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnR2V0U3RhdHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSh3aW5kb3cpIHtcbiAgLy8gc2hpbSBhZGRUcmFjay9yZW1vdmVUcmFjayB3aXRoIG5hdGl2ZSB2YXJpYW50cyBpbiBvcmRlciB0byBtYWtlXG4gIC8vIHRoZSBpbnRlcmFjdGlvbnMgd2l0aCBsZWdhY3kgZ2V0TG9jYWxTdHJlYW1zIGJlaGF2ZSBhcyBpbiBvdGhlciBicm93c2Vycy5cbiAgLy8gS2VlcHMgYSBtYXBwaW5nIHN0cmVhbS5pZCA9PiBbc3RyZWFtLCBydHBzZW5kZXJzLi4uXVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcyA9IGZ1bmN0aW9uIGdldExvY2FsU3RyZWFtcygpIHtcbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcykubWFwKHN0cmVhbUlkID0+IHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdWzBdKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjayA9IGZ1bmN0aW9uIGFkZFRyYWNrKHRyYWNrLCBzdHJlYW0pIHtcbiAgICBpZiAoIXN0cmVhbSkge1xuICAgICAgcmV0dXJuIG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zID0gdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtcyB8fCB7fTtcbiAgICBjb25zdCBzZW5kZXIgPSBvcmlnQWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoIXRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXSkge1xuICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbSwgc2VuZGVyXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtLmlkXS5pbmRleE9mKHNlbmRlcikgPT09IC0xKSB7XG4gICAgICB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF0ucHVzaChzZW5kZXIpO1xuICAgIH1cbiAgICByZXR1cm4gc2VuZGVyO1xuICB9O1xuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIHN0cmVhbS5nZXRUcmFja3MoKS5mb3JFYWNoKHRyYWNrID0+IHtcbiAgICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgICAgaWYgKGFscmVhZHlFeGlzdHMpIHtcbiAgICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVHJhY2sgYWxyZWFkeSBleGlzdHMuJywgJ0ludmFsaWRBY2Nlc3NFcnJvcicpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IGV4aXN0aW5nU2VuZGVycyA9IHRoaXMuZ2V0U2VuZGVycygpO1xuICAgIG9yaWdBZGRTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBjb25zdCBuZXdTZW5kZXJzID0gdGhpcy5nZXRTZW5kZXJzKCkuZmlsdGVyKG5ld1NlbmRlciA9PiBleGlzdGluZ1NlbmRlcnMuaW5kZXhPZihuZXdTZW5kZXIpID09PSAtMSk7XG4gICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW0uaWRdID0gW3N0cmVhbV0uY29uY2F0KG5ld1NlbmRlcnMpO1xuICB9O1xuICBjb25zdCBvcmlnUmVtb3ZlU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtID0gZnVuY3Rpb24gcmVtb3ZlU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbS5pZF07XG4gICAgcmV0dXJuIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjaztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVUcmFjayA9IGZ1bmN0aW9uIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMgPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zIHx8IHt9O1xuICAgIGlmIChzZW5kZXIpIHtcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXMpLmZvckVhY2goc3RyZWFtSWQgPT4ge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXS5pbmRleE9mKHNlbmRlcik7XG4gICAgICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgICAgdGhpcy5fc2hpbW1lZExvY2FsU3RyZWFtc1tzdHJlYW1JZF0uc3BsaWNlKGlkeCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3NoaW1tZWRMb2NhbFN0cmVhbXNbc3RyZWFtSWRdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9zaGltbWVkTG9jYWxTdHJlYW1zW3N0cmVhbUlkXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnUmVtb3ZlVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gc2hpbSBhZGRUcmFjayBhbmQgcmVtb3ZlVHJhY2suXG4gIGlmICh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrICYmIGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPj0gNjUpIHtcbiAgICByZXR1cm4gc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlKHdpbmRvdyk7XG4gIH1cblxuICAvLyBhbHNvIHNoaW0gcGMuZ2V0TG9jYWxTdHJlYW1zIHdoZW4gYWRkVHJhY2sgaXMgc2hpbW1lZFxuICAvLyB0byByZXR1cm4gdGhlIG9yaWdpbmFsIHN0cmVhbXMuXG4gIGNvbnN0IG9yaWdHZXRMb2NhbFN0cmVhbXMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldExvY2FsU3RyZWFtcztcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRMb2NhbFN0cmVhbXMgPSBmdW5jdGlvbiBnZXRMb2NhbFN0cmVhbXMoKSB7XG4gICAgY29uc3QgbmF0aXZlU3RyZWFtcyA9IG9yaWdHZXRMb2NhbFN0cmVhbXMuYXBwbHkodGhpcyk7XG4gICAgdGhpcy5fcmV2ZXJzZVN0cmVhbXMgPSB0aGlzLl9yZXZlcnNlU3RyZWFtcyB8fCB7fTtcbiAgICByZXR1cm4gbmF0aXZlU3RyZWFtcy5tYXAoc3RyZWFtID0+IHRoaXMuX3JldmVyc2VTdHJlYW1zW3N0cmVhbS5pZF0pO1xuICB9O1xuICBjb25zdCBvcmlnQWRkU3RyZWFtID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRTdHJlYW07XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgY29uc3QgYWxyZWFkeUV4aXN0cyA9IHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoYWxyZWFkeUV4aXN0cykge1xuICAgICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGlkZW50aXR5IG1hcHBpbmcgZm9yIGNvbnNpc3RlbmN5IHdpdGggYWRkVHJhY2suXG4gICAgLy8gVW5sZXNzIHRoaXMgaXMgYmVpbmcgdXNlZCB3aXRoIGEgc3RyZWFtIGZyb20gYWRkVHJhY2suXG4gICAgaWYgKCF0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKSB7XG4gICAgICBjb25zdCBuZXdTdHJlYW0gPSBuZXcgd2luZG93Lk1lZGlhU3RyZWFtKHN0cmVhbS5nZXRUcmFja3MoKSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgc3RyZWFtID0gbmV3U3RyZWFtO1xuICAgIH1cbiAgICBvcmlnQWRkU3RyZWFtLmFwcGx5KHRoaXMsIFtzdHJlYW1dKTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1JlbW92ZVN0cmVhbSA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlU3RyZWFtO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICB0aGlzLl9zdHJlYW1zID0gdGhpcy5fc3RyZWFtcyB8fCB7fTtcbiAgICB0aGlzLl9yZXZlcnNlU3RyZWFtcyA9IHRoaXMuX3JldmVyc2VTdHJlYW1zIHx8IHt9O1xuICAgIG9yaWdSZW1vdmVTdHJlYW0uYXBwbHkodGhpcywgW3RoaXMuX3N0cmVhbXNbc3RyZWFtLmlkXSB8fCBzdHJlYW1dKTtcbiAgICBkZWxldGUgdGhpcy5fcmV2ZXJzZVN0cmVhbXNbdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdID8gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdLmlkIDogc3RyZWFtLmlkXTtcbiAgICBkZWxldGUgdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICB9O1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2ssIHN0cmVhbSkge1xuICAgIGlmICh0aGlzLnNpZ25hbGluZ1N0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIFJUQ1BlZXJDb25uZWN0aW9uXFwncyBzaWduYWxpbmdTdGF0ZSBpcyBcXCdjbG9zZWRcXCcuJywgJ0ludmFsaWRTdGF0ZUVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IHN0cmVhbXMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKHN0cmVhbXMubGVuZ3RoICE9PSAxIHx8ICFzdHJlYW1zWzBdLmdldFRyYWNrcygpLmZpbmQodCA9PiB0ID09PSB0cmFjaykpIHtcbiAgICAgIC8vIHRoaXMgaXMgbm90IGZ1bGx5IGNvcnJlY3QgYnV0IGFsbCB3ZSBjYW4gbWFuYWdlIHdpdGhvdXRcbiAgICAgIC8vIFtbYXNzb2NpYXRlZCBNZWRpYVN0cmVhbXNdXSBpbnRlcm5hbCBzbG90LlxuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVGhlIGFkYXB0ZXIuanMgYWRkVHJhY2sgcG9seWZpbGwgb25seSBzdXBwb3J0cyBhIHNpbmdsZSAnICsgJyBzdHJlYW0gd2hpY2ggaXMgYXNzb2NpYXRlZCB3aXRoIHRoZSBzcGVjaWZpZWQgdHJhY2suJywgJ05vdFN1cHBvcnRlZEVycm9yJyk7XG4gICAgfVxuICAgIGNvbnN0IGFscmVhZHlFeGlzdHMgPSB0aGlzLmdldFNlbmRlcnMoKS5maW5kKHMgPT4gcy50cmFjayA9PT0gdHJhY2spO1xuICAgIGlmIChhbHJlYWR5RXhpc3RzKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUcmFjayBhbHJlYWR5IGV4aXN0cy4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIHRoaXMuX3JldmVyc2VTdHJlYW1zID0gdGhpcy5fcmV2ZXJzZVN0cmVhbXMgfHwge307XG4gICAgY29uc3Qgb2xkU3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW0uaWRdO1xuICAgIGlmIChvbGRTdHJlYW0pIHtcbiAgICAgIC8vIHRoaXMgaXMgdXNpbmcgb2RkIENocm9tZSBiZWhhdmlvdXIsIHVzZSB3aXRoIGNhdXRpb246XG4gICAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NzgxNVxuICAgICAgLy8gTm90ZTogd2UgcmVseSBvbiB0aGUgaGlnaC1sZXZlbCBhZGRUcmFjay9kdG1mIHNoaW0gdG9cbiAgICAgIC8vIGNyZWF0ZSB0aGUgc2VuZGVyIHdpdGggYSBkdG1mIHNlbmRlci5cbiAgICAgIG9sZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG5cbiAgICAgIC8vIFRyaWdnZXIgT05OIGFzeW5jLlxuICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoJ25lZ290aWF0aW9ubmVlZGVkJykpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG5ld1N0cmVhbSA9IG5ldyB3aW5kb3cuTWVkaWFTdHJlYW0oW3RyYWNrXSk7XG4gICAgICB0aGlzLl9zdHJlYW1zW3N0cmVhbS5pZF0gPSBuZXdTdHJlYW07XG4gICAgICB0aGlzLl9yZXZlcnNlU3RyZWFtc1tuZXdTdHJlYW0uaWRdID0gc3RyZWFtO1xuICAgICAgdGhpcy5hZGRTdHJlYW0obmV3U3RyZWFtKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZ2V0U2VuZGVycygpLmZpbmQocyA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gIH07XG5cbiAgLy8gcmVwbGFjZSB0aGUgaW50ZXJuYWwgc3RyZWFtIGlkIHdpdGggdGhlIGV4dGVybmFsIG9uZSBhbmRcbiAgLy8gdmljZSB2ZXJzYS5cbiAgZnVuY3Rpb24gcmVwbGFjZUludGVybmFsU3RyZWFtSWQocGMsIGRlc2NyaXB0aW9uKSB7XG4gICAgbGV0IHNkcCA9IGRlc2NyaXB0aW9uLnNkcDtcbiAgICBPYmplY3Qua2V5cyhwYy5fcmV2ZXJzZVN0cmVhbXMgfHwgW10pLmZvckVhY2goaW50ZXJuYWxJZCA9PiB7XG4gICAgICBjb25zdCBleHRlcm5hbFN0cmVhbSA9IHBjLl9yZXZlcnNlU3RyZWFtc1tpbnRlcm5hbElkXTtcbiAgICAgIGNvbnN0IGludGVybmFsU3RyZWFtID0gcGMuX3N0cmVhbXNbZXh0ZXJuYWxTdHJlYW0uaWRdO1xuICAgICAgc2RwID0gc2RwLnJlcGxhY2UobmV3IFJlZ0V4cChpbnRlcm5hbFN0cmVhbS5pZCwgJ2cnKSwgZXh0ZXJuYWxTdHJlYW0uaWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBuZXcgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgIHR5cGU6IGRlc2NyaXB0aW9uLnR5cGUsXG4gICAgICBzZHBcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiByZXBsYWNlRXh0ZXJuYWxTdHJlYW1JZChwYywgZGVzY3JpcHRpb24pIHtcbiAgICBsZXQgc2RwID0gZGVzY3JpcHRpb24uc2RwO1xuICAgIE9iamVjdC5rZXlzKHBjLl9yZXZlcnNlU3RyZWFtcyB8fCBbXSkuZm9yRWFjaChpbnRlcm5hbElkID0+IHtcbiAgICAgIGNvbnN0IGV4dGVybmFsU3RyZWFtID0gcGMuX3JldmVyc2VTdHJlYW1zW2ludGVybmFsSWRdO1xuICAgICAgY29uc3QgaW50ZXJuYWxTdHJlYW0gPSBwYy5fc3RyZWFtc1tleHRlcm5hbFN0cmVhbS5pZF07XG4gICAgICBzZHAgPSBzZHAucmVwbGFjZShuZXcgUmVnRXhwKGV4dGVybmFsU3RyZWFtLmlkLCAnZycpLCBpbnRlcm5hbFN0cmVhbS5pZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG5ldyBSVENTZXNzaW9uRGVzY3JpcHRpb24oe1xuICAgICAgdHlwZTogZGVzY3JpcHRpb24udHlwZSxcbiAgICAgIHNkcFxuICAgIH0pO1xuICB9XG4gIFsnY3JlYXRlT2ZmZXInLCAnY3JlYXRlQW5zd2VyJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgY29uc3QgbmF0aXZlTWV0aG9kID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdO1xuICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgIFttZXRob2RdKCkge1xuICAgICAgICBjb25zdCBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBjb25zdCBpc0xlZ2FjeUNhbGwgPSBhcmd1bWVudHMubGVuZ3RoICYmIHR5cGVvZiBhcmd1bWVudHNbMF0gPT09ICdmdW5jdGlvbic7XG4gICAgICAgIGlmIChpc0xlZ2FjeUNhbGwpIHtcbiAgICAgICAgICByZXR1cm4gbmF0aXZlTWV0aG9kLmFwcGx5KHRoaXMsIFtkZXNjcmlwdGlvbiA9PiB7XG4gICAgICAgICAgICBjb25zdCBkZXNjID0gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgICAgICAgICAgYXJnc1swXS5hcHBseShudWxsLCBbZGVzY10pO1xuICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoYXJnc1sxXSkge1xuICAgICAgICAgICAgICBhcmdzWzFdLmFwcGx5KG51bGwsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgYXJndW1lbnRzWzJdXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpLnRoZW4oZGVzY3JpcHRpb24gPT4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICB9KTtcbiAgY29uc3Qgb3JpZ1NldExvY2FsRGVzY3JpcHRpb24gPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb247XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuc2V0TG9jYWxEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldExvY2FsRGVzY3JpcHRpb24oKSB7XG4gICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8ICFhcmd1bWVudHNbMF0udHlwZSkge1xuICAgICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGFyZ3VtZW50c1swXSA9IHJlcGxhY2VFeHRlcm5hbFN0cmVhbUlkKHRoaXMsIGFyZ3VtZW50c1swXSk7XG4gICAgcmV0dXJuIG9yaWdTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG5cbiAgLy8gVE9ETzogbWFuZ2xlIGdldFN0YXRzOiBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXN0YXRzLyNkb20tcnRjbWVkaWFzdHJlYW1zdGF0cy1zdHJlYW1pZGVudGlmaWVyXG5cbiAgY29uc3Qgb3JpZ0xvY2FsRGVzY3JpcHRpb24gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUsICdsb2NhbERlc2NyaXB0aW9uJyk7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLCAnbG9jYWxEZXNjcmlwdGlvbicsIHtcbiAgICBnZXQoKSB7XG4gICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IG9yaWdMb2NhbERlc2NyaXB0aW9uLmdldC5hcHBseSh0aGlzKTtcbiAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnJykge1xuICAgICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVwbGFjZUludGVybmFsU3RyZWFtSWQodGhpcywgZGVzY3JpcHRpb24pO1xuICAgIH1cbiAgfSk7XG4gIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUucmVtb3ZlVHJhY2sgPSBmdW5jdGlvbiByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICBpZiAodGhpcy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ1RoZSBSVENQZWVyQ29ubmVjdGlvblxcJ3Mgc2lnbmFsaW5nU3RhdGUgaXMgXFwnY2xvc2VkXFwnLicsICdJbnZhbGlkU3RhdGVFcnJvcicpO1xuICAgIH1cbiAgICAvLyBXZSBjYW4gbm90IHlldCBjaGVjayBmb3Igc2VuZGVyIGluc3RhbmNlb2YgUlRDUnRwU2VuZGVyXG4gICAgLy8gc2luY2Ugd2Ugc2hpbSBSVFBTZW5kZXIuIFNvIHdlIGNoZWNrIGlmIHNlbmRlci5fcGMgaXMgc2V0LlxuICAgIGlmICghc2VuZGVyLl9wYykge1xuICAgICAgdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignQXJndW1lbnQgMSBvZiBSVENQZWVyQ29ubmVjdGlvbi5yZW1vdmVUcmFjayAnICsgJ2RvZXMgbm90IGltcGxlbWVudCBpbnRlcmZhY2UgUlRDUnRwU2VuZGVyLicsICdUeXBlRXJyb3InKTtcbiAgICB9XG4gICAgY29uc3QgaXNMb2NhbCA9IHNlbmRlci5fcGMgPT09IHRoaXM7XG4gICAgaWYgKCFpc0xvY2FsKSB7XG4gICAgICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdTZW5kZXIgd2FzIG5vdCBjcmVhdGVkIGJ5IHRoaXMgY29ubmVjdGlvbi4nLCAnSW52YWxpZEFjY2Vzc0Vycm9yJyk7XG4gICAgfVxuXG4gICAgLy8gU2VhcmNoIGZvciB0aGUgbmF0aXZlIHN0cmVhbSB0aGUgc2VuZGVycyB0cmFjayBiZWxvbmdzIHRvLlxuICAgIHRoaXMuX3N0cmVhbXMgPSB0aGlzLl9zdHJlYW1zIHx8IHt9O1xuICAgIGxldCBzdHJlYW07XG4gICAgT2JqZWN0LmtleXModGhpcy5fc3RyZWFtcykuZm9yRWFjaChzdHJlYW1pZCA9PiB7XG4gICAgICBjb25zdCBoYXNUcmFjayA9IHRoaXMuX3N0cmVhbXNbc3RyZWFtaWRdLmdldFRyYWNrcygpLmZpbmQodHJhY2sgPT4gc2VuZGVyLnRyYWNrID09PSB0cmFjayk7XG4gICAgICBpZiAoaGFzVHJhY2spIHtcbiAgICAgICAgc3RyZWFtID0gdGhpcy5fc3RyZWFtc1tzdHJlYW1pZF07XG4gICAgICB9XG4gICAgfSk7XG4gICAgaWYgKHN0cmVhbSkge1xuICAgICAgaWYgKHN0cmVhbS5nZXRUcmFja3MoKS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgbGFzdCB0cmFjayBvZiB0aGUgc3RyZWFtLCByZW1vdmUgdGhlIHN0cmVhbS4gVGhpc1xuICAgICAgICAvLyB0YWtlcyBjYXJlIG9mIGFueSBzaGltbWVkIF9zZW5kZXJzLlxuICAgICAgICB0aGlzLnJlbW92ZVN0cmVhbSh0aGlzLl9yZXZlcnNlU3RyZWFtc1tzdHJlYW0uaWRdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHJlbHlpbmcgb24gdGhlIHNhbWUgb2RkIGNocm9tZSBiZWhhdmlvdXIgYXMgYWJvdmUuXG4gICAgICAgIHN0cmVhbS5yZW1vdmVUcmFjayhzZW5kZXIudHJhY2spO1xuICAgICAgfVxuICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudCgnbmVnb3RpYXRpb25uZWVkZWQnKSk7XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uJDEod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICAvLyB2ZXJ5IGJhc2ljIHN1cHBvcnQgZm9yIG9sZCB2ZXJzaW9ucy5cbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gPSB3aW5kb3cud2Via2l0UlRDUGVlckNvbm5lY3Rpb247XG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBzaGltIGltcGxpY2l0IGNyZWF0aW9uIG9mIFJUQ1Nlc3Npb25EZXNjcmlwdGlvbi9SVENJY2VDYW5kaWRhdGVcbiAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA1Mykge1xuICAgIFsnc2V0TG9jYWxEZXNjcmlwdGlvbicsICdzZXRSZW1vdGVEZXNjcmlwdGlvbicsICdhZGRJY2VDYW5kaWRhdGUnXS5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2QpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZU1ldGhvZCA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXTtcbiAgICAgIGNvbnN0IG1ldGhvZE9iaiA9IHtcbiAgICAgICAgW21ldGhvZF0oKSB7XG4gICAgICAgICAgYXJndW1lbnRzWzBdID0gbmV3IChtZXRob2QgPT09ICdhZGRJY2VDYW5kaWRhdGUnID8gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSA6IHdpbmRvdy5SVENTZXNzaW9uRGVzY3JpcHRpb24pKGFyZ3VtZW50c1swXSk7XG4gICAgICAgICAgcmV0dXJuIG5hdGl2ZU1ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZVttZXRob2RdID0gbWV0aG9kT2JqW21ldGhvZF07XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gQXR0ZW1wdCB0byBmaXggT05OIGluIHBsYW4tYiBtb2RlLlxuZnVuY3Rpb24gZml4TmVnb3RpYXRpb25OZWVkZWQod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICduZWdvdGlhdGlvbm5lZWRlZCcsIGUgPT4ge1xuICAgIGNvbnN0IHBjID0gZS50YXJnZXQ7XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA3MiB8fCBwYy5nZXRDb25maWd1cmF0aW9uICYmIHBjLmdldENvbmZpZ3VyYXRpb24oKS5zZHBTZW1hbnRpY3MgPT09ICdwbGFuLWInKSB7XG4gICAgICBpZiAocGMuc2lnbmFsaW5nU3RhdGUgIT09ICdzdGFibGUnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xufVxuXG52YXIgY2hyb21lU2hpbSA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBmaXhOZWdvdGlhdGlvbk5lZWRlZDogZml4TmVnb3RpYXRpb25OZWVkZWQsXG4gIHNoaW1BZGRUcmFja1JlbW92ZVRyYWNrOiBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayxcbiAgc2hpbUFkZFRyYWNrUmVtb3ZlVHJhY2tXaXRoTmF0aXZlOiBzaGltQWRkVHJhY2tSZW1vdmVUcmFja1dpdGhOYXRpdmUsXG4gIHNoaW1HZXRTZW5kZXJzV2l0aER0bWY6IHNoaW1HZXRTZW5kZXJzV2l0aER0bWYsXG4gIHNoaW1HZXRVc2VyTWVkaWE6IHNoaW1HZXRVc2VyTWVkaWEkMixcbiAgc2hpbU1lZGlhU3RyZWFtOiBzaGltTWVkaWFTdHJlYW0sXG4gIHNoaW1PblRyYWNrOiBzaGltT25UcmFjayQxLFxuICBzaGltUGVlckNvbm5lY3Rpb246IHNoaW1QZWVyQ29ubmVjdGlvbiQxLFxuICBzaGltU2VuZGVyUmVjZWl2ZXJHZXRTdGF0czogc2hpbVNlbmRlclJlY2VpdmVyR2V0U3RhdHNcbn0pO1xuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxNiBUaGUgV2ViUlRDIHByb2plY3QgYXV0aG9ycy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiAgVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYSBCU0Qtc3R5bGUgbGljZW5zZVxuICogIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3Qgb2YgdGhlIHNvdXJjZVxuICogIHRyZWUuXG4gKi9cbi8qIGVzbGludC1lbnYgbm9kZSAqL1xuZnVuY3Rpb24gc2hpbUdldFVzZXJNZWRpYSQxKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgY29uc3QgbmF2aWdhdG9yID0gd2luZG93ICYmIHdpbmRvdy5uYXZpZ2F0b3I7XG4gIGNvbnN0IE1lZGlhU3RyZWFtVHJhY2sgPSB3aW5kb3cgJiYgd2luZG93Lk1lZGlhU3RyZWFtVHJhY2s7XG4gIG5hdmlnYXRvci5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoY29uc3RyYWludHMsIG9uU3VjY2Vzcywgb25FcnJvcikge1xuICAgIC8vIFJlcGxhY2UgRmlyZWZveCA0NCsncyBkZXByZWNhdGlvbiB3YXJuaW5nIHdpdGggdW5wcmVmaXhlZCB2ZXJzaW9uLlxuICAgIGRlcHJlY2F0ZWQoJ25hdmlnYXRvci5nZXRVc2VyTWVkaWEnLCAnbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEnKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cykudGhlbihvblN1Y2Nlc3MsIG9uRXJyb3IpO1xuICB9O1xuICBpZiAoIShicm93c2VyRGV0YWlscy52ZXJzaW9uID4gNTUgJiYgJ2F1dG9HYWluQ29udHJvbCcgaW4gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRTdXBwb3J0ZWRDb25zdHJhaW50cygpKSkge1xuICAgIGNvbnN0IHJlbWFwID0gZnVuY3Rpb24gKG9iaiwgYSwgYikge1xuICAgICAgaWYgKGEgaW4gb2JqICYmICEoYiBpbiBvYmopKSB7XG4gICAgICAgIG9ialtiXSA9IG9ialthXTtcbiAgICAgICAgZGVsZXRlIG9ialthXTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IG5hdGl2ZUdldFVzZXJNZWRpYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobmF2aWdhdG9yLm1lZGlhRGV2aWNlcyk7XG4gICAgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEgPSBmdW5jdGlvbiAoYykge1xuICAgICAgaWYgKHR5cGVvZiBjID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgYy5hdWRpbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnYXV0b0dhaW5Db250cm9sJywgJ21vekF1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChjLmF1ZGlvLCAnbm9pc2VTdXBwcmVzc2lvbicsICdtb3pOb2lzZVN1cHByZXNzaW9uJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlR2V0VXNlck1lZGlhKGMpO1xuICAgIH07XG4gICAgaWYgKE1lZGlhU3RyZWFtVHJhY2sgJiYgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3MpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUdldFNldHRpbmdzID0gTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuZ2V0U2V0dGluZ3M7XG4gICAgICBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3Qgb2JqID0gbmF0aXZlR2V0U2V0dGluZ3MuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgcmVtYXAob2JqLCAnbW96QXV0b0dhaW5Db250cm9sJywgJ2F1dG9HYWluQ29udHJvbCcpO1xuICAgICAgICByZW1hcChvYmosICdtb3pOb2lzZVN1cHByZXNzaW9uJywgJ25vaXNlU3VwcHJlc3Npb24nKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChNZWRpYVN0cmVhbVRyYWNrICYmIE1lZGlhU3RyZWFtVHJhY2sucHJvdG90eXBlLmFwcGx5Q29uc3RyYWludHMpIHtcbiAgICAgIGNvbnN0IG5hdGl2ZUFwcGx5Q29uc3RyYWludHMgPSBNZWRpYVN0cmVhbVRyYWNrLnByb3RvdHlwZS5hcHBseUNvbnN0cmFpbnRzO1xuICAgICAgTWVkaWFTdHJlYW1UcmFjay5wcm90b3R5cGUuYXBwbHlDb25zdHJhaW50cyA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIGlmICh0aGlzLmtpbmQgPT09ICdhdWRpbycgJiYgdHlwZW9mIGMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgYyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYykpO1xuICAgICAgICAgIHJlbWFwKGMsICdhdXRvR2FpbkNvbnRyb2wnLCAnbW96QXV0b0dhaW5Db250cm9sJyk7XG4gICAgICAgICAgcmVtYXAoYywgJ25vaXNlU3VwcHJlc3Npb24nLCAnbW96Tm9pc2VTdXBwcmVzc2lvbicpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVBcHBseUNvbnN0cmFpbnRzLmFwcGx5KHRoaXMsIFtjXSk7XG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vKlxuICogIENvcHlyaWdodCAoYykgMjAxOCBUaGUgYWRhcHRlci5qcyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cblxuZnVuY3Rpb24gc2hpbUdldERpc3BsYXlNZWRpYSh3aW5kb3csIHByZWZlcnJlZE1lZGlhU291cmNlKSB7XG4gIGlmICh3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcyAmJiAnZ2V0RGlzcGxheU1lZGlhJyBpbiB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoIXdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHdpbmRvdy5uYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9IGZ1bmN0aW9uIGdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cykge1xuICAgIGlmICghKGNvbnN0cmFpbnRzICYmIGNvbnN0cmFpbnRzLnZpZGVvKSkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IERPTUV4Y2VwdGlvbignZ2V0RGlzcGxheU1lZGlhIHdpdGhvdXQgdmlkZW8gJyArICdjb25zdHJhaW50cyBpcyB1bmRlZmluZWQnKTtcbiAgICAgIGVyci5uYW1lID0gJ05vdEZvdW5kRXJyb3InO1xuICAgICAgLy8gZnJvbSBodHRwczovL2hleWNhbS5naXRodWIuaW8vd2ViaWRsLyNpZGwtRE9NRXhjZXB0aW9uLWVycm9yLW5hbWVzXG4gICAgICBlcnIuY29kZSA9IDg7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0cmFpbnRzLnZpZGVvID09PSB0cnVlKSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlbyA9IHtcbiAgICAgICAgbWVkaWFTb3VyY2U6IHByZWZlcnJlZE1lZGlhU291cmNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdHJhaW50cy52aWRlby5tZWRpYVNvdXJjZSA9IHByZWZlcnJlZE1lZGlhU291cmNlO1xuICAgIH1cbiAgICByZXR1cm4gd2luZG93Lm5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKTtcbiAgfTtcbn1cblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1PblRyYWNrKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1RyYWNrRXZlbnQgJiYgJ3JlY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUgJiYgISgndHJhbnNjZWl2ZXInIGluIHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlLCAndHJhbnNjZWl2ZXInLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVjZWl2ZXI6IHRoaXMucmVjZWl2ZXJcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVBlZXJDb25uZWN0aW9uKHdpbmRvdywgYnJvd3NlckRldGFpbHMpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICEod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uIHx8IHdpbmRvdy5tb3pSVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47IC8vIHByb2JhYmx5IG1lZGlhLnBlZXJjb25uZWN0aW9uLmVuYWJsZWQ9ZmFsc2UgaW4gYWJvdXQ6Y29uZmlnXG4gIH1cbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgLy8gdmVyeSBiYXNpYyBzdXBwb3J0IGZvciBvbGQgdmVyc2lvbnMuXG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gd2luZG93Lm1velJUQ1BlZXJDb25uZWN0aW9uO1xuICB9XG4gIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMpIHtcbiAgICAvLyBzaGltIGF3YXkgbmVlZCBmb3Igb2Jzb2xldGUgUlRDSWNlQ2FuZGlkYXRlL1JUQ1Nlc3Npb25EZXNjcmlwdGlvbi5cbiAgICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nLCAnYWRkSWNlQ2FuZGlkYXRlJ10uZm9yRWFjaChmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICBjb25zdCBuYXRpdmVNZXRob2QgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlW21ldGhvZF07XG4gICAgICBjb25zdCBtZXRob2RPYmogPSB7XG4gICAgICAgIFttZXRob2RdKCkge1xuICAgICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyAobWV0aG9kID09PSAnYWRkSWNlQ2FuZGlkYXRlJyA/IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUgOiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKShhcmd1bWVudHNbMF0pO1xuICAgICAgICAgIHJldHVybiBuYXRpdmVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGVbbWV0aG9kXSA9IG1ldGhvZE9ialttZXRob2RdO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0IG1vZGVyblN0YXRzVHlwZXMgPSB7XG4gICAgaW5ib3VuZHJ0cDogJ2luYm91bmQtcnRwJyxcbiAgICBvdXRib3VuZHJ0cDogJ291dGJvdW5kLXJ0cCcsXG4gICAgY2FuZGlkYXRlcGFpcjogJ2NhbmRpZGF0ZS1wYWlyJyxcbiAgICBsb2NhbGNhbmRpZGF0ZTogJ2xvY2FsLWNhbmRpZGF0ZScsXG4gICAgcmVtb3RlY2FuZGlkYXRlOiAncmVtb3RlLWNhbmRpZGF0ZSdcbiAgfTtcbiAgY29uc3QgbmF0aXZlR2V0U3RhdHMgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgY29uc3QgW3NlbGVjdG9yLCBvblN1Y2MsIG9uRXJyXSA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmF0aXZlR2V0U3RhdHMuYXBwbHkodGhpcywgW3NlbGVjdG9yIHx8IG51bGxdKS50aGVuKHN0YXRzID0+IHtcbiAgICAgIGlmIChicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNTMgJiYgIW9uU3VjYykge1xuICAgICAgICAvLyBTaGltIG9ubHkgcHJvbWlzZSBnZXRTdGF0cyB3aXRoIHNwZWMtaHlwaGVucyBpbiB0eXBlIG5hbWVzXG4gICAgICAgIC8vIExlYXZlIGNhbGxiYWNrIHZlcnNpb24gYWxvbmU7IG1pc2Mgb2xkIHVzZXMgb2YgZm9yRWFjaCBiZWZvcmUgTWFwXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgICAgIHN0YXQudHlwZSA9IG1vZGVyblN0YXRzVHlwZXNbc3RhdC50eXBlXSB8fCBzdGF0LnR5cGU7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBpZiAoZS5uYW1lICE9PSAnVHlwZUVycm9yJykge1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQXZvaWQgVHlwZUVycm9yOiBcInR5cGVcIiBpcyByZWFkLW9ubHksIGluIG9sZCB2ZXJzaW9ucy4gMzQtNDNpc2hcbiAgICAgICAgICBzdGF0cy5mb3JFYWNoKChzdGF0LCBpKSA9PiB7XG4gICAgICAgICAgICBzdGF0cy5zZXQoaSwgT2JqZWN0LmFzc2lnbih7fSwgc3RhdCwge1xuICAgICAgICAgICAgICB0eXBlOiBtb2Rlcm5TdGF0c1R5cGVzW3N0YXQudHlwZV0gfHwgc3RhdC50eXBlXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdGF0cztcbiAgICB9KS50aGVuKG9uU3VjYywgb25FcnIpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdykge1xuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHdpbmRvdy5SVENSdHBTZW5kZXIgJiYgJ2dldFN0YXRzJyBpbiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0U2VuZGVycyA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0U2VuZGVycztcbiAgaWYgKG9yaWdHZXRTZW5kZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRTZW5kZXJzID0gZnVuY3Rpb24gZ2V0U2VuZGVycygpIHtcbiAgICAgIGNvbnN0IHNlbmRlcnMgPSBvcmlnR2V0U2VuZGVycy5hcHBseSh0aGlzLCBbXSk7XG4gICAgICBzZW5kZXJzLmZvckVhY2goc2VuZGVyID0+IHNlbmRlci5fcGMgPSB0aGlzKTtcbiAgICAgIHJldHVybiBzZW5kZXJzO1xuICAgIH07XG4gIH1cbiAgY29uc3Qgb3JpZ0FkZFRyYWNrID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5hZGRUcmFjaztcbiAgaWYgKG9yaWdBZGRUcmFjaykge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhY2sgPSBmdW5jdGlvbiBhZGRUcmFjaygpIHtcbiAgICAgIGNvbnN0IHNlbmRlciA9IG9yaWdBZGRUcmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgc2VuZGVyLl9wYyA9IHRoaXM7XG4gICAgICByZXR1cm4gc2VuZGVyO1xuICAgIH07XG4gIH1cbiAgd2luZG93LlJUQ1J0cFNlbmRlci5wcm90b3R5cGUuZ2V0U3RhdHMgPSBmdW5jdGlvbiBnZXRTdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy50cmFjayA/IHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spIDogUHJvbWlzZS5yZXNvbHZlKG5ldyBNYXAoKSk7XG4gIH07XG59XG5mdW5jdGlvbiBzaGltUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uICYmIHdpbmRvdy5SVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICh3aW5kb3cuUlRDUnRwU2VuZGVyICYmICdnZXRTdGF0cycgaW4gd2luZG93LlJUQ1J0cFJlY2VpdmVyLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBvcmlnR2V0UmVjZWl2ZXJzID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnM7XG4gIGlmIChvcmlnR2V0UmVjZWl2ZXJzKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5nZXRSZWNlaXZlcnMgPSBmdW5jdGlvbiBnZXRSZWNlaXZlcnMoKSB7XG4gICAgICBjb25zdCByZWNlaXZlcnMgPSBvcmlnR2V0UmVjZWl2ZXJzLmFwcGx5KHRoaXMsIFtdKTtcbiAgICAgIHJlY2VpdmVycy5mb3JFYWNoKHJlY2VpdmVyID0+IHJlY2VpdmVyLl9wYyA9IHRoaXMpO1xuICAgICAgcmV0dXJuIHJlY2VpdmVycztcbiAgICB9O1xuICB9XG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ3RyYWNrJywgZSA9PiB7XG4gICAgZS5yZWNlaXZlci5fcGMgPSBlLnNyY0VsZW1lbnQ7XG4gICAgcmV0dXJuIGU7XG4gIH0pO1xuICB3aW5kb3cuUlRDUnRwUmVjZWl2ZXIucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gZ2V0U3RhdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKHRoaXMudHJhY2spO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ3JlbW92ZVN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnJlbW92ZVN0cmVhbSA9IGZ1bmN0aW9uIHJlbW92ZVN0cmVhbShzdHJlYW0pIHtcbiAgICBkZXByZWNhdGVkKCdyZW1vdmVTdHJlYW0nLCAncmVtb3ZlVHJhY2snKTtcbiAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICBpZiAoc2VuZGVyLnRyYWNrICYmIHN0cmVhbS5nZXRUcmFja3MoKS5pbmNsdWRlcyhzZW5kZXIudHJhY2spKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1SVENEYXRhQ2hhbm5lbCh3aW5kb3cpIHtcbiAgLy8gcmVuYW1lIERhdGFDaGFubmVsIHRvIFJUQ0RhdGFDaGFubmVsIChuYXRpdmUgZml4IGluIEZGNjApOlxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTczODUxXG4gIGlmICh3aW5kb3cuRGF0YUNoYW5uZWwgJiYgIXdpbmRvdy5SVENEYXRhQ2hhbm5lbCkge1xuICAgIHdpbmRvdy5SVENEYXRhQ2hhbm5lbCA9IHdpbmRvdy5EYXRhQ2hhbm5lbDtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUFkZFRyYW5zY2VpdmVyKHdpbmRvdykge1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2VicnRjSGFja3MvYWRhcHRlci9pc3N1ZXMvOTk4I2lzc3VlY29tbWVudC01MTY5MjE2NDdcbiAgLy8gRmlyZWZveCBpZ25vcmVzIHRoZSBpbml0IHNlbmRFbmNvZGluZ3Mgb3B0aW9ucyBwYXNzZWQgdG8gYWRkVHJhbnNjZWl2ZXJcbiAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM5NjkxOFxuICBpZiAoISh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IG9yaWdBZGRUcmFuc2NlaXZlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkVHJhbnNjZWl2ZXI7XG4gIGlmIChvcmlnQWRkVHJhbnNjZWl2ZXIpIHtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYW5zY2VpdmVyID0gZnVuY3Rpb24gYWRkVHJhbnNjZWl2ZXIoKSB7XG4gICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgLy8gV2ViSURMIGlucHV0IGNvZXJjaW9uIGFuZCB2YWxpZGF0aW9uXG4gICAgICBsZXQgc2VuZEVuY29kaW5ncyA9IGFyZ3VtZW50c1sxXSAmJiBhcmd1bWVudHNbMV0uc2VuZEVuY29kaW5ncztcbiAgICAgIGlmIChzZW5kRW5jb2RpbmdzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VuZEVuY29kaW5ncyA9IFtdO1xuICAgICAgfVxuICAgICAgc2VuZEVuY29kaW5ncyA9IFsuLi5zZW5kRW5jb2RpbmdzXTtcbiAgICAgIGNvbnN0IHNob3VsZFBlcmZvcm1DaGVjayA9IHNlbmRFbmNvZGluZ3MubGVuZ3RoID4gMDtcbiAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgLy8gSWYgc2VuZEVuY29kaW5ncyBwYXJhbXMgYXJlIHByb3ZpZGVkLCB2YWxpZGF0ZSBncmFtbWFyXG4gICAgICAgIHNlbmRFbmNvZGluZ3MuZm9yRWFjaChlbmNvZGluZ1BhcmFtID0+IHtcbiAgICAgICAgICBpZiAoJ3JpZCcgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgY29uc3QgcmlkUmVnZXggPSAvXlthLXowLTldezAsMTZ9JC9pO1xuICAgICAgICAgICAgaWYgKCFyaWRSZWdleC50ZXN0KGVuY29kaW5nUGFyYW0ucmlkKSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIFJJRCB2YWx1ZSBwcm92aWRlZC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCdzY2FsZVJlc29sdXRpb25Eb3duQnknIGluIGVuY29kaW5nUGFyYW0pIHtcbiAgICAgICAgICAgIGlmICghKHBhcnNlRmxvYXQoZW5jb2RpbmdQYXJhbS5zY2FsZVJlc29sdXRpb25Eb3duQnkpID49IDEuMCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NjYWxlX3Jlc29sdXRpb25fZG93bl9ieSBtdXN0IGJlID49IDEuMCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoJ21heEZyYW1lcmF0ZScgaW4gZW5jb2RpbmdQYXJhbSkge1xuICAgICAgICAgICAgaWYgKCEocGFyc2VGbG9hdChlbmNvZGluZ1BhcmFtLm1heEZyYW1lcmF0ZSkgPj0gMCkpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ21heF9mcmFtZXJhdGUgbXVzdCBiZSA+PSAwLjAnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSBvcmlnQWRkVHJhbnNjZWl2ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIGlmIChzaG91bGRQZXJmb3JtQ2hlY2spIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGluaXQgb3B0aW9ucyB3ZXJlIGFwcGxpZWQuIElmIG5vdCB3ZSBkbyB0aGlzIGluIGFuXG4gICAgICAgIC8vIGFzeW5jaHJvbm91cyB3YXkgYW5kIHNhdmUgdGhlIHByb21pc2UgcmVmZXJlbmNlIGluIGEgZ2xvYmFsIG9iamVjdC5cbiAgICAgICAgLy8gVGhpcyBpcyBhbiB1Z2x5IGhhY2ssIGJ1dCBhdCB0aGUgc2FtZSB0aW1lIGlzIHdheSBtb3JlIHJvYnVzdCB0aGFuXG4gICAgICAgIC8vIGNoZWNraW5nIHRoZSBzZW5kZXIgcGFyYW1ldGVycyBiZWZvcmUgYW5kIGFmdGVyIHRoZSBjcmVhdGVPZmZlclxuICAgICAgICAvLyBBbHNvIG5vdGUgdGhhdCBhZnRlciB0aGUgY3JlYXRlb2ZmZXIgd2UgYXJlIG5vdCAxMDAlIHN1cmUgdGhhdFxuICAgICAgICAvLyB0aGUgcGFyYW1zIHdlcmUgYXN5bmNocm9ub3VzbHkgYXBwbGllZCBzbyB3ZSBtaWdodCBtaXNzIHRoZVxuICAgICAgICAvLyBvcHBvcnR1bml0eSB0byByZWNyZWF0ZSBvZmZlci5cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHNlbmRlclxuICAgICAgICB9ID0gdHJhbnNjZWl2ZXI7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIGlmICghKCdlbmNvZGluZ3MnIGluIHBhcmFtcykgfHxcbiAgICAgICAgLy8gQXZvaWQgYmVpbmcgZm9vbGVkIGJ5IHBhdGNoZWQgZ2V0UGFyYW1ldGVycygpIGJlbG93LlxuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJiBPYmplY3Qua2V5cyhwYXJhbXMuZW5jb2RpbmdzWzBdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gc2VuZEVuY29kaW5ncztcbiAgICAgICAgICBzZW5kZXIuc2VuZEVuY29kaW5ncyA9IHNlbmRFbmNvZGluZ3M7XG4gICAgICAgICAgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMucHVzaChzZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHNlbmRlci5zZW5kRW5jb2RpbmdzO1xuICAgICAgICAgIH0pLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSBzZW5kZXIuc2VuZEVuY29kaW5ncztcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc2NlaXZlcjtcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzaGltR2V0UGFyYW1ldGVycyh3aW5kb3cpIHtcbiAgaWYgKCEodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcgJiYgd2luZG93LlJUQ1J0cFNlbmRlcikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0dldFBhcmFtZXRlcnMgPSB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzO1xuICBpZiAob3JpZ0dldFBhcmFtZXRlcnMpIHtcbiAgICB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzID0gZnVuY3Rpb24gZ2V0UGFyYW1ldGVycygpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IG9yaWdHZXRQYXJhbWV0ZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICBpZiAoISgnZW5jb2RpbmdzJyBpbiBwYXJhbXMpKSB7XG4gICAgICAgIHBhcmFtcy5lbmNvZGluZ3MgPSBbXS5jb25jYXQodGhpcy5zZW5kRW5jb2RpbmdzIHx8IFt7fV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBzaGltQ3JlYXRlT2ZmZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKCkge1xuICAgIGlmICh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyAmJiB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLmFsbCh0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcykudGhlbigoKSA9PiB7XG4gICAgICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICB0aGlzLnNldFBhcmFtZXRlcnNQcm9taXNlcyA9IFtdO1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1DcmVhdGVBbnN3ZXIod2luZG93KSB7XG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJydGNIYWNrcy9hZGFwdGVyL2lzc3Vlcy85OTgjaXNzdWVjb21tZW50LTUxNjkyMTY0N1xuICAvLyBGaXJlZm94IGlnbm9yZXMgdGhlIGluaXQgc2VuZEVuY29kaW5ncyBvcHRpb25zIHBhc3NlZCB0byBhZGRUcmFuc2NlaXZlclxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMzk2OTE4XG4gIGlmICghKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb3JpZ0NyZWF0ZUFuc3dlciA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuY3JlYXRlQW5zd2VyO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZUFuc3dlciA9IGZ1bmN0aW9uIGNyZWF0ZUFuc3dlcigpIHtcbiAgICBpZiAodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMgJiYgdGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5zZXRQYXJhbWV0ZXJzUHJvbWlzZXMpLnRoZW4oKCkgPT4ge1xuICAgICAgICByZXR1cm4gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSkuZmluYWxseSgoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0UGFyYW1ldGVyc1Byb21pc2VzID0gW107XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVBbnN3ZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIGZpcmVmb3hTaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHNoaW1BZGRUcmFuc2NlaXZlcjogc2hpbUFkZFRyYW5zY2VpdmVyLFxuICBzaGltQ3JlYXRlQW5zd2VyOiBzaGltQ3JlYXRlQW5zd2VyLFxuICBzaGltQ3JlYXRlT2ZmZXI6IHNoaW1DcmVhdGVPZmZlcixcbiAgc2hpbUdldERpc3BsYXlNZWRpYTogc2hpbUdldERpc3BsYXlNZWRpYSxcbiAgc2hpbUdldFBhcmFtZXRlcnM6IHNoaW1HZXRQYXJhbWV0ZXJzLFxuICBzaGltR2V0VXNlck1lZGlhOiBzaGltR2V0VXNlck1lZGlhJDEsXG4gIHNoaW1PblRyYWNrOiBzaGltT25UcmFjayxcbiAgc2hpbVBlZXJDb25uZWN0aW9uOiBzaGltUGVlckNvbm5lY3Rpb24sXG4gIHNoaW1SVENEYXRhQ2hhbm5lbDogc2hpbVJUQ0RhdGFDaGFubmVsLFxuICBzaGltUmVjZWl2ZXJHZXRTdGF0czogc2hpbVJlY2VpdmVyR2V0U3RhdHMsXG4gIHNoaW1SZW1vdmVTdHJlYW06IHNoaW1SZW1vdmVTdHJlYW0sXG4gIHNoaW1TZW5kZXJHZXRTdGF0czogc2hpbVNlbmRlckdldFN0YXRzXG59KTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTYgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG5mdW5jdGlvbiBzaGltTG9jYWxTdHJlYW1zQVBJKHdpbmRvdykge1xuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ29iamVjdCcgfHwgIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnZ2V0TG9jYWxTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0TG9jYWxTdHJlYW1zID0gZnVuY3Rpb24gZ2V0TG9jYWxTdHJlYW1zKCkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fbG9jYWxTdHJlYW1zO1xuICAgIH07XG4gIH1cbiAgaWYgKCEoJ2FkZFN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBjb25zdCBfYWRkVHJhY2sgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrO1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuYWRkU3RyZWFtID0gZnVuY3Rpb24gYWRkU3RyZWFtKHN0cmVhbSkge1xuICAgICAgaWYgKCF0aGlzLl9sb2NhbFN0cmVhbXMpIHtcbiAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW107XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICB9XG4gICAgICAvLyBUcnkgdG8gZW11bGF0ZSBDaHJvbWUncyBiZWhhdmlvdXIgb2YgYWRkaW5nIGluIGF1ZGlvLXZpZGVvIG9yZGVyLlxuICAgICAgLy8gU2FmYXJpIG9yZGVycyBieSB0cmFjayBpZC5cbiAgICAgIHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpLmZvckVhY2godHJhY2sgPT4gX2FkZFRyYWNrLmNhbGwodGhpcywgdHJhY2ssIHN0cmVhbSkpO1xuICAgICAgc3RyZWFtLmdldFZpZGVvVHJhY2tzKCkuZm9yRWFjaCh0cmFjayA9PiBfYWRkVHJhY2suY2FsbCh0aGlzLCB0cmFjaywgc3RyZWFtKSk7XG4gICAgfTtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZFRyYWNrID0gZnVuY3Rpb24gYWRkVHJhY2sodHJhY2spIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgc3RyZWFtc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICBpZiAoc3RyZWFtcykge1xuICAgICAgICBzdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zID0gW3N0cmVhbV07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5fbG9jYWxTdHJlYW1zLmluY2x1ZGVzKHN0cmVhbSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xvY2FsU3RyZWFtcy5wdXNoKHN0cmVhbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfYWRkVHJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdyZW1vdmVTdHJlYW0nIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5yZW1vdmVTdHJlYW0gPSBmdW5jdGlvbiByZW1vdmVTdHJlYW0oc3RyZWFtKSB7XG4gICAgICBpZiAoIXRoaXMuX2xvY2FsU3RyZWFtcykge1xuICAgICAgICB0aGlzLl9sb2NhbFN0cmVhbXMgPSBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbG9jYWxTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKTtcbiAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fbG9jYWxTdHJlYW1zLnNwbGljZShpbmRleCwgMSk7XG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VHJhY2tzKCk7XG4gICAgICB0aGlzLmdldFNlbmRlcnMoKS5mb3JFYWNoKHNlbmRlciA9PiB7XG4gICAgICAgIGlmICh0cmFja3MuaW5jbHVkZXMoc2VuZGVyLnRyYWNrKSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVJlbW90ZVN0cmVhbXNBUEkod2luZG93KSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAnb2JqZWN0JyB8fCAhd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghKCdnZXRSZW1vdGVTdHJlYW1zJyBpbiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUuZ2V0UmVtb3RlU3RyZWFtcyA9IGZ1bmN0aW9uIGdldFJlbW90ZVN0cmVhbXMoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fcmVtb3RlU3RyZWFtcyA/IHRoaXMuX3JlbW90ZVN0cmVhbXMgOiBbXTtcbiAgICB9O1xuICB9XG4gIGlmICghKCdvbmFkZHN0cmVhbScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ29uYWRkc3RyZWFtJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb25hZGRzdHJlYW07XG4gICAgICB9LFxuICAgICAgc2V0KGYpIHtcbiAgICAgICAgaWYgKHRoaXMuX29uYWRkc3RyZWFtKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSk7XG4gICAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCd0cmFjaycsIHRoaXMuX29uYWRkc3RyZWFtcG9seSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdhZGRzdHJlYW0nLCB0aGlzLl9vbmFkZHN0cmVhbSA9IGYpO1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZSA9PiB7XG4gICAgICAgICAgZS5zdHJlYW1zLmZvckVhY2goc3RyZWFtID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICB0aGlzLl9yZW1vdGVTdHJlYW1zID0gW107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtb3RlU3RyZWFtcy5pbmNsdWRlcyhzdHJlYW0pKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVN0cmVhbXMucHVzaChzdHJlYW0pO1xuICAgICAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ2FkZHN0cmVhbScpO1xuICAgICAgICAgICAgZXZlbnQuc3RyZWFtID0gc3RyZWFtO1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0UmVtb3RlRGVzY3JpcHRpb24oKSB7XG4gICAgICBjb25zdCBwYyA9IHRoaXM7XG4gICAgICBpZiAoIXRoaXMuX29uYWRkc3RyZWFtcG9seSkge1xuICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYWNrJywgdGhpcy5fb25hZGRzdHJlYW1wb2x5ID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICBlLnN0cmVhbXMuZm9yRWFjaChzdHJlYW0gPT4ge1xuICAgICAgICAgICAgaWYgKCFwYy5fcmVtb3RlU3RyZWFtcykge1xuICAgICAgICAgICAgICBwYy5fcmVtb3RlU3RyZWFtcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBjLl9yZW1vdGVTdHJlYW1zLmluZGV4T2Yoc3RyZWFtKSA+PSAwKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBjLl9yZW1vdGVTdHJlYW1zLnB1c2goc3RyZWFtKTtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KCdhZGRzdHJlYW0nKTtcbiAgICAgICAgICAgIGV2ZW50LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgIHBjLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkocGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbUNhbGxiYWNrc0FQSSh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8ICF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvdG90eXBlID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZTtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gcHJvdG90eXBlLmNyZWF0ZU9mZmVyO1xuICBjb25zdCBvcmlnQ3JlYXRlQW5zd2VyID0gcHJvdG90eXBlLmNyZWF0ZUFuc3dlcjtcbiAgY29uc3Qgc2V0TG9jYWxEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBjb25zdCBzZXRSZW1vdGVEZXNjcmlwdGlvbiA9IHByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgY29uc3QgYWRkSWNlQ2FuZGlkYXRlID0gcHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgcHJvdG90eXBlLmNyZWF0ZU9mZmVyID0gZnVuY3Rpb24gY3JlYXRlT2ZmZXIoc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+PSAyID8gYXJndW1lbnRzWzJdIDogYXJndW1lbnRzWzBdO1xuICAgIGNvbnN0IHByb21pc2UgPSBvcmlnQ3JlYXRlT2ZmZXIuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgICBpZiAoIWZhaWx1cmVDYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIHByb21pc2UudGhlbihzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjayk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICB9O1xuICBwcm90b3R5cGUuY3JlYXRlQW5zd2VyID0gZnVuY3Rpb24gY3JlYXRlQW5zd2VyKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1syXSA6IGFyZ3VtZW50c1swXTtcbiAgICBjb25zdCBwcm9taXNlID0gb3JpZ0NyZWF0ZUFuc3dlci5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIGxldCB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZGVzY3JpcHRpb24sIHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcHJvbWlzZSA9IHNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldExvY2FsRGVzY3JpcHRpb24gPSB3aXRoQ2FsbGJhY2s7XG4gIHdpdGhDYWxsYmFjayA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICBjb25zdCBwcm9taXNlID0gc2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2Rlc2NyaXB0aW9uXSk7XG4gICAgaWYgKCFmYWlsdXJlQ2FsbGJhY2spIHtcbiAgICAgIHJldHVybiBwcm9taXNlO1xuICAgIH1cbiAgICBwcm9taXNlLnRoZW4oc3VjY2Vzc0NhbGxiYWNrLCBmYWlsdXJlQ2FsbGJhY2spO1xuICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgfTtcbiAgcHJvdG90eXBlLnNldFJlbW90ZURlc2NyaXB0aW9uID0gd2l0aENhbGxiYWNrO1xuICB3aXRoQ2FsbGJhY2sgPSBmdW5jdGlvbiAoY2FuZGlkYXRlLCBzdWNjZXNzQ2FsbGJhY2ssIGZhaWx1cmVDYWxsYmFjaykge1xuICAgIGNvbnN0IHByb21pc2UgPSBhZGRJY2VDYW5kaWRhdGUuYXBwbHkodGhpcywgW2NhbmRpZGF0ZV0pO1xuICAgIGlmICghZmFpbHVyZUNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcHJvbWlzZS50aGVuKHN1Y2Nlc3NDYWxsYmFjaywgZmFpbHVyZUNhbGxiYWNrKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIH07XG4gIHByb3RvdHlwZS5hZGRJY2VDYW5kaWRhdGUgPSB3aXRoQ2FsbGJhY2s7XG59XG5mdW5jdGlvbiBzaGltR2V0VXNlck1lZGlhKHdpbmRvdykge1xuICBjb25zdCBuYXZpZ2F0b3IgPSB3aW5kb3cgJiYgd2luZG93Lm5hdmlnYXRvcjtcbiAgaWYgKG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICAvLyBzaGltIG5vdCBuZWVkZWQgaW4gU2FmYXJpIDEyLjFcbiAgICBjb25zdCBtZWRpYURldmljZXMgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzO1xuICAgIGNvbnN0IF9nZXRVc2VyTWVkaWEgPSBtZWRpYURldmljZXMuZ2V0VXNlck1lZGlhLmJpbmQobWVkaWFEZXZpY2VzKTtcbiAgICBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSA9IGNvbnN0cmFpbnRzID0+IHtcbiAgICAgIHJldHVybiBfZ2V0VXNlck1lZGlhKHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykpO1xuICAgIH07XG4gIH1cbiAgaWYgKCFuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhICYmIG5hdmlnYXRvci5tZWRpYURldmljZXMgJiYgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEpIHtcbiAgICBuYXZpZ2F0b3IuZ2V0VXNlck1lZGlhID0gZnVuY3Rpb24gZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzLCBjYiwgZXJyY2IpIHtcbiAgICAgIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKGNvbnN0cmFpbnRzKS50aGVuKGNiLCBlcnJjYik7XG4gICAgfS5iaW5kKG5hdmlnYXRvcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1Db25zdHJhaW50cyhjb25zdHJhaW50cykge1xuICBpZiAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHMudmlkZW8gIT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb25zdHJhaW50cywge1xuICAgICAgdmlkZW86IGNvbXBhY3RPYmplY3QoY29uc3RyYWludHMudmlkZW8pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNvbnN0cmFpbnRzO1xufVxuZnVuY3Rpb24gc2hpbVJUQ0ljZVNlcnZlclVybHMod2luZG93KSB7XG4gIGlmICghd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIC8vIG1pZ3JhdGUgZnJvbSBub24tc3BlYyBSVENJY2VTZXJ2ZXIudXJsIHRvIFJUQ0ljZVNlcnZlci51cmxzXG4gIGNvbnN0IE9yaWdQZWVyQ29ubmVjdGlvbiA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uID0gZnVuY3Rpb24gUlRDUGVlckNvbm5lY3Rpb24ocGNDb25maWcsIHBjQ29uc3RyYWludHMpIHtcbiAgICBpZiAocGNDb25maWcgJiYgcGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgY29uc3QgbmV3SWNlU2VydmVycyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwY0NvbmZpZy5pY2VTZXJ2ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBzZXJ2ZXIgPSBwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldO1xuICAgICAgICBpZiAoc2VydmVyLnVybHMgPT09IHVuZGVmaW5lZCAmJiBzZXJ2ZXIudXJsKSB7XG4gICAgICAgICAgZGVwcmVjYXRlZCgnUlRDSWNlU2VydmVyLnVybCcsICdSVENJY2VTZXJ2ZXIudXJscycpO1xuICAgICAgICAgIHNlcnZlciA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoc2VydmVyKSk7XG4gICAgICAgICAgc2VydmVyLnVybHMgPSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIGRlbGV0ZSBzZXJ2ZXIudXJsO1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChzZXJ2ZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0ljZVNlcnZlcnMucHVzaChwY0NvbmZpZy5pY2VTZXJ2ZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGNDb25maWcuaWNlU2VydmVycyA9IG5ld0ljZVNlcnZlcnM7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3JpZ1BlZXJDb25uZWN0aW9uKHBjQ29uZmlnLCBwY0NvbnN0cmFpbnRzKTtcbiAgfTtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSA9IE9yaWdQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIC8vIHdyYXAgc3RhdGljIG1ldGhvZHMuIEN1cnJlbnRseSBqdXN0IGdlbmVyYXRlQ2VydGlmaWNhdGUuXG4gIGlmICgnZ2VuZXJhdGVDZXJ0aWZpY2F0ZScgaW4gT3JpZ1BlZXJDb25uZWN0aW9uKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiwgJ2dlbmVyYXRlQ2VydGlmaWNhdGUnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiBPcmlnUGVlckNvbm5lY3Rpb24uZ2VuZXJhdGVDZXJ0aWZpY2F0ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gc2hpbVRyYWNrRXZlbnRUcmFuc2NlaXZlcih3aW5kb3cpIHtcbiAgLy8gQWRkIGV2ZW50LnRyYW5zY2VpdmVyIG1lbWJlciBvdmVyIGRlcHJlY2F0ZWQgZXZlbnQucmVjZWl2ZXJcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHdpbmRvdy5SVENUcmFja0V2ZW50ICYmICdyZWNlaXZlcicgaW4gd2luZG93LlJUQ1RyYWNrRXZlbnQucHJvdG90eXBlICYmICEoJ3RyYW5zY2VpdmVyJyBpbiB3aW5kb3cuUlRDVHJhY2tFdmVudC5wcm90b3R5cGUpKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHdpbmRvdy5SVENUcmFja0V2ZW50LnByb3RvdHlwZSwgJ3RyYW5zY2VpdmVyJywge1xuICAgICAgZ2V0KCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlY2VpdmVyOiB0aGlzLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNoaW1DcmVhdGVPZmZlckxlZ2FjeSh3aW5kb3cpIHtcbiAgY29uc3Qgb3JpZ0NyZWF0ZU9mZmVyID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlcjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5jcmVhdGVPZmZlciA9IGZ1bmN0aW9uIGNyZWF0ZU9mZmVyKG9mZmVyT3B0aW9ucykge1xuICAgIGlmIChvZmZlck9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVBdWRpbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlQXVkaW87XG4gICAgICB9XG4gICAgICBjb25zdCBhdWRpb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICdhdWRpbycpO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSBmYWxzZSAmJiBhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmIChhdWRpb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoYXVkaW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAoYXVkaW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGF1ZGlvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhdWRpb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZUF1ZGlvID09PSB0cnVlICYmICFhdWRpb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2Ygb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIHN1cHBvcnQgYml0IHZhbHVlc1xuICAgICAgICBvZmZlck9wdGlvbnMub2ZmZXJUb1JlY2VpdmVWaWRlbyA9ICEhb2ZmZXJPcHRpb25zLm9mZmVyVG9SZWNlaXZlVmlkZW87XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb1RyYW5zY2VpdmVyID0gdGhpcy5nZXRUcmFuc2NlaXZlcnMoKS5maW5kKHRyYW5zY2VpdmVyID0+IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLmtpbmQgPT09ICd2aWRlbycpO1xuICAgICAgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSBmYWxzZSAmJiB2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9PT0gJ3NlbmRyZWN2Jykge1xuICAgICAgICAgIGlmICh2aWRlb1RyYW5zY2VpdmVyLnNldERpcmVjdGlvbikge1xuICAgICAgICAgICAgdmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24oJ3NlbmRvbmx5Jyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodmlkZW9UcmFuc2NlaXZlci5kaXJlY3Rpb24gPT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICBpZiAodmlkZW9UcmFuc2NlaXZlci5zZXREaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIHZpZGVvVHJhbnNjZWl2ZXIuc2V0RGlyZWN0aW9uKCdpbmFjdGl2ZScpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2aWRlb1RyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZmVyT3B0aW9ucy5vZmZlclRvUmVjZWl2ZVZpZGVvID09PSB0cnVlICYmICF2aWRlb1RyYW5zY2VpdmVyKSB7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJywge1xuICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3Zvbmx5J1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9yaWdDcmVhdGVPZmZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuZnVuY3Rpb24gc2hpbUF1ZGlvQ29udGV4dCh3aW5kb3cpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICdvYmplY3QnIHx8IHdpbmRvdy5BdWRpb0NvbnRleHQpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LkF1ZGlvQ29udGV4dCA9IHdpbmRvdy53ZWJraXRBdWRpb0NvbnRleHQ7XG59XG5cbnZhciBzYWZhcmlTaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHNoaW1BdWRpb0NvbnRleHQ6IHNoaW1BdWRpb0NvbnRleHQsXG4gIHNoaW1DYWxsYmFja3NBUEk6IHNoaW1DYWxsYmFja3NBUEksXG4gIHNoaW1Db25zdHJhaW50czogc2hpbUNvbnN0cmFpbnRzLFxuICBzaGltQ3JlYXRlT2ZmZXJMZWdhY3k6IHNoaW1DcmVhdGVPZmZlckxlZ2FjeSxcbiAgc2hpbUdldFVzZXJNZWRpYTogc2hpbUdldFVzZXJNZWRpYSxcbiAgc2hpbUxvY2FsU3RyZWFtc0FQSTogc2hpbUxvY2FsU3RyZWFtc0FQSSxcbiAgc2hpbVJUQ0ljZVNlcnZlclVybHM6IHNoaW1SVENJY2VTZXJ2ZXJVcmxzLFxuICBzaGltUmVtb3RlU3RyZWFtc0FQSTogc2hpbVJlbW90ZVN0cmVhbXNBUEksXG4gIHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXI6IHNoaW1UcmFja0V2ZW50VHJhbnNjZWl2ZXJcbn0pO1xuXG52YXIgc2RwJDEgPSB7ZXhwb3J0czoge319O1xuXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbnZhciBoYXNSZXF1aXJlZFNkcDtcbmZ1bmN0aW9uIHJlcXVpcmVTZHAoKSB7XG4gIGlmIChoYXNSZXF1aXJlZFNkcCkgcmV0dXJuIHNkcCQxLmV4cG9ydHM7XG4gIGhhc1JlcXVpcmVkU2RwID0gMTtcbiAgKGZ1bmN0aW9uIChtb2R1bGUpIHtcblxuICAgIC8vIFNEUCBoZWxwZXJzLlxuICAgIGNvbnN0IFNEUFV0aWxzID0ge307XG5cbiAgICAvLyBHZW5lcmF0ZSBhbiBhbHBoYW51bWVyaWMgaWRlbnRpZmllciBmb3IgY25hbWUgb3IgbWlkcy5cbiAgICAvLyBUT0RPOiB1c2UgVVVJRHMgaW5zdGVhZD8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vamVkLzk4Mjg4M1xuICAgIFNEUFV0aWxzLmdlbmVyYXRlSWRlbnRpZmllciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBNYXRoLnJhbmRvbSgpLnRvU3RyaW5nKDM2KS5zdWJzdHJpbmcoMiwgMTIpO1xuICAgIH07XG5cbiAgICAvLyBUaGUgUlRDUCBDTkFNRSB1c2VkIGJ5IGFsbCBwZWVyY29ubmVjdGlvbnMgZnJvbSB0aGUgc2FtZSBKUy5cbiAgICBTRFBVdGlscy5sb2NhbENOYW1lID0gU0RQVXRpbHMuZ2VuZXJhdGVJZGVudGlmaWVyKCk7XG5cbiAgICAvLyBTcGxpdHMgU0RQIGludG8gbGluZXMsIGRlYWxpbmcgd2l0aCBib3RoIENSTEYgYW5kIExGLlxuICAgIFNEUFV0aWxzLnNwbGl0TGluZXMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgcmV0dXJuIGJsb2IudHJpbSgpLnNwbGl0KCdcXG4nKS5tYXAobGluZSA9PiBsaW5lLnRyaW0oKSk7XG4gICAgfTtcbiAgICAvLyBTcGxpdHMgU0RQIGludG8gc2Vzc2lvbnBhcnQgYW5kIG1lZGlhc2VjdGlvbnMuIEVuc3VyZXMgQ1JMRi5cbiAgICBTRFBVdGlscy5zcGxpdFNlY3Rpb25zID0gZnVuY3Rpb24gKGJsb2IpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gYmxvYi5zcGxpdCgnXFxubT0nKTtcbiAgICAgIHJldHVybiBwYXJ0cy5tYXAoKHBhcnQsIGluZGV4KSA9PiAoaW5kZXggPiAwID8gJ209JyArIHBhcnQgOiBwYXJ0KS50cmltKCkgKyAnXFxyXFxuJyk7XG4gICAgfTtcblxuICAgIC8vIFJldHVybnMgdGhlIHNlc3Npb24gZGVzY3JpcHRpb24uXG4gICAgU0RQVXRpbHMuZ2V0RGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICAgICAgcmV0dXJuIHNlY3Rpb25zICYmIHNlY3Rpb25zWzBdO1xuICAgIH07XG5cbiAgICAvLyBSZXR1cm5zIHRoZSBpbmRpdmlkdWFsIG1lZGlhIHNlY3Rpb25zLlxuICAgIFNEUFV0aWxzLmdldE1lZGlhU2VjdGlvbnMgPSBmdW5jdGlvbiAoYmxvYikge1xuICAgICAgY29uc3Qgc2VjdGlvbnMgPSBTRFBVdGlscy5zcGxpdFNlY3Rpb25zKGJsb2IpO1xuICAgICAgc2VjdGlvbnMuc2hpZnQoKTtcbiAgICAgIHJldHVybiBzZWN0aW9ucztcbiAgICB9O1xuXG4gICAgLy8gUmV0dXJucyBsaW5lcyB0aGF0IHN0YXJ0IHdpdGggYSBjZXJ0YWluIHByZWZpeC5cbiAgICBTRFBVdGlscy5tYXRjaFByZWZpeCA9IGZ1bmN0aW9uIChibG9iLCBwcmVmaXgpIHtcbiAgICAgIHJldHVybiBTRFBVdGlscy5zcGxpdExpbmVzKGJsb2IpLmZpbHRlcihsaW5lID0+IGxpbmUuaW5kZXhPZihwcmVmaXgpID09PSAwKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGFuIElDRSBjYW5kaWRhdGUgbGluZS4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGNhbmRpZGF0ZTo3MDI3ODYzNTAgMiB1ZHAgNDE4MTk5MDIgOC44LjguOCA2MDc2OSB0eXAgcmVsYXkgcmFkZHIgOC44LjguOFxuICAgIC8vIHJwb3J0IDU1OTk2XCJcbiAgICAvLyBJbnB1dCBjYW4gYmUgcHJlZml4ZWQgd2l0aCBhPS5cbiAgICBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBsZXQgcGFydHM7XG4gICAgICAvLyBQYXJzZSBib3RoIHZhcmlhbnRzLlxuICAgICAgaWYgKGxpbmUuaW5kZXhPZignYT1jYW5kaWRhdGU6JykgPT09IDApIHtcbiAgICAgICAgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMikuc3BsaXQoJyAnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTApLnNwbGl0KCcgJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSB7XG4gICAgICAgIGZvdW5kYXRpb246IHBhcnRzWzBdLFxuICAgICAgICBjb21wb25lbnQ6IHtcbiAgICAgICAgICAxOiAncnRwJyxcbiAgICAgICAgICAyOiAncnRjcCdcbiAgICAgICAgfVtwYXJ0c1sxXV0gfHwgcGFydHNbMV0sXG4gICAgICAgIHByb3RvY29sOiBwYXJ0c1syXS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICBwcmlvcml0eTogcGFyc2VJbnQocGFydHNbM10sIDEwKSxcbiAgICAgICAgaXA6IHBhcnRzWzRdLFxuICAgICAgICBhZGRyZXNzOiBwYXJ0c1s0XSxcbiAgICAgICAgLy8gYWRkcmVzcyBpcyBhbiBhbGlhcyBmb3IgaXAuXG4gICAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzVdLCAxMCksXG4gICAgICAgIC8vIHNraXAgcGFydHNbNl0gPT0gJ3R5cCdcbiAgICAgICAgdHlwZTogcGFydHNbN11cbiAgICAgIH07XG4gICAgICBmb3IgKGxldCBpID0gODsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHN3aXRjaCAocGFydHNbaV0pIHtcbiAgICAgICAgICBjYXNlICdyYWRkcic6XG4gICAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICdycG9ydCc6XG4gICAgICAgICAgICBjYW5kaWRhdGUucmVsYXRlZFBvcnQgPSBwYXJzZUludChwYXJ0c1tpICsgMV0sIDEwKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3RjcHR5cGUnOlxuICAgICAgICAgICAgY2FuZGlkYXRlLnRjcFR5cGUgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlICd1ZnJhZyc6XG4gICAgICAgICAgICBjYW5kaWRhdGUudWZyYWcgPSBwYXJ0c1tpICsgMV07IC8vIGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LlxuICAgICAgICAgICAgY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gZXh0ZW5zaW9uIGhhbmRsaW5nLCBpbiBwYXJ0aWN1bGFyIHVmcmFnLiBEb24ndCBvdmVyd3JpdGUuXG4gICAgICAgICAgICBpZiAoY2FuZGlkYXRlW3BhcnRzW2ldXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgIGNhbmRpZGF0ZVtwYXJ0c1tpXV0gPSBwYXJ0c1tpICsgMV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICB9O1xuXG4gICAgLy8gVHJhbnNsYXRlcyBhIGNhbmRpZGF0ZSBvYmplY3QgaW50byBTRFAgY2FuZGlkYXRlIGF0dHJpYnV0ZS5cbiAgICAvLyBUaGlzIGRvZXMgbm90IGluY2x1ZGUgdGhlIGE9IHByZWZpeCFcbiAgICBTRFBVdGlscy53cml0ZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIChjYW5kaWRhdGUpIHtcbiAgICAgIGNvbnN0IHNkcCA9IFtdO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLmZvdW5kYXRpb24pO1xuICAgICAgY29uc3QgY29tcG9uZW50ID0gY2FuZGlkYXRlLmNvbXBvbmVudDtcbiAgICAgIGlmIChjb21wb25lbnQgPT09ICdydHAnKSB7XG4gICAgICAgIHNkcC5wdXNoKDEpO1xuICAgICAgfSBlbHNlIGlmIChjb21wb25lbnQgPT09ICdydGNwJykge1xuICAgICAgICBzZHAucHVzaCgyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNkcC5wdXNoKGNvbXBvbmVudCk7XG4gICAgICB9XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUucHJvdG9jb2wudG9VcHBlckNhc2UoKSk7XG4gICAgICBzZHAucHVzaChjYW5kaWRhdGUucHJpb3JpdHkpO1xuICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLmFkZHJlc3MgfHwgY2FuZGlkYXRlLmlwKTtcbiAgICAgIHNkcC5wdXNoKGNhbmRpZGF0ZS5wb3J0KTtcbiAgICAgIGNvbnN0IHR5cGUgPSBjYW5kaWRhdGUudHlwZTtcbiAgICAgIHNkcC5wdXNoKCd0eXAnKTtcbiAgICAgIHNkcC5wdXNoKHR5cGUpO1xuICAgICAgaWYgKHR5cGUgIT09ICdob3N0JyAmJiBjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MgJiYgY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KSB7XG4gICAgICAgIHNkcC5wdXNoKCdyYWRkcicpO1xuICAgICAgICBzZHAucHVzaChjYW5kaWRhdGUucmVsYXRlZEFkZHJlc3MpO1xuICAgICAgICBzZHAucHVzaCgncnBvcnQnKTtcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnJlbGF0ZWRQb3J0KTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5kaWRhdGUudGNwVHlwZSAmJiBjYW5kaWRhdGUucHJvdG9jb2wudG9Mb3dlckNhc2UoKSA9PT0gJ3RjcCcpIHtcbiAgICAgICAgc2RwLnB1c2goJ3RjcHR5cGUnKTtcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnRjcFR5cGUpO1xuICAgICAgfVxuICAgICAgaWYgKGNhbmRpZGF0ZS51c2VybmFtZUZyYWdtZW50IHx8IGNhbmRpZGF0ZS51ZnJhZykge1xuICAgICAgICBzZHAucHVzaCgndWZyYWcnKTtcbiAgICAgICAgc2RwLnB1c2goY2FuZGlkYXRlLnVzZXJuYW1lRnJhZ21lbnQgfHwgY2FuZGlkYXRlLnVmcmFnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnY2FuZGlkYXRlOicgKyBzZHAuam9pbignICcpO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgYW4gaWNlLW9wdGlvbnMgbGluZSwgcmV0dXJucyBhbiBhcnJheSBvZiBvcHRpb24gdGFncy5cbiAgICAvLyBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1pY2Utb3B0aW9uczpmb28gYmFyXG4gICAgU0RQVXRpbHMucGFyc2VJY2VPcHRpb25zID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIHJldHVybiBsaW5lLnN1YnN0cmluZygxNCkuc3BsaXQoJyAnKTtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgcnRwbWFwIGxpbmUsIHJldHVybnMgUlRDUnRwQ29kZGVjUGFyYW1ldGVycy4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9cnRwbWFwOjExMSBvcHVzLzQ4MDAwLzJcbiAgICBTRFBVdGlscy5wYXJzZVJ0cE1hcCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBsZXQgcGFydHMgPSBsaW5lLnN1YnN0cmluZyg5KS5zcGxpdCgnICcpO1xuICAgICAgY29uc3QgcGFyc2VkID0ge1xuICAgICAgICBwYXlsb2FkVHlwZTogcGFyc2VJbnQocGFydHMuc2hpZnQoKSwgMTApIC8vIHdhczogaWRcbiAgICAgIH07XG4gICAgICBwYXJ0cyA9IHBhcnRzWzBdLnNwbGl0KCcvJyk7XG4gICAgICBwYXJzZWQubmFtZSA9IHBhcnRzWzBdO1xuICAgICAgcGFyc2VkLmNsb2NrUmF0ZSA9IHBhcnNlSW50KHBhcnRzWzFdLCAxMCk7IC8vIHdhczogY2xvY2tyYXRlXG4gICAgICBwYXJzZWQuY2hhbm5lbHMgPSBwYXJ0cy5sZW5ndGggPT09IDMgPyBwYXJzZUludChwYXJ0c1syXSwgMTApIDogMTtcbiAgICAgIC8vIGxlZ2FjeSBhbGlhcywgZ290IHJlbmFtZWQgYmFjayB0byBjaGFubmVscyBpbiBPUlRDLlxuICAgICAgcGFyc2VkLm51bUNoYW5uZWxzID0gcGFyc2VkLmNoYW5uZWxzO1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGVzIGEgcnRwbWFwIGxpbmUgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3JcbiAgICAvLyBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMud3JpdGVSdHBNYXAgPSBmdW5jdGlvbiAoY29kZWMpIHtcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHMgfHwgY29kZWMubnVtQ2hhbm5lbHMgfHwgMTtcbiAgICAgIHJldHVybiAnYT1ydHBtYXA6JyArIHB0ICsgJyAnICsgY29kZWMubmFtZSArICcvJyArIGNvZGVjLmNsb2NrUmF0ZSArIChjaGFubmVscyAhPT0gMSA/ICcvJyArIGNoYW5uZWxzIDogJycpICsgJ1xcclxcbic7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIGV4dG1hcCBsaW5lIChoZWFkZXJleHRlbnNpb24gZnJvbSBSRkMgNTI4NSkuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAvLyBhPWV4dG1hcDoyL3NlbmRvbmx5IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICBTRFBVdGlscy5wYXJzZUV4dG1hcCA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogcGFyc2VJbnQocGFydHNbMF0sIDEwKSxcbiAgICAgICAgZGlyZWN0aW9uOiBwYXJ0c1swXS5pbmRleE9mKCcvJykgPiAwID8gcGFydHNbMF0uc3BsaXQoJy8nKVsxXSA6ICdzZW5kcmVjdicsXG4gICAgICAgIHVyaTogcGFydHNbMV0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHBhcnRzLnNsaWNlKDIpLmpvaW4oJyAnKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gR2VuZXJhdGVzIGFuIGV4dG1hcCBsaW5lIGZyb20gUlRDUnRwSGVhZGVyRXh0ZW5zaW9uUGFyYW1ldGVycyBvclxuICAgIC8vIFJUQ1J0cEhlYWRlckV4dGVuc2lvbi5cbiAgICBTRFBVdGlscy53cml0ZUV4dG1hcCA9IGZ1bmN0aW9uIChoZWFkZXJFeHRlbnNpb24pIHtcbiAgICAgIHJldHVybiAnYT1leHRtYXA6JyArIChoZWFkZXJFeHRlbnNpb24uaWQgfHwgaGVhZGVyRXh0ZW5zaW9uLnByZWZlcnJlZElkKSArIChoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uICYmIGhlYWRlckV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdzZW5kcmVjdicgPyAnLycgKyBoZWFkZXJFeHRlbnNpb24uZGlyZWN0aW9uIDogJycpICsgJyAnICsgaGVhZGVyRXh0ZW5zaW9uLnVyaSArIChoZWFkZXJFeHRlbnNpb24uYXR0cmlidXRlcyA/ICcgJyArIGhlYWRlckV4dGVuc2lvbi5hdHRyaWJ1dGVzIDogJycpICsgJ1xcclxcbic7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIGZtdHAgbGluZSwgcmV0dXJucyBkaWN0aW9uYXJ5LiBTYW1wbGUgaW5wdXQ6XG4gICAgLy8gYT1mbXRwOjk2IHZicj1vbjtjbmc9b25cbiAgICAvLyBBbHNvIGRlYWxzIHdpdGggdmJyPW9uOyBjbmc9b25cbiAgICBTRFBVdGlscy5wYXJzZUZtdHAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFyc2VkID0ge307XG4gICAgICBsZXQga3Y7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJzsnKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAga3YgPSBwYXJ0c1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICAgICAgcGFyc2VkW2t2WzBdLnRyaW0oKV0gPSBrdlsxXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfTtcblxuICAgIC8vIEdlbmVyYXRlcyBhIGZtdHAgbGluZSBmcm9tIFJUQ1J0cENvZGVjQ2FwYWJpbGl0eSBvciBSVENSdHBDb2RlY1BhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMud3JpdGVGbXRwID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICBsZXQgbGluZSA9ICcnO1xuICAgICAgbGV0IHB0ID0gY29kZWMucGF5bG9hZFR5cGU7XG4gICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwdCA9IGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVjLnBhcmFtZXRlcnMgJiYgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKS5mb3JFYWNoKHBhcmFtID0+IHtcbiAgICAgICAgICBpZiAoY29kZWMucGFyYW1ldGVyc1twYXJhbV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gocGFyYW0gKyAnPScgKyBjb2RlYy5wYXJhbWV0ZXJzW3BhcmFtXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBsaW5lICs9ICdhPWZtdHA6JyArIHB0ICsgJyAnICsgcGFyYW1zLmpvaW4oJzsnKSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxpbmU7XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIHJ0Y3AtZmIgbGluZSwgcmV0dXJucyBSVENQUnRjcEZlZWRiYWNrIG9iamVjdC4gU2FtcGxlIGlucHV0OlxuICAgIC8vIGE9cnRjcC1mYjo5OCBuYWNrIHJwc2lcbiAgICBTRFBVdGlscy5wYXJzZVJ0Y3BGYiA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKGxpbmUuaW5kZXhPZignICcpICsgMSkuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IHBhcnRzLnNoaWZ0KCksXG4gICAgICAgIHBhcmFtZXRlcjogcGFydHMuam9pbignICcpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSBhPXJ0Y3AtZmIgbGluZXMgZnJvbSBSVENSdHBDb2RlY0NhcGFiaWxpdHkgb3IgUlRDUnRwQ29kZWNQYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLndyaXRlUnRjcEZiID0gZnVuY3Rpb24gKGNvZGVjKSB7XG4gICAgICBsZXQgbGluZXMgPSAnJztcbiAgICAgIGxldCBwdCA9IGNvZGVjLnBheWxvYWRUeXBlO1xuICAgICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHQgPSBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChjb2RlYy5ydGNwRmVlZGJhY2sgJiYgY29kZWMucnRjcEZlZWRiYWNrLmxlbmd0aCkge1xuICAgICAgICAvLyBGSVhNRTogc3BlY2lhbCBoYW5kbGluZyBmb3IgdHJyLWludD9cbiAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLmZvckVhY2goZmIgPT4ge1xuICAgICAgICAgIGxpbmVzICs9ICdhPXJ0Y3AtZmI6JyArIHB0ICsgJyAnICsgZmIudHlwZSArIChmYi5wYXJhbWV0ZXIgJiYgZmIucGFyYW1ldGVyLmxlbmd0aCA/ICcgJyArIGZiLnBhcmFtZXRlciA6ICcnKSArICdcXHJcXG4nO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBsaW5lcztcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGEgUkZDIDU1NzYgc3NyYyBtZWRpYSBhdHRyaWJ1dGUuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPXNzcmM6MzczNTkyODU1OSBjbmFtZTpzb21ldGhpbmdcbiAgICBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBzcCA9IGxpbmUuaW5kZXhPZignICcpO1xuICAgICAgY29uc3QgcGFydHMgPSB7XG4gICAgICAgIHNzcmM6IHBhcnNlSW50KGxpbmUuc3Vic3RyaW5nKDcsIHNwKSwgMTApXG4gICAgICB9O1xuICAgICAgY29uc3QgY29sb24gPSBsaW5lLmluZGV4T2YoJzonLCBzcCk7XG4gICAgICBpZiAoY29sb24gPiAtMSkge1xuICAgICAgICBwYXJ0cy5hdHRyaWJ1dGUgPSBsaW5lLnN1YnN0cmluZyhzcCArIDEsIGNvbG9uKTtcbiAgICAgICAgcGFydHMudmFsdWUgPSBsaW5lLnN1YnN0cmluZyhjb2xvbiArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFydHMuYXR0cmlidXRlID0gbGluZS5zdWJzdHJpbmcoc3AgKyAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJ0cztcbiAgICB9O1xuXG4gICAgLy8gUGFyc2UgYSBzc3JjLWdyb3VwIGxpbmUgKHNlZSBSRkMgNTU3NikuIFNhbXBsZSBpbnB1dDpcbiAgICAvLyBhPXNzcmMtZ3JvdXA6c2VtYW50aWNzIDEyIDM0XG4gICAgU0RQVXRpbHMucGFyc2VTc3JjR3JvdXAgPSBmdW5jdGlvbiAobGluZSkge1xuICAgICAgY29uc3QgcGFydHMgPSBsaW5lLnN1YnN0cmluZygxMykuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHNlbWFudGljczogcGFydHMuc2hpZnQoKSxcbiAgICAgICAgc3NyY3M6IHBhcnRzLm1hcChzc3JjID0+IHBhcnNlSW50KHNzcmMsIDEwKSlcbiAgICAgIH07XG4gICAgfTtcblxuICAgIC8vIEV4dHJhY3RzIHRoZSBNSUQgKFJGQyA1ODg4KSBmcm9tIGEgbWVkaWEgc2VjdGlvbi5cbiAgICAvLyBSZXR1cm5zIHRoZSBNSUQgb3IgdW5kZWZpbmVkIGlmIG5vIG1pZCBsaW5lIHdhcyBmb3VuZC5cbiAgICBTRFBVdGlscy5nZXRNaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBtaWQgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1pZDonKVswXTtcbiAgICAgIGlmIChtaWQpIHtcbiAgICAgICAgcmV0dXJuIG1pZC5zdWJzdHJpbmcoNik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBhcnNlcyBhIGZpbmdlcnByaW50IGxpbmUgZm9yIERUTFMtU1JUUC5cbiAgICBTRFBVdGlscy5wYXJzZUZpbmdlcnByaW50ID0gZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTQpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBhbGdvcml0aG06IHBhcnRzWzBdLnRvTG93ZXJDYXNlKCksXG4gICAgICAgIC8vIGFsZ29yaXRobSBpcyBjYXNlLXNlbnNpdGl2ZSBpbiBFZGdlLlxuICAgICAgICB2YWx1ZTogcGFydHNbMV0udG9VcHBlckNhc2UoKSAvLyB0aGUgZGVmaW5pdGlvbiBpcyB1cHBlci1jYXNlIGluIFJGQyA0NTcyLlxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gRXh0cmFjdHMgRFRMUyBwYXJhbWV0ZXJzIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4gICAgLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4gICAgLy8gICBnZXQgdGhlIGZpbmdlcnByaW50IGxpbmUgYXMgaW5wdXQuIFNlZSBhbHNvIGdldEljZVBhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMuZ2V0RHRsc1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9ZmluZ2VycHJpbnQ6Jyk7XG4gICAgICAvLyBOb3RlOiBhPXNldHVwIGxpbmUgaXMgaWdub3JlZCBzaW5jZSB3ZSB1c2UgdGhlICdhdXRvJyByb2xlIGluIEVkZ2UuXG4gICAgICByZXR1cm4ge1xuICAgICAgICByb2xlOiAnYXV0bycsXG4gICAgICAgIGZpbmdlcnByaW50czogbGluZXMubWFwKFNEUFV0aWxzLnBhcnNlRmluZ2VycHJpbnQpXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBTZXJpYWxpemVzIERUTFMgcGFyYW1ldGVycyB0byBTRFAuXG4gICAgU0RQVXRpbHMud3JpdGVEdGxzUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChwYXJhbXMsIHNldHVwVHlwZSkge1xuICAgICAgbGV0IHNkcCA9ICdhPXNldHVwOicgKyBzZXR1cFR5cGUgKyAnXFxyXFxuJztcbiAgICAgIHBhcmFtcy5maW5nZXJwcmludHMuZm9yRWFjaChmcCA9PiB7XG4gICAgICAgIHNkcCArPSAnYT1maW5nZXJwcmludDonICsgZnAuYWxnb3JpdGhtICsgJyAnICsgZnAudmFsdWUgKyAnXFxyXFxuJztcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIGE9Y3J5cHRvIGxpbmVzIGludG9cbiAgICAvLyAgIGh0dHBzOi8vcmF3Z2l0LmNvbS9hYm9iYS9lZGdlcnRjL21hc3Rlci9tc29ydGMtcnM0Lmh0bWwjZGljdGlvbmFyeS1ydGNzcnRwc2Rlc3BhcmFtZXRlcnMtbWVtYmVyc1xuICAgIFNEUFV0aWxzLnBhcnNlQ3J5cHRvTGluZSA9IGZ1bmN0aW9uIChsaW5lKSB7XG4gICAgICBjb25zdCBwYXJ0cyA9IGxpbmUuc3Vic3RyaW5nKDkpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICAgIGNyeXB0b1N1aXRlOiBwYXJ0c1sxXSxcbiAgICAgICAga2V5UGFyYW1zOiBwYXJ0c1syXSxcbiAgICAgICAgc2Vzc2lvblBhcmFtczogcGFydHMuc2xpY2UoMylcbiAgICAgIH07XG4gICAgfTtcbiAgICBTRFBVdGlscy53cml0ZUNyeXB0b0xpbmUgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xuICAgICAgcmV0dXJuICdhPWNyeXB0bzonICsgcGFyYW1ldGVycy50YWcgKyAnICcgKyBwYXJhbWV0ZXJzLmNyeXB0b1N1aXRlICsgJyAnICsgKHR5cGVvZiBwYXJhbWV0ZXJzLmtleVBhcmFtcyA9PT0gJ29iamVjdCcgPyBTRFBVdGlscy53cml0ZUNyeXB0b0tleVBhcmFtcyhwYXJhbWV0ZXJzLmtleVBhcmFtcykgOiBwYXJhbWV0ZXJzLmtleVBhcmFtcykgKyAocGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zID8gJyAnICsgcGFyYW1ldGVycy5zZXNzaW9uUGFyYW1zLmpvaW4oJyAnKSA6ICcnKSArICdcXHJcXG4nO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgdGhlIGNyeXB0byBrZXkgcGFyYW1ldGVycyBpbnRvXG4gICAgLy8gICBodHRwczovL3Jhd2dpdC5jb20vYWJvYmEvZWRnZXJ0Yy9tYXN0ZXIvbXNvcnRjLXJzNC5odG1sI3J0Y3NydHBrZXlwYXJhbSpcbiAgICBTRFBVdGlscy5wYXJzZUNyeXB0b0tleVBhcmFtcyA9IGZ1bmN0aW9uIChrZXlQYXJhbXMpIHtcbiAgICAgIGlmIChrZXlQYXJhbXMuaW5kZXhPZignaW5saW5lOicpICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFydHMgPSBrZXlQYXJhbXMuc3Vic3RyaW5nKDcpLnNwbGl0KCd8Jyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXlNZXRob2Q6ICdpbmxpbmUnLFxuICAgICAgICBrZXlTYWx0OiBwYXJ0c1swXSxcbiAgICAgICAgbGlmZVRpbWU6IHBhcnRzWzFdLFxuICAgICAgICBta2lWYWx1ZTogcGFydHNbMl0gPyBwYXJ0c1syXS5zcGxpdCgnOicpWzBdIDogdW5kZWZpbmVkLFxuICAgICAgICBta2lMZW5ndGg6IHBhcnRzWzJdID8gcGFydHNbMl0uc3BsaXQoJzonKVsxXSA6IHVuZGVmaW5lZFxuICAgICAgfTtcbiAgICB9O1xuICAgIFNEUFV0aWxzLndyaXRlQ3J5cHRvS2V5UGFyYW1zID0gZnVuY3Rpb24gKGtleVBhcmFtcykge1xuICAgICAgcmV0dXJuIGtleVBhcmFtcy5rZXlNZXRob2QgKyAnOicgKyBrZXlQYXJhbXMua2V5U2FsdCArIChrZXlQYXJhbXMubGlmZVRpbWUgPyAnfCcgKyBrZXlQYXJhbXMubGlmZVRpbWUgOiAnJykgKyAoa2V5UGFyYW1zLm1raVZhbHVlICYmIGtleVBhcmFtcy5ta2lMZW5ndGggPyAnfCcgKyBrZXlQYXJhbXMubWtpVmFsdWUgKyAnOicgKyBrZXlQYXJhbXMubWtpTGVuZ3RoIDogJycpO1xuICAgIH07XG5cbiAgICAvLyBFeHRyYWN0cyBhbGwgU0RFUyBwYXJhbWV0ZXJzLlxuICAgIFNEUFV0aWxzLmdldENyeXB0b1BhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgICAgY29uc3QgbGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24gKyBzZXNzaW9ucGFydCwgJ2E9Y3J5cHRvOicpO1xuICAgICAgcmV0dXJuIGxpbmVzLm1hcChTRFBVdGlscy5wYXJzZUNyeXB0b0xpbmUpO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgSUNFIGluZm9ybWF0aW9uIGZyb20gU0RQIG1lZGlhIHNlY3Rpb24gb3Igc2Vzc2lvbnBhcnQuXG4gICAgLy8gRklYTUU6IGZvciBjb25zaXN0ZW5jeSB3aXRoIG90aGVyIGZ1bmN0aW9ucyB0aGlzIHNob3VsZCBvbmx5XG4gICAgLy8gICBnZXQgdGhlIGljZS11ZnJhZyBhbmQgaWNlLXB3ZCBsaW5lcyBhcyBpbnB1dC5cbiAgICBTRFBVdGlscy5nZXRJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbiwgc2Vzc2lvbnBhcnQpIHtcbiAgICAgIGNvbnN0IHVmcmFnID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uICsgc2Vzc2lvbnBhcnQsICdhPWljZS11ZnJhZzonKVswXTtcbiAgICAgIGNvbnN0IHB3ZCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiArIHNlc3Npb25wYXJ0LCAnYT1pY2UtcHdkOicpWzBdO1xuICAgICAgaWYgKCEodWZyYWcgJiYgcHdkKSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJuYW1lRnJhZ21lbnQ6IHVmcmFnLnN1YnN0cmluZygxMiksXG4gICAgICAgIHBhc3N3b3JkOiBwd2Quc3Vic3RyaW5nKDEwKVxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgLy8gU2VyaWFsaXplcyBJQ0UgcGFyYW1ldGVycyB0byBTRFAuXG4gICAgU0RQVXRpbHMud3JpdGVJY2VQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHBhcmFtcykge1xuICAgICAgbGV0IHNkcCA9ICdhPWljZS11ZnJhZzonICsgcGFyYW1zLnVzZXJuYW1lRnJhZ21lbnQgKyAnXFxyXFxuJyArICdhPWljZS1wd2Q6JyArIHBhcmFtcy5wYXNzd29yZCArICdcXHJcXG4nO1xuICAgICAgaWYgKHBhcmFtcy5pY2VMaXRlKSB7XG4gICAgICAgIHNkcCArPSAnYT1pY2UtbGl0ZVxcclxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH07XG5cbiAgICAvLyBQYXJzZXMgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGFuZCByZXR1cm5zIFJUQ1J0cFBhcmFtZXRlcnMuXG4gICAgU0RQVXRpbHMucGFyc2VSdHBQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKG1lZGlhU2VjdGlvbikge1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgICAgICBmZWNNZWNoYW5pc21zOiBbXSxcbiAgICAgICAgcnRjcDogW11cbiAgICAgIH07XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IG1saW5lID0gbGluZXNbMF0uc3BsaXQoJyAnKTtcbiAgICAgIGRlc2NyaXB0aW9uLnByb2ZpbGUgPSBtbGluZVsyXTtcbiAgICAgIGZvciAobGV0IGkgPSAzOyBpIDwgbWxpbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gZmluZCBhbGwgY29kZWNzIGZyb20gbWxpbmVbMy4uXVxuICAgICAgICBjb25zdCBwdCA9IG1saW5lW2ldO1xuICAgICAgICBjb25zdCBydHBtYXBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydHBtYXA6JyArIHB0ICsgJyAnKVswXTtcbiAgICAgICAgaWYgKHJ0cG1hcGxpbmUpIHtcbiAgICAgICAgICBjb25zdCBjb2RlYyA9IFNEUFV0aWxzLnBhcnNlUnRwTWFwKHJ0cG1hcGxpbmUpO1xuICAgICAgICAgIGNvbnN0IGZtdHBzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1mbXRwOicgKyBwdCArICcgJyk7XG4gICAgICAgICAgLy8gT25seSB0aGUgZmlyc3QgYT1mbXRwOjxwdD4gaXMgY29uc2lkZXJlZC5cbiAgICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzID0gZm10cHMubGVuZ3RoID8gU0RQVXRpbHMucGFyc2VGbXRwKGZtdHBzWzBdKSA6IHt9O1xuICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1mYjonICsgcHQgKyAnICcpLm1hcChTRFBVdGlscy5wYXJzZVJ0Y3BGYik7XG4gICAgICAgICAgZGVzY3JpcHRpb24uY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAgIC8vIHBhcnNlIEZFQyBtZWNoYW5pc21zIGZyb20gcnRwbWFwIGxpbmVzLlxuICAgICAgICAgIHN3aXRjaCAoY29kZWMubmFtZS50b1VwcGVyQ2FzZSgpKSB7XG4gICAgICAgICAgICBjYXNlICdSRUQnOlxuICAgICAgICAgICAgY2FzZSAnVUxQRkVDJzpcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5wdXNoKGNvZGVjLm5hbWUudG9VcHBlckNhc2UoKSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1leHRtYXA6JykuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgZGVzY3JpcHRpb24uaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKFNEUFV0aWxzLnBhcnNlRXh0bWFwKGxpbmUpKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3Qgd2lsZGNhcmRSdGNwRmIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXJ0Y3AtZmI6KiAnKS5tYXAoU0RQVXRpbHMucGFyc2VSdGNwRmIpO1xuICAgICAgZGVzY3JpcHRpb24uY29kZWNzLmZvckVhY2goY29kZWMgPT4ge1xuICAgICAgICB3aWxkY2FyZFJ0Y3BGYi5mb3JFYWNoKGZiID0+IHtcbiAgICAgICAgICBjb25zdCBkdXBsaWNhdGUgPSBjb2RlYy5ydGNwRmVlZGJhY2suZmluZChleGlzdGluZ0ZlZWRiYWNrID0+IHtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0ZlZWRiYWNrLnR5cGUgPT09IGZiLnR5cGUgJiYgZXhpc3RpbmdGZWVkYmFjay5wYXJhbWV0ZXIgPT09IGZiLnBhcmFtZXRlcjtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoIWR1cGxpY2F0ZSkge1xuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrLnB1c2goZmIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIC8vIEZJWE1FOiBwYXJzZSBydGNwLlxuICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZXMgcGFydHMgb2YgdGhlIFNEUCBtZWRpYSBzZWN0aW9uIGRlc2NyaWJpbmcgdGhlIGNhcGFiaWxpdGllcyAvXG4gICAgLy8gcGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy53cml0ZVJ0cERlc2NyaXB0aW9uID0gZnVuY3Rpb24gKGtpbmQsIGNhcHMpIHtcbiAgICAgIGxldCBzZHAgPSAnJztcblxuICAgICAgLy8gQnVpbGQgdGhlIG1saW5lLlxuICAgICAgc2RwICs9ICdtPScgKyBraW5kICsgJyAnO1xuICAgICAgc2RwICs9IGNhcHMuY29kZWNzLmxlbmd0aCA+IDAgPyAnOScgOiAnMCc7IC8vIHJlamVjdCBpZiBubyBjb2RlY3MuXG4gICAgICBzZHAgKz0gJyAnICsgKGNhcHMucHJvZmlsZSB8fCAnVURQL1RMUy9SVFAvU0FWUEYnKSArICcgJztcbiAgICAgIHNkcCArPSBjYXBzLmNvZGVjcy5tYXAoY29kZWMgPT4ge1xuICAgICAgICBpZiAoY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZWMucGF5bG9hZFR5cGU7XG4gICAgICB9KS5qb2luKCcgJykgKyAnXFxyXFxuJztcbiAgICAgIHNkcCArPSAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbic7XG4gICAgICBzZHAgKz0gJ2E9cnRjcDo5IElOIElQNCAwLjAuMC4wXFxyXFxuJztcblxuICAgICAgLy8gQWRkIGE9cnRwbWFwIGxpbmVzIGZvciBlYWNoIGNvZGVjLiBBbHNvIGZtdHAgYW5kIHJ0Y3AtZmIuXG4gICAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlUnRwTWFwKGNvZGVjKTtcbiAgICAgICAgc2RwICs9IFNEUFV0aWxzLndyaXRlRm10cChjb2RlYyk7XG4gICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZVJ0Y3BGYihjb2RlYyk7XG4gICAgICB9KTtcbiAgICAgIGxldCBtYXhwdGltZSA9IDA7XG4gICAgICBjYXBzLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgaWYgKGNvZGVjLm1heHB0aW1lID4gbWF4cHRpbWUpIHtcbiAgICAgICAgICBtYXhwdGltZSA9IGNvZGVjLm1heHB0aW1lO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChtYXhwdGltZSA+IDApIHtcbiAgICAgICAgc2RwICs9ICdhPW1heHB0aW1lOicgKyBtYXhwdGltZSArICdcXHJcXG4nO1xuICAgICAgfVxuICAgICAgaWYgKGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMuZm9yRWFjaChleHRlbnNpb24gPT4ge1xuICAgICAgICAgIHNkcCArPSBTRFBVdGlscy53cml0ZUV4dG1hcChleHRlbnNpb24pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIEZJWE1FOiB3cml0ZSBmZWNNZWNoYW5pc21zLlxuICAgICAgcmV0dXJuIHNkcDtcbiAgICB9O1xuXG4gICAgLy8gUGFyc2VzIHRoZSBTRFAgbWVkaWEgc2VjdGlvbiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZlxuICAgIC8vIFJUQ1J0cEVuY29kaW5nUGFyYW1ldGVycy5cbiAgICBTRFBVdGlscy5wYXJzZVJ0cEVuY29kaW5nUGFyYW1ldGVycyA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGVuY29kaW5nUGFyYW1ldGVycyA9IFtdO1xuICAgICAgY29uc3QgZGVzY3JpcHRpb24gPSBTRFBVdGlscy5wYXJzZVJ0cFBhcmFtZXRlcnMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IGhhc1JlZCA9IGRlc2NyaXB0aW9uLmZlY01lY2hhbmlzbXMuaW5kZXhPZignUkVEJykgIT09IC0xO1xuICAgICAgY29uc3QgaGFzVWxwZmVjID0gZGVzY3JpcHRpb24uZmVjTWVjaGFuaXNtcy5pbmRleE9mKCdVTFBGRUMnKSAhPT0gLTE7XG5cbiAgICAgIC8vIGZpbHRlciBhPXNzcmM6Li4uIGNuYW1lOiwgaWdub3JlIFBsYW5CLW1zaWRcbiAgICAgIGNvbnN0IHNzcmNzID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zc3JjOicpLm1hcChsaW5lID0+IFNEUFV0aWxzLnBhcnNlU3NyY01lZGlhKGxpbmUpKS5maWx0ZXIocGFydHMgPT4gcGFydHMuYXR0cmlidXRlID09PSAnY25hbWUnKTtcbiAgICAgIGNvbnN0IHByaW1hcnlTc3JjID0gc3NyY3MubGVuZ3RoID4gMCAmJiBzc3Jjc1swXS5zc3JjO1xuICAgICAgbGV0IHNlY29uZGFyeVNzcmM7XG4gICAgICBjb25zdCBmbG93cyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYy1ncm91cDpGSUQnKS5tYXAobGluZSA9PiB7XG4gICAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMTcpLnNwbGl0KCcgJyk7XG4gICAgICAgIHJldHVybiBwYXJ0cy5tYXAocGFydCA9PiBwYXJzZUludChwYXJ0LCAxMCkpO1xuICAgICAgfSk7XG4gICAgICBpZiAoZmxvd3MubGVuZ3RoID4gMCAmJiBmbG93c1swXS5sZW5ndGggPiAxICYmIGZsb3dzWzBdWzBdID09PSBwcmltYXJ5U3NyYykge1xuICAgICAgICBzZWNvbmRhcnlTc3JjID0gZmxvd3NbMF1bMV07XG4gICAgICB9XG4gICAgICBkZXNjcmlwdGlvbi5jb2RlY3MuZm9yRWFjaChjb2RlYyA9PiB7XG4gICAgICAgIGlmIChjb2RlYy5uYW1lLnRvVXBwZXJDYXNlKCkgPT09ICdSVFgnICYmIGNvZGVjLnBhcmFtZXRlcnMuYXB0KSB7XG4gICAgICAgICAgbGV0IGVuY1BhcmFtID0ge1xuICAgICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmMsXG4gICAgICAgICAgICBjb2RlY1BheWxvYWRUeXBlOiBwYXJzZUludChjb2RlYy5wYXJhbWV0ZXJzLmFwdCwgMTApXG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAocHJpbWFyeVNzcmMgJiYgc2Vjb25kYXJ5U3NyYykge1xuICAgICAgICAgICAgZW5jUGFyYW0ucnR4ID0ge1xuICAgICAgICAgICAgICBzc3JjOiBzZWNvbmRhcnlTc3JjXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaChlbmNQYXJhbSk7XG4gICAgICAgICAgaWYgKGhhc1JlZCkge1xuICAgICAgICAgICAgZW5jUGFyYW0gPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVuY1BhcmFtKSk7XG4gICAgICAgICAgICBlbmNQYXJhbS5mZWMgPSB7XG4gICAgICAgICAgICAgIHNzcmM6IHByaW1hcnlTc3JjLFxuICAgICAgICAgICAgICBtZWNoYW5pc206IGhhc1VscGZlYyA/ICdyZWQrdWxwZmVjJyA6ICdyZWQnXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZW5jb2RpbmdQYXJhbWV0ZXJzLnB1c2goZW5jUGFyYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZW5jb2RpbmdQYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMCAmJiBwcmltYXJ5U3NyYykge1xuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMucHVzaCh7XG4gICAgICAgICAgc3NyYzogcHJpbWFyeVNzcmNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlIHN1cHBvcnQgYm90aCBiPUFTIGFuZCBiPVRJQVMgYnV0IGludGVycHJldCBBUyBhcyBUSUFTLlxuICAgICAgbGV0IGJhbmR3aWR0aCA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2I9Jyk7XG4gICAgICBpZiAoYmFuZHdpZHRoLmxlbmd0aCkge1xuICAgICAgICBpZiAoYmFuZHdpZHRoWzBdLmluZGV4T2YoJ2I9VElBUzonKSA9PT0gMCkge1xuICAgICAgICAgIGJhbmR3aWR0aCA9IHBhcnNlSW50KGJhbmR3aWR0aFswXS5zdWJzdHJpbmcoNyksIDEwKTtcbiAgICAgICAgfSBlbHNlIGlmIChiYW5kd2lkdGhbMF0uaW5kZXhPZignYj1BUzonKSA9PT0gMCkge1xuICAgICAgICAgIC8vIHVzZSBmb3JtdWxhIGZyb20gSlNFUCB0byBjb252ZXJ0IGI9QVMgdG8gVElBUyB2YWx1ZS5cbiAgICAgICAgICBiYW5kd2lkdGggPSBwYXJzZUludChiYW5kd2lkdGhbMF0uc3Vic3RyaW5nKDUpLCAxMCkgKiAxMDAwICogMC45NSAtIDUwICogNDAgKiA4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGJhbmR3aWR0aCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZ1BhcmFtZXRlcnMuZm9yRWFjaChwYXJhbXMgPT4ge1xuICAgICAgICAgIHBhcmFtcy5tYXhCaXRyYXRlID0gYmFuZHdpZHRoO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGluZ1BhcmFtZXRlcnM7XG4gICAgfTtcblxuICAgIC8vIHBhcnNlcyBodHRwOi8vZHJhZnQub3J0Yy5vcmcvI3J0Y3J0Y3BwYXJhbWV0ZXJzKlxuICAgIFNEUFV0aWxzLnBhcnNlUnRjcFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBydGNwUGFyYW1ldGVycyA9IHt9O1xuXG4gICAgICAvLyBHZXRzIHRoZSBmaXJzdCBTU1JDLiBOb3RlIHRoYXQgd2l0aCBSVFggdGhlcmUgbWlnaHQgYmUgbXVsdGlwbGVcbiAgICAgIC8vIFNTUkNzLlxuICAgICAgY29uc3QgcmVtb3RlU3NyYyA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9c3NyYzonKS5tYXAobGluZSA9PiBTRFBVdGlscy5wYXJzZVNzcmNNZWRpYShsaW5lKSkuZmlsdGVyKG9iaiA9PiBvYmouYXR0cmlidXRlID09PSAnY25hbWUnKVswXTtcbiAgICAgIGlmIChyZW1vdGVTc3JjKSB7XG4gICAgICAgIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lID0gcmVtb3RlU3NyYy52YWx1ZTtcbiAgICAgICAgcnRjcFBhcmFtZXRlcnMuc3NyYyA9IHJlbW90ZVNzcmMuc3NyYztcbiAgICAgIH1cblxuICAgICAgLy8gRWRnZSB1c2VzIHRoZSBjb21wb3VuZCBhdHRyaWJ1dGUgaW5zdGVhZCBvZiByZWR1Y2VkU2l6ZVxuICAgICAgLy8gY29tcG91bmQgaXMgIXJlZHVjZWRTaXplXG4gICAgICBjb25zdCByc2l6ZSA9IFNEUFV0aWxzLm1hdGNoUHJlZml4KG1lZGlhU2VjdGlvbiwgJ2E9cnRjcC1yc2l6ZScpO1xuICAgICAgcnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUgPSByc2l6ZS5sZW5ndGggPiAwO1xuICAgICAgcnRjcFBhcmFtZXRlcnMuY29tcG91bmQgPSByc2l6ZS5sZW5ndGggPT09IDA7XG5cbiAgICAgIC8vIHBhcnNlcyB0aGUgcnRjcC1tdXggYXR0ctGWYnV0ZS5cbiAgICAgIC8vIE5vdGUgdGhhdCBFZGdlIGRvZXMgbm90IHN1cHBvcnQgdW5tdXhlZCBSVENQLlxuICAgICAgY29uc3QgbXV4ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1ydGNwLW11eCcpO1xuICAgICAgcnRjcFBhcmFtZXRlcnMubXV4ID0gbXV4Lmxlbmd0aCA+IDA7XG4gICAgICByZXR1cm4gcnRjcFBhcmFtZXRlcnM7XG4gICAgfTtcbiAgICBTRFBVdGlscy53cml0ZVJ0Y3BQYXJhbWV0ZXJzID0gZnVuY3Rpb24gKHJ0Y3BQYXJhbWV0ZXJzKSB7XG4gICAgICBsZXQgc2RwID0gJyc7XG4gICAgICBpZiAocnRjcFBhcmFtZXRlcnMucmVkdWNlZFNpemUpIHtcbiAgICAgICAgc2RwICs9ICdhPXJ0Y3AtcnNpemVcXHJcXG4nO1xuICAgICAgfVxuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLm11eCkge1xuICAgICAgICBzZHAgKz0gJ2E9cnRjcC1tdXhcXHJcXG4nO1xuICAgICAgfVxuICAgICAgaWYgKHJ0Y3BQYXJhbWV0ZXJzLnNzcmMgIT09IHVuZGVmaW5lZCAmJiBydGNwUGFyYW1ldGVycy5jbmFtZSkge1xuICAgICAgICBzZHAgKz0gJ2E9c3NyYzonICsgcnRjcFBhcmFtZXRlcnMuc3NyYyArICcgY25hbWU6JyArIHJ0Y3BQYXJhbWV0ZXJzLmNuYW1lICsgJ1xcclxcbic7XG4gICAgICB9XG4gICAgICByZXR1cm4gc2RwO1xuICAgIH07XG5cbiAgICAvLyBwYXJzZXMgZWl0aGVyIGE9bXNpZDogb3IgYT1zc3JjOi4uLiBtc2lkIGxpbmVzIGFuZCByZXR1cm5zXG4gICAgLy8gdGhlIGlkIG9mIHRoZSBNZWRpYVN0cmVhbSBhbmQgTWVkaWFTdHJlYW1UcmFjay5cbiAgICBTRFBVdGlscy5wYXJzZU1zaWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBsZXQgcGFydHM7XG4gICAgICBjb25zdCBzcGVjID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1tc2lkOicpO1xuICAgICAgaWYgKHNwZWMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHBhcnRzID0gc3BlY1swXS5zdWJzdHJpbmcoNykuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJlYW06IHBhcnRzWzBdLFxuICAgICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcGxhbkIgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNzcmM6JykubWFwKGxpbmUgPT4gU0RQVXRpbHMucGFyc2VTc3JjTWVkaWEobGluZSkpLmZpbHRlcihtc2lkUGFydHMgPT4gbXNpZFBhcnRzLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgICAgIGlmIChwbGFuQi5sZW5ndGggPiAwKSB7XG4gICAgICAgIHBhcnRzID0gcGxhbkJbMF0udmFsdWUuc3BsaXQoJyAnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdHJlYW06IHBhcnRzWzBdLFxuICAgICAgICAgIHRyYWNrOiBwYXJ0c1sxXVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBTQ1RQXG4gICAgLy8gcGFyc2VzIGRyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2IGZpcnN0IGFuZCBmYWxscyBiYWNrXG4gICAgLy8gdG8gZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDVcbiAgICBTRFBVdGlscy5wYXJzZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IG1saW5lID0gU0RQVXRpbHMucGFyc2VNTGluZShtZWRpYVNlY3Rpb24pO1xuICAgICAgY29uc3QgbWF4U2l6ZUxpbmUgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgICBsZXQgbWF4TWVzc2FnZVNpemU7XG4gICAgICBpZiAobWF4U2l6ZUxpbmUubGVuZ3RoID4gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IHBhcnNlSW50KG1heFNpemVMaW5lWzBdLnN1YnN0cmluZygxOSksIDEwKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hTihtYXhNZXNzYWdlU2l6ZSkpIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjdHBQb3J0ID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnYT1zY3RwLXBvcnQ6Jyk7XG4gICAgICBpZiAoc2N0cFBvcnQubGVuZ3RoID4gMCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcnQ6IHBhcnNlSW50KHNjdHBQb3J0WzBdLnN1YnN0cmluZygxMiksIDEwKSxcbiAgICAgICAgICBwcm90b2NvbDogbWxpbmUuZm10LFxuICAgICAgICAgIG1heE1lc3NhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCBzY3RwTWFwTGluZXMgPSBTRFBVdGlscy5tYXRjaFByZWZpeChtZWRpYVNlY3Rpb24sICdhPXNjdHBtYXA6Jyk7XG4gICAgICBpZiAoc2N0cE1hcExpbmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgcGFydHMgPSBzY3RwTWFwTGluZXNbMF0uc3Vic3RyaW5nKDEwKS5zcGxpdCgnICcpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHBvcnQ6IHBhcnNlSW50KHBhcnRzWzBdLCAxMCksXG4gICAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzFdLFxuICAgICAgICAgIG1heE1lc3NhZ2VTaXplXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFNDVFBcbiAgICAvLyBvdXRwdXRzIHRoZSBkcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiB2ZXJzaW9uIHRoYXQgYWxsIGJyb3dzZXJzXG4gICAgLy8gc3VwcG9ydCBieSBub3cgcmVjZWl2aW5nIGluIHRoaXMgZm9ybWF0LCB1bmxlc3Mgd2Ugb3JpZ2luYWxseSBwYXJzZWRcbiAgICAvLyBhcyB0aGUgZHJhZnQtaWV0Zi1tbXVzaWMtc2N0cC1zZHAtMDUgZm9ybWF0IChpbmRpY2F0ZWQgYnkgdGhlIG0tbGluZVxuICAgIC8vIHByb3RvY29sIG9mIERUTFMvU0NUUCAtLSB3aXRob3V0IFVEUC8gb3IgVENQLylcbiAgICBTRFBVdGlscy53cml0ZVNjdHBEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChtZWRpYSwgc2N0cCkge1xuICAgICAgbGV0IG91dHB1dCA9IFtdO1xuICAgICAgaWYgKG1lZGlhLnByb3RvY29sICE9PSAnRFRMUy9TQ1RQJykge1xuICAgICAgICBvdXRwdXQgPSBbJ209JyArIG1lZGlhLmtpbmQgKyAnIDkgJyArIG1lZGlhLnByb3RvY29sICsgJyAnICsgc2N0cC5wcm90b2NvbCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHAtcG9ydDonICsgc2N0cC5wb3J0ICsgJ1xcclxcbiddO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gWydtPScgKyBtZWRpYS5raW5kICsgJyA5ICcgKyBtZWRpYS5wcm90b2NvbCArICcgJyArIHNjdHAucG9ydCArICdcXHJcXG4nLCAnYz1JTiBJUDQgMC4wLjAuMFxcclxcbicsICdhPXNjdHBtYXA6JyArIHNjdHAucG9ydCArICcgJyArIHNjdHAucHJvdG9jb2wgKyAnIDY1NTM1XFxyXFxuJ107XG4gICAgICB9XG4gICAgICBpZiAoc2N0cC5tYXhNZXNzYWdlU2l6ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG91dHB1dC5wdXNoKCdhPW1heC1tZXNzYWdlLXNpemU6JyArIHNjdHAubWF4TWVzc2FnZVNpemUgKyAnXFxyXFxuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0LmpvaW4oJycpO1xuICAgIH07XG5cbiAgICAvLyBHZW5lcmF0ZSBhIHNlc3Npb24gSUQgZm9yIFNEUC5cbiAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvZHJhZnQtaWV0Zi1ydGN3ZWItanNlcC0yMCNzZWN0aW9uLTUuMi4xXG4gICAgLy8gcmVjb21tZW5kcyB1c2luZyBhIGNyeXB0b2dyYXBoaWNhbGx5IHJhbmRvbSArdmUgNjQtYml0IHZhbHVlXG4gICAgLy8gYnV0IHJpZ2h0IG5vdyB0aGlzIHNob3VsZCBiZSBhY2NlcHRhYmxlIGFuZCB3aXRoaW4gdGhlIHJpZ2h0IHJhbmdlXG4gICAgU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gTWF0aC5yYW5kb20oKS50b1N0cmluZygpLnN1YnN0cigyLCAyMik7XG4gICAgfTtcblxuICAgIC8vIFdyaXRlIGJvaWxlciBwbGF0ZSBmb3Igc3RhcnQgb2YgU0RQXG4gICAgLy8gc2Vzc0lkIGFyZ3VtZW50IGlzIG9wdGlvbmFsIC0gaWYgbm90IHN1cHBsaWVkIGl0IHdpbGxcbiAgICAvLyBiZSBnZW5lcmF0ZWQgcmFuZG9tbHlcbiAgICAvLyBzZXNzVmVyc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gMlxuICAgIC8vIHNlc3NVc2VyIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byAndGhpc2lzYWRhcHRlcm9ydGMnXG4gICAgU0RQVXRpbHMud3JpdGVTZXNzaW9uQm9pbGVycGxhdGUgPSBmdW5jdGlvbiAoc2Vzc0lkLCBzZXNzVmVyLCBzZXNzVXNlcikge1xuICAgICAgbGV0IHNlc3Npb25JZDtcbiAgICAgIGNvbnN0IHZlcnNpb24gPSBzZXNzVmVyICE9PSB1bmRlZmluZWQgPyBzZXNzVmVyIDogMjtcbiAgICAgIGlmIChzZXNzSWQpIHtcbiAgICAgICAgc2Vzc2lvbklkID0gc2Vzc0lkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2Vzc2lvbklkID0gU0RQVXRpbHMuZ2VuZXJhdGVTZXNzaW9uSWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHVzZXIgPSBzZXNzVXNlciB8fCAndGhpc2lzYWRhcHRlcm9ydGMnO1xuICAgICAgLy8gRklYTUU6IHNlc3MtaWQgc2hvdWxkIGJlIGFuIE5UUCB0aW1lc3RhbXAuXG4gICAgICByZXR1cm4gJ3Y9MFxcclxcbicgKyAnbz0nICsgdXNlciArICcgJyArIHNlc3Npb25JZCArICcgJyArIHZlcnNpb24gKyAnIElOIElQNCAxMjcuMC4wLjFcXHJcXG4nICsgJ3M9LVxcclxcbicgKyAndD0wIDBcXHJcXG4nO1xuICAgIH07XG5cbiAgICAvLyBHZXRzIHRoZSBkaXJlY3Rpb24gZnJvbSB0aGUgbWVkaWFTZWN0aW9uIG9yIHRoZSBzZXNzaW9ucGFydC5cbiAgICBTRFBVdGlscy5nZXREaXJlY3Rpb24gPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uLCBzZXNzaW9ucGFydCkge1xuICAgICAgLy8gTG9vayBmb3Igc2VuZHJlY3YsIHNlbmRvbmx5LCByZWN2b25seSwgaW5hY3RpdmUsIGRlZmF1bHQgdG8gc2VuZHJlY3YuXG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgc3dpdGNoIChsaW5lc1tpXSkge1xuICAgICAgICAgIGNhc2UgJ2E9c2VuZHJlY3YnOlxuICAgICAgICAgIGNhc2UgJ2E9c2VuZG9ubHknOlxuICAgICAgICAgIGNhc2UgJ2E9cmVjdm9ubHknOlxuICAgICAgICAgIGNhc2UgJ2E9aW5hY3RpdmUnOlxuICAgICAgICAgICAgcmV0dXJuIGxpbmVzW2ldLnN1YnN0cmluZygyKTtcbiAgICAgICAgICAvLyBGSVhNRTogV2hhdCBzaG91bGQgaGFwcGVuIGhlcmU/XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzZXNzaW9ucGFydCkge1xuICAgICAgICByZXR1cm4gU0RQVXRpbHMuZ2V0RGlyZWN0aW9uKHNlc3Npb25wYXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAnc2VuZHJlY3YnO1xuICAgIH07XG4gICAgU0RQVXRpbHMuZ2V0S2luZCA9IGZ1bmN0aW9uIChtZWRpYVNlY3Rpb24pIHtcbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhtZWRpYVNlY3Rpb24pO1xuICAgICAgY29uc3QgbWxpbmUgPSBsaW5lc1swXS5zcGxpdCgnICcpO1xuICAgICAgcmV0dXJuIG1saW5lWzBdLnN1YnN0cmluZygyKTtcbiAgICB9O1xuICAgIFNEUFV0aWxzLmlzUmVqZWN0ZWQgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbWVkaWFTZWN0aW9uLnNwbGl0KCcgJywgMilbMV0gPT09ICcwJztcbiAgICB9O1xuICAgIFNEUFV0aWxzLnBhcnNlTUxpbmUgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBsaW5lcyA9IFNEUFV0aWxzLnNwbGl0TGluZXMobWVkaWFTZWN0aW9uKTtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbMF0uc3Vic3RyaW5nKDIpLnNwbGl0KCcgJyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBwYXJ0c1swXSxcbiAgICAgICAgcG9ydDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcbiAgICAgICAgcHJvdG9jb2w6IHBhcnRzWzJdLFxuICAgICAgICBmbXQ6IHBhcnRzLnNsaWNlKDMpLmpvaW4oJyAnKVxuICAgICAgfTtcbiAgICB9O1xuICAgIFNEUFV0aWxzLnBhcnNlT0xpbmUgPSBmdW5jdGlvbiAobWVkaWFTZWN0aW9uKSB7XG4gICAgICBjb25zdCBsaW5lID0gU0RQVXRpbHMubWF0Y2hQcmVmaXgobWVkaWFTZWN0aW9uLCAnbz0nKVswXTtcbiAgICAgIGNvbnN0IHBhcnRzID0gbGluZS5zdWJzdHJpbmcoMikuc3BsaXQoJyAnKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHVzZXJuYW1lOiBwYXJ0c1swXSxcbiAgICAgICAgc2Vzc2lvbklkOiBwYXJ0c1sxXSxcbiAgICAgICAgc2Vzc2lvblZlcnNpb246IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgICAgIG5ldFR5cGU6IHBhcnRzWzNdLFxuICAgICAgICBhZGRyZXNzVHlwZTogcGFydHNbNF0sXG4gICAgICAgIGFkZHJlc3M6IHBhcnRzWzVdXG4gICAgICB9O1xuICAgIH07XG5cbiAgICAvLyBhIHZlcnkgbmFpdmUgaW50ZXJwcmV0YXRpb24gb2YgYSB2YWxpZCBTRFAuXG4gICAgU0RQVXRpbHMuaXNWYWxpZFNEUCA9IGZ1bmN0aW9uIChibG9iKSB7XG4gICAgICBpZiAodHlwZW9mIGJsb2IgIT09ICdzdHJpbmcnIHx8IGJsb2IubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxpbmVzID0gU0RQVXRpbHMuc3BsaXRMaW5lcyhibG9iKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGxpbmVzW2ldLmxlbmd0aCA8IDIgfHwgbGluZXNbaV0uY2hhckF0KDEpICE9PSAnPScpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETzogY2hlY2sgdGhlIG1vZGlmaWVyIGEgYml0IG1vcmUuXG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgLy8gRXhwb3NlIHB1YmxpYyBtZXRob2RzLlxuICAgIHtcbiAgICAgIG1vZHVsZS5leHBvcnRzID0gU0RQVXRpbHM7XG4gICAgfVxuICB9KShzZHAkMSk7XG4gIHJldHVybiBzZHAkMS5leHBvcnRzO1xufVxuXG52YXIgc2RwRXhwb3J0cyA9IHJlcXVpcmVTZHAoKTtcbnZhciBTRFBVdGlscyA9IC8qQF9fUFVSRV9fKi9nZXREZWZhdWx0RXhwb3J0RnJvbUNqcyhzZHBFeHBvcnRzKTtcblxudmFyIHNkcCA9IC8qI19fUFVSRV9fKi9fbWVyZ2VOYW1lc3BhY2VzKHtcbiAgX19wcm90b19fOiBudWxsLFxuICBkZWZhdWx0OiBTRFBVdGlsc1xufSwgW3NkcEV4cG9ydHNdKTtcblxuLypcbiAqICBDb3B5cmlnaHQgKGMpIDIwMTcgVGhlIFdlYlJUQyBwcm9qZWN0IGF1dGhvcnMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGEgQlNELXN0eWxlIGxpY2Vuc2VcbiAqICB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGluIHRoZSByb290IG9mIHRoZSBzb3VyY2VcbiAqICB0cmVlLlxuICovXG4vKiBlc2xpbnQtZW52IG5vZGUgKi9cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KSB7XG4gIC8vIGZvdW5kYXRpb24gaXMgYXJiaXRyYXJpbHkgY2hvc2VuIGFzIGFuIGluZGljYXRvciBmb3IgZnVsbCBzdXBwb3J0IGZvclxuICAvLyBodHRwczovL3czYy5naXRodWIuaW8vd2VicnRjLXBjLyNydGNpY2VjYW5kaWRhdGUtaW50ZXJmYWNlXG4gIGlmICghd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSB8fCB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlICYmICdmb3VuZGF0aW9uJyBpbiB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBOYXRpdmVSVENJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlO1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlID0gZnVuY3Rpb24gUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGE9IHdoaWNoIHNob3VsZG4ndCBiZSBwYXJ0IG9mIHRoZSBjYW5kaWRhdGUgc3RyaW5nLlxuICAgIGlmICh0eXBlb2YgYXJncyA9PT0gJ29iamVjdCcgJiYgYXJncy5jYW5kaWRhdGUgJiYgYXJncy5jYW5kaWRhdGUuaW5kZXhPZignYT0nKSA9PT0gMCkge1xuICAgICAgYXJncyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xuICAgICAgYXJncy5jYW5kaWRhdGUgPSBhcmdzLmNhbmRpZGF0ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIGlmIChhcmdzLmNhbmRpZGF0ZSAmJiBhcmdzLmNhbmRpZGF0ZS5sZW5ndGgpIHtcbiAgICAgIC8vIEF1Z21lbnQgdGhlIG5hdGl2ZSBjYW5kaWRhdGUgd2l0aCB0aGUgcGFyc2VkIGZpZWxkcy5cbiAgICAgIGNvbnN0IG5hdGl2ZUNhbmRpZGF0ZSA9IG5ldyBOYXRpdmVSVENJY2VDYW5kaWRhdGUoYXJncyk7XG4gICAgICBjb25zdCBwYXJzZWRDYW5kaWRhdGUgPSBTRFBVdGlscy5wYXJzZUNhbmRpZGF0ZShhcmdzLmNhbmRpZGF0ZSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBpbiBwYXJzZWRDYW5kaWRhdGUpIHtcbiAgICAgICAgaWYgKCEoa2V5IGluIG5hdGl2ZUNhbmRpZGF0ZSkpIHtcbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobmF0aXZlQ2FuZGlkYXRlLCBrZXksIHtcbiAgICAgICAgICAgIHZhbHVlOiBwYXJzZWRDYW5kaWRhdGVba2V5XVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIE92ZXJyaWRlIHNlcmlhbGl6ZXIgdG8gbm90IHNlcmlhbGl6ZSB0aGUgZXh0cmEgYXR0cmlidXRlcy5cbiAgICAgIG5hdGl2ZUNhbmRpZGF0ZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FuZGlkYXRlOiBuYXRpdmVDYW5kaWRhdGUuY2FuZGlkYXRlLFxuICAgICAgICAgIHNkcE1pZDogbmF0aXZlQ2FuZGlkYXRlLnNkcE1pZCxcbiAgICAgICAgICBzZHBNTGluZUluZGV4OiBuYXRpdmVDYW5kaWRhdGUuc2RwTUxpbmVJbmRleCxcbiAgICAgICAgICB1c2VybmFtZUZyYWdtZW50OiBuYXRpdmVDYW5kaWRhdGUudXNlcm5hbWVGcmFnbWVudFxuICAgICAgICB9O1xuICAgICAgfTtcbiAgICAgIHJldHVybiBuYXRpdmVDYW5kaWRhdGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgTmF0aXZlUlRDSWNlQ2FuZGlkYXRlKGFyZ3MpO1xuICB9O1xuICB3aW5kb3cuUlRDSWNlQ2FuZGlkYXRlLnByb3RvdHlwZSA9IE5hdGl2ZVJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGU7XG5cbiAgLy8gSG9vayB1cCB0aGUgYXVnbWVudGVkIGNhbmRpZGF0ZSBpbiBvbmljZWNhbmRpZGF0ZSBhbmRcbiAgLy8gYWRkRXZlbnRMaXN0ZW5lcignaWNlY2FuZGlkYXRlJywgLi4uKVxuICB3cmFwUGVlckNvbm5lY3Rpb25FdmVudCh3aW5kb3csICdpY2VjYW5kaWRhdGUnLCBlID0+IHtcbiAgICBpZiAoZS5jYW5kaWRhdGUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLCAnY2FuZGlkYXRlJywge1xuICAgICAgICB2YWx1ZTogbmV3IHdpbmRvdy5SVENJY2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUpLFxuICAgICAgICB3cml0YWJsZTogJ2ZhbHNlJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdykge1xuICBpZiAoIXdpbmRvdy5SVENJY2VDYW5kaWRhdGUgfHwgd2luZG93LlJUQ0ljZUNhbmRpZGF0ZSAmJiAncmVsYXlQcm90b2NvbCcgaW4gd2luZG93LlJUQ0ljZUNhbmRpZGF0ZS5wcm90b3R5cGUpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICAvLyBIb29rIHVwIHRoZSBhdWdtZW50ZWQgY2FuZGlkYXRlIGluIG9uaWNlY2FuZGlkYXRlIGFuZFxuICAvLyBhZGRFdmVudExpc3RlbmVyKCdpY2VjYW5kaWRhdGUnLCAuLi4pXG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2ljZWNhbmRpZGF0ZScsIGUgPT4ge1xuICAgIGlmIChlLmNhbmRpZGF0ZSkge1xuICAgICAgY29uc3QgcGFyc2VkQ2FuZGlkYXRlID0gU0RQVXRpbHMucGFyc2VDYW5kaWRhdGUoZS5jYW5kaWRhdGUuY2FuZGlkYXRlKTtcbiAgICAgIGlmIChwYXJzZWRDYW5kaWRhdGUudHlwZSA9PT0gJ3JlbGF5Jykge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbGlid2VicnRjLXNwZWNpZmljIG1hcHBpbmcgb2YgbG9jYWwgdHlwZSBwcmVmZXJlbmNlXG4gICAgICAgIC8vIHRvIHJlbGF5UHJvdG9jb2wuXG4gICAgICAgIGUuY2FuZGlkYXRlLnJlbGF5UHJvdG9jb2wgPSB7XG4gICAgICAgICAgMDogJ3RscycsXG4gICAgICAgICAgMTogJ3RjcCcsXG4gICAgICAgICAgMjogJ3VkcCdcbiAgICAgICAgfVtwYXJzZWRDYW5kaWRhdGUucHJpb3JpdHkgPj4gMjRdO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5mdW5jdGlvbiBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscykge1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoISgnc2N0cCcgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkod2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSwgJ3NjdHAnLCB7XG4gICAgICBnZXQoKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY3RwSW5EZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbikge1xuICAgIGlmICghZGVzY3JpcHRpb24gfHwgIWRlc2NyaXB0aW9uLnNkcCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBzZWN0aW9ucyA9IFNEUFV0aWxzLnNwbGl0U2VjdGlvbnMoZGVzY3JpcHRpb24uc2RwKTtcbiAgICBzZWN0aW9ucy5zaGlmdCgpO1xuICAgIHJldHVybiBzZWN0aW9ucy5zb21lKG1lZGlhU2VjdGlvbiA9PiB7XG4gICAgICBjb25zdCBtTGluZSA9IFNEUFV0aWxzLnBhcnNlTUxpbmUobWVkaWFTZWN0aW9uKTtcbiAgICAgIHJldHVybiBtTGluZSAmJiBtTGluZS5raW5kID09PSAnYXBwbGljYXRpb24nICYmIG1MaW5lLnByb3RvY29sLmluZGV4T2YoJ1NDVFAnKSAhPT0gLTE7XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uID0gZnVuY3Rpb24gKGRlc2NyaXB0aW9uKSB7XG4gICAgLy8gVE9ETzogSXMgdGhlcmUgYSBiZXR0ZXIgc29sdXRpb24gZm9yIGRldGVjdGluZyBGaXJlZm94P1xuICAgIGNvbnN0IG1hdGNoID0gZGVzY3JpcHRpb24uc2RwLm1hdGNoKC9tb3ppbGxhLi4uVEhJU19JU19TRFBBUlRBLShcXGQrKS8pO1xuICAgIGlmIChtYXRjaCA9PT0gbnVsbCB8fCBtYXRjaC5sZW5ndGggPCAyKSB7XG4gICAgICByZXR1cm4gLTE7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludChtYXRjaFsxXSwgMTApO1xuICAgIC8vIFRlc3QgZm9yIE5hTiAoeWVzLCB0aGlzIGlzIHVnbHkpXG4gICAgcmV0dXJuIHZlcnNpb24gIT09IHZlcnNpb24gPyAtMSA6IHZlcnNpb247XG4gIH07XG4gIGNvbnN0IGdldENhblNlbmRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChyZW1vdGVJc0ZpcmVmb3gpIHtcbiAgICAvLyBFdmVyeSBpbXBsZW1lbnRhdGlvbiB3ZSBrbm93IGNhbiBzZW5kIGF0IGxlYXN0IDY0IEtpQi5cbiAgICAvLyBOb3RlOiBBbHRob3VnaCBDaHJvbWUgaXMgdGVjaG5pY2FsbHkgYWJsZSB0byBzZW5kIHVwIHRvIDI1NiBLaUIsIHRoZVxuICAgIC8vICAgICAgIGRhdGEgZG9lcyBub3QgcmVhY2ggdGhlIG90aGVyIHBlZXIgcmVsaWFibHkuXG4gICAgLy8gICAgICAgU2VlOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9ODQxOVxuICAgIGxldCBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSA2NTUzNjtcbiAgICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnKSB7XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDU3KSB7XG4gICAgICAgIGlmIChyZW1vdGVJc0ZpcmVmb3ggPT09IC0xKSB7XG4gICAgICAgICAgLy8gRkYgPCA1NyB3aWxsIHNlbmQgaW4gMTYgS2lCIGNodW5rcyB1c2luZyB0aGUgZGVwcmVjYXRlZCBQUElEXG4gICAgICAgICAgLy8gZnJhZ21lbnRhdGlvbi5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAxNjM4NDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBIb3dldmVyLCBvdGhlciBGRiAoYW5kIFJBV1JUQykgY2FuIHJlYXNzZW1ibGUgUFBJRC1mcmFnbWVudGVkXG4gICAgICAgICAgLy8gbWVzc2FnZXMuIFRodXMsIHN1cHBvcnRpbmcgfjIgR2lCIHdoZW4gc2VuZGluZy5cbiAgICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGJyb3dzZXJEZXRhaWxzLnZlcnNpb24gPCA2MCkge1xuICAgICAgICAvLyBDdXJyZW50bHksIGFsbCBGRiA+PSA1NyB3aWxsIHJlc2V0IHRoZSByZW1vdGUgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgICAgLy8gdG8gdGhlIGRlZmF1bHQgdmFsdWUgd2hlbiBhIGRhdGEgY2hhbm5lbCBpcyBjcmVhdGVkIGF0IGEgbGF0ZXJcbiAgICAgICAgLy8gc3RhZ2UuIDooXG4gICAgICAgIC8vIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1NyA/IDY1NTM1IDogNjU1MzY7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGRiA+PSA2MCBzdXBwb3J0cyBzZW5kaW5nIH4yIEdpQlxuICAgICAgICBjYW5TZW5kTWF4TWVzc2FnZVNpemUgPSAyMTQ3NDgzNjM3O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY2FuU2VuZE1heE1lc3NhZ2VTaXplO1xuICB9O1xuICBjb25zdCBnZXRNYXhNZXNzYWdlU2l6ZSA9IGZ1bmN0aW9uIChkZXNjcmlwdGlvbiwgcmVtb3RlSXNGaXJlZm94KSB7XG4gICAgLy8gTm90ZTogNjU1MzYgYnl0ZXMgaXMgdGhlIGRlZmF1bHQgdmFsdWUgZnJvbSB0aGUgU0RQIHNwZWMuIEFsc28sXG4gICAgLy8gICAgICAgZXZlcnkgaW1wbGVtZW50YXRpb24gd2Uga25vdyBzdXBwb3J0cyByZWNlaXZpbmcgNjU1MzYgYnl0ZXMuXG4gICAgbGV0IG1heE1lc3NhZ2VTaXplID0gNjU1MzY7XG5cbiAgICAvLyBGRiA1NyBoYXMgYSBzbGlnaHRseSBpbmNvcnJlY3QgZGVmYXVsdCByZW1vdGUgbWF4IG1lc3NhZ2Ugc2l6ZSwgc29cbiAgICAvLyB3ZSBuZWVkIHRvIGFkanVzdCBpdCBoZXJlIHRvIGF2b2lkIGEgZmFpbHVyZSB3aGVuIHNlbmRpbmcuXG4gICAgLy8gU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xNDI1Njk3XG4gICAgaWYgKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID09PSA1Nykge1xuICAgICAgbWF4TWVzc2FnZVNpemUgPSA2NTUzNTtcbiAgICB9XG4gICAgY29uc3QgbWF0Y2ggPSBTRFBVdGlscy5tYXRjaFByZWZpeChkZXNjcmlwdGlvbi5zZHAsICdhPW1heC1tZXNzYWdlLXNpemU6Jyk7XG4gICAgaWYgKG1hdGNoLmxlbmd0aCA+IDApIHtcbiAgICAgIG1heE1lc3NhZ2VTaXplID0gcGFyc2VJbnQobWF0Y2hbMF0uc3Vic3RyaW5nKDE5KSwgMTApO1xuICAgIH0gZWxzZSBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2ZpcmVmb3gnICYmIHJlbW90ZUlzRmlyZWZveCAhPT0gLTEpIHtcbiAgICAgIC8vIElmIHRoZSBtYXhpbXVtIG1lc3NhZ2Ugc2l6ZSBpcyBub3QgcHJlc2VudCBpbiB0aGUgcmVtb3RlIFNEUCBhbmRcbiAgICAgIC8vIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBhcmUgRmlyZWZveCwgdGhlIHJlbW90ZSBwZWVyIGNhbiByZWNlaXZlXG4gICAgICAvLyB+MiBHaUIuXG4gICAgICBtYXhNZXNzYWdlU2l6ZSA9IDIxNDc0ODM2Mzc7XG4gICAgfVxuICAgIHJldHVybiBtYXhNZXNzYWdlU2l6ZTtcbiAgfTtcbiAgY29uc3Qgb3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHRoaXMuX3NjdHAgPSBudWxsO1xuICAgIC8vIENocm9tZSBkZWNpZGVkIHRvIG5vdCBleHBvc2UgLnNjdHAgaW4gcGxhbi1iIG1vZGUuXG4gICAgLy8gQXMgdXN1YWwsIGFkYXB0ZXIuanMgaGFzIHRvIGRvIGFuICd1Z2x5IHdvcmFrYXJvdW5kJ1xuICAgIC8vIHRvIGNvdmVyIHVwIHRoZSBtZXNzLlxuICAgIGlmIChicm93c2VyRGV0YWlscy5icm93c2VyID09PSAnY2hyb21lJyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uID49IDc2KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHNkcFNlbWFudGljc1xuICAgICAgfSA9IHRoaXMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgaWYgKHNkcFNlbWFudGljcyA9PT0gJ3BsYW4tYicpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdzY3RwJywge1xuICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgdGhpcy5fc2N0cCA9PT0gJ3VuZGVmaW5lZCcgPyBudWxsIDogdGhpcy5fc2N0cDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2N0cEluRGVzY3JpcHRpb24oYXJndW1lbnRzWzBdKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhlIHJlbW90ZSBpcyBGRi5cbiAgICAgIGNvbnN0IGlzRmlyZWZveCA9IGdldFJlbW90ZUZpcmVmb3hWZXJzaW9uKGFyZ3VtZW50c1swXSk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgdGhlIGxvY2FsIHBlZXIgaXMgY2FwYWJsZSBvZiBzZW5kaW5nXG4gICAgICBjb25zdCBjYW5TZW5kTU1TID0gZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplKGlzRmlyZWZveCk7XG5cbiAgICAgIC8vIEdldCB0aGUgbWF4aW11bSBtZXNzYWdlIHNpemUgb2YgdGhlIHJlbW90ZSBwZWVyLlxuICAgICAgY29uc3QgcmVtb3RlTU1TID0gZ2V0TWF4TWVzc2FnZVNpemUoYXJndW1lbnRzWzBdLCBpc0ZpcmVmb3gpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgZmluYWwgbWF4aW11bSBtZXNzYWdlIHNpemVcbiAgICAgIGxldCBtYXhNZXNzYWdlU2l6ZTtcbiAgICAgIGlmIChjYW5TZW5kTU1TID09PSAwICYmIHJlbW90ZU1NUyA9PT0gMCkge1xuICAgICAgICBtYXhNZXNzYWdlU2l6ZSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgIH0gZWxzZSBpZiAoY2FuU2VuZE1NUyA9PT0gMCB8fCByZW1vdGVNTVMgPT09IDApIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1heChjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF4TWVzc2FnZVNpemUgPSBNYXRoLm1pbihjYW5TZW5kTU1TLCByZW1vdGVNTVMpO1xuICAgICAgfVxuXG4gICAgICAvLyBDcmVhdGUgYSBkdW1teSBSVENTY3RwVHJhbnNwb3J0IG9iamVjdCBhbmQgdGhlICdtYXhNZXNzYWdlU2l6ZSdcbiAgICAgIC8vIGF0dHJpYnV0ZS5cbiAgICAgIGNvbnN0IHNjdHAgPSB7fTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzY3RwLCAnbWF4TWVzc2FnZVNpemUnLCB7XG4gICAgICAgIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gbWF4TWVzc2FnZVNpemU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2N0cCA9IHNjdHA7XG4gICAgfVxuICAgIHJldHVybiBvcmlnU2V0UmVtb3RlRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiAnY3JlYXRlRGF0YUNoYW5uZWwnIGluIHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGUpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gTm90ZTogQWx0aG91Z2ggRmlyZWZveCA+PSA1NyBoYXMgYSBuYXRpdmUgaW1wbGVtZW50YXRpb24sIHRoZSBtYXhpbXVtXG4gIC8vICAgICAgIG1lc3NhZ2Ugc2l6ZSBjYW4gYmUgcmVzZXQgZm9yIGFsbCBkYXRhIGNoYW5uZWxzIGF0IGEgbGF0ZXIgc3RhZ2UuXG4gIC8vICAgICAgIFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTQyNjgzMVxuXG4gIGZ1bmN0aW9uIHdyYXBEY1NlbmQoZGMsIHBjKSB7XG4gICAgY29uc3Qgb3JpZ0RhdGFDaGFubmVsU2VuZCA9IGRjLnNlbmQ7XG4gICAgZGMuc2VuZCA9IGZ1bmN0aW9uIHNlbmQoKSB7XG4gICAgICBjb25zdCBkYXRhID0gYXJndW1lbnRzWzBdO1xuICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YS5sZW5ndGggfHwgZGF0YS5zaXplIHx8IGRhdGEuYnl0ZUxlbmd0aDtcbiAgICAgIGlmIChkYy5yZWFkeVN0YXRlID09PSAnb3BlbicgJiYgcGMuc2N0cCAmJiBsZW5ndGggPiBwYy5zY3RwLm1heE1lc3NhZ2VTaXplKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ01lc3NhZ2UgdG9vIGxhcmdlIChjYW4gc2VuZCBhIG1heGltdW0gb2YgJyArIHBjLnNjdHAubWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yaWdEYXRhQ2hhbm5lbFNlbmQuYXBwbHkoZGMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfVxuICBjb25zdCBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsO1xuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZURhdGFDaGFubmVsID0gZnVuY3Rpb24gY3JlYXRlRGF0YUNoYW5uZWwoKSB7XG4gICAgY29uc3QgZGF0YUNoYW5uZWwgPSBvcmlnQ3JlYXRlRGF0YUNoYW5uZWwuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB3cmFwRGNTZW5kKGRhdGFDaGFubmVsLCB0aGlzKTtcbiAgICByZXR1cm4gZGF0YUNoYW5uZWw7XG4gIH07XG4gIHdyYXBQZWVyQ29ubmVjdGlvbkV2ZW50KHdpbmRvdywgJ2RhdGFjaGFubmVsJywgZSA9PiB7XG4gICAgd3JhcERjU2VuZChlLmNoYW5uZWwsIGUudGFyZ2V0KTtcbiAgICByZXR1cm4gZTtcbiAgfSk7XG59XG5cbi8qIHNoaW1zIFJUQ0Nvbm5lY3Rpb25TdGF0ZSBieSBwcmV0ZW5kaW5nIGl0IGlzIHRoZSBzYW1lIGFzIGljZUNvbm5lY3Rpb25TdGF0ZS5cbiAqIFNlZSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3Avd2VicnRjL2lzc3Vlcy9kZXRhaWw/aWQ9NjE0NSNjMTJcbiAqIGZvciB3aHkgdGhpcyBpcyBhIHZhbGlkIGhhY2sgaW4gQ2hyb21lLiBJbiBGaXJlZm94IGl0IGlzIHNsaWdodGx5IGluY29ycmVjdFxuICogc2luY2UgRFRMUyBmYWlsdXJlcyB3b3VsZCBiZSBoaWRkZW4uIFNlZVxuICogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI2NTgyN1xuICogZm9yIHRoZSBGaXJlZm94IHRyYWNraW5nIGJ1Zy5cbiAqL1xuZnVuY3Rpb24gc2hpbUNvbm5lY3Rpb25TdGF0ZSh3aW5kb3cpIHtcbiAgaWYgKCF3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24gfHwgJ2Nvbm5lY3Rpb25TdGF0ZScgaW4gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm90byA9IHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbi5wcm90b3R5cGU7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgJ2Nvbm5lY3Rpb25TdGF0ZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb21wbGV0ZWQ6ICdjb25uZWN0ZWQnLFxuICAgICAgICBjaGVja2luZzogJ2Nvbm5lY3RpbmcnXG4gICAgICB9W3RoaXMuaWNlQ29ubmVjdGlvblN0YXRlXSB8fCB0aGlzLmljZUNvbm5lY3Rpb25TdGF0ZTtcbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sICdvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgfHwgbnVsbDtcbiAgICB9LFxuICAgIHNldChjYikge1xuICAgICAgaWYgKHRoaXMuX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2UpO1xuICAgICAgICBkZWxldGUgdGhpcy5fb25jb25uZWN0aW9uc3RhdGVjaGFuZ2U7XG4gICAgICB9XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCB0aGlzLl9vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IGNiKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xuICBbJ3NldExvY2FsRGVzY3JpcHRpb24nLCAnc2V0UmVtb3RlRGVzY3JpcHRpb24nXS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgY29uc3Qgb3JpZ01ldGhvZCA9IHByb3RvW21ldGhvZF07XG4gICAgcHJvdG9bbWV0aG9kXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSkge1xuICAgICAgICB0aGlzLl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5ID0gZSA9PiB7XG4gICAgICAgICAgY29uc3QgcGMgPSBlLnRhcmdldDtcbiAgICAgICAgICBpZiAocGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgIT09IHBjLmNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgcGMuX2xhc3RDb25uZWN0aW9uU3RhdGUgPSBwYy5jb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBjb25zdCBuZXdFdmVudCA9IG5ldyBFdmVudCgnY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgZSk7XG4gICAgICAgICAgICBwYy5kaXNwYXRjaEV2ZW50KG5ld0V2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgdGhpcy5fY29ubmVjdGlvbnN0YXRlY2hhbmdlcG9seSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3JpZ01ldGhvZC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8qIHJlbW92ZSBhPWV4dG1hcC1hbGxvdy1taXhlZCBmb3Igd2VicnRjLm9yZyA8IE03MSAqL1xuICBpZiAoIXdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA3MSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA+PSA2MDUpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbmF0aXZlU1JEID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbjtcbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRSZW1vdGVEZXNjcmlwdGlvbiA9IGZ1bmN0aW9uIHNldFJlbW90ZURlc2NyaXB0aW9uKGRlc2MpIHtcbiAgICBpZiAoZGVzYyAmJiBkZXNjLnNkcCAmJiBkZXNjLnNkcC5pbmRleE9mKCdcXG5hPWV4dG1hcC1hbGxvdy1taXhlZCcpICE9PSAtMSkge1xuICAgICAgY29uc3Qgc2RwID0gZGVzYy5zZHAuc3BsaXQoJ1xcbicpLmZpbHRlcihsaW5lID0+IHtcbiAgICAgICAgcmV0dXJuIGxpbmUudHJpbSgpICE9PSAnYT1leHRtYXAtYWxsb3ctbWl4ZWQnO1xuICAgICAgfSkuam9pbignXFxuJyk7XG4gICAgICAvLyBTYWZhcmkgZW5mb3JjZXMgcmVhZC1vbmx5LW5lc3Mgb2YgUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIGZpZWxkcy5cbiAgICAgIGlmICh3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uICYmIGRlc2MgaW5zdGFuY2VvZiB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGFyZ3VtZW50c1swXSA9IG5ldyB3aW5kb3cuUlRDU2Vzc2lvbkRlc2NyaXB0aW9uKHtcbiAgICAgICAgICB0eXBlOiBkZXNjLnR5cGUsXG4gICAgICAgICAgc2RwXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVzYy5zZHAgPSBzZHA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuYXRpdmVTUkQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIC8vIFN1cHBvcnQgZm9yIGFkZEljZUNhbmRpZGF0ZShudWxsIG9yIHVuZGVmaW5lZClcbiAgLy8gYXMgd2VsbCBhcyBhZGRJY2VDYW5kaWRhdGUoe2NhbmRpZGF0ZTogXCJcIiwgLi4ufSlcbiAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9OTc4NTgyXG4gIC8vIE5vdGU6IG11c3QgYmUgY2FsbGVkIGJlZm9yZSBvdGhlciBwb2x5ZmlsbHMgd2hpY2ggY2hhbmdlIHRoZSBzaWduYXR1cmUuXG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVBZGRJY2VDYW5kaWRhdGUgPSB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZTtcbiAgaWYgKCFuYXRpdmVBZGRJY2VDYW5kaWRhdGUgfHwgbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlLmFkZEljZUNhbmRpZGF0ZSA9IGZ1bmN0aW9uIGFkZEljZUNhbmRpZGF0ZSgpIHtcbiAgICBpZiAoIWFyZ3VtZW50c1swXSkge1xuICAgICAgaWYgKGFyZ3VtZW50c1sxXSkge1xuICAgICAgICBhcmd1bWVudHNbMV0uYXBwbHkobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIC8vIEZpcmVmb3ggNjgrIGVtaXRzIGFuZCBwcm9jZXNzZXMge2NhbmRpZGF0ZTogXCJcIiwgLi4ufSwgaWdub3JlXG4gICAgLy8gaW4gb2xkZXIgdmVyc2lvbnMuXG4gICAgLy8gTmF0aXZlIHN1cHBvcnQgZm9yIGlnbm9yaW5nIGV4aXN0cyBmb3IgQ2hyb21lIE03NysuXG4gICAgLy8gU2FmYXJpIGlnbm9yZXMgYXMgd2VsbCwgZXhhY3QgdmVyc2lvbiB1bmtub3duIGJ1dCB3b3JrcyBpbiB0aGUgc2FtZVxuICAgIC8vIHZlcnNpb24gdGhhdCBhbHNvIGlnbm9yZXMgYWRkSWNlQ2FuZGlkYXRlKG51bGwpLlxuICAgIGlmICgoYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ2Nocm9tZScgJiYgYnJvd3NlckRldGFpbHMudmVyc2lvbiA8IDc4IHx8IGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIgPT09ICdmaXJlZm94JyAmJiBicm93c2VyRGV0YWlscy52ZXJzaW9uIDwgNjggfHwgYnJvd3NlckRldGFpbHMuYnJvd3NlciA9PT0gJ3NhZmFyaScpICYmIGFyZ3VtZW50c1swXSAmJiBhcmd1bWVudHNbMF0uY2FuZGlkYXRlID09PSAnJykge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gbmF0aXZlQWRkSWNlQ2FuZGlkYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbi8vIE5vdGU6IE1ha2Ugc3VyZSB0byBjYWxsIHRoaXMgYWhlYWQgb2YgQVBJcyB0aGF0IG1vZGlmeVxuLy8gc2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGhcbmZ1bmN0aW9uIHNoaW1QYXJhbWV0ZXJsZXNzU2V0TG9jYWxEZXNjcmlwdGlvbih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKSB7XG4gIGlmICghKHdpbmRvdy5SVENQZWVyQ29ubmVjdGlvbiAmJiB3aW5kb3cuUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uID0gd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uO1xuICBpZiAoIW5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24gfHwgbmF0aXZlU2V0TG9jYWxEZXNjcmlwdGlvbi5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgd2luZG93LlJUQ1BlZXJDb25uZWN0aW9uLnByb3RvdHlwZS5zZXRMb2NhbERlc2NyaXB0aW9uID0gZnVuY3Rpb24gc2V0TG9jYWxEZXNjcmlwdGlvbigpIHtcbiAgICBsZXQgZGVzYyA9IGFyZ3VtZW50c1swXSB8fCB7fTtcbiAgICBpZiAodHlwZW9mIGRlc2MgIT09ICdvYmplY3QnIHx8IGRlc2MudHlwZSAmJiBkZXNjLnNkcCkge1xuICAgICAgcmV0dXJuIG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgLy8gVGhlIHJlbWFpbmluZyBzdGVwcyBzaG91bGQgdGVjaG5pY2FsbHkgaGFwcGVuIHdoZW4gU0xEIGNvbWVzIG9mZiB0aGVcbiAgICAvLyBSVENQZWVyQ29ubmVjdGlvbidzIG9wZXJhdGlvbnMgY2hhaW4gKG5vdCBhaGVhZCBvZiBnb2luZyBvbiBpdCksIGJ1dFxuICAgIC8vIHRoaXMgaXMgdG9vIGRpZmZpY3VsdCB0byBzaGltLiBJbnN0ZWFkLCB0aGlzIHNoaW0gb25seSBjb3ZlcnMgdGhlXG4gICAgLy8gY29tbW9uIGNhc2Ugd2hlcmUgdGhlIG9wZXJhdGlvbnMgY2hhaW4gaXMgZW1wdHkuIFRoaXMgaXMgaW1wZXJmZWN0LCBidXRcbiAgICAvLyBzaG91bGQgY292ZXIgbWFueSBjYXNlcy4gUmF0aW9uYWxlOiBFdmVuIGlmIHdlIGNhbid0IHJlZHVjZSB0aGUgZ2xhcmVcbiAgICAvLyB3aW5kb3cgdG8gemVybyBvbiBpbXBlcmZlY3QgaW1wbGVtZW50YXRpb25zLCB0aGVyZSdzIHZhbHVlIGluIHRhcHBpbmdcbiAgICAvLyBpbnRvIHRoZSBwZXJmZWN0IG5lZ290aWF0aW9uIHBhdHRlcm4gdGhhdCBzZXZlcmFsIGJyb3dzZXJzIHN1cHBvcnQuXG4gICAgZGVzYyA9IHtcbiAgICAgIHR5cGU6IGRlc2MudHlwZSxcbiAgICAgIHNkcDogZGVzYy5zZHBcbiAgICB9O1xuICAgIGlmICghZGVzYy50eXBlKSB7XG4gICAgICBzd2l0Y2ggKHRoaXMuc2lnbmFsaW5nU3RhdGUpIHtcbiAgICAgICAgY2FzZSAnc3RhYmxlJzpcbiAgICAgICAgY2FzZSAnaGF2ZS1sb2NhbC1vZmZlcic6XG4gICAgICAgIGNhc2UgJ2hhdmUtcmVtb3RlLXByYW5zd2VyJzpcbiAgICAgICAgICBkZXNjLnR5cGUgPSAnb2ZmZXInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGRlc2MudHlwZSA9ICdhbnN3ZXInO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGVzYy5zZHAgfHwgZGVzYy50eXBlICE9PSAnb2ZmZXInICYmIGRlc2MudHlwZSAhPT0gJ2Fuc3dlcicpIHtcbiAgICAgIHJldHVybiBuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uLmFwcGx5KHRoaXMsIFtkZXNjXSk7XG4gICAgfVxuICAgIGNvbnN0IGZ1bmMgPSBkZXNjLnR5cGUgPT09ICdvZmZlcicgPyB0aGlzLmNyZWF0ZU9mZmVyIDogdGhpcy5jcmVhdGVBbnN3ZXI7XG4gICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcykudGhlbihkID0+IG5hdGl2ZVNldExvY2FsRGVzY3JpcHRpb24uYXBwbHkodGhpcywgW2RdKSk7XG4gIH07XG59XG5cbnZhciBjb21tb25TaGltID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQ6IHJlbW92ZUV4dG1hcEFsbG93TWl4ZWQsXG4gIHNoaW1BZGRJY2VDYW5kaWRhdGVOdWxsT3JFbXB0eTogc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5LFxuICBzaGltQ29ubmVjdGlvblN0YXRlOiBzaGltQ29ubmVjdGlvblN0YXRlLFxuICBzaGltTWF4TWVzc2FnZVNpemU6IHNoaW1NYXhNZXNzYWdlU2l6ZSxcbiAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uOiBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24sXG4gIHNoaW1SVENJY2VDYW5kaWRhdGU6IHNoaW1SVENJY2VDYW5kaWRhdGUsXG4gIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sOiBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCxcbiAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcjogc2hpbVNlbmRUaHJvd1R5cGVFcnJvclxufSk7XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuXG4vLyBTaGltbWluZyBzdGFydHMgaGVyZS5cbmZ1bmN0aW9uIGFkYXB0ZXJGYWN0b3J5KCkge1xuICBsZXQge1xuICAgIHdpbmRvd1xuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICBzaGltQ2hyb21lOiB0cnVlLFxuICAgIHNoaW1GaXJlZm94OiB0cnVlLFxuICAgIHNoaW1TYWZhcmk6IHRydWVcbiAgfTtcbiAgLy8gVXRpbHMuXG4gIGNvbnN0IGxvZ2dpbmcgPSBsb2c7XG4gIGNvbnN0IGJyb3dzZXJEZXRhaWxzID0gZGV0ZWN0QnJvd3Nlcih3aW5kb3cpO1xuICBjb25zdCBhZGFwdGVyID0ge1xuICAgIGJyb3dzZXJEZXRhaWxzLFxuICAgIGNvbW1vblNoaW0sXG4gICAgZXh0cmFjdFZlcnNpb246IGV4dHJhY3RWZXJzaW9uLFxuICAgIGRpc2FibGVMb2c6IGRpc2FibGVMb2csXG4gICAgZGlzYWJsZVdhcm5pbmdzOiBkaXNhYmxlV2FybmluZ3MsXG4gICAgLy8gRXhwb3NlIHNkcCBhcyBhIGNvbnZlbmllbmNlLiBGb3IgcHJvZHVjdGlvbiBhcHBzIGluY2x1ZGUgZGlyZWN0bHkuXG4gICAgc2RwXG4gIH07XG5cbiAgLy8gU2hpbSBicm93c2VyIGlmIGZvdW5kLlxuICBzd2l0Y2ggKGJyb3dzZXJEZXRhaWxzLmJyb3dzZXIpIHtcbiAgICBjYXNlICdjaHJvbWUnOlxuICAgICAgaWYgKCFjaHJvbWVTaGltIHx8ICFzaGltUGVlckNvbm5lY3Rpb24kMSB8fCAhb3B0aW9ucy5zaGltQ2hyb21lKSB7XG4gICAgICAgIGxvZ2dpbmcoJ0Nocm9tZSBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBpZiAoYnJvd3NlckRldGFpbHMudmVyc2lvbiA9PT0gbnVsbCkge1xuICAgICAgICBsb2dnaW5nKCdDaHJvbWUgc2hpbSBjYW4gbm90IGRldGVybWluZSB2ZXJzaW9uLCBub3Qgc2hpbW1pbmcuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBjaHJvbWUuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGNocm9tZVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltUGVlckNvbm5lY3Rpb24uXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcbiAgICAgIHNoaW1HZXRVc2VyTWVkaWEkMih3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1NZWRpYVN0cmVhbSh3aW5kb3cpO1xuICAgICAgc2hpbVBlZXJDb25uZWN0aW9uJDEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltT25UcmFjayQxKHdpbmRvdyk7XG4gICAgICBzaGltQWRkVHJhY2tSZW1vdmVUcmFjayh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1HZXRTZW5kZXJzV2l0aER0bWYod2luZG93KTtcbiAgICAgIHNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzKHdpbmRvdyk7XG4gICAgICBmaXhOZWdvdGlhdGlvbk5lZWRlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sKHdpbmRvdyk7XG4gICAgICBzaGltQ29ubmVjdGlvblN0YXRlKHdpbmRvdyk7XG4gICAgICBzaGltTWF4TWVzc2FnZVNpemUod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltU2VuZFRocm93VHlwZUVycm9yKHdpbmRvdyk7XG4gICAgICByZW1vdmVFeHRtYXBBbGxvd01peGVkKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmlyZWZveCc6XG4gICAgICBpZiAoIWZpcmVmb3hTaGltIHx8ICFzaGltUGVlckNvbm5lY3Rpb24gfHwgIW9wdGlvbnMuc2hpbUZpcmVmb3gpIHtcbiAgICAgICAgbG9nZ2luZygnRmlyZWZveCBzaGltIGlzIG5vdCBpbmNsdWRlZCBpbiB0aGlzIGFkYXB0ZXIgcmVsZWFzZS4nKTtcbiAgICAgICAgcmV0dXJuIGFkYXB0ZXI7XG4gICAgICB9XG4gICAgICBsb2dnaW5nKCdhZGFwdGVyLmpzIHNoaW1taW5nIGZpcmVmb3guJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IGZpcmVmb3hTaGltO1xuXG4gICAgICAvLyBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgc2hpbVBlZXJDb25uZWN0aW9uLlxuICAgICAgc2hpbUFkZEljZUNhbmRpZGF0ZU51bGxPckVtcHR5KHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVBhcmFtZXRlcmxlc3NTZXRMb2NhbERlc2NyaXB0aW9uKHdpbmRvdyk7XG4gICAgICBzaGltR2V0VXNlck1lZGlhJDEod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGVlckNvbm5lY3Rpb24od2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltT25UcmFjayh3aW5kb3cpO1xuICAgICAgc2hpbVJlbW92ZVN0cmVhbSh3aW5kb3cpO1xuICAgICAgc2hpbVNlbmRlckdldFN0YXRzKHdpbmRvdyk7XG4gICAgICBzaGltUmVjZWl2ZXJHZXRTdGF0cyh3aW5kb3cpO1xuICAgICAgc2hpbVJUQ0RhdGFDaGFubmVsKHdpbmRvdyk7XG4gICAgICBzaGltQWRkVHJhbnNjZWl2ZXIod2luZG93KTtcbiAgICAgIHNoaW1HZXRQYXJhbWV0ZXJzKHdpbmRvdyk7XG4gICAgICBzaGltQ3JlYXRlT2ZmZXIod2luZG93KTtcbiAgICAgIHNoaW1DcmVhdGVBbnN3ZXIod2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VDYW5kaWRhdGUod2luZG93KTtcbiAgICAgIHNoaW1Db25uZWN0aW9uU3RhdGUod2luZG93KTtcbiAgICAgIHNoaW1NYXhNZXNzYWdlU2l6ZSh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIHNoaW1TZW5kVGhyb3dUeXBlRXJyb3Iod2luZG93KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3NhZmFyaSc6XG4gICAgICBpZiAoIXNhZmFyaVNoaW0gfHwgIW9wdGlvbnMuc2hpbVNhZmFyaSkge1xuICAgICAgICBsb2dnaW5nKCdTYWZhcmkgc2hpbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhpcyBhZGFwdGVyIHJlbGVhc2UuJyk7XG4gICAgICAgIHJldHVybiBhZGFwdGVyO1xuICAgICAgfVxuICAgICAgbG9nZ2luZygnYWRhcHRlci5qcyBzaGltbWluZyBzYWZhcmkuJyk7XG4gICAgICAvLyBFeHBvcnQgdG8gdGhlIGFkYXB0ZXIgZ2xvYmFsIG9iamVjdCB2aXNpYmxlIGluIHRoZSBicm93c2VyLlxuICAgICAgYWRhcHRlci5icm93c2VyU2hpbSA9IHNhZmFyaVNoaW07XG5cbiAgICAgIC8vIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBzaGltQ2FsbGJhY2tBUEkuXG4gICAgICBzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkod2luZG93LCBicm93c2VyRGV0YWlscyk7XG4gICAgICBzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24od2luZG93KTtcbiAgICAgIHNoaW1SVENJY2VTZXJ2ZXJVcmxzKHdpbmRvdyk7XG4gICAgICBzaGltQ3JlYXRlT2ZmZXJMZWdhY3kod2luZG93KTtcbiAgICAgIHNoaW1DYWxsYmFja3NBUEkod2luZG93KTtcbiAgICAgIHNoaW1Mb2NhbFN0cmVhbXNBUEkod2luZG93KTtcbiAgICAgIHNoaW1SZW1vdGVTdHJlYW1zQVBJKHdpbmRvdyk7XG4gICAgICBzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyKHdpbmRvdyk7XG4gICAgICBzaGltR2V0VXNlck1lZGlhKHdpbmRvdyk7XG4gICAgICBzaGltQXVkaW9Db250ZXh0KHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlKHdpbmRvdyk7XG4gICAgICBzaGltUlRDSWNlQ2FuZGlkYXRlUmVsYXlQcm90b2NvbCh3aW5kb3cpO1xuICAgICAgc2hpbU1heE1lc3NhZ2VTaXplKHdpbmRvdywgYnJvd3NlckRldGFpbHMpO1xuICAgICAgc2hpbVNlbmRUaHJvd1R5cGVFcnJvcih3aW5kb3cpO1xuICAgICAgcmVtb3ZlRXh0bWFwQWxsb3dNaXhlZCh3aW5kb3csIGJyb3dzZXJEZXRhaWxzKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBsb2dnaW5nKCdVbnN1cHBvcnRlZCBicm93c2VyIScpO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIGFkYXB0ZXI7XG59XG5cbi8qXG4gKiAgQ29weXJpZ2h0IChjKSAyMDE2IFRoZSBXZWJSVEMgcHJvamVjdCBhdXRob3JzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqICBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhIEJTRC1zdHlsZSBsaWNlbnNlXG4gKiAgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBvZiB0aGUgc291cmNlXG4gKiAgdHJlZS5cbiAqL1xuLyogZXNsaW50LWVudiBub2RlICovXG5cbmFkYXB0ZXJGYWN0b3J5KHtcbiAgd2luZG93OiB0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IHdpbmRvd1xufSk7XG5cbmNvbnN0IEVOQ1JZUFRJT05fQUxHT1JJVEhNID0gJ0FFUy1HQ00nO1xuLy8gSG93IG1hbnkgY29uc2VjdXRpdmUgZnJhbWVzIGNhbiBmYWlsIGRlY3J5cHRpbmcgYmVmb3JlIGEgcGFydGljdWxhciBrZXkgZ2V0cyBtYXJrZWQgYXMgaW52YWxpZFxuY29uc3QgREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSA9IDEwO1xuLy8gZmxhZyBzZXQgdG8gaW5kaWNhdGUgdGhhdCBlMmVlIGhhcyBiZWVuIHNldHVwIGZvciBzZW5kZXIvcmVjZWl2ZXI7XG5jb25zdCBFMkVFX0ZMQUcgPSAnbGtfZTJlZSc7XG5jb25zdCBTQUxUID0gJ0xLRnJhbWVFbmNyeXB0aW9uS2V5JztcbmNvbnN0IEtFWV9QUk9WSURFUl9ERUZBVUxUUyA9IHtcbiAgc2hhcmVkS2V5OiBmYWxzZSxcbiAgcmF0Y2hldFNhbHQ6IFNBTFQsXG4gIHJhdGNoZXRXaW5kb3dTaXplOiA4LFxuICBmYWlsdXJlVG9sZXJhbmNlOiBERUNSWVBUSU9OX0ZBSUxVUkVfVE9MRVJBTkNFLFxuICBrZXlyaW5nU2l6ZTogMTYsXG4gIGFsbG93S2V5RXh0cmFjdGlvbjogZmFsc2Vcbn07XG5cbnZhciBLZXlQcm92aWRlckV2ZW50O1xuKGZ1bmN0aW9uIChLZXlQcm92aWRlckV2ZW50KSB7XG4gIEtleVByb3ZpZGVyRXZlbnRbXCJTZXRLZXlcIl0gPSBcInNldEtleVwiO1xuICBLZXlQcm92aWRlckV2ZW50W1wiUmF0Y2hldFJlcXVlc3RcIl0gPSBcInJhdGNoZXRSZXF1ZXN0XCI7XG4gIEtleVByb3ZpZGVyRXZlbnRbXCJLZXlSYXRjaGV0ZWRcIl0gPSBcImtleVJhdGNoZXRlZFwiO1xufSkoS2V5UHJvdmlkZXJFdmVudCB8fCAoS2V5UHJvdmlkZXJFdmVudCA9IHt9KSk7XG52YXIgS2V5SGFuZGxlckV2ZW50O1xuKGZ1bmN0aW9uIChLZXlIYW5kbGVyRXZlbnQpIHtcbiAgS2V5SGFuZGxlckV2ZW50W1wiS2V5UmF0Y2hldGVkXCJdID0gXCJrZXlSYXRjaGV0ZWRcIjtcbn0pKEtleUhhbmRsZXJFdmVudCB8fCAoS2V5SGFuZGxlckV2ZW50ID0ge30pKTtcbnZhciBFbmNyeXB0aW9uRXZlbnQ7XG4oZnVuY3Rpb24gKEVuY3J5cHRpb25FdmVudCkge1xuICBFbmNyeXB0aW9uRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIEVuY3J5cHRpb25FdmVudFtcIkVuY3J5cHRpb25FcnJvclwiXSA9IFwiZW5jcnlwdGlvbkVycm9yXCI7XG59KShFbmNyeXB0aW9uRXZlbnQgfHwgKEVuY3J5cHRpb25FdmVudCA9IHt9KSk7XG52YXIgQ3J5cHRvckV2ZW50O1xuKGZ1bmN0aW9uIChDcnlwdG9yRXZlbnQpIHtcbiAgQ3J5cHRvckV2ZW50W1wiRXJyb3JcIl0gPSBcImNyeXB0b3JFcnJvclwiO1xufSkoQ3J5cHRvckV2ZW50IHx8IChDcnlwdG9yRXZlbnQgPSB7fSkpO1xuXG5mdW5jdGlvbiBpc0UyRUVTdXBwb3J0ZWQoKSB7XG4gIHJldHVybiBpc0luc2VydGFibGVTdHJlYW1TdXBwb3J0ZWQoKSB8fCBpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpO1xufVxuZnVuY3Rpb24gaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQoKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2NyaXB0VHJhbnNmb3JtICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCgpIHtcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAvLyBAdHMtaWdub3JlXG4gIHR5cGVvZiB3aW5kb3cuUlRDUnRwU2VuZGVyLnByb3RvdHlwZS5jcmVhdGVFbmNvZGVkU3RyZWFtcyAhPT0gJ3VuZGVmaW5lZCc7XG59XG5mdW5jdGlvbiBpc1ZpZGVvRnJhbWUoZnJhbWUpIHtcbiAgcmV0dXJuICd0eXBlJyBpbiBmcmFtZTtcbn1cbmZ1bmN0aW9uIGltcG9ydEtleShrZXlCeXRlc18xKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChrZXlCeXRlcykge1xuICAgIGxldCBhbGdvcml0aG0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNXG4gICAgfTtcbiAgICBsZXQgdXNhZ2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6ICdlbmNyeXB0JztcbiAgICBsZXQgZXh0cmFjdGFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1N1YnRsZUNyeXB0by9pbXBvcnRLZXlcbiAgICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3Jywga2V5Qnl0ZXMsIGFsZ29yaXRobSwgZXh0cmFjdGFibGUsIHVzYWdlID09PSAnZGVyaXZlJyA/IFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSA6IFsnZW5jcnlwdCcsICdkZWNyeXB0J10pO1xuICAgIH0oKTtcbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcocGFzc3dvcmQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBsZXQgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgY29uc3Qga2V5TWF0ZXJpYWwgPSB5aWVsZCBjcnlwdG8uc3VidGxlLmltcG9ydEtleSgncmF3JywgZW5jLmVuY29kZShwYXNzd29yZCksIHtcbiAgICAgIG5hbWU6ICdQQktERjInXG4gICAgfSwgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlcihjcnlwdG9CdWZmZXIpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBrZXlNYXRlcmlhbCA9IHlpZWxkIGNyeXB0by5zdWJ0bGUuaW1wb3J0S2V5KCdyYXcnLCBjcnlwdG9CdWZmZXIsICdIS0RGJywgZmFsc2UsIFsnZGVyaXZlQml0cycsICdkZXJpdmVLZXknXSk7XG4gICAgcmV0dXJuIGtleU1hdGVyaWFsO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGdldEFsZ29PcHRpb25zKGFsZ29yaXRobU5hbWUsIHNhbHQpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgY29uc3QgZW5jb2RlZFNhbHQgPSB0ZXh0RW5jb2Rlci5lbmNvZGUoc2FsdCk7XG4gIHN3aXRjaCAoYWxnb3JpdGhtTmFtZSkge1xuICAgIGNhc2UgJ0hLREYnOlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogJ0hLREYnLFxuICAgICAgICBzYWx0OiBlbmNvZGVkU2FsdCxcbiAgICAgICAgaGFzaDogJ1NIQS0yNTYnLFxuICAgICAgICBpbmZvOiBuZXcgQXJyYXlCdWZmZXIoMTI4KVxuICAgICAgfTtcbiAgICBjYXNlICdQQktERjInOlxuICAgICAge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG5hbWU6ICdQQktERjInLFxuICAgICAgICAgIHNhbHQ6IGVuY29kZWRTYWx0LFxuICAgICAgICAgIGhhc2g6ICdTSEEtMjU2JyxcbiAgICAgICAgICBpdGVyYXRpb25zOiAxMDAwMDBcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWxnb3JpdGhtIFwiLmNvbmNhdChhbGdvcml0aG1OYW1lLCBcIiBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWRcIikpO1xuICB9XG59XG4vKipcbiAqIERlcml2ZXMgYSBzZXQgb2Yga2V5cyBmcm9tIHRoZSBtYXN0ZXIga2V5LlxuICogU2VlIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuMVxuICovXG5mdW5jdGlvbiBkZXJpdmVLZXlzKG1hdGVyaWFsLCBzYWx0KSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgY29uc3QgYWxnb3JpdGhtT3B0aW9ucyA9IGdldEFsZ29PcHRpb25zKG1hdGVyaWFsLmFsZ29yaXRobS5uYW1lLCBzYWx0KTtcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvU3VidGxlQ3J5cHRvL2Rlcml2ZUtleSNIS0RGXG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hrZGZQYXJhbXNcbiAgICBjb25zdCBlbmNyeXB0aW9uS2V5ID0geWllbGQgY3J5cHRvLnN1YnRsZS5kZXJpdmVLZXkoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIHtcbiAgICAgIG5hbWU6IEVOQ1JZUFRJT05fQUxHT1JJVEhNLFxuICAgICAgbGVuZ3RoOiAxMjhcbiAgICB9LCBmYWxzZSwgWydlbmNyeXB0JywgJ2RlY3J5cHQnXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hdGVyaWFsLFxuICAgICAgZW5jcnlwdGlvbktleVxuICAgIH07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlRTJFRUtleSgpIHtcbiAgcmV0dXJuIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50OEFycmF5KDMyKSk7XG59XG4vKipcbiAqIFJhdGNoZXRzIGEga2V5LiBTZWVcbiAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1vbWFyYS1zZnJhbWUtMDAjc2VjdGlvbi00LjMuNS4xXG4gKi9cbmZ1bmN0aW9uIHJhdGNoZXQobWF0ZXJpYWwsIHNhbHQpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCBhbGdvcml0aG1PcHRpb25zID0gZ2V0QWxnb09wdGlvbnMobWF0ZXJpYWwuYWxnb3JpdGhtLm5hbWUsIHNhbHQpO1xuICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9TdWJ0bGVDcnlwdG8vZGVyaXZlQml0c1xuICAgIHJldHVybiBjcnlwdG8uc3VidGxlLmRlcml2ZUJpdHMoYWxnb3JpdGhtT3B0aW9ucywgbWF0ZXJpYWwsIDI1Nik7XG4gIH0pO1xufVxuZnVuY3Rpb24gbmVlZHNSYnNwVW5lc2NhcGluZyhmcmFtZURhdGEpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmFtZURhdGEubGVuZ3RoIC0gMzsgaSsrKSB7XG4gICAgaWYgKGZyYW1lRGF0YVtpXSA9PSAwICYmIGZyYW1lRGF0YVtpICsgMV0gPT0gMCAmJiBmcmFtZURhdGFbaSArIDJdID09IDMpIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIHBhcnNlUmJzcChzdHJlYW0pIHtcbiAgY29uc3QgZGF0YU91dCA9IFtdO1xuICB2YXIgbGVuZ3RoID0gc3RyZWFtLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHJlYW0ubGVuZ3RoOykge1xuICAgIC8vIEJlIGNhcmVmdWwgYWJvdXQgb3Zlci91bmRlcmZsb3cgaGVyZS4gYnl0ZV9sZW5ndGhfIC0gMyBjYW4gdW5kZXJmbG93LCBhbmRcbiAgICAvLyBpICsgMyBjYW4gb3ZlcmZsb3csIGJ1dCBieXRlX2xlbmd0aF8gLSBpIGNhbid0LCBiZWNhdXNlIGkgPCBieXRlX2xlbmd0aF9cbiAgICAvLyBhYm92ZSwgYW5kIHRoYXQgZXhwcmVzc2lvbiB3aWxsIHByb2R1Y2UgdGhlIG51bWJlciBvZiBieXRlcyBsZWZ0IGluXG4gICAgLy8gdGhlIHN0cmVhbSBpbmNsdWRpbmcgdGhlIGJ5dGUgYXQgaS5cbiAgICBpZiAobGVuZ3RoIC0gaSA+PSAzICYmICFzdHJlYW1baV0gJiYgIXN0cmVhbVtpICsgMV0gJiYgc3RyZWFtW2kgKyAyXSA9PSAzKSB7XG4gICAgICAvLyBUd28gcmJzcCBieXRlcy5cbiAgICAgIGRhdGFPdXQucHVzaChzdHJlYW1baSsrXSk7XG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgICAgLy8gU2tpcCB0aGUgZW11bGF0aW9uIGJ5dGUuXG4gICAgICBpKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFNpbmdsZSByYnNwIGJ5dGUuXG4gICAgICBkYXRhT3V0LnB1c2goc3RyZWFtW2krK10pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YU91dCk7XG59XG5jb25zdCBrWmVyb3NJblN0YXJ0U2VxdWVuY2UgPSAyO1xuY29uc3Qga0VtdWxhdGlvbkJ5dGUgPSAzO1xuZnVuY3Rpb24gd3JpdGVSYnNwKGRhdGFfaW4pIHtcbiAgY29uc3QgZGF0YU91dCA9IFtdO1xuICB2YXIgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YV9pbi5sZW5ndGg7ICsraSkge1xuICAgIHZhciBieXRlID0gZGF0YV9pbltpXTtcbiAgICBpZiAoYnl0ZSA8PSBrRW11bGF0aW9uQnl0ZSAmJiBudW1Db25zZWN1dGl2ZVplcm9zID49IGtaZXJvc0luU3RhcnRTZXF1ZW5jZSkge1xuICAgICAgLy8gTmVlZCB0byBlc2NhcGUuXG4gICAgICBkYXRhT3V0LnB1c2goa0VtdWxhdGlvbkJ5dGUpO1xuICAgICAgbnVtQ29uc2VjdXRpdmVaZXJvcyA9IDA7XG4gICAgfVxuICAgIGRhdGFPdXQucHVzaChieXRlKTtcbiAgICBpZiAoYnl0ZSA9PSAwKSB7XG4gICAgICArK251bUNvbnNlY3V0aXZlWmVyb3M7XG4gICAgfSBlbHNlIHtcbiAgICAgIG51bUNvbnNlY3V0aXZlWmVyb3MgPSAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoZGF0YU91dCk7XG59XG5cbi8qKlxuICogQGV4cGVyaW1lbnRhbFxuICovXG5jbGFzcyBCYXNlS2V5UHJvdmlkZXIgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBzdXBlcigpO1xuICAgIC8qKlxuICAgICAqIGNhbGxiYWNrIGJlaW5nIGludm9rZWQgYWZ0ZXIgYSByYXRjaGV0IHJlcXVlc3QgaGFzIGJlZW4gcGVyZm9ybWVkIG9uIGEgcGFydGljaXBhbnRcbiAgICAgKiB0aGF0IHN1cmZhY2VzIHRoZSBuZXcga2V5IG1hdGVyaWFsLlxuICAgICAqIEBwYXJhbSBtYXRlcmlhbFxuICAgICAqIEBwYXJhbSBrZXlJbmRleFxuICAgICAqL1xuICAgIHRoaXMub25LZXlSYXRjaGV0ZWQgPSAobWF0ZXJpYWwsIGtleUluZGV4KSA9PiB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCdrZXkgcmF0Y2hldGVkIGV2ZW50IHJlY2VpdmVkJywge1xuICAgICAgICBtYXRlcmlhbCxcbiAgICAgICAga2V5SW5kZXhcbiAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5rZXlJbmZvTWFwID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgS0VZX1BST1ZJREVSX0RFRkFVTFRTKSwgb3B0aW9ucyk7XG4gICAgdGhpcy5vbihLZXlQcm92aWRlckV2ZW50LktleVJhdGNoZXRlZCwgdGhpcy5vbktleVJhdGNoZXRlZCk7XG4gIH1cbiAgLyoqXG4gICAqIGNhbGxiYWNrIHRvIGludm9rZSBvbmNlIGEga2V5IGhhcyBiZWVuIHNldCBmb3IgYSBwYXJ0aWNpcGFudFxuICAgKiBAcGFyYW0ga2V5XG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAqIEBwYXJhbSBrZXlJbmRleFxuICAgKi9cbiAgb25TZXRFbmNyeXB0aW9uS2V5KGtleSwgcGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgpIHtcbiAgICBjb25zdCBrZXlJbmZvID0ge1xuICAgICAga2V5LFxuICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgIGtleUluZGV4XG4gICAgfTtcbiAgICBpZiAoIXRoaXMub3B0aW9ucy5zaGFyZWRLZXkgJiYgIXBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcigncGFydGljaXBhbnQgaWRlbnRpdHkgbmVlZHMgdG8gYmUgcGFzc2VkIGZvciBlbmNyeXB0aW9uIGtleSBpZiBzaGFyZWRLZXkgb3B0aW9uIGlzIGZhbHNlJyk7XG4gICAgfVxuICAgIHRoaXMua2V5SW5mb01hcC5zZXQoXCJcIi5jb25jYXQocGFydGljaXBhbnRJZGVudGl0eSAhPT0gbnVsbCAmJiBwYXJ0aWNpcGFudElkZW50aXR5ICE9PSB2b2lkIDAgPyBwYXJ0aWNpcGFudElkZW50aXR5IDogJ3NoYXJlZCcsIFwiLVwiKS5jb25jYXQoa2V5SW5kZXggIT09IG51bGwgJiYga2V5SW5kZXggIT09IHZvaWQgMCA/IGtleUluZGV4IDogMCksIGtleUluZm8pO1xuICAgIHRoaXMuZW1pdChLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyk7XG4gIH1cbiAgZ2V0S2V5cygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmtleUluZm9NYXAudmFsdWVzKCkpO1xuICB9XG4gIGdldE9wdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9ucztcbiAgfVxuICByYXRjaGV0S2V5KHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KSB7XG4gICAgdGhpcy5lbWl0KEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIHBhcnRpY2lwYW50SWRlbnRpdHksIGtleUluZGV4KTtcbiAgfVxufVxuLyoqXG4gKiBBIGJhc2ljIEtleVByb3ZpZGVyIGltcGxlbWVudGF0aW9uIGludGVuZGVkIGZvciBhIHNpbmdsZSBzaGFyZWRcbiAqIHBhc3NwaHJhc2UgYmV0d2VlbiBhbGwgcGFydGljaXBhbnRzXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyIGV4dGVuZHMgQmFzZUtleVByb3ZpZGVyIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICBzaGFyZWRLZXk6IHRydWUsXG4gICAgICAvLyBmb3IgYSBzaGFyZWQga2V5IHByb3ZpZGVyIGZhaWxpbmcgdG8gZGVjcnlwdCBmb3IgYSBzcGVjaWZpYyBwYXJ0aWNpcGFudFxuICAgICAgLy8gc2hvdWxkIG5vdCBtYXJrIHRoZSBrZXkgYXMgaW52YWxpZCwgc28gd2UgYWNjZXB0IHdyb25nIGtleXMgZm9yZXZlclxuICAgICAgLy8gYW5kIHdvbid0IHRyeSB0byBhdXRvLXJhdGNoZXRcbiAgICAgIHJhdGNoZXRXaW5kb3dTaXplOiAwLFxuICAgICAgZmFpbHVyZVRvbGVyYW5jZTogLTFcbiAgICB9KTtcbiAgICBzdXBlcihvcHRzKTtcbiAgfVxuICAvKipcbiAgICogQWNjZXB0cyBhIHBhc3NwaHJhc2UgdGhhdCdzIHVzZWQgdG8gY3JlYXRlIHRoZSBjcnlwdG8ga2V5cy5cbiAgICogV2hlbiBwYXNzaW5nIGluIGEgc3RyaW5nLCBQQktERjIgaXMgdXNlZC5cbiAgICogV2hlbiBwYXNzaW5nIGluIGFuIEFycmF5IGJ1ZmZlciBvZiBjcnlwdG9ncmFwaGljYWxseSByYW5kb20gbnVtYmVycywgSEtERiBpcyBiZWluZyB1c2VkLiAocmVjb21tZW5kZWQpXG4gICAqIEBwYXJhbSBrZXlcbiAgICovXG4gIHNldEtleShrZXkpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZGVyaXZlZEtleSA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8geWllbGQgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tU3RyaW5nKGtleSkgOiB5aWVsZCBjcmVhdGVLZXlNYXRlcmlhbEZyb21CdWZmZXIoa2V5KTtcbiAgICAgIHRoaXMub25TZXRFbmNyeXB0aW9uS2V5KGRlcml2ZWRLZXkpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIExpdmVraXRFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UgfHwgJ2FuIGVycm9yIGhhcyBvY2N1cmVkJyk7XG4gICAgdGhpcy5uYW1lID0gJ0xpdmVLaXRFcnJvcic7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgfVxufVxudmFyIENvbm5lY3Rpb25FcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoQ29ubmVjdGlvbkVycm9yUmVhc29uKSB7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJOb3RBbGxvd2VkXCJdID0gMF0gPSBcIk5vdEFsbG93ZWRcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIlNlcnZlclVucmVhY2hhYmxlXCJdID0gMV0gPSBcIlNlcnZlclVucmVhY2hhYmxlXCI7XG4gIENvbm5lY3Rpb25FcnJvclJlYXNvbltDb25uZWN0aW9uRXJyb3JSZWFzb25bXCJJbnRlcm5hbEVycm9yXCJdID0gMl0gPSBcIkludGVybmFsRXJyb3JcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIkNhbmNlbGxlZFwiXSA9IDNdID0gXCJDYW5jZWxsZWRcIjtcbiAgQ29ubmVjdGlvbkVycm9yUmVhc29uW0Nvbm5lY3Rpb25FcnJvclJlYXNvbltcIkxlYXZlUmVxdWVzdFwiXSA9IDRdID0gXCJMZWF2ZVJlcXVlc3RcIjtcbn0pKENvbm5lY3Rpb25FcnJvclJlYXNvbiB8fCAoQ29ubmVjdGlvbkVycm9yUmVhc29uID0ge30pKTtcbmNsYXNzIENvbm5lY3Rpb25FcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlYXNvbiwgc3RhdHVzLCBjb250ZXh0KSB7XG4gICAgc3VwZXIoMSwgbWVzc2FnZSk7XG4gICAgdGhpcy5uYW1lID0gJ0Nvbm5lY3Rpb25FcnJvcic7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB0aGlzLnJlYXNvbk5hbWUgPSBDb25uZWN0aW9uRXJyb3JSZWFzb25bcmVhc29uXTtcbiAgfVxufVxuY2xhc3MgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigyMSwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ2RldmljZSBpcyB1bnN1cHBvcnRlZCcpO1xuICAgIHRoaXMubmFtZSA9ICdEZXZpY2VVbnN1cHBvcnRlZEVycm9yJztcbiAgfVxufVxuY2xhc3MgVHJhY2tJbnZhbGlkRXJyb3IgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMjAsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd0cmFjayBpcyBpbnZhbGlkJyk7XG4gICAgdGhpcy5uYW1lID0gJ1RyYWNrSW52YWxpZEVycm9yJztcbiAgfVxufVxuY2xhc3MgVW5zdXBwb3J0ZWRTZXJ2ZXIgZXh0ZW5kcyBMaXZla2l0RXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIoMTAsIG1lc3NhZ2UgIT09IG51bGwgJiYgbWVzc2FnZSAhPT0gdm9pZCAwID8gbWVzc2FnZSA6ICd1bnN1cHBvcnRlZCBzZXJ2ZXInKTtcbiAgICB0aGlzLm5hbWUgPSAnVW5zdXBwb3J0ZWRTZXJ2ZXInO1xuICB9XG59XG5jbGFzcyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEyLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5leHBlY3RlZCBjb25uZWN0aW9uIHN0YXRlJyk7XG4gICAgdGhpcy5uYW1lID0gJ1VuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUnO1xuICB9XG59XG5jbGFzcyBOZWdvdGlhdGlvbkVycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKDEzLCBtZXNzYWdlICE9PSBudWxsICYmIG1lc3NhZ2UgIT09IHZvaWQgMCA/IG1lc3NhZ2UgOiAndW5hYmxlIHRvIG5lZ290aWF0ZScpO1xuICAgIHRoaXMubmFtZSA9ICdOZWdvdGlhdGlvbkVycm9yJztcbiAgfVxufVxuY2xhc3MgUHVibGlzaERhdGFFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcigxNCwgbWVzc2FnZSAhPT0gbnVsbCAmJiBtZXNzYWdlICE9PSB2b2lkIDAgPyBtZXNzYWdlIDogJ3VuYWJsZSB0byBwdWJsaXNoIGRhdGEnKTtcbiAgICB0aGlzLm5hbWUgPSAnUHVibGlzaERhdGFFcnJvcic7XG4gIH1cbn1cbmNsYXNzIFB1Ymxpc2hUcmFja0Vycm9yIGV4dGVuZHMgTGl2ZWtpdEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSwgc3RhdHVzKSB7XG4gICAgc3VwZXIoMTUsIG1lc3NhZ2UpO1xuICAgIHRoaXMubmFtZSA9ICdQdWJsaXNoVHJhY2tFcnJvcic7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gIH1cbn1cbmNsYXNzIFNpZ25hbFJlcXVlc3RFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHJlYXNvbikge1xuICAgIHN1cGVyKDE1LCBtZXNzYWdlKTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLnJlYXNvbk5hbWUgPSB0eXBlb2YgcmVhc29uID09PSAnc3RyaW5nJyA/IHJlYXNvbiA6IFJlcXVlc3RSZXNwb25zZV9SZWFzb25bcmVhc29uXTtcbiAgfVxufVxudmFyIE1lZGlhRGV2aWNlRmFpbHVyZTtcbihmdW5jdGlvbiAoTWVkaWFEZXZpY2VGYWlsdXJlKSB7XG4gIC8vIHVzZXIgcmVqZWN0ZWQgcGVybWlzc2lvbnNcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiUGVybWlzc2lvbkRlbmllZFwiXSA9IFwiUGVybWlzc2lvbkRlbmllZFwiO1xuICAvLyBkZXZpY2UgaXMgbm90IGF2YWlsYWJsZVxuICBNZWRpYURldmljZUZhaWx1cmVbXCJOb3RGb3VuZFwiXSA9IFwiTm90Rm91bmRcIjtcbiAgLy8gZGV2aWNlIGlzIGluIHVzZS4gT24gV2luZG93cywgb25seSBhIHNpbmdsZSB0YWIgbWF5IGdldCBhY2Nlc3MgdG8gYSBkZXZpY2UgYXQgYSB0aW1lLlxuICBNZWRpYURldmljZUZhaWx1cmVbXCJEZXZpY2VJblVzZVwiXSA9IFwiRGV2aWNlSW5Vc2VcIjtcbiAgTWVkaWFEZXZpY2VGYWlsdXJlW1wiT3RoZXJcIl0gPSBcIk90aGVyXCI7XG59KShNZWRpYURldmljZUZhaWx1cmUgfHwgKE1lZGlhRGV2aWNlRmFpbHVyZSA9IHt9KSk7XG4oZnVuY3Rpb24gKE1lZGlhRGV2aWNlRmFpbHVyZSkge1xuICBmdW5jdGlvbiBnZXRGYWlsdXJlKGVycm9yKSB7XG4gICAgaWYgKGVycm9yICYmICduYW1lJyBpbiBlcnJvcikge1xuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RGb3VuZEVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnRGV2aWNlc05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgIHJldHVybiBNZWRpYURldmljZUZhaWx1cmUuTm90Rm91bmQ7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IubmFtZSA9PT0gJ05vdEFsbG93ZWRFcnJvcicgfHwgZXJyb3IubmFtZSA9PT0gJ1Blcm1pc3Npb25EZW5pZWRFcnJvcicpIHtcbiAgICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5QZXJtaXNzaW9uRGVuaWVkO1xuICAgICAgfVxuICAgICAgaWYgKGVycm9yLm5hbWUgPT09ICdOb3RSZWFkYWJsZUVycm9yJyB8fCBlcnJvci5uYW1lID09PSAnVHJhY2tTdGFydEVycm9yJykge1xuICAgICAgICByZXR1cm4gTWVkaWFEZXZpY2VGYWlsdXJlLkRldmljZUluVXNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1lZGlhRGV2aWNlRmFpbHVyZS5PdGhlcjtcbiAgICB9XG4gIH1cbiAgTWVkaWFEZXZpY2VGYWlsdXJlLmdldEZhaWx1cmUgPSBnZXRGYWlsdXJlO1xufSkoTWVkaWFEZXZpY2VGYWlsdXJlIHx8IChNZWRpYURldmljZUZhaWx1cmUgPSB7fSkpO1xuXG52YXIgQ3J5cHRvckVycm9yUmVhc29uO1xuKGZ1bmN0aW9uIChDcnlwdG9yRXJyb3JSZWFzb24pIHtcbiAgQ3J5cHRvckVycm9yUmVhc29uW0NyeXB0b3JFcnJvclJlYXNvbltcIkludmFsaWRLZXlcIl0gPSAwXSA9IFwiSW52YWxpZEtleVwiO1xuICBDcnlwdG9yRXJyb3JSZWFzb25bQ3J5cHRvckVycm9yUmVhc29uW1wiTWlzc2luZ0tleVwiXSA9IDFdID0gXCJNaXNzaW5nS2V5XCI7XG4gIENyeXB0b3JFcnJvclJlYXNvbltDcnlwdG9yRXJyb3JSZWFzb25bXCJJbnRlcm5hbEVycm9yXCJdID0gMl0gPSBcIkludGVybmFsRXJyb3JcIjtcbn0pKENyeXB0b3JFcnJvclJlYXNvbiB8fCAoQ3J5cHRvckVycm9yUmVhc29uID0ge30pKTtcbmNsYXNzIENyeXB0b3JFcnJvciBleHRlbmRzIExpdmVraXRFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgcmVhc29uID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBDcnlwdG9yRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcjtcbiAgICBsZXQgcGFydGljaXBhbnRJZGVudGl0eSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gYXJndW1lbnRzWzJdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKDQwLCBtZXNzYWdlKTtcbiAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICB0aGlzLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBwYXJ0aWNpcGFudElkZW50aXR5O1xuICB9XG59XG5cbi8qKlxuICogRXZlbnRzIGFyZSB0aGUgcHJpbWFyeSB3YXkgTGl2ZUtpdCBub3RpZmllcyB5b3VyIGFwcGxpY2F0aW9uIG9mIGNoYW5nZXMuXG4gKlxuICogVGhlIGZvbGxvd2luZyBhcmUgZXZlbnRzIGVtaXR0ZWQgYnkgW1tSb29tXV0sIGxpc3RlbiB0byByb29tIGV2ZW50cyBsaWtlXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogcm9vbS5vbihSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsICh0cmFjaywgcHVibGljYXRpb24sIHBhcnRpY2lwYW50KSA9PiB7fSlcbiAqIGBgYFxuICovXG52YXIgUm9vbUV2ZW50O1xuKGZ1bmN0aW9uIChSb29tRXZlbnQpIHtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBlc3RhYmxpc2hlZFxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQ29ubmVjdGVkXCJdID0gXCJjb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gdGhlIGNvbm5lY3Rpb24gdG8gdGhlIHNlcnZlciBoYXMgYmVlbiBpbnRlcnJ1cHRlZCBhbmQgaXQncyBhdHRlbXB0aW5nXG4gICAqIHRvIHJlY29ubmVjdC5cbiAgICovXG4gIFJvb21FdmVudFtcIlJlY29ubmVjdGluZ1wiXSA9IFwicmVjb25uZWN0aW5nXCI7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBzaWduYWwgY29ubmVjdGlvbiB0byB0aGUgc2VydmVyIGhhcyBiZWVuIGludGVycnVwdGVkLiBUaGlzIGlzbid0IG5vdGljZWFibGUgdG8gdXNlcnMgbW9zdCBvZiB0aGUgdGltZS5cbiAgICogSXQgd2lsbCByZXNvbHZlIHdpdGggYSBgUm9vbUV2ZW50LlJlY29ubmVjdGVkYCBvbmNlIHRoZSBzaWduYWwgY29ubmVjdGlvbiBoYXMgYmVlbiByZS1lc3RhYmxpc2hlZC5cbiAgICogSWYgbWVkaWEgZmFpbHMgYWRkaXRpb25hbGx5IGl0IGFuIGFkZGl0aW9uYWwgYFJvb21FdmVudC5SZWNvbm5lY3RpbmdgIHdpbGwgYmUgZW1pdHRlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIlNpZ25hbFJlY29ubmVjdGluZ1wiXSA9IFwic2lnbmFsUmVjb25uZWN0aW5nXCI7XG4gIC8qKlxuICAgKiBGaXJlcyB3aGVuIGEgcmVjb25uZWN0aW9uIGhhcyBiZWVuIHN1Y2Nlc3NmdWwuXG4gICAqL1xuICBSb29tRXZlbnRbXCJSZWNvbm5lY3RlZFwiXSA9IFwicmVjb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gZGlzY29ubmVjdGVkIGZyb20gcm9vbS4gVGhpcyBmaXJlcyB3aGVuIHJvb20uZGlzY29ubmVjdCgpIGlzIGNhbGxlZCBvclxuICAgKiB3aGVuIGFuIHVucmVjb3ZlcmFibGUgY29ubmVjdGlvbiBpc3N1ZSBoYWQgb2NjdXJlZC5cbiAgICpcbiAgICogRGlzY29ubmVjdFJlYXNvbiBjYW4gYmUgdXNlZCB0byBkZXRlcm1pbmUgd2h5IHRoZSBwYXJ0aWNpcGFudCB3YXMgZGlzY29ubmVjdGVkLiBOb3RhYmxlIHJlYXNvbnMgYXJlXG4gICAqIC0gRFVQTElDQVRFX0lERU5USVRZOiBhbm90aGVyIGNsaWVudCB3aXRoIHRoZSBzYW1lIGlkZW50aXR5IGhhcyBqb2luZWQgdGhlIHJvb21cbiAgICogLSBQQVJUSUNJUEFOVF9SRU1PVkVEOiBwYXJ0aWNpcGFudCB3YXMgcmVtb3ZlZCBieSBSZW1vdmVQYXJ0aWNpcGFudCBBUElcbiAgICogLSBST09NX0RFTEVURUQ6IHRoZSByb29tIGhhcyBlbmRlZCB2aWEgRGVsZXRlUm9vbSBBUElcbiAgICpcbiAgICogYXJnczogKFtbRGlzY29ubmVjdFJlYXNvbl1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgLyoqXG4gICAqIFdoZW5ldmVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIG9mIHRoZSByb29tIGNoYW5nZXNcbiAgICpcbiAgICogYXJnczogKFtbQ29ubmVjdGlvblN0YXRlXV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJDb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGlucHV0IG9yIG91dHB1dCBkZXZpY2VzIG9uIHRoZSBtYWNoaW5lIGhhdmUgY2hhbmdlZC5cbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0NoYW5nZWRcIl0gPSBcIm1lZGlhRGV2aWNlc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gam9pbnMgKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQuIEl0IHdpbGwgbm90IGVtaXQgZXZlbnRzIGZvciBwYXJ0aWNpcGFudHMgdGhhdCBhcmUgYWxyZWFkeVxuICAgKiBpbiB0aGUgcm9vbVxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRDb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50Q29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGxlYXZlcyAqYWZ0ZXIqIHRoZSBsb2NhbFxuICAgKiBwYXJ0aWNpcGFudCBoYXMgam9pbmVkLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnREaXNjb25uZWN0ZWRcIl0gPSBcInBhcnRpY2lwYW50RGlzY29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBXaGVuIGEgbmV3IHRyYWNrIGlzIHB1Ymxpc2hlZCB0byByb29tICphZnRlciogdGhlIGxvY2FsXG4gICAqIHBhcnRpY2lwYW50IGhhcyBqb2luZWQuIEl0IHdpbGwgbm90IGZpcmUgZm9yIHRyYWNrcyB0aGF0IGFyZSBhbHJlYWR5IHB1Ymxpc2hlZC5cbiAgICpcbiAgICogQSB0cmFjayBwdWJsaXNoZWQgZG9lc24ndCBtZWFuIHRoZSBwYXJ0aWNpcGFudCBoYXMgc3Vic2NyaWJlZCB0byBpdC4gSXQnc1xuICAgKiBzaW1wbHkgcmVmbGVjdGluZyB0aGUgc3RhdGUgb2YgdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tQdWJsaXNoZWRcIl0gPSBcInRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBUaGUgW1tMb2NhbFBhcnRpY2lwYW50XV0gaGFzIHN1YnNjcmliZWQgdG8gYSBuZXcgdHJhY2suIFRoaXMgZXZlbnQgd2lsbCAqKmFsd2F5cyoqXG4gICAqIGZpcmUgYXMgbG9uZyBhcyBuZXcgdHJhY2tzIGFyZSByZWFkeSBmb3IgdXNlLlxuICAgKlxuICAgKiBhcmdzOiAoW1tSZW1vdGVUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkLCBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25GYWlsZWRcIjtcbiAgLyoqXG4gICAqIEEgW1tSZW1vdGVQYXJ0aWNpcGFudF1dIGhhcyB1bnB1Ymxpc2hlZCBhIHRyYWNrXG4gICAqXG4gICAqIGFyZ3M6IChbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwidHJhY2tVbnB1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBzdWJzY3JpYmVkIHRyYWNrIGlzIG5vIGxvbmdlciBhdmFpbGFibGUuIENsaWVudHMgc2hvdWxkIGxpc3RlbiB0byB0aGlzXG4gICAqIGV2ZW50IGFuZCBlbnN1cmUgdGhleSBkZXRhY2ggdHJhY2tzLlxuICAgKlxuICAgKiBhcmdzOiAoW1tUcmFja11dLCBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tNdXRlZFwiXSA9IFwidHJhY2tNdXRlZFwiO1xuICAvKipcbiAgICogQSB0cmFjayB0aGF0IHdhcyB1bm11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSwgW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tVbm11dGVkXCJdID0gXCJ0cmFja1VubXV0ZWRcIjtcbiAgLyoqXG4gICAqIEEgbG9jYWwgdHJhY2sgd2FzIHB1Ymxpc2hlZCBzdWNjZXNzZnVsbHkuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93XG4gICAqIHdoZW4gdG8gdXBkYXRlIHlvdXIgbG9jYWwgVUkgd2l0aCB0aGUgbmV3bHkgcHVibGlzaGVkIHRyYWNrLlxuICAgKlxuICAgKiBhcmdzOiAoW1tMb2NhbFRyYWNrUHVibGljYXRpb25dXSwgW1tMb2NhbFBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbFRyYWNrUHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrUHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyB1bnB1Ymxpc2hlZC4gVGhpcyBldmVudCBpcyBoZWxwZnVsIHRvIGtub3cgd2hlbiB0byByZW1vdmVcbiAgICogdGhlIGxvY2FsIHRyYWNrIGZyb20geW91ciBVSS5cbiAgICpcbiAgICogV2hlbiBhIHVzZXIgc3RvcHMgc2hhcmluZyB0aGVpciBzY3JlZW4gYnkgcHJlc3NpbmcgXCJFbmRcIiBvbiB0aGUgYnJvd3NlciBVSSxcbiAgICogdGhpcyBldmVudCB3aWxsIGFsc28gZmlyZS5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0sIFtbTG9jYWxQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIFdoZW4gYSBsb2NhbCBhdWRpbyB0cmFjayBpcyBwdWJsaXNoZWQgdGhlIFNESyBjaGVja3Mgd2hldGhlciB0aGVyZSBpcyBjb21wbGV0ZSBzaWxlbmNlXG4gICAqIG9uIHRoYXQgdHJhY2sgYW5kIGVtaXRzIHRoZSBMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkIGV2ZW50IGluIHRoYXQgY2FzZS5cbiAgICogVGhpcyBhbGxvd3MgZm9yIGFwcGxpY2F0aW9ucyB0byBzaG93IFVJIGluZm9ybWluZyB1c2VycyB0aGF0IHRoZXkgbWlnaHQgaGF2ZSB0b1xuICAgKiByZXNldCB0aGVpciBhdWRpbyBoYXJkd2FyZSBvciBjaGVjayBmb3IgcHJvcGVyIGRldmljZSBjb25uZWN0aXZpdHkuXG4gICAqL1xuICBSb29tRXZlbnRbXCJMb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCJdID0gXCJsb2NhbEF1ZGlvU2lsZW5jZURldGVjdGVkXCI7XG4gIC8qKlxuICAgKiBBY3RpdmUgc3BlYWtlcnMgY2hhbmdlZC4gTGlzdCBvZiBzcGVha2VycyBhcmUgb3JkZXJlZCBieSB0aGVpciBhdWRpbyBsZXZlbC5cbiAgICogbG91ZGVzdCBzcGVha2VycyBmaXJzdC4gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIExvY2FsUGFydGljaXBhbnQgdG9vLlxuICAgKlxuICAgKiBTcGVha2VyIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB0byB0aGUgcHVibGlzaGluZyBwYXJ0aWNpcGFudCBhbmQgdGhlaXIgc3Vic2NyaWJlcnMuXG4gICAqXG4gICAqIGFyZ3M6IChBcnJheTxbW1BhcnRpY2lwYW50XV0+KVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQWN0aXZlU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJhY3RpdmVTcGVha2Vyc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50IG1ldGFkYXRhIGlzIGEgc2ltcGxlIHdheSBmb3IgYXBwLXNwZWNpZmljIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gUm9vbVNlcnZpY2UuVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcGFydGljaXBhbnQnc1xuICAgKiBzdGF0ZSwgKmFsbCogIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIGZpcmUgdGhpcyBldmVudC5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFBhcnRpY2lwYW50J3MgZGlzcGxheSBuYW1lIGNoYW5nZWRcbiAgICpcbiAgICogYXJnczogKG5hbWU6IHN0cmluZywgW1tQYXJ0aWNpcGFudF1dKVxuICAgKlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQgYXR0cmlidXRlcyBpcyBhbiBhcHAtc3BlY2lmaWMga2V5IHZhbHVlIHN0YXRlIHRvIGJlIHB1c2hlZCB0b1xuICAgKiBhbGwgdXNlcnMuXG4gICAqIFdoZW4gYSBwYXJ0aWNpcGFudCdzIGF0dHJpYnV0ZXMgY2hhbmdlZCwgdGhpcyBldmVudCB3aWxsIGJlIGVtaXR0ZWQgd2l0aCB0aGUgY2hhbmdlZCBhdHRyaWJ1dGVzIGFuZCB0aGUgcGFydGljaXBhbnRcbiAgICogYXJnczogKGNoYW5nZWRBdHRyaWJ1dGVzOiBbW1JlY29yZDxzdHJpbmcsIHN0cmluZ11dLCBwYXJ0aWNpcGFudDogW1tQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUm9vbSBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVJvb21NZXRhZGF0YSBpcyBjYWxsZWQgdG8gY2hhbmdlIGEgcm9vbSdzIHN0YXRlLFxuICAgKiAqYWxsKiAgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgZmlyZSB0aGlzIGV2ZW50LlxuICAgKlxuICAgKiBhcmdzOiAoc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUm9vbU1ldGFkYXRhQ2hhbmdlZFwiXSA9IFwicm9vbU1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIGFub3RoZXIgcGFydGljaXBhbnQuXG4gICAqIERhdGEgcGFja2V0cyBwcm92aWRlcyB0aGUgYWJpbGl0eSB0byB1c2UgTGl2ZUtpdCB0byBzZW5kL3JlY2VpdmUgYXJiaXRyYXJ5IHBheWxvYWRzLlxuICAgKiBBbGwgcGFydGljaXBhbnRzIGluIHRoZSByb29tIHdpbGwgcmVjZWl2ZSB0aGUgbWVzc2FnZXMgc2VudCB0byB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKHBheWxvYWQ6IFVpbnQ4QXJyYXksIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGtpbmQ6IFtbRGF0YVBhY2tldF9LaW5kXV0sIHRvcGljPzogc3RyaW5nKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRGF0YVJlY2VpdmVkXCJdID0gXCJkYXRhUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIFNJUCBEVE1GIHRvbmVzIHJlY2VpdmVkIGZyb20gYW5vdGhlciBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0sIGR0bWY6IFtbRGF0YVBhY2tldF9LaW5kXV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xuICAvKipcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIGEgcGFydGljaXBhbnQncyB0cmFjay5cbiAgICogQGJldGFcbiAgICovXG4gIFJvb21FdmVudFtcIlRyYW5zY3JpcHRpb25SZWNlaXZlZFwiXSA9IFwidHJhbnNjcmlwdGlvblJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBDb25uZWN0aW9uIHF1YWxpdHkgd2FzIGNoYW5nZWQgZm9yIGEgUGFydGljaXBhbnQuIEl0J2xsIHJlY2VpdmUgdXBkYXRlc1xuICAgKiBmcm9tIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCwgYXMgd2VsbCBhcyBhbnkgW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyB0aGF0IHdlIGFyZVxuICAgKiBzdWJzY3JpYmVkIHRvLlxuICAgKlxuICAgKiBhcmdzOiAoY29ubmVjdGlvblF1YWxpdHk6IFtbQ29ubmVjdGlvblF1YWxpdHldXSwgcGFydGljaXBhbnQ6IFtbUGFydGljaXBhbnRdXSlcbiAgICovXG4gIFJvb21FdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZFwiXSA9IFwiY29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBTdHJlYW1TdGF0ZSBpbmRpY2F0ZXMgaWYgYSBzdWJzY3JpYmVkIChyZW1vdGUpIHRyYWNrIGhhcyBiZWVuIHBhdXNlZCBieSB0aGUgU0ZVXG4gICAqICh0eXBpY2FsbHkgdGhpcyBoYXBwZW5zIGJlY2F1c2Ugb2Ygc3Vic2NyaWJlcidzIGJhbmR3aWR0aCBjb25zdHJhaW50cylcbiAgICpcbiAgICogV2hlbiBiYW5kd2lkdGggY29uZGl0aW9ucyBhbGxvdywgdGhlIHRyYWNrIHdpbGwgYmUgcmVzdW1lZCBhdXRvbWF0aWNhbGx5LlxuICAgKiBUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCB3aWxsIGFsc28gYmUgZW1pdHRlZCB3aGVuIHRoYXQgaGFwcGVucy5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sIHN0cmVhbVN0YXRlOiBbW1RyYWNrLlN0cmVhbVN0YXRlXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBPbmUgb2Ygc3Vic2NyaWJlZCB0cmFja3MgaGF2ZSBjaGFuZ2VkIGl0cyBwZXJtaXNzaW9ucyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcGFydGljaXBhbnQuIElmIHBlcm1pc3Npb24gd2FzIHJldm9rZWQsIHRoZW4gdGhlIHRyYWNrIHdpbGwgbm8gbG9uZ2VyXG4gICAqIGJlIHN1YnNjcmliZWQuIElmIHBlcm1pc3Npb24gd2FzIGdyYW50ZWQsIGEgVHJhY2tTdWJzY3JpYmVkIGV2ZW50IHdpbGxcbiAgICogYmUgZW1pdHRlZC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzXV0sXG4gICAqICAgICAgICBwYXJ0aWNpcGFudDogW1tSZW1vdGVQYXJ0aWNpcGFudF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiXSA9IFwidHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiO1xuICAvKipcbiAgICogT25lIG9mIHN1YnNjcmliZWQgdHJhY2tzIGhhdmUgY2hhbmdlZCBpdHMgc3RhdHVzIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC5cbiAgICpcbiAgICogYXJnczogKHB1YjogW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0sXG4gICAqICAgICAgICBzdGF0dXM6IFtbVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXNdXSxcbiAgICogICAgICAgIHBhcnRpY2lwYW50OiBbW1JlbW90ZVBhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJUcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogTGl2ZUtpdCB3aWxsIGF0dGVtcHQgdG8gYXV0b3BsYXkgYWxsIGF1ZGlvIHRyYWNrcyB3aGVuIHlvdSBhdHRhY2ggdGhlbSB0b1xuICAgKiBhdWRpbyBlbGVtZW50cy4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIGBSb29tLmNhblBsYXliYWNrQXVkaW9gIHdpbGwgaW5kaWNhdGUgaWYgYXVkaW8gcGxheWJhY2sgaXMgcGVybWl0dGVkLlxuICAgKi9cbiAgUm9vbUV2ZW50W1wiQXVkaW9QbGF5YmFja1N0YXR1c0NoYW5nZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tDaGFuZ2VkXCI7XG4gIC8qKlxuICAgKiBMaXZlS2l0IHdpbGwgYXR0ZW1wdCB0byBhdXRvcGxheSBhbGwgdmlkZW8gdHJhY2tzIHdoZW4geW91IGF0dGFjaCB0aGVtIHRvXG4gICAqIGEgdmlkZW8gZWxlbWVudC4gSG93ZXZlciwgaWYgdGhhdCBmYWlscywgd2UnbGwgbm90aWZ5IHlvdSB2aWEgVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQuXG4gICAqIENhbGxpbmcgYHJvb20uc3RhcnRWaWRlbygpYCBpbiBhIHVzZXIgZ2VzdHVyZSBldmVudCBoYW5kbGVyIHdpbGwgcmVzdW1lIHRoZSB2aWRlbyBwbGF5YmFjay5cbiAgICovXG4gIFJvb21FdmVudFtcIlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkXCJdID0gXCJ2aWRlb1BsYXliYWNrQ2hhbmdlZFwiO1xuICAvKipcbiAgICogV2hlbiB3ZSBoYXZlIGVuY291bnRlcmVkIGFuIGVycm9yIHdoaWxlIGF0dGVtcHRpbmcgdG8gY3JlYXRlIGEgdHJhY2suXG4gICAqIFRoZSBlcnJvcnMgdGFrZSBwbGFjZSBpbiBnZXRVc2VyTWVkaWEoKS5cbiAgICogVXNlIE1lZGlhRGV2aWNlRmFpbHVyZS5nZXRGYWlsdXJlKGVycm9yKSB0byBnZXQgdGhlIHJlYXNvbiBvZiBmYWlsdXJlLlxuICAgKiBbW0xvY2FsUGFydGljaXBhbnQubGFzdENhbWVyYUVycm9yXV0gYW5kIFtbTG9jYWxQYXJ0aWNpcGFudC5sYXN0TWljcm9waG9uZUVycm9yXV1cbiAgICogd2lsbCBpbmRpY2F0ZSBpZiBpdCBoYWQgYW4gZXJyb3Igd2hpbGUgY3JlYXRpbmcgdGhlIGF1ZGlvIG9yIHZpZGVvIHRyYWNrIHJlc3BlY3RpdmVseS5cbiAgICpcbiAgICogYXJnczogKGVycm9yOiBFcnJvcilcbiAgICovXG4gIFJvb21FdmVudFtcIk1lZGlhRGV2aWNlc0Vycm9yXCJdID0gXCJtZWRpYURldmljZXNFcnJvclwiO1xuICAvKipcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0sIHBhcnRpY2lwYW50OiBbW1BhcnRpY2lwYW50XV0pXG4gICAqL1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFNpZ25hbCBjb25uZWN0ZWQsIGNhbiBwdWJsaXNoIHRyYWNrcy5cbiAgICovXG4gIFJvb21FdmVudFtcIlNpZ25hbENvbm5lY3RlZFwiXSA9IFwic2lnbmFsQ29ubmVjdGVkXCI7XG4gIC8qKlxuICAgKiBSZWNvcmRpbmcgb2YgYSByb29tIGhhcyBzdGFydGVkL3N0b3BwZWQuIFJvb20uaXNSZWNvcmRpbmcgd2lsbCBiZSB1cGRhdGVkIHRvby5cbiAgICogYXJnczogKGlzUmVjb3JkaW5nOiBib29sZWFuKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiUmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiXSA9IFwicmVjb3JkaW5nU3RhdHVzQ2hhbmdlZFwiO1xuICBSb29tRXZlbnRbXCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkXCI7XG4gIFJvb21FdmVudFtcIkVuY3J5cHRpb25FcnJvclwiXSA9IFwiZW5jcnlwdGlvbkVycm9yXCI7XG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuZXZlciB0aGUgY3VycmVudCBidWZmZXIgc3RhdHVzIG9mIGEgZGF0YSBjaGFubmVsIGNoYW5nZXNcbiAgICogYXJnczogKGlzTG93OiBib29sZWFuLCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUm9vbUV2ZW50W1wiRENCdWZmZXJTdGF0dXNDaGFuZ2VkXCJdID0gXCJkY0J1ZmZlclN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFRyaWdnZXJlZCBieSBhIGNhbGwgdG8gcm9vbS5zd2l0Y2hBY3RpdmVEZXZpY2VcbiAgICogYXJnczogKGtpbmQ6IE1lZGlhRGV2aWNlS2luZCwgZGV2aWNlSWQ6IHN0cmluZylcbiAgICovXG4gIFJvb21FdmVudFtcIkFjdGl2ZURldmljZUNoYW5nZWRcIl0gPSBcImFjdGl2ZURldmljZUNoYW5nZWRcIjtcbiAgUm9vbUV2ZW50W1wiQ2hhdE1lc3NhZ2VcIl0gPSBcImNoYXRNZXNzYWdlXCI7XG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBmaXJzdCByZW1vdGUgcGFydGljaXBhbnQgaGFzIHN1YnNjcmliZWQgdG8gdGhlIGxvY2FsUGFydGljaXBhbnQncyB0cmFja1xuICAgKi9cbiAgUm9vbUV2ZW50W1wiTG9jYWxUcmFja1N1YnNjcmliZWRcIl0gPSBcImxvY2FsVHJhY2tTdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBmaXJlZCB3aGVuIHRoZSBjbGllbnQgcmVjZWl2ZXMgY29ubmVjdGlvbiBtZXRyaWNzIGZyb20gb3RoZXIgcGFydGljaXBhbnRzXG4gICAqL1xuICBSb29tRXZlbnRbXCJNZXRyaWNzUmVjZWl2ZWRcIl0gPSBcIm1ldHJpY3NSZWNlaXZlZFwiO1xufSkoUm9vbUV2ZW50IHx8IChSb29tRXZlbnQgPSB7fSkpO1xudmFyIFBhcnRpY2lwYW50RXZlbnQ7XG4oZnVuY3Rpb24gKFBhcnRpY2lwYW50RXZlbnQpIHtcbiAgLyoqXG4gICAqIFdoZW4gYSBuZXcgdHJhY2sgaXMgcHVibGlzaGVkIHRvIHJvb20gKmFmdGVyKiB0aGUgbG9jYWxcbiAgICogcGFydGljaXBhbnQgaGFzIGpvaW5lZC4gSXQgd2lsbCBub3QgZmlyZSBmb3IgdHJhY2tzIHRoYXQgYXJlIGFscmVhZHkgcHVibGlzaGVkLlxuICAgKlxuICAgKiBBIHRyYWNrIHB1Ymxpc2hlZCBkb2Vzbid0IG1lYW4gdGhlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIGl0LiBJdCdzXG4gICAqIHNpbXBseSByZWZsZWN0aW5nIHRoZSBzdGF0ZSBvZiB0aGUgcm9vbS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrUHVibGlzaGVkXCJdID0gXCJ0cmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogU3VjY2Vzc2Z1bGx5IHN1YnNjcmliZWQgdG8gdGhlIFtbUmVtb3RlUGFydGljaXBhbnRdXSdzIHRyYWNrLlxuICAgKiBUaGlzIGV2ZW50IHdpbGwgKiphbHdheXMqKiBmaXJlIGFzIGxvbmcgYXMgbmV3IHRyYWNrcyBhcmUgcmVhZHkgZm9yIHVzZS5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpYmVkXCJdID0gXCJ0cmFja1N1YnNjcmliZWRcIjtcbiAgLyoqXG4gICAqIENvdWxkIG5vdCBzdWJzY3JpYmUgdG8gYSB0cmFja1xuICAgKlxuICAgKiBhcmdzOiAodHJhY2sgc2lkKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvbkZhaWxlZFwiO1xuICAvKipcbiAgICogQSBbW1JlbW90ZVBhcnRpY2lwYW50XV0gaGFzIHVucHVibGlzaGVkIGEgdHJhY2tcbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5wdWJsaXNoZWRcIl0gPSBcInRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgLyoqXG4gICAqIEEgc3Vic2NyaWJlZCB0cmFjayBpcyBubyBsb25nZXIgYXZhaWxhYmxlLiBDbGllbnRzIHNob3VsZCBsaXN0ZW4gdG8gdGhpc1xuICAgKiBldmVudCBhbmQgZW5zdXJlIHRoZXkgZGV0YWNoIHRyYWNrcy5cbiAgICpcbiAgICogYXJnczogKFtbUmVtb3RlVHJhY2tdXSwgW1tSZW1vdGVUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tVbnN1YnNjcmliZWRcIl0gPSBcInRyYWNrVW5zdWJzY3JpYmVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIG11dGVkLCBmaXJlcyBvbiBib3RoIFtbUmVtb3RlUGFydGljaXBhbnRdXXMgYW5kIFtbTG9jYWxQYXJ0aWNpcGFudF1dXG4gICAqXG4gICAqIGFyZ3M6IChbW1RyYWNrUHVibGljYXRpb25dXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja011dGVkXCJdID0gXCJ0cmFja011dGVkXCI7XG4gIC8qKlxuICAgKiBBIHRyYWNrIHRoYXQgd2FzIHVubXV0ZWQsIGZpcmVzIG9uIGJvdGggW1tSZW1vdGVQYXJ0aWNpcGFudF1dcyBhbmQgW1tMb2NhbFBhcnRpY2lwYW50XV1cbiAgICpcbiAgICogYXJnczogKFtbVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrVW5tdXRlZFwiXSA9IFwidHJhY2tVbm11dGVkXCI7XG4gIC8qKlxuICAgKiBBIGxvY2FsIHRyYWNrIHdhcyBwdWJsaXNoZWQgc3VjY2Vzc2Z1bGx5LiBUaGlzIGV2ZW50IGlzIGhlbHBmdWwgdG8ga25vd1xuICAgKiB3aGVuIHRvIHVwZGF0ZSB5b3VyIGxvY2FsIFVJIHdpdGggdGhlIG5ld2x5IHB1Ymxpc2hlZCB0cmFjay5cbiAgICpcbiAgICogYXJnczogKFtbTG9jYWxUcmFja1B1YmxpY2F0aW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiTG9jYWxUcmFja1B1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1B1Ymxpc2hlZFwiO1xuICAvKipcbiAgICogQSBsb2NhbCB0cmFjayB3YXMgdW5wdWJsaXNoZWQuIFRoaXMgZXZlbnQgaXMgaGVscGZ1bCB0byBrbm93IHdoZW4gdG8gcmVtb3ZlXG4gICAqIHRoZSBsb2NhbCB0cmFjayBmcm9tIHlvdXIgVUkuXG4gICAqXG4gICAqIFdoZW4gYSB1c2VyIHN0b3BzIHNoYXJpbmcgdGhlaXIgc2NyZWVuIGJ5IHByZXNzaW5nIFwiRW5kXCIgb24gdGhlIGJyb3dzZXIgVUksXG4gICAqIHRoaXMgZXZlbnQgd2lsbCBhbHNvIGZpcmUuXG4gICAqXG4gICAqIGFyZ3M6IChbW0xvY2FsVHJhY2tQdWJsaWNhdGlvbl1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZFwiXSA9IFwibG9jYWxUcmFja1VucHVibGlzaGVkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBtZXRhZGF0YSBpcyBhIHNpbXBsZSB3YXkgZm9yIGFwcC1zcGVjaWZpYyBzdGF0ZSB0byBiZSBwdXNoZWQgdG9cbiAgICogYWxsIHVzZXJzLlxuICAgKiBXaGVuIFJvb21TZXJ2aWNlLlVwZGF0ZVBhcnRpY2lwYW50TWV0YWRhdGEgaXMgY2FsbGVkIHRvIGNoYW5nZSBhIHBhcnRpY2lwYW50J3NcbiAgICogc3RhdGUsICphbGwqICBwYXJ0aWNpcGFudHMgaW4gdGhlIHJvb20gd2lsbCBmaXJlIHRoaXMgZXZlbnQuXG4gICAqIFRvIGFjY2VzcyB0aGUgY3VycmVudCBtZXRhZGF0YSwgc2VlIFtbUGFydGljaXBhbnQubWV0YWRhdGFdXS5cbiAgICpcbiAgICogYXJnczogKHByZXZNZXRhZGF0YTogc3RyaW5nKVxuICAgKlxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkXCJdID0gXCJwYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZFwiO1xuICAvKipcbiAgICogUGFydGljaXBhbnQncyBkaXNwbGF5IG5hbWUgY2hhbmdlZFxuICAgKlxuICAgKiBhcmdzOiAobmFtZTogc3RyaW5nLCBbW1BhcnRpY2lwYW50XV0pXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnROYW1lQ2hhbmdlZFwiXSA9IFwicGFydGljaXBhbnROYW1lQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRGF0YSByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKiBEYXRhIHBhY2tldHMgcHJvdmlkZXMgdGhlIGFiaWxpdHkgdG8gdXNlIExpdmVLaXQgdG8gc2VuZC9yZWNlaXZlIGFyYml0cmFyeSBwYXlsb2Fkcy5cbiAgICogQWxsIHBhcnRpY2lwYW50cyBpbiB0aGUgcm9vbSB3aWxsIHJlY2VpdmUgdGhlIG1lc3NhZ2VzIHNlbnQgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIGFyZ3M6IChwYXlsb2FkOiBVaW50OEFycmF5LCBraW5kOiBbW0RhdGFQYWNrZXRfS2luZF1dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkRhdGFSZWNlaXZlZFwiXSA9IFwiZGF0YVJlY2VpdmVkXCI7XG4gIC8qKlxuICAgKiBTSVAgRFRNRiB0b25lcyByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgc2VuZGVyLlxuICAgKlxuICAgKiBhcmdzOiAoZHRtZjogW1tEYXRhUGFja2V0X0tpbmRdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJTaXBEVE1GUmVjZWl2ZWRcIl0gPSBcInNpcERUTUZSZWNlaXZlZFwiO1xuICAvKipcbiAgICogVHJhbnNjcmlwdGlvbiByZWNlaXZlZCBmcm9tIHRoaXMgcGFydGljaXBhbnQgYXMgZGF0YSBzb3VyY2UuXG4gICAqIEBiZXRhXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhbnNjcmlwdGlvblJlY2VpdmVkXCJdID0gXCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIEhhcyBzcGVha2luZyBzdGF0dXMgY2hhbmdlZCBmb3IgdGhlIGN1cnJlbnQgcGFydGljaXBhbnRcbiAgICpcbiAgICogYXJnczogKHNwZWFraW5nOiBib29sZWFuKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIklzU3BlYWtpbmdDaGFuZ2VkXCJdID0gXCJpc1NwZWFraW5nQ2hhbmdlZFwiO1xuICAvKipcbiAgICogQ29ubmVjdGlvbiBxdWFsaXR5IHdhcyBjaGFuZ2VkIGZvciBhIFBhcnRpY2lwYW50LiBJdCdsbCByZWNlaXZlIHVwZGF0ZXNcbiAgICogZnJvbSB0aGUgbG9jYWwgcGFydGljaXBhbnQsIGFzIHdlbGwgYXMgYW55IFtbUmVtb3RlUGFydGljaXBhbnRdXXMgdGhhdCB3ZSBhcmVcbiAgICogc3Vic2NyaWJlZCB0by5cbiAgICpcbiAgICogYXJnczogKGNvbm5lY3Rpb25RdWFsaXR5OiBbW0Nvbm5lY3Rpb25RdWFsaXR5XV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIFN0cmVhbVN0YXRlIGluZGljYXRlcyBpZiBhIHN1YnNjcmliZWQgdHJhY2sgaGFzIGJlZW4gcGF1c2VkIGJ5IHRoZSBTRlVcbiAgICogKHR5cGljYWxseSB0aGlzIGhhcHBlbnMgYmVjYXVzZSBvZiBzdWJzY3JpYmVyJ3MgYmFuZHdpZHRoIGNvbnN0cmFpbnRzKVxuICAgKlxuICAgKiBXaGVuIGJhbmR3aWR0aCBjb25kaXRpb25zIGFsbG93LCB0aGUgdHJhY2sgd2lsbCBiZSByZXN1bWVkIGF1dG9tYXRpY2FsbHkuXG4gICAqIFRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIHdpbGwgYWxzbyBiZSBlbWl0dGVkIHdoZW4gdGhhdCBoYXBwZW5zLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSwgc3RyZWFtU3RhdGU6IFtbVHJhY2suU3RyZWFtU3RhdGVdXSlcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJUcmFja1N0cmVhbVN0YXRlQ2hhbmdlZFwiXSA9IFwidHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiBzdWJzY3JpYmVkIHRyYWNrcyBoYXZlIGNoYW5nZWQgaXRzIHBlcm1pc3Npb25zIGZvciB0aGUgY3VycmVudFxuICAgKiBwYXJ0aWNpcGFudC4gSWYgcGVybWlzc2lvbiB3YXMgcmV2b2tlZCwgdGhlbiB0aGUgdHJhY2sgd2lsbCBubyBsb25nZXJcbiAgICogYmUgc3Vic2NyaWJlZC4gSWYgcGVybWlzc2lvbiB3YXMgZ3JhbnRlZCwgYSBUcmFja1N1YnNjcmliZWQgZXZlbnQgd2lsbFxuICAgKiBiZSBlbWl0dGVkLlxuICAgKlxuICAgKiBhcmdzOiAocHViOiBbW1JlbW90ZVRyYWNrUHVibGljYXRpb25dXSxcbiAgICogICAgICAgIHN0YXR1czogW1tUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1c11dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIl0gPSBcInRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWRcIjtcbiAgLyoqXG4gICAqIE9uZSBvZiB0aGUgcmVtb3RlIHBhcnRpY2lwYW50cyBwdWJsaWNhdGlvbnMgaGFzIGNoYW5nZWQgaXRzIHN1YnNjcmlwdGlvbiBzdGF0dXMuXG4gICAqXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkXCJdID0gXCJ0cmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgLy8gZmlyZWQgb25seSBvbiBMb2NhbFBhcnRpY2lwYW50XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIk1lZGlhRGV2aWNlc0Vycm9yXCJdID0gXCJtZWRpYURldmljZXNFcnJvclwiO1xuICAvLyBmaXJlZCBvbmx5IG9uIExvY2FsUGFydGljaXBhbnRcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQXVkaW9TdHJlYW1BY3F1aXJlZFwiXSA9IFwiYXVkaW9TdHJlYW1BY3F1aXJlZFwiO1xuICAvKipcbiAgICogQSBwYXJ0aWNpcGFudCdzIHBlcm1pc3Npb24gaGFzIGNoYW5nZWQuXG4gICAqIGFyZ3M6IChwcmV2UGVybWlzc2lvbnM6IFtbUGFydGljaXBhbnRQZXJtaXNzaW9uXV0pXG4gICAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWRcIl0gPSBcInBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIlBDVHJhY2tBZGRlZFwiXSA9IFwicGNUcmFja0FkZGVkXCI7XG4gIC8qKlxuICAgKiBQYXJ0aWNpcGFudCBhdHRyaWJ1dGVzIGlzIGFuIGFwcC1zcGVjaWZpYyBrZXkgdmFsdWUgc3RhdGUgdG8gYmUgcHVzaGVkIHRvXG4gICAqIGFsbCB1c2Vycy5cbiAgICogV2hlbiBhIHBhcnRpY2lwYW50J3MgYXR0cmlidXRlcyBjaGFuZ2VkLCB0aGlzIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCB3aXRoIHRoZSBjaGFuZ2VkIGF0dHJpYnV0ZXNcbiAgICogYXJnczogKGNoYW5nZWRBdHRyaWJ1dGVzOiBbW1JlY29yZDxzdHJpbmcsIHN0cmluZ11dKVxuICAgKi9cbiAgUGFydGljaXBhbnRFdmVudFtcIkF0dHJpYnV0ZXNDaGFuZ2VkXCJdID0gXCJhdHRyaWJ1dGVzQ2hhbmdlZFwiO1xuICAvKipcbiAgICogZmlyZWQgb24gbG9jYWwgcGFydGljaXBhbnQgb25seSwgd2hlbiB0aGUgZmlyc3QgcmVtb3RlIHBhcnRpY2lwYW50IGhhcyBzdWJzY3JpYmVkIHRvIHRoZSB0cmFjayBzcGVjaWZpZWQgaW4gdGhlIHBheWxvYWRcbiAgICovXG4gIFBhcnRpY2lwYW50RXZlbnRbXCJMb2NhbFRyYWNrU3Vic2NyaWJlZFwiXSA9IFwibG9jYWxUcmFja1N1YnNjcmliZWRcIjtcbiAgLyoqIG9ubHkgZW1pdHRlZCBvbiBsb2NhbCBwYXJ0aWNpcGFudCAqL1xuICBQYXJ0aWNpcGFudEV2ZW50W1wiQ2hhdE1lc3NhZ2VcIl0gPSBcImNoYXRNZXNzYWdlXCI7XG59KShQYXJ0aWNpcGFudEV2ZW50IHx8IChQYXJ0aWNpcGFudEV2ZW50ID0ge30pKTtcbi8qKiBAaW50ZXJuYWwgKi9cbnZhciBFbmdpbmVFdmVudDtcbihmdW5jdGlvbiAoRW5naW5lRXZlbnQpIHtcbiAgRW5naW5lRXZlbnRbXCJUcmFuc3BvcnRzQ3JlYXRlZFwiXSA9IFwidHJhbnNwb3J0c0NyZWF0ZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJDb25uZWN0ZWRcIl0gPSBcImNvbm5lY3RlZFwiO1xuICBFbmdpbmVFdmVudFtcIkRpc2Nvbm5lY3RlZFwiXSA9IFwiZGlzY29ubmVjdGVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdW1pbmdcIl0gPSBcInJlc3VtaW5nXCI7XG4gIEVuZ2luZUV2ZW50W1wiUmVzdW1lZFwiXSA9IFwicmVzdW1lZFwiO1xuICBFbmdpbmVFdmVudFtcIlJlc3RhcnRpbmdcIl0gPSBcInJlc3RhcnRpbmdcIjtcbiAgRW5naW5lRXZlbnRbXCJSZXN0YXJ0ZWRcIl0gPSBcInJlc3RhcnRlZFwiO1xuICBFbmdpbmVFdmVudFtcIlNpZ25hbFJlc3VtZWRcIl0gPSBcInNpZ25hbFJlc3VtZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxSZXN0YXJ0ZWRcIl0gPSBcInNpZ25hbFJlc3RhcnRlZFwiO1xuICBFbmdpbmVFdmVudFtcIkNsb3NpbmdcIl0gPSBcImNsb3NpbmdcIjtcbiAgRW5naW5lRXZlbnRbXCJNZWRpYVRyYWNrQWRkZWRcIl0gPSBcIm1lZGlhVHJhY2tBZGRlZFwiO1xuICBFbmdpbmVFdmVudFtcIkFjdGl2ZVNwZWFrZXJzVXBkYXRlXCJdID0gXCJhY3RpdmVTcGVha2Vyc1VwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIkRhdGFQYWNrZXRSZWNlaXZlZFwiXSA9IFwiZGF0YVBhY2tldFJlY2VpdmVkXCI7XG4gIEVuZ2luZUV2ZW50W1wiUlRQVmlkZW9NYXBVcGRhdGVcIl0gPSBcInJ0cFZpZGVvTWFwVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiRENCdWZmZXJTdGF0dXNDaGFuZ2VkXCJdID0gXCJkY0J1ZmZlclN0YXR1c0NoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJQYXJ0aWNpcGFudFVwZGF0ZVwiXSA9IFwicGFydGljaXBhbnRVcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJSb29tVXBkYXRlXCJdID0gXCJyb29tVXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3BlYWtlcnNDaGFuZ2VkXCJdID0gXCJzcGVha2Vyc0NoYW5nZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJTdHJlYW1TdGF0ZUNoYW5nZWRcIl0gPSBcInN0cmVhbVN0YXRlQ2hhbmdlZFwiO1xuICBFbmdpbmVFdmVudFtcIkNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlXCJdID0gXCJjb25uZWN0aW9uUXVhbGl0eVVwZGF0ZVwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmlwdGlvbkVycm9yXCJdID0gXCJzdWJzY3JpcHRpb25FcnJvclwiO1xuICBFbmdpbmVFdmVudFtcIlN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIl0gPSBcInN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGVcIjtcbiAgRW5naW5lRXZlbnRbXCJSZW1vdGVNdXRlXCJdID0gXCJyZW1vdGVNdXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGVcIl0gPSBcInN1YnNjcmliZWRRdWFsaXR5VXBkYXRlXCI7XG4gIEVuZ2luZUV2ZW50W1wiTG9jYWxUcmFja1VucHVibGlzaGVkXCJdID0gXCJsb2NhbFRyYWNrVW5wdWJsaXNoZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJMb2NhbFRyYWNrU3Vic2NyaWJlZFwiXSA9IFwibG9jYWxUcmFja1N1YnNjcmliZWRcIjtcbiAgRW5naW5lRXZlbnRbXCJPZmZsaW5lXCJdID0gXCJvZmZsaW5lXCI7XG4gIEVuZ2luZUV2ZW50W1wiU2lnbmFsUmVxdWVzdFJlc3BvbnNlXCJdID0gXCJzaWduYWxSZXF1ZXN0UmVzcG9uc2VcIjtcbiAgRW5naW5lRXZlbnRbXCJTaWduYWxDb25uZWN0ZWRcIl0gPSBcInNpZ25hbENvbm5lY3RlZFwiO1xufSkoRW5naW5lRXZlbnQgfHwgKEVuZ2luZUV2ZW50ID0ge30pKTtcbnZhciBUcmFja0V2ZW50O1xuKGZ1bmN0aW9uIChUcmFja0V2ZW50KSB7XG4gIFRyYWNrRXZlbnRbXCJNZXNzYWdlXCJdID0gXCJtZXNzYWdlXCI7XG4gIFRyYWNrRXZlbnRbXCJNdXRlZFwiXSA9IFwibXV0ZWRcIjtcbiAgVHJhY2tFdmVudFtcIlVubXV0ZWRcIl0gPSBcInVubXV0ZWRcIjtcbiAgLyoqXG4gICAqIE9ubHkgZmlyZXMgb24gTG9jYWxUcmFja3NcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJSZXN0YXJ0ZWRcIl0gPSBcInJlc3RhcnRlZFwiO1xuICBUcmFja0V2ZW50W1wiRW5kZWRcIl0gPSBcImVuZGVkXCI7XG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpYmVkXCJdID0gXCJzdWJzY3JpYmVkXCI7XG4gIFRyYWNrRXZlbnRbXCJVbnN1YnNjcmliZWRcIl0gPSBcInVuc3Vic2NyaWJlZFwiO1xuICAvKiogQGludGVybmFsICovXG4gIFRyYWNrRXZlbnRbXCJVcGRhdGVTZXR0aW5nc1wiXSA9IFwidXBkYXRlU2V0dGluZ3NcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVXBkYXRlU3Vic2NyaXB0aW9uXCJdID0gXCJ1cGRhdGVTdWJzY3JpcHRpb25cIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiQXVkaW9QbGF5YmFja1N0YXJ0ZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tTdGFydGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIkF1ZGlvUGxheWJhY2tGYWlsZWRcIl0gPSBcImF1ZGlvUGxheWJhY2tGYWlsZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsQXVkaW9UcmFjayBpbnN0YW5jZXNcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1NpbGVuY2VEZXRlY3RlZFwiXSA9IFwiYXVkaW9TaWxlbmNlRGV0ZWN0ZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlzaWJpbGl0eUNoYW5nZWRcIl0gPSBcInZpc2liaWxpdHlDaGFuZ2VkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlZpZGVvRGltZW5zaW9uc0NoYW5nZWRcIl0gPSBcInZpZGVvRGltZW5zaW9uc0NoYW5nZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiVmlkZW9QbGF5YmFja1N0YXJ0ZWRcIl0gPSBcInZpZGVvUGxheWJhY2tTdGFydGVkXCI7XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgVHJhY2tFdmVudFtcIlZpZGVvUGxheWJhY2tGYWlsZWRcIl0gPSBcInZpZGVvUGxheWJhY2tGYWlsZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiRWxlbWVudEF0dGFjaGVkXCJdID0gXCJlbGVtZW50QXR0YWNoZWRcIjtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBUcmFja0V2ZW50W1wiRWxlbWVudERldGFjaGVkXCJdID0gXCJlbGVtZW50RGV0YWNoZWRcIjtcbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBPbmx5IGZpcmVzIG9uIExvY2FsVHJhY2tzXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVXBzdHJlYW1QYXVzZWRcIl0gPSBcInVwc3RyZWFtUGF1c2VkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogT25seSBmaXJlcyBvbiBMb2NhbFRyYWNrc1xuICAgKi9cbiAgVHJhY2tFdmVudFtcIlVwc3RyZWFtUmVzdW1lZFwiXSA9IFwidXBzdHJlYW1SZXN1bWVkXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkXCJdID0gXCJzdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZFwiO1xuICAvKipcbiAgICogRmlyZXMgb24gUmVtb3RlVHJhY2tQdWJsaWNhdGlvblxuICAgKi9cbiAgVHJhY2tFdmVudFtcIlN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIl0gPSBcInN1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWRcIjtcbiAgLyoqXG4gICAqIEZpcmVzIG9uIFJlbW90ZVRyYWNrUHVibGljYXRpb25cbiAgICovXG4gIFRyYWNrRXZlbnRbXCJTdWJzY3JpcHRpb25GYWlsZWRcIl0gPSBcInN1YnNjcmlwdGlvbkZhaWxlZFwiO1xuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVHJhY2tQcm9jZXNzb3JVcGRhdGVcIl0gPSBcInRyYWNrUHJvY2Vzc29yVXBkYXRlXCI7XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJBdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZVwiXSA9IFwiYXVkaW9UcmFja0ZlYXR1cmVVcGRhdGVcIjtcbiAgLyoqXG4gICAqIEBiZXRhXG4gICAqL1xuICBUcmFja0V2ZW50W1wiVHJhbnNjcmlwdGlvblJlY2VpdmVkXCJdID0gXCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRcIjtcbiAgLyoqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICovXG4gIFRyYWNrRXZlbnRbXCJUaW1lU3luY1VwZGF0ZVwiXSA9IFwidGltZVN5bmNVcGRhdGVcIjtcbn0pKFRyYWNrRXZlbnQgfHwgKFRyYWNrRXZlbnQgPSB7fSkpO1xuXG5mdW5jdGlvbiBjbG9uZURlZXAodmFsdWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJ1Y3R1cmVkQ2xvbmUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gc3RydWN0dXJlZENsb25lKHZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICB9XG59XG5cbi8vIHRpbnksIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiBodHRwczovL2dpdGh1Yi5jb20vbGFuY2VkaWtzb24vYm93c2VyL2Jsb2IvbWFzdGVyL3NyYy9wYXJzZXItYnJvd3NlcnMuanNcbi8vIHJlZHVjZWQgdG8gb25seSBkaWZmZXJlbnRpYXRlIENocm9tZShpdW0pIGJhc2VkIGJyb3dzZXJzIC8gRmlyZWZveCAvIFNhZmFyaVxuY29uc3QgY29tbW9uVmVyc2lvbklkZW50aWZpZXIgPSAvdmVyc2lvblxcLyhcXGQrKFxcLj9fP1xcZCspKykvaTtcbmxldCBicm93c2VyRGV0YWlscztcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldEJyb3dzZXIodXNlckFnZW50KSB7XG4gIGxldCBmb3JjZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgaWYgKHR5cGVvZiB1c2VyQWdlbnQgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBuYXZpZ2F0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHVhID0gKHVzZXJBZ2VudCAhPT0gbnVsbCAmJiB1c2VyQWdlbnQgIT09IHZvaWQgMCA/IHVzZXJBZ2VudCA6IG5hdmlnYXRvci51c2VyQWdlbnQpLnRvTG93ZXJDYXNlKCk7XG4gIGlmIChicm93c2VyRGV0YWlscyA9PT0gdW5kZWZpbmVkIHx8IGZvcmNlKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IGJyb3dzZXJzTGlzdC5maW5kKF9yZWYgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgdGVzdFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gdGVzdC50ZXN0KHVhKTtcbiAgICB9KTtcbiAgICBicm93c2VyRGV0YWlscyA9IGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5kZXNjcmliZSh1YSk7XG4gIH1cbiAgcmV0dXJuIGJyb3dzZXJEZXRhaWxzO1xufVxuY29uc3QgYnJvd3NlcnNMaXN0ID0gW3tcbiAgdGVzdDogL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdGaXJlZm94JyxcbiAgICAgIHZlcnNpb246IGdldE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksIHVhKSxcbiAgICAgIG9zOiB1YS50b0xvd2VyQ2FzZSgpLmluY2x1ZGVzKCdmeGlvcycpID8gJ2lPUycgOiB1bmRlZmluZWQsXG4gICAgICBvc1ZlcnNpb246IGdldE9TVmVyc2lvbih1YSlcbiAgICB9O1xuICAgIHJldHVybiBicm93c2VyO1xuICB9XG59LCB7XG4gIHRlc3Q6IC9jaHJvbXxjcmlvc3xjcm1vL2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdDaHJvbWUnLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goLyg/OmNocm9tZXxjaHJvbWl1bXxjcmlvc3xjcm1vKVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSwgdWEpLFxuICAgICAgb3M6IHVhLnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ2NyaW9zJykgPyAnaU9TJyA6IHVuZGVmaW5lZCxcbiAgICAgIG9zVmVyc2lvbjogZ2V0T1NWZXJzaW9uKHVhKVxuICAgIH07XG4gICAgcmV0dXJuIGJyb3dzZXI7XG4gIH1cbn0sIC8qIFNhZmFyaSAqL1xue1xuICB0ZXN0OiAvc2FmYXJpfGFwcGxld2Via2l0L2ksXG4gIGRlc2NyaWJlKHVhKSB7XG4gICAgY29uc3QgYnJvd3NlciA9IHtcbiAgICAgIG5hbWU6ICdTYWZhcmknLFxuICAgICAgdmVyc2lvbjogZ2V0TWF0Y2goY29tbW9uVmVyc2lvbklkZW50aWZpZXIsIHVhKSxcbiAgICAgIG9zOiB1YS5pbmNsdWRlcygnbW9iaWxlLycpID8gJ2lPUycgOiAnbWFjT1MnLFxuICAgICAgb3NWZXJzaW9uOiBnZXRPU1ZlcnNpb24odWEpXG4gICAgfTtcbiAgICByZXR1cm4gYnJvd3NlcjtcbiAgfVxufV07XG5mdW5jdGlvbiBnZXRNYXRjaChleHAsIHVhKSB7XG4gIGxldCBpZCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogMTtcbiAgY29uc3QgbWF0Y2ggPSB1YS5tYXRjaChleHApO1xuICByZXR1cm4gbWF0Y2ggJiYgbWF0Y2gubGVuZ3RoID49IGlkICYmIG1hdGNoW2lkXSB8fCAnJztcbn1cbmZ1bmN0aW9uIGdldE9TVmVyc2lvbih1YSkge1xuICByZXR1cm4gdWEuaW5jbHVkZXMoJ21hYyBvcycpID8gZ2V0TWF0Y2goL1xcKC4rPyhcXGQrX1xcZCsoOj9fXFxkKyk/KS8sIHVhLCAxKS5yZXBsYWNlKC9fL2csICcuJykgOiB1bmRlZmluZWQ7XG59XG5cbnZhciB2ZXJzaW9uJDEgPSBcIjIuMTEuM1wiO1xuXG5jb25zdCB2ZXJzaW9uID0gdmVyc2lvbiQxO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9uID0gMTU7XG5cbi8qKlxuICogVGltZXJzIHRoYXQgY2FuIGJlIG92ZXJyaWRkZW4gd2l0aCBwbGF0Zm9ybSBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbnNcbiAqIHRoYXQgZW5zdXJlIHRoYXQgdGhleSBhcmUgZmlyZWQuIFRoZXNlIHNob3VsZCBiZSB1c2VkIHdoZW4gaXQgaXMgY3JpdGljYWxcbiAqIHRoYXQgdGhlIHRpbWVyIGZpcmVzIG9uIHRpbWUuXG4gKi9cbmNsYXNzIENyaXRpY2FsVGltZXJzIHt9XG5Dcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gc2V0VGltZW91dCguLi5hcmd1bWVudHMpO1xufTtcbkNyaXRpY2FsVGltZXJzLnNldEludGVydmFsID1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8taW1wbGllZC1ldmFsXG5mdW5jdGlvbiAoKSB7XG4gIHJldHVybiBzZXRJbnRlcnZhbCguLi5hcmd1bWVudHMpO1xufTtcbkNyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGNsZWFyVGltZW91dCguLi5hcmd1bWVudHMpO1xufTtcbkNyaXRpY2FsVGltZXJzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjbGVhckludGVydmFsKC4uLmFyZ3VtZW50cyk7XG59O1xuXG5jb25zdCBCQUNLR1JPVU5EX1JFQUNUSU9OX0RFTEFZID0gNTAwMDtcbi8vIGtlZXAgb2xkIGF1ZGlvIGVsZW1lbnRzIHdoZW4gZGV0YWNoZWQsIHdlIHdvdWxkIHJlLXVzZSB0aGVtIHNpbmNlIG9uIGlPU1xuLy8gU2FmYXJpIHRyYWNrcyB3aGljaCBhdWRpbyBlbGVtZW50cyBoYXZlIGJlZW4gXCJibGVzc2VkXCIgYnkgdGhlIHVzZXIuXG5jb25zdCByZWN5Y2xlZEVsZW1lbnRzID0gW107XG52YXIgVmlkZW9RdWFsaXR5O1xuKGZ1bmN0aW9uIChWaWRlb1F1YWxpdHkpIHtcbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIkxPV1wiXSA9IDBdID0gXCJMT1dcIjtcbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIk1FRElVTVwiXSA9IDFdID0gXCJNRURJVU1cIjtcbiAgVmlkZW9RdWFsaXR5W1ZpZGVvUXVhbGl0eVtcIkhJR0hcIl0gPSAyXSA9IFwiSElHSFwiO1xufSkoVmlkZW9RdWFsaXR5IHx8IChWaWRlb1F1YWxpdHkgPSB7fSkpO1xuY2xhc3MgVHJhY2sgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQpIHtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5pc011dGVkID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogaW5kaWNhdGVzIGN1cnJlbnQgc3RhdGUgb2Ygc3RyZWFtLCBpdCdsbCBpbmRpY2F0ZSBgcGF1c2VkYCBpZiB0aGUgdHJhY2tcbiAgICAgKiBoYXMgYmVlbiBwYXVzZWQgYnkgY29uZ2VzdGlvbiBjb250cm9sbGVyXG4gICAgICovXG4gICAgdGhpcy5zdHJlYW1TdGF0ZSA9IFRyYWNrLlN0cmVhbVN0YXRlLkFjdGl2ZTtcbiAgICB0aGlzLmlzSW5CYWNrZ3JvdW5kID0gZmFsc2U7XG4gICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5iYWNrZ3JvdW5kVGltZW91dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5iYWNrZ3JvdW5kVGltZW91dCk7XG4gICAgICB9XG4gICAgICAvLyBkZWxheSBhcHAgdmlzaWJpbGl0eSB1cGRhdGUgaWYgaXQgZ29lcyB0byBoaWRkZW5cbiAgICAgIC8vIHVwZGF0ZSBpbW1lZGlhdGVseSBpZiBpdCBjb21lcyBiYWNrIHRvIGZvY3VzXG4gICAgICBpZiAoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlID09PSAnaGlkZGVuJykge1xuICAgICAgICB0aGlzLmJhY2tncm91bmRUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkKCksIEJBQ0tHUk9VTkRfUkVBQ1RJT05fREVMQVkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5UcmFjayk7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG1lZGlhVHJhY2s7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1JRCA9IG1lZGlhVHJhY2suaWQ7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuVW5rbm93bjtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0aGlzKSk7XG4gIH1cbiAgLyoqIGN1cnJlbnQgcmVjZWl2ZSBiaXRzIHBlciBzZWNvbmQgKi9cbiAgZ2V0IGN1cnJlbnRCaXRyYXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9jdXJyZW50Qml0cmF0ZTtcbiAgfVxuICBnZXQgbWVkaWFTdHJlYW1UcmFjaygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIHVzZWQgZm9yIGtlZXAgbWVkaWFTdHJlYW0ncyBmaXJzdCBpZCwgc2luY2UgaXQncyBpZCBtaWdodCBjaGFuZ2VcbiAgICogaWYgd2UgZGlzYWJsZS9lbmFibGUgYSB0cmFja1xuICAgKi9cbiAgZ2V0IG1lZGlhU3RyZWFtSUQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lZGlhU3RyZWFtSUQ7XG4gIH1cbiAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZWxlbWVudFR5cGUgPSAnYXVkaW8nO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8pIHtcbiAgICAgIGVsZW1lbnRUeXBlID0gJ3ZpZGVvJztcbiAgICB9XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDAgJiYgdGhpcy5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICB0aGlzLmFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpO1xuICAgIH1cbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICByZWN5Y2xlZEVsZW1lbnRzLmZvckVhY2goZSA9PiB7XG4gICAgICAgICAgaWYgKGUucGFyZW50RWxlbWVudCA9PT0gbnVsbCAmJiAhZWxlbWVudCkge1xuICAgICAgICAgICAgZWxlbWVudCA9IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICAvLyByZW1vdmUgaXQgZnJvbSBwb29sXG4gICAgICAgICAgcmVjeWNsZWRFbGVtZW50cy5zcGxpY2UocmVjeWNsZWRFbGVtZW50cy5pbmRleE9mKGVsZW1lbnQpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsZW1lbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5jbHVkZXMoZWxlbWVudCkpIHtcbiAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5wdXNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyBldmVuIGlmIHdlIGJlbGlldmUgaXQncyBhbHJlYWR5IGF0dGFjaGVkIHRvIHRoZSBlbGVtZW50LCBpdCdzIHBvc3NpYmxlXG4gICAgLy8gdGhlIGVsZW1lbnQncyBzcmNPYmplY3Qgd2FzIHNldCB0byBzb21ldGhpbmcgZWxzZSBvdXQgb2YgYmFuZC5cbiAgICAvLyB3ZSdsbCB3YW50IHRvIHJlLWF0dGFjaCBpdCBpbiB0aGF0IGNhc2VcbiAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbGVtZW50KTtcbiAgICAvLyBoYW5kbGUgYXV0byBwbGF5YmFjayBmYWlsdXJlc1xuICAgIGNvbnN0IGFsbE1lZGlhU3RyZWFtVHJhY2tzID0gZWxlbWVudC5zcmNPYmplY3QuZ2V0VHJhY2tzKCk7XG4gICAgY29uc3QgaGFzQXVkaW8gPSBhbGxNZWRpYVN0cmVhbVRyYWNrcy5zb21lKHRyID0+IHRyLmtpbmQgPT09ICdhdWRpbycpO1xuICAgIC8vIG1hbnVhbGx5IHBsYXkgbWVkaWEgdG8gZGV0ZWN0IGF1dG8gcGxheWJhY2sgc3RhdHVzXG4gICAgZWxlbWVudC5wbGF5KCkudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tTdGFydGVkIDogVHJhY2tFdmVudC5WaWRlb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICBpZiAoZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICB0aGlzLmVtaXQoaGFzQXVkaW8gPyBUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQgOiBUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgfSBlbHNlIGlmIChlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAvLyBjb21tb25seSB0cmlnZ2VyZWQgYnkgYW5vdGhlciBgcGxheWAgcmVxdWVzdCwgb25seSBsb2cgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwiXCIuY29uY2F0KGhhc0F1ZGlvID8gJ2F1ZGlvJyA6ICd2aWRlbycsIFwiIHBsYXliYWNrIGFib3J0ZWQsIGxpa2VseSBkdWUgdG8gbmV3IHBsYXkgcmVxdWVzdFwiKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oXCJjb3VsZCBub3QgcGxheWJhY2sgXCIuY29uY2F0KGhhc0F1ZGlvID8gJ2F1ZGlvJyA6ICd2aWRlbycpLCBlKTtcbiAgICAgIH1cbiAgICAgIC8vIElmIGF1ZGlvIHBsYXliYWNrIGlzbid0IGFsbG93ZWQgbWFrZSBzdXJlIHdlIHN0aWxsIHBsYXkgYmFjayB0aGUgdmlkZW9cbiAgICAgIGlmIChoYXNBdWRpbyAmJiBlbGVtZW50ICYmIGFsbE1lZGlhU3RyZWFtVHJhY2tzLnNvbWUodHIgPT4gdHIua2luZCA9PT0gJ3ZpZGVvJykgJiYgZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICBlbGVtZW50Lm11dGVkID0gdHJ1ZTtcbiAgICAgICAgZWxlbWVudC5wbGF5KCkuY2F0Y2goKCkgPT4ge1xuICAgICAgICAgIC8vIGNhdGNoIGZvciBTYWZhcmksIGV4Y2VlZGVkIG9wdGlvbnMgYXQgdGhpcyBwb2ludCB0byBhdXRvbWF0aWNhbGx5IHBsYXkgdGhlIG1lZGlhIGVsZW1lbnRcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudEF0dGFjaGVkLCBlbGVtZW50KTtcbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBkZXRhY2goZWxlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICAvLyBkZXRhY2ggZnJvbSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICBpZiAoZWxlbWVudCkge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsZW1lbnQpO1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMuaW5kZXhPZihlbGVtZW50KTtcbiAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgIHRoaXMucmVjeWNsZUVsZW1lbnQoZWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRWxlbWVudERldGFjaGVkLCBlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGRldGFjaGVkID0gW107XG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbG0gPT4ge1xuICAgICAgICBkZXRhY2hUcmFjayh0aGlzLm1lZGlhU3RyZWFtVHJhY2ssIGVsbSk7XG4gICAgICAgIGRldGFjaGVkLnB1c2goZWxtKTtcbiAgICAgICAgdGhpcy5yZWN5Y2xlRWxlbWVudChlbG0pO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbGVtZW50RGV0YWNoZWQsIGVsbSk7XG4gICAgICB9KTtcbiAgICAgIC8vIHJlbW92ZSBhbGwgdHJhY2tzXG4gICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMgPSBbXTtcbiAgICAgIHJldHVybiBkZXRhY2hlZDtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhpcy5yZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB0aGlzLnN0b3BNb25pdG9yKCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IHRydWU7XG4gIH1cbiAgZGlzYWJsZSgpIHtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc3RvcE1vbml0b3IoKSB7XG4gICAgaWYgKHRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICBjbGVhckludGVydmFsKHRoaXMubW9uaXRvckludGVydmFsKTtcbiAgICB9XG4gICAgaWYgKHRoaXMudGltZVN5bmNIYW5kbGUpIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudGltZVN5bmNIYW5kbGUpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUxvZ2dlck9wdGlvbnMobG9nZ2VyT3B0aW9ucykge1xuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpIHtcbiAgICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSk7XG4gICAgfVxuICAgIGlmIChsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYikge1xuICAgICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB9XG4gIH1cbiAgcmVjeWNsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIGlmIChlbGVtZW50IGluc3RhbmNlb2YgSFRNTEF1ZGlvRWxlbWVudCkge1xuICAgICAgLy8gd2Ugb25seSBuZWVkIHRvIHJlLXVzZSBhIHNpbmdsZSBlbGVtZW50XG4gICAgICBsZXQgc2hvdWxkQ2FjaGUgPSB0cnVlO1xuICAgICAgZWxlbWVudC5wYXVzZSgpO1xuICAgICAgcmVjeWNsZWRFbGVtZW50cy5mb3JFYWNoKGUgPT4ge1xuICAgICAgICBpZiAoIWUucGFyZW50RWxlbWVudCkge1xuICAgICAgICAgIHNob3VsZENhY2hlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3VsZENhY2hlKSB7XG4gICAgICAgIHJlY3ljbGVkRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuaXNJbkJhY2tncm91bmQgPSBkb2N1bWVudC52aXNpYmlsaXR5U3RhdGUgPT09ICdoaWRkZW4nO1xuICAgICAgaWYgKCF0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IGVsLnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyoqIGNhdGNoIGNsYXVzZSBuZWNlc3NhcnkgZm9yIFNhZmFyaSAqL1xuICAgICAgICB9KSksIDApO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lcigpIHtcbiAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGRvY3VtZW50LnZpc2liaWxpdHlTdGF0ZSA9PT0gJ2hpZGRlbic7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd2aXNpYmlsaXR5Y2hhbmdlJywgdGhpcy5hcHBWaXNpYmlsaXR5Q2hhbmdlZExpc3RlbmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pc0luQmFja2dyb3VuZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZW1vdmVBcHBWaXNpYmlsaXR5TGlzdGVuZXIoKSB7XG4gICAgaWYgKGlzV2ViKCkpIHtcbiAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCB0aGlzLmFwcFZpc2liaWxpdHlDaGFuZ2VkTGlzdGVuZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoVG9FbGVtZW50KHRyYWNrLCBlbGVtZW50KSB7XG4gIGxldCBtZWRpYVN0cmVhbTtcbiAgaWYgKGVsZW1lbnQuc3JjT2JqZWN0IGluc3RhbmNlb2YgTWVkaWFTdHJlYW0pIHtcbiAgICBtZWRpYVN0cmVhbSA9IGVsZW1lbnQuc3JjT2JqZWN0O1xuICB9IGVsc2Uge1xuICAgIG1lZGlhU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gIH1cbiAgLy8gY2hlY2sgaWYgdHJhY2sgbWF0Y2hlcyBleGlzdGluZyB0cmFja1xuICBsZXQgZXhpc3RpbmdUcmFja3M7XG4gIGlmICh0cmFjay5raW5kID09PSAnYXVkaW8nKSB7XG4gICAgZXhpc3RpbmdUcmFja3MgPSBtZWRpYVN0cmVhbS5nZXRBdWRpb1RyYWNrcygpO1xuICB9IGVsc2Uge1xuICAgIGV4aXN0aW5nVHJhY2tzID0gbWVkaWFTdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgfVxuICBpZiAoIWV4aXN0aW5nVHJhY2tzLmluY2x1ZGVzKHRyYWNrKSkge1xuICAgIGV4aXN0aW5nVHJhY2tzLmZvckVhY2goZXQgPT4ge1xuICAgICAgbWVkaWFTdHJlYW0ucmVtb3ZlVHJhY2soZXQpO1xuICAgIH0pO1xuICAgIG1lZGlhU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBpZiAoIWlzU2FmYXJpKCkgfHwgIShlbGVtZW50IGluc3RhbmNlb2YgSFRNTFZpZGVvRWxlbWVudCkpIHtcbiAgICAvLyB3aGVuIGluIGxvdyBwb3dlciBtb2RlIChhcHBsaWVzIHRvIGJvdGggbWFjT1MgYW5kIGlPUyksIFNhZmFyaSB3aWxsIHNob3cgYSBwbGF5L3BhdXNlIG92ZXJsYXlcbiAgICAvLyB3aGVuIGEgdmlkZW8gc3RhcnRzIHRoYXQgaGFzIHRoZSBgYXV0b3BsYXlgIGF0dHJpYnV0ZSBpcyBzZXQuXG4gICAgLy8gd2Ugd29yayBhcm91bmQgdGhpcyBieSBfbm90XyBzZXR0aW5nIHRoZSBhdXRvcGxheSBhdHRyaWJ1dGUgb24gc2FmYXJpIGFuZCBpbnN0ZWFkIGNhbGwgYHNldFRpbWVvdXQoKCkgPT4gZWwucGxheSgpLDApYCBmdXJ0aGVyIGRvd25cbiAgICBlbGVtZW50LmF1dG9wbGF5ID0gdHJ1ZTtcbiAgfVxuICAvLyBJbiBjYXNlIHRoZXJlIGFyZSBubyBhdWRpbyB0cmFja3MgcHJlc2VudCBvbiB0aGUgbWVkaWFzdHJlYW0sIHdlIHNldCB0aGUgZWxlbWVudCBhcyBtdXRlZCB0byBlbnN1cmUgYXV0b3BsYXkgd29ya3NcbiAgZWxlbWVudC5tdXRlZCA9IG1lZGlhU3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID09PSAwO1xuICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICBlbGVtZW50LnBsYXlzSW5saW5lID0gdHJ1ZTtcbiAgfVxuICAvLyBhdm9pZCBmbGlja2VyXG4gIGlmIChlbGVtZW50LnNyY09iamVjdCAhPT0gbWVkaWFTdHJlYW0pIHtcbiAgICBlbGVtZW50LnNyY09iamVjdCA9IG1lZGlhU3RyZWFtO1xuICAgIGlmICgoaXNTYWZhcmkoKSB8fCBpc0ZpcmVGb3goKSkgJiYgZWxlbWVudCBpbnN0YW5jZW9mIEhUTUxWaWRlb0VsZW1lbnQpIHtcbiAgICAgIC8vIEZpcmVmb3ggYWxzbyBoYXMgYSB0aW1pbmcgaXNzdWUgd2hlcmUgdmlkZW8gZG9lc24ndCBhY3R1YWxseSBnZXQgYXR0YWNoZWQgdW5sZXNzXG4gICAgICAvLyBwZXJmb3JtZWQgb3V0LW9mLWJhbmRcbiAgICAgIC8vIFNhZmFyaSAxNSBoYXMgYSBidWcgd2hlcmUgaW4gY2VydGFpbiBsYXlvdXRzLCB2aWRlbyBlbGVtZW50IHJlbmRlcnNcbiAgICAgIC8vIGJsYWNrIHVudGlsIHRoZSBwYWdlIGlzIHJlc2l6ZWQgb3Igb3RoZXIgY2hhbmdlcyB0YWtlIHBsYWNlLlxuICAgICAgLy8gUmVzZXR0aW5nIHRoZSBzcmMgdHJpZ2dlcnMgaXQgdG8gcmVuZGVyLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuYXBwbGUuY29tL2ZvcnVtcy90aHJlYWQvNjkwNTIzXG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgZWxlbWVudC5zcmNPYmplY3QgPSBtZWRpYVN0cmVhbTtcbiAgICAgICAgLy8gU2FmYXJpIDE1IHNvbWV0aW1lcyBmYWlscyB0byBzdGFydCBhIHZpZGVvXG4gICAgICAgIC8vIHdoZW4gdGhlIHdpbmRvdyBpcyBiYWNrZ3JvdW5kZWQgYmVmb3JlIHRoZSBmaXJzdCBmcmFtZSBpcyBkcmF3blxuICAgICAgICAvLyBtYW51YWxseSBjYWxsaW5nIHBsYXkgaGVyZSBzZWVtcyB0byBmaXggdGhhdFxuICAgICAgICBlbGVtZW50LnBsYXkoKS5jYXRjaCgoKSA9PiB7XG4gICAgICAgICAgLyoqIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgfSk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gIH1cbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGRldGFjaFRyYWNrKHRyYWNrLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50LnNyY09iamVjdCBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtKSB7XG4gICAgY29uc3QgbWVkaWFTdHJlYW0gPSBlbGVtZW50LnNyY09iamVjdDtcbiAgICBtZWRpYVN0cmVhbS5yZW1vdmVUcmFjayh0cmFjayk7XG4gICAgaWYgKG1lZGlhU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbWVkaWFTdHJlYW07XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuc3JjT2JqZWN0ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cbihmdW5jdGlvbiAoVHJhY2spIHtcbiAgbGV0IEtpbmQ7XG4gIChmdW5jdGlvbiAoS2luZCkge1xuICAgIEtpbmRbXCJBdWRpb1wiXSA9IFwiYXVkaW9cIjtcbiAgICBLaW5kW1wiVmlkZW9cIl0gPSBcInZpZGVvXCI7XG4gICAgS2luZFtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbiAgfSkoS2luZCA9IFRyYWNrLktpbmQgfHwgKFRyYWNrLktpbmQgPSB7fSkpO1xuICBsZXQgU291cmNlO1xuICAoZnVuY3Rpb24gKFNvdXJjZSkge1xuICAgIFNvdXJjZVtcIkNhbWVyYVwiXSA9IFwiY2FtZXJhXCI7XG4gICAgU291cmNlW1wiTWljcm9waG9uZVwiXSA9IFwibWljcm9waG9uZVwiO1xuICAgIFNvdXJjZVtcIlNjcmVlblNoYXJlXCJdID0gXCJzY3JlZW5fc2hhcmVcIjtcbiAgICBTb3VyY2VbXCJTY3JlZW5TaGFyZUF1ZGlvXCJdID0gXCJzY3JlZW5fc2hhcmVfYXVkaW9cIjtcbiAgICBTb3VyY2VbXCJVbmtub3duXCJdID0gXCJ1bmtub3duXCI7XG4gIH0pKFNvdXJjZSA9IFRyYWNrLlNvdXJjZSB8fCAoVHJhY2suU291cmNlID0ge30pKTtcbiAgbGV0IFN0cmVhbVN0YXRlJDE7XG4gIChmdW5jdGlvbiAoU3RyZWFtU3RhdGUpIHtcbiAgICBTdHJlYW1TdGF0ZVtcIkFjdGl2ZVwiXSA9IFwiYWN0aXZlXCI7XG4gICAgU3RyZWFtU3RhdGVbXCJQYXVzZWRcIl0gPSBcInBhdXNlZFwiO1xuICAgIFN0cmVhbVN0YXRlW1wiVW5rbm93blwiXSA9IFwidW5rbm93blwiO1xuICB9KShTdHJlYW1TdGF0ZSQxID0gVHJhY2suU3RyZWFtU3RhdGUgfHwgKFRyYWNrLlN0cmVhbVN0YXRlID0ge30pKTtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBraW5kVG9Qcm90byhrKSB7XG4gICAgc3dpdGNoIChrKSB7XG4gICAgICBjYXNlIEtpbmQuQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuQVVESU87XG4gICAgICBjYXNlIEtpbmQuVmlkZW86XG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuVklERU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBGSVhNRSB0aGlzIHdhcyBVTlJFQ09HTklaRUQgYmVmb3JlXG4gICAgICAgIHJldHVybiBUcmFja1R5cGUuREFUQTtcbiAgICB9XG4gIH1cbiAgVHJhY2sua2luZFRvUHJvdG8gPSBraW5kVG9Qcm90bztcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBmdW5jdGlvbiBraW5kRnJvbVByb3RvKHQpIHtcbiAgICBzd2l0Y2ggKHQpIHtcbiAgICAgIGNhc2UgVHJhY2tUeXBlLkFVRElPOlxuICAgICAgICByZXR1cm4gS2luZC5BdWRpbztcbiAgICAgIGNhc2UgVHJhY2tUeXBlLlZJREVPOlxuICAgICAgICByZXR1cm4gS2luZC5WaWRlbztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBLaW5kLlVua25vd247XG4gICAgfVxuICB9XG4gIFRyYWNrLmtpbmRGcm9tUHJvdG8gPSBraW5kRnJvbVByb3RvO1xuICAvKiogQGludGVybmFsICovXG4gIGZ1bmN0aW9uIHNvdXJjZVRvUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBTb3VyY2UuQ2FtZXJhOlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuQ0FNRVJBO1xuICAgICAgY2FzZSBTb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU7XG4gICAgICBjYXNlIFNvdXJjZS5TY3JlZW5TaGFyZTpcbiAgICAgICAgcmV0dXJuIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRTtcbiAgICAgIGNhc2UgU291cmNlLlNjcmVlblNoYXJlQXVkaW86XG4gICAgICAgIHJldHVybiBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkVfQVVESU87XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gVHJhY2tTb3VyY2UuVU5LTk9XTjtcbiAgICB9XG4gIH1cbiAgVHJhY2suc291cmNlVG9Qcm90byA9IHNvdXJjZVRvUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc291cmNlRnJvbVByb3RvKHMpIHtcbiAgICBzd2l0Y2ggKHMpIHtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuQ0FNRVJBOlxuICAgICAgICByZXR1cm4gU291cmNlLkNhbWVyYTtcbiAgICAgIGNhc2UgVHJhY2tTb3VyY2UuTUlDUk9QSE9ORTpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5NaWNyb3Bob25lO1xuICAgICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICAgIHJldHVybiBTb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICBjYXNlIFRyYWNrU291cmNlLlNDUkVFTl9TSEFSRV9BVURJTzpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFNvdXJjZS5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5zb3VyY2VGcm9tUHJvdG8gPSBzb3VyY2VGcm9tUHJvdG87XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZnVuY3Rpb24gc3RyZWFtU3RhdGVGcm9tUHJvdG8ocykge1xuICAgIHN3aXRjaCAocykge1xuICAgICAgY2FzZSBTdHJlYW1TdGF0ZS5BQ1RJVkU6XG4gICAgICAgIHJldHVybiBTdHJlYW1TdGF0ZSQxLkFjdGl2ZTtcbiAgICAgIGNhc2UgU3RyZWFtU3RhdGUuUEFVU0VEOlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5QYXVzZWQ7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gU3RyZWFtU3RhdGUkMS5Vbmtub3duO1xuICAgIH1cbiAgfVxuICBUcmFjay5zdHJlYW1TdGF0ZUZyb21Qcm90byA9IHN0cmVhbVN0YXRlRnJvbVByb3RvO1xufSkoVHJhY2sgfHwgKFRyYWNrID0ge30pKTtcblxuY2xhc3MgVmlkZW9QcmVzZXQge1xuICBjb25zdHJ1Y3Rvcih3aWR0aE9yT3B0aW9ucywgaGVpZ2h0LCBtYXhCaXRyYXRlLCBtYXhGcmFtZXJhdGUsIHByaW9yaXR5KSB7XG4gICAgaWYgKHR5cGVvZiB3aWR0aE9yT3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aE9yT3B0aW9ucy53aWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gd2lkdGhPck9wdGlvbnMuaGVpZ2h0O1xuICAgICAgdGhpcy5hc3BlY3RSYXRpbyA9IHdpZHRoT3JPcHRpb25zLmFzcGVjdFJhdGlvO1xuICAgICAgdGhpcy5lbmNvZGluZyA9IHtcbiAgICAgICAgbWF4Qml0cmF0ZTogd2lkdGhPck9wdGlvbnMubWF4Qml0cmF0ZSxcbiAgICAgICAgbWF4RnJhbWVyYXRlOiB3aWR0aE9yT3B0aW9ucy5tYXhGcmFtZXJhdGUsXG4gICAgICAgIHByaW9yaXR5OiB3aWR0aE9yT3B0aW9ucy5wcmlvcml0eVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGhlaWdodCAhPT0gdW5kZWZpbmVkICYmIG1heEJpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoT3JPcHRpb25zO1xuICAgICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmFzcGVjdFJhdGlvID0gd2lkdGhPck9wdGlvbnMgLyBoZWlnaHQ7XG4gICAgICB0aGlzLmVuY29kaW5nID0ge1xuICAgICAgICBtYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGUsXG4gICAgICAgIHByaW9yaXR5XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbnN1cHBvcnRlZCBvcHRpb25zOiBwcm92aWRlIGF0IGxlYXN0IHdpZHRoLCBoZWlnaHQgYW5kIG1heEJpdHJhdGUnKTtcbiAgICB9XG4gIH1cbiAgZ2V0IHJlc29sdXRpb24oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB0aGlzLndpZHRoLFxuICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgIGZyYW1lUmF0ZTogdGhpcy5lbmNvZGluZy5tYXhGcmFtZXJhdGUsXG4gICAgICBhc3BlY3RSYXRpbzogdGhpcy5hc3BlY3RSYXRpb1xuICAgIH07XG4gIH1cbn1cbmNvbnN0IGJhY2t1cENvZGVjcyA9IFsndnA4JywgJ2gyNjQnXTtcbmNvbnN0IHZpZGVvQ29kZWNzID0gWyd2cDgnLCAnaDI2NCcsICd2cDknLCAnYXYxJ107XG5mdW5jdGlvbiBpc0JhY2t1cENvZGVjKGNvZGVjKSB7XG4gIHJldHVybiAhIWJhY2t1cENvZGVjcy5maW5kKGJhY2t1cCA9PiBiYWNrdXAgPT09IGNvZGVjKTtcbn1cbnZhciBCYWNrdXBDb2RlY1BvbGljeTtcbihmdW5jdGlvbiAoQmFja3VwQ29kZWNQb2xpY3kpIHtcbiAgLy8gY29kZWMgcmVncmVzc2lvbiBpcyBwcmVmZXJyZWQsIHRoZSBzZnUgd2lsbCB0cnkgdG8gcmVncmVzcyBjb2RlYyBpZiBwb3NzaWJsZSBidXQgbm90IGd1YXJhbnRlZWRcbiAgQmFja3VwQ29kZWNQb2xpY3lbQmFja3VwQ29kZWNQb2xpY3lbXCJQUkVGRVJfUkVHUkVTU0lPTlwiXSA9IDBdID0gXCJQUkVGRVJfUkVHUkVTU0lPTlwiO1xuICAvLyBtdWx0aS1jb2RlYyBzaW11bGNhc3QsIHB1Ymxpc2ggYm90aCBwcmltYXJ5IGFuZCBiYWNrdXAgY29kZWMgYXQgdGhlIHNhbWUgdGltZVxuICBCYWNrdXBDb2RlY1BvbGljeVtCYWNrdXBDb2RlY1BvbGljeVtcIlNJTVVMQ0FTVFwiXSA9IDFdID0gXCJTSU1VTENBU1RcIjtcbiAgLy8gYWx3YXlzIHVzZSBiYWNrdXAgY29kZWMgb25seVxuICBCYWNrdXBDb2RlY1BvbGljeVtCYWNrdXBDb2RlY1BvbGljeVtcIlJFR1JFU1NJT05cIl0gPSAyXSA9IFwiUkVHUkVTU0lPTlwiO1xufSkoQmFja3VwQ29kZWNQb2xpY3kgfHwgKEJhY2t1cENvZGVjUG9saWN5ID0ge30pKTtcbnZhciBBdWRpb1ByZXNldHM7XG4oZnVuY3Rpb24gKEF1ZGlvUHJlc2V0cykge1xuICBBdWRpb1ByZXNldHMudGVsZXBob25lID0ge1xuICAgIG1heEJpdHJhdGU6IDEyMDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5zcGVlY2ggPSB7XG4gICAgbWF4Qml0cmF0ZTogMjQwMDBcbiAgfTtcbiAgQXVkaW9QcmVzZXRzLm11c2ljID0ge1xuICAgIG1heEJpdHJhdGU6IDQ4MDAwXG4gIH07XG4gIEF1ZGlvUHJlc2V0cy5tdXNpY1N0ZXJlbyA9IHtcbiAgICBtYXhCaXRyYXRlOiA2NDAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWNIaWdoUXVhbGl0eSA9IHtcbiAgICBtYXhCaXRyYXRlOiA5NjAwMFxuICB9O1xuICBBdWRpb1ByZXNldHMubXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyA9IHtcbiAgICBtYXhCaXRyYXRlOiAxMjgwMDBcbiAgfTtcbn0pKEF1ZGlvUHJlc2V0cyB8fCAoQXVkaW9QcmVzZXRzID0ge30pKTtcbi8qKlxuICogU2FuZSBwcmVzZXRzIGZvciB2aWRlbyByZXNvbHV0aW9uL2VuY29kaW5nXG4gKi9cbmNvbnN0IFZpZGVvUHJlc2V0cyA9IHtcbiAgaDkwOiBuZXcgVmlkZW9QcmVzZXQoMTYwLCA5MCwgOTAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMTgwLCAxNjAwMDAsIDIwKSxcbiAgaDIxNjogbmV3IFZpZGVvUHJlc2V0KDM4NCwgMjE2LCAxODAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0NTAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNTQwLCA4MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDEyODAsIDcyMCwgMTcwMDAwMCwgMzApLFxuICBoMTA4MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDEwODAsIDMwMDAwMDAsIDMwKSxcbiAgaDE0NDA6IG5ldyBWaWRlb1ByZXNldCgyNTYwLCAxNDQwLCA1MDAwMDAwLCAzMCksXG4gIGgyMTYwOiBuZXcgVmlkZW9QcmVzZXQoMzg0MCwgMjE2MCwgODAwMDAwMCwgMzApXG59O1xuLyoqXG4gKiBGb3VyIGJ5IHRocmVlIHByZXNldHNcbiAqL1xuY29uc3QgVmlkZW9QcmVzZXRzNDMgPSB7XG4gIGgxMjA6IG5ldyBWaWRlb1ByZXNldCgxNjAsIDEyMCwgNzAwMDAsIDIwKSxcbiAgaDE4MDogbmV3IFZpZGVvUHJlc2V0KDI0MCwgMTgwLCAxMjUwMDAsIDIwKSxcbiAgaDI0MDogbmV3IFZpZGVvUHJlc2V0KDMyMCwgMjQwLCAxNDAwMDAsIDIwKSxcbiAgaDM2MDogbmV3IFZpZGVvUHJlc2V0KDQ4MCwgMzYwLCAzMzAwMDAsIDIwKSxcbiAgaDQ4MDogbmV3IFZpZGVvUHJlc2V0KDY0MCwgNDgwLCA1MDAwMDAsIDIwKSxcbiAgaDU0MDogbmV3IFZpZGVvUHJlc2V0KDcyMCwgNTQwLCA2MDAwMDAsIDI1KSxcbiAgaDcyMDogbmV3IFZpZGVvUHJlc2V0KDk2MCwgNzIwLCAxMzAwMDAwLCAzMCksXG4gIGgxMDgwOiBuZXcgVmlkZW9QcmVzZXQoMTQ0MCwgMTA4MCwgMjMwMDAwMCwgMzApLFxuICBoMTQ0MDogbmV3IFZpZGVvUHJlc2V0KDE5MjAsIDE0NDAsIDM4MDAwMDAsIDMwKVxufTtcbmNvbnN0IFNjcmVlblNoYXJlUHJlc2V0cyA9IHtcbiAgaDM2MGZwczM6IG5ldyBWaWRlb1ByZXNldCg2NDAsIDM2MCwgMjAwMDAwLCAzLCAnbWVkaXVtJyksXG4gIGgzNjBmcHMxNTogbmV3IFZpZGVvUHJlc2V0KDY0MCwgMzYwLCA0MDAwMDAsIDE1LCAnbWVkaXVtJyksXG4gIGg3MjBmcHM1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCA4MDAwMDAsIDUsICdtZWRpdW0nKSxcbiAgaDcyMGZwczE1OiBuZXcgVmlkZW9QcmVzZXQoMTI4MCwgNzIwLCAxNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoNzIwZnBzMzA6IG5ldyBWaWRlb1ByZXNldCgxMjgwLCA3MjAsIDIwMDAwMDAsIDMwLCAnbWVkaXVtJyksXG4gIGgxMDgwZnBzMTU6IG5ldyBWaWRlb1ByZXNldCgxOTIwLCAxMDgwLCAyNTAwMDAwLCAxNSwgJ21lZGl1bScpLFxuICBoMTA4MGZwczMwOiBuZXcgVmlkZW9QcmVzZXQoMTkyMCwgMTA4MCwgNTAwMDAwMCwgMzAsICdtZWRpdW0nKSxcbiAgLy8gb3JpZ2luYWwgcmVzb2x1dGlvbiwgd2l0aG91dCByZXNpemluZ1xuICBvcmlnaW5hbDogbmV3IFZpZGVvUHJlc2V0KDAsIDAsIDcwMDAwMDAsIDMwLCAnbWVkaXVtJylcbn07XG5cbmNvbnN0IHNlcGFyYXRvciA9ICd8JztcbmNvbnN0IGRkRXh0ZW5zaW9uVVJJID0gJ2h0dHBzOi8vYW9tZWRpYWNvZGVjLmdpdGh1Yi5pby9hdjEtcnRwLXNwZWMvI2RlcGVuZGVuY3ktZGVzY3JpcHRvci1ydHAtaGVhZGVyLWV4dGVuc2lvbic7XG5mdW5jdGlvbiB1bnBhY2tTdHJlYW1JZChwYWNrZWQpIHtcbiAgY29uc3QgcGFydHMgPSBwYWNrZWQuc3BsaXQoc2VwYXJhdG9yKTtcbiAgaWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcbiAgICByZXR1cm4gW3BhcnRzWzBdLCBwYWNrZWQuc3Vic3RyKHBhcnRzWzBdLmxlbmd0aCArIDEpXTtcbiAgfVxuICByZXR1cm4gW3BhY2tlZCwgJyddO1xufVxuZnVuY3Rpb24gc2xlZXAoZHVyYXRpb24pIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKSk7XG4gIH0pO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gc3VwcG9ydHNUcmFuc2NlaXZlcigpIHtcbiAgcmV0dXJuICdhZGRUcmFuc2NlaXZlcicgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gc3VwcG9ydHNBZGRUcmFjaygpIHtcbiAgcmV0dXJuICdhZGRUcmFjaycgaW4gUlRDUGVlckNvbm5lY3Rpb24ucHJvdG90eXBlO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgcmV0dXJuIHR5cGVvZiBSZXNpemVPYnNlcnZlciAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gc3VwcG9ydHNEeW5hY2FzdCgpIHtcbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzQVYxKCkge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgLy8gU2FmYXJpIDE3IG9uIGlQaG9uZTE0IHJlcG9ydHMgQVYxIGNhcGFiaWxpdHksIGJ1dCBkb2VzIG5vdCBhY3R1YWxseSBzdXBwb3J0IGl0XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNBVjEgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vQVYxJykge1xuICAgICAgICBoYXNBVjEgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc0FWMTtcbn1cbmZ1bmN0aW9uIHN1cHBvcnRzVlA5KCkge1xuICBpZiAoISgnZ2V0Q2FwYWJpbGl0aWVzJyBpbiBSVENSdHBTZW5kZXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChpc0ZpcmVGb3goKSkge1xuICAgIC8vIHRlY2huaWNhbGx5IHNwZWFraW5nIEZpcmVGb3ggc3VwcG9ydHMgVlA5LCBidXQgU1ZDIHB1Ymxpc2hpbmcgaXMgYnJva2VuXG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTYzMzg3NlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaXNTYWZhcmkoKSkge1xuICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIudmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIudmVyc2lvbiwgJzE2JykgPCAwKSB7XG4gICAgICAvLyBTYWZhcmkgMTYgYW5kIGJlbG93IGRvZXMgbm90IHN1cHBvcnQgVlA5XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIGNvbnN0IGNhcGFiaWxpdGllcyA9IFJUQ1J0cFNlbmRlci5nZXRDYXBhYmlsaXRpZXMoJ3ZpZGVvJyk7XG4gIGxldCBoYXNWUDkgPSBmYWxzZTtcbiAgaWYgKGNhcGFiaWxpdGllcykge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2YgY2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgaWYgKGNvZGVjLm1pbWVUeXBlID09PSAndmlkZW8vVlA5Jykge1xuICAgICAgICBoYXNWUDkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGhhc1ZQOTtcbn1cbmZ1bmN0aW9uIGlzU1ZDQ29kZWMoY29kZWMpIHtcbiAgcmV0dXJuIGNvZGVjID09PSAnYXYxJyB8fCBjb2RlYyA9PT0gJ3ZwOSc7XG59XG5mdW5jdGlvbiBzdXBwb3J0c1NldFNpbmtJZChlbG0pIHtcbiAgaWYgKCFkb2N1bWVudCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoIWVsbSkge1xuICAgIGVsbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2F1ZGlvJyk7XG4gIH1cbiAgcmV0dXJuICdzZXRTaW5rSWQnIGluIGVsbTtcbn1cbmZ1bmN0aW9uIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgaWYgKHR5cGVvZiBSVENQZWVyQ29ubmVjdGlvbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHN1cHBvcnRzVHJhbnNjZWl2ZXIoKSB8fCBzdXBwb3J0c0FkZFRyYWNrKCk7XG59XG5mdW5jdGlvbiBpc0ZpcmVGb3goKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ0ZpcmVmb3gnO1xufVxuZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gIHZhciBfYTtcbiAgcmV0dXJuICgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSA9PT0gJ1NhZmFyaSc7XG59XG5mdW5jdGlvbiBpc1NhZmFyaTE3KCkge1xuICBjb25zdCBiID0gZ2V0QnJvd3NlcigpO1xuICByZXR1cm4gKGIgPT09IG51bGwgfHwgYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogYi5uYW1lKSA9PT0gJ1NhZmFyaScgJiYgYi52ZXJzaW9uLnN0YXJ0c1dpdGgoJzE3LicpO1xufVxuZnVuY3Rpb24gaXNNb2JpbGUoKSB7XG4gIHZhciBfYSwgX2I7XG4gIGlmICghaXNXZWIoKSkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gKFxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgYHVzZXJBZ2VudERhdGFgIGlzIG5vdCB5ZXQgcGFydCBvZiB0eXBlc2NyaXB0XG4gICAgKF9iID0gKF9hID0gbmF2aWdhdG9yLnVzZXJBZ2VudERhdGEpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tb2JpbGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IC9UYWJsZXR8aVBhZHxNb2JpbGV8QW5kcm9pZHxCbGFja0JlcnJ5Ly50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICk7XG59XG5mdW5jdGlvbiBpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQoKSB7XG4gIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gIGNvbnN0IHN1cHBvcnRlZFNhZmFyaVZlcnNpb24gPSAnMTcuMic7IC8vIHNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MjU3ODAzXG4gIGlmIChicm93c2VyKSB7XG4gICAgaWYgKGJyb3dzZXIubmFtZSAhPT0gJ1NhZmFyaScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoYnJvd3Nlci5vcyA9PT0gJ2lPUycgJiYgYnJvd3Nlci5vc1ZlcnNpb24gJiYgY29tcGFyZVZlcnNpb25zKHN1cHBvcnRlZFNhZmFyaVZlcnNpb24sIGJyb3dzZXIub3NWZXJzaW9uKSA+PSAwKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGJyb3dzZXIubmFtZSA9PT0gJ1NhZmFyaScgJiYgY29tcGFyZVZlcnNpb25zKHN1cHBvcnRlZFNhZmFyaVZlcnNpb24sIGJyb3dzZXIudmVyc2lvbikgPj0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGlzV2ViKCkge1xuICByZXR1cm4gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcbn1cbmZ1bmN0aW9uIGlzUmVhY3ROYXRpdmUoKSB7XG4gIC8vIG5hdmlnYXRvci5wcm9kdWN0IGlzIGRlcHJlY2F0ZWQgb24gYnJvd3NlcnMsIGJ1dCB3aWxsIGJlIHNldCBhcHByb3ByaWF0ZWx5IGZvciByZWFjdC1uYXRpdmUuXG4gIHJldHVybiBuYXZpZ2F0b3IucHJvZHVjdCA9PSAnUmVhY3ROYXRpdmUnO1xufVxuZnVuY3Rpb24gaXNDbG91ZChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIHNlcnZlclVybC5ob3N0bmFtZS5lbmRzV2l0aCgnLmxpdmVraXQuY2xvdWQnKSB8fCBzZXJ2ZXJVcmwuaG9zdG5hbWUuZW5kc1dpdGgoJy5saXZla2l0LnJ1bicpO1xufVxuZnVuY3Rpb24gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKSB7XG4gIC8vIGdsb2JhbCBkZWZpbmVkIG9ubHkgZm9yIFJlYWN0TmF0aXZlLlxuICAvLyBAdHMtaWdub3JlXG4gIGlmIChnbG9iYWwgJiYgZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gZ2xvYmFsLkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0UmVhY3ROYXRpdmVPcygpIHtcbiAgaWYgKCFpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgaWYgKGluZm8pIHtcbiAgICByZXR1cm4gaW5mby5wbGF0Zm9ybTtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gZ2V0RGV2aWNlUGl4ZWxSYXRpbygpIHtcbiAgaWYgKGlzV2ViKCkpIHtcbiAgICByZXR1cm4gd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH1cbiAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgIGxldCBpbmZvID0gZ2V0TEtSZWFjdE5hdGl2ZUluZm8oKTtcbiAgICBpZiAoaW5mbykge1xuICAgICAgcmV0dXJuIGluZm8uZGV2aWNlUGl4ZWxSYXRpbztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIDE7XG59XG5mdW5jdGlvbiBjb21wYXJlVmVyc2lvbnModjEsIHYyKSB7XG4gIGNvbnN0IHBhcnRzMSA9IHYxLnNwbGl0KCcuJyk7XG4gIGNvbnN0IHBhcnRzMiA9IHYyLnNwbGl0KCcuJyk7XG4gIGNvbnN0IGsgPSBNYXRoLm1pbihwYXJ0czEubGVuZ3RoLCBwYXJ0czIubGVuZ3RoKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBrOyArK2kpIHtcbiAgICBjb25zdCBwMSA9IHBhcnNlSW50KHBhcnRzMVtpXSwgMTApO1xuICAgIGNvbnN0IHAyID0gcGFyc2VJbnQocGFydHMyW2ldLCAxMCk7XG4gICAgaWYgKHAxID4gcDIpIHJldHVybiAxO1xuICAgIGlmIChwMSA8IHAyKSByZXR1cm4gLTE7XG4gICAgaWYgKGkgPT09IGsgLSAxICYmIHAxID09PSBwMikgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKHYxID09PSAnJyAmJiB2MiAhPT0gJycpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAodjIgPT09ICcnKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIHBhcnRzMS5sZW5ndGggPT0gcGFydHMyLmxlbmd0aCA/IDAgOiBwYXJ0czEubGVuZ3RoIDwgcGFydHMyLmxlbmd0aCA/IC0xIDogMTtcbn1cbmZ1bmN0aW9uIHJvRGlzcGF0Y2hDYWxsYmFjayhlbnRyaWVzKSB7XG4gIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgIGVudHJ5LnRhcmdldC5oYW5kbGVSZXNpemUoZW50cnkpO1xuICB9XG59XG5mdW5jdGlvbiBpb0Rpc3BhdGNoQ2FsbGJhY2soZW50cmllcykge1xuICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICBlbnRyeS50YXJnZXQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQoZW50cnkpO1xuICB9XG59XG5sZXQgcmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0UmVzaXplT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghcmVzaXplT2JzZXJ2ZXIpIHJlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKHJvRGlzcGF0Y2hDYWxsYmFjayk7XG4gIHJldHVybiByZXNpemVPYnNlcnZlcjtcbn07XG5sZXQgaW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSBudWxsO1xuY29uc3QgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAoKSA9PiB7XG4gIGlmICghaW50ZXJzZWN0aW9uT2JzZXJ2ZXIpIHtcbiAgICBpbnRlcnNlY3Rpb25PYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihpb0Rpc3BhdGNoQ2FsbGJhY2ssIHtcbiAgICAgIHJvb3Q6IG51bGwsXG4gICAgICByb290TWFyZ2luOiAnMHB4J1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBpbnRlcnNlY3Rpb25PYnNlcnZlcjtcbn07XG5mdW5jdGlvbiBnZXRDbGllbnRJbmZvKCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGluZm8gPSBuZXcgQ2xpZW50SW5mbyh7XG4gICAgc2RrOiBDbGllbnRJbmZvX1NESy5KUyxcbiAgICBwcm90b2NvbDogcHJvdG9jb2xWZXJzaW9uLFxuICAgIHZlcnNpb25cbiAgfSk7XG4gIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICBpbmZvLm9zID0gKF9hID0gZ2V0UmVhY3ROYXRpdmVPcygpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgfVxuICByZXR1cm4gaW5mbztcbn1cbmxldCBlbXB0eVZpZGVvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eVZpZGVvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlWaWRlb1N0cmVhbVRyYWNrKSB7XG4gICAgZW1wdHlWaWRlb1N0cmVhbVRyYWNrID0gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCk7XG4gIH1cbiAgcmV0dXJuIGVtcHR5VmlkZW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKCkge1xuICBsZXQgd2lkdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDE2O1xuICBsZXQgaGVpZ2h0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxNjtcbiAgbGV0IGVuYWJsZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBsZXQgcGFpbnRDb250ZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIC8vIHRoZSBjYW52YXMgc2l6ZSBpcyBzZXQgdG8gMTYgYnkgZGVmYXVsdCwgYmVjYXVzZSBlbGVjdHJvbiBhcHBzIHNlZW0gdG8gZmFpbCB3aXRoIHNtYWxsZXIgdmFsdWVzXG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gIGlmIChwYWludENvbnRlbnQgJiYgY3R4KSB7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5hcmMod2lkdGggLyAyLCBoZWlnaHQgLyAyLCA1MCwgMCwgTWF0aC5QSSAqIDIsIHRydWUpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICBjdHguZmlsbFN0eWxlID0gJ2dyZXknO1xuICAgIGN0eC5maWxsKCk7XG4gIH1cbiAgLy8gQHRzLWlnbm9yZVxuICBjb25zdCBkdW1teVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gIGNvbnN0IFtkdW1teVRyYWNrXSA9IGR1bW15U3RyZWFtLmdldFRyYWNrcygpO1xuICBpZiAoIWR1bW15VHJhY2spIHtcbiAgICB0aHJvdyBFcnJvcignQ291bGQgbm90IGdldCBlbXB0eSBtZWRpYSBzdHJlYW0gdmlkZW8gdHJhY2snKTtcbiAgfVxuICBkdW1teVRyYWNrLmVuYWJsZWQgPSBlbmFibGVkO1xuICByZXR1cm4gZHVtbXlUcmFjaztcbn1cbmxldCBlbXB0eUF1ZGlvU3RyZWFtVHJhY2s7XG5mdW5jdGlvbiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSB7XG4gIGlmICghZW1wdHlBdWRpb1N0cmVhbVRyYWNrKSB7XG4gICAgLy8gaW1wbGVtZW50YXRpb24gYWRhcHRlZCBmcm9tIGh0dHBzOi8vYmxvZy5tb3ppbGxhLm9yZy93ZWJydGMvd2FybS11cC13aXRoLXJlcGxhY2V0cmFjay9cbiAgICBjb25zdCBjdHggPSBuZXcgQXVkaW9Db250ZXh0KCk7XG4gICAgY29uc3Qgb3NjaWxsYXRvciA9IGN0eC5jcmVhdGVPc2NpbGxhdG9yKCk7XG4gICAgY29uc3QgZ2FpbiA9IGN0eC5jcmVhdGVHYWluKCk7XG4gICAgZ2Fpbi5nYWluLnNldFZhbHVlQXRUaW1lKDAsIDApO1xuICAgIGNvbnN0IGRzdCA9IGN0eC5jcmVhdGVNZWRpYVN0cmVhbURlc3RpbmF0aW9uKCk7XG4gICAgb3NjaWxsYXRvci5jb25uZWN0KGdhaW4pO1xuICAgIGdhaW4uY29ubmVjdChkc3QpO1xuICAgIG9zY2lsbGF0b3Iuc3RhcnQoKTtcbiAgICBbZW1wdHlBdWRpb1N0cmVhbVRyYWNrXSA9IGRzdC5zdHJlYW0uZ2V0QXVkaW9UcmFja3MoKTtcbiAgICBpZiAoIWVtcHR5QXVkaW9TdHJlYW1UcmFjaykge1xuICAgICAgdGhyb3cgRXJyb3IoJ0NvdWxkIG5vdCBnZXQgZW1wdHkgbWVkaWEgc3RyZWFtIGF1ZGlvIHRyYWNrJyk7XG4gICAgfVxuICAgIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5lbmFibGVkID0gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIGVtcHR5QXVkaW9TdHJlYW1UcmFjay5jbG9uZSgpO1xufVxuY2xhc3MgRnV0dXJlIHtcbiAgY29uc3RydWN0b3IoZnV0dXJlQmFzZSwgb25GaW5hbGx5KSB7XG4gICAgdGhpcy5vbkZpbmFsbHkgPSBvbkZpbmFsbHk7XG4gICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgaWYgKGZ1dHVyZUJhc2UpIHtcbiAgICAgICAgeWllbGQgZnV0dXJlQmFzZShyZXNvbHZlLCByZWplY3QpO1xuICAgICAgfVxuICAgIH0pKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9uRmluYWxseSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhbiBhbmFseXNlciB3ZWIgYXVkaW8gbm9kZSB0aGF0IGlzIGF0dGFjaGVkIHRvIHRoZSBwcm92aWRlZCB0cmFjay5cbiAqIEFkZGl0aW9uYWxseSByZXR1cm5zIGEgY29udmVuaWVuY2UgbWV0aG9kIGBjYWxjdWxhdGVWb2x1bWVgIHRvIHBlcmZvcm0gaW5zdGFudCB2b2x1bWUgcmVhZGluZ3Mgb24gdGhhdCB0cmFjay5cbiAqIENhbGwgdGhlIHJldHVybmVkIGBjbGVhbnVwYCBmdW5jdGlvbiB0byBjbG9zZSB0aGUgYXVkaW9Db250ZXh0IHRoYXQgaGFzIGJlZW4gY3JlYXRlZCBmb3IgdGhlIGluc3RhbmNlIG9mIHRoaXMgaGVscGVyXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUF1ZGlvQW5hbHlzZXIodHJhY2ssIG9wdGlvbnMpIHtcbiAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oe1xuICAgIGNsb25lVHJhY2s6IGZhbHNlLFxuICAgIGZmdFNpemU6IDIwNDgsXG4gICAgc21vb3RoaW5nVGltZUNvbnN0YW50OiAwLjgsXG4gICAgbWluRGVjaWJlbHM6IC0xMDAsXG4gICAgbWF4RGVjaWJlbHM6IC04MFxuICB9LCBvcHRpb25zKTtcbiAgY29uc3QgYXVkaW9Db250ZXh0ID0gZ2V0TmV3QXVkaW9Db250ZXh0KCk7XG4gIGlmICghYXVkaW9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBdWRpbyBDb250ZXh0IG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyJyk7XG4gIH1cbiAgY29uc3Qgc3RyZWFtVHJhY2sgPSBvcHRzLmNsb25lVHJhY2sgPyB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmNsb25lKCkgOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrO1xuICBjb25zdCBtZWRpYVN0cmVhbVNvdXJjZSA9IGF1ZGlvQ29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShuZXcgTWVkaWFTdHJlYW0oW3N0cmVhbVRyYWNrXSkpO1xuICBjb25zdCBhbmFseXNlciA9IGF1ZGlvQ29udGV4dC5jcmVhdGVBbmFseXNlcigpO1xuICBhbmFseXNlci5taW5EZWNpYmVscyA9IG9wdHMubWluRGVjaWJlbHM7XG4gIGFuYWx5c2VyLm1heERlY2liZWxzID0gb3B0cy5tYXhEZWNpYmVscztcbiAgYW5hbHlzZXIuZmZ0U2l6ZSA9IG9wdHMuZmZ0U2l6ZTtcbiAgYW5hbHlzZXIuc21vb3RoaW5nVGltZUNvbnN0YW50ID0gb3B0cy5zbW9vdGhpbmdUaW1lQ29uc3RhbnQ7XG4gIG1lZGlhU3RyZWFtU291cmNlLmNvbm5lY3QoYW5hbHlzZXIpO1xuICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShhbmFseXNlci5mcmVxdWVuY3lCaW5Db3VudCk7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGVzIHRoZSBjdXJyZW50IHZvbHVtZSBvZiB0aGUgdHJhY2sgaW4gdGhlIHJhbmdlIGZyb20gMCB0byAxXG4gICAqL1xuICBjb25zdCBjYWxjdWxhdGVWb2x1bWUgPSAoKSA9PiB7XG4gICAgYW5hbHlzZXIuZ2V0Qnl0ZUZyZXF1ZW5jeURhdGEoZGF0YUFycmF5KTtcbiAgICBsZXQgc3VtID0gMDtcbiAgICBmb3IgKGNvbnN0IGFtcGxpdHVkZSBvZiBkYXRhQXJyYXkpIHtcbiAgICAgIHN1bSArPSBNYXRoLnBvdyhhbXBsaXR1ZGUgLyAyNTUsIDIpO1xuICAgIH1cbiAgICBjb25zdCB2b2x1bWUgPSBNYXRoLnNxcnQoc3VtIC8gZGF0YUFycmF5Lmxlbmd0aCk7XG4gICAgcmV0dXJuIHZvbHVtZTtcbiAgfTtcbiAgY29uc3QgY2xlYW51cCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICB5aWVsZCBhdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICBpZiAob3B0cy5jbG9uZVRyYWNrKSB7XG4gICAgICBzdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBjYWxjdWxhdGVWb2x1bWUsXG4gICAgYW5hbHlzZXIsXG4gICAgY2xlYW51cFxuICB9O1xufVxuZnVuY3Rpb24gaXNWaWRlb0NvZGVjKG1heWJlQ29kZWMpIHtcbiAgcmV0dXJuIHZpZGVvQ29kZWNzLmluY2x1ZGVzKG1heWJlQ29kZWMpO1xufVxuZnVuY3Rpb24gdW53cmFwQ29uc3RyYWludChjb25zdHJhaW50KSB7XG4gIGlmICh0eXBlb2YgY29uc3RyYWludCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNvbnN0cmFpbnQgPT09ICdudW1iZXInKSB7XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQ7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uc3RyYWludCkpIHtcbiAgICByZXR1cm4gY29uc3RyYWludFswXTtcbiAgfVxuICBpZiAoY29uc3RyYWludC5leGFjdCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnN0cmFpbnQuZXhhY3QpKSB7XG4gICAgICByZXR1cm4gY29uc3RyYWludC5leGFjdFswXTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnN0cmFpbnQuZXhhY3Q7XG4gIH1cbiAgaWYgKGNvbnN0cmFpbnQuaWRlYWwpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb25zdHJhaW50LmlkZWFsKSkge1xuICAgICAgcmV0dXJuIGNvbnN0cmFpbnQuaWRlYWxbMF07XG4gICAgfVxuICAgIHJldHVybiBjb25zdHJhaW50LmlkZWFsO1xuICB9XG4gIHRocm93IEVycm9yKCdjb3VsZCBub3QgdW53cmFwIGNvbnN0cmFpbnQnKTtcbn1cbmZ1bmN0aW9uIHRvV2Vic29ja2V0VXJsKHVybCkge1xuICBpZiAodXJsLnN0YXJ0c1dpdGgoJ2h0dHAnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXihodHRwKS8sICd3cycpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiB0b0h0dHBVcmwodXJsKSB7XG4gIGlmICh1cmwuc3RhcnRzV2l0aCgnd3MnKSkge1xuICAgIHJldHVybiB1cmwucmVwbGFjZSgvXih3cykvLCAnaHR0cCcpO1xuICB9XG4gIHJldHVybiB1cmw7XG59XG5mdW5jdGlvbiBleHRyYWN0VHJhbnNjcmlwdGlvblNlZ21lbnRzKHRyYW5zY3JpcHRpb24sIGZpcnN0UmVjZWl2ZWRUaW1lc01hcCkge1xuICByZXR1cm4gdHJhbnNjcmlwdGlvbi5zZWdtZW50cy5tYXAoX3JlZiA9PiB7XG4gICAgbGV0IHtcbiAgICAgIGlkLFxuICAgICAgdGV4dCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgc3RhcnRUaW1lLFxuICAgICAgZW5kVGltZSxcbiAgICAgIGZpbmFsXG4gICAgfSA9IF9yZWY7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IGZpcnN0UmVjZWl2ZWRUaW1lID0gKF9hID0gZmlyc3RSZWNlaXZlZFRpbWVzTWFwLmdldChpZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IERhdGUubm93KCk7XG4gICAgY29uc3QgbGFzdFJlY2VpdmVkVGltZSA9IERhdGUubm93KCk7XG4gICAgaWYgKGZpbmFsKSB7XG4gICAgICBmaXJzdFJlY2VpdmVkVGltZXNNYXAuZGVsZXRlKGlkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZmlyc3RSZWNlaXZlZFRpbWVzTWFwLnNldChpZCwgZmlyc3RSZWNlaXZlZFRpbWUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgaWQsXG4gICAgICB0ZXh0LFxuICAgICAgc3RhcnRUaW1lOiBOdW1iZXIucGFyc2VJbnQoc3RhcnRUaW1lLnRvU3RyaW5nKCkpLFxuICAgICAgZW5kVGltZTogTnVtYmVyLnBhcnNlSW50KGVuZFRpbWUudG9TdHJpbmcoKSksXG4gICAgICBmaW5hbCxcbiAgICAgIGxhbmd1YWdlLFxuICAgICAgZmlyc3RSZWNlaXZlZFRpbWUsXG4gICAgICBsYXN0UmVjZWl2ZWRUaW1lXG4gICAgfTtcbiAgfSk7XG59XG5mdW5jdGlvbiBleHRyYWN0Q2hhdE1lc3NhZ2UobXNnKSB7XG4gIGNvbnN0IHtcbiAgICBpZCxcbiAgICB0aW1lc3RhbXAsXG4gICAgbWVzc2FnZSxcbiAgICBlZGl0VGltZXN0YW1wXG4gIH0gPSBtc2c7XG4gIHJldHVybiB7XG4gICAgaWQsXG4gICAgdGltZXN0YW1wOiBOdW1iZXIucGFyc2VJbnQodGltZXN0YW1wLnRvU3RyaW5nKCkpLFxuICAgIGVkaXRUaW1lc3RhbXA6IGVkaXRUaW1lc3RhbXAgPyBOdW1iZXIucGFyc2VJbnQoZWRpdFRpbWVzdGFtcC50b1N0cmluZygpKSA6IHVuZGVmaW5lZCxcbiAgICBtZXNzYWdlXG4gIH07XG59XG5mdW5jdGlvbiBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKSB7XG4gIHN3aXRjaCAoZS5yZWFzb24pIHtcbiAgICBjYXNlIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3Q6XG4gICAgICByZXR1cm4gZS5jb250ZXh0O1xuICAgIGNhc2UgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZDpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQ7XG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZDpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLlVTRVJfUkVKRUNURUQ7XG4gICAgY2FzZSBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGU6XG4gICAgICByZXR1cm4gRGlzY29ubmVjdFJlYXNvbi5KT0lOX0ZBSUxVUkU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBEaXNjb25uZWN0UmVhc29uLlVOS05PV05fUkVBU09OO1xuICB9XG59XG4vKiogY29udmVydCBiaWdpbnRzIHRvIG51bWJlcnMgcHJlc2VydmluZyB1bmRlZmluZWQgdmFsdWVzICovXG5mdW5jdGlvbiBiaWdJbnRUb051bWJlcih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IE51bWJlcih2YWx1ZSkgOiB1bmRlZmluZWQ7XG59XG4vKiogY29udmVydCBudW1iZXJzIHRvIGJpZ2ludHMgcHJlc2VydmluZyB1bmRlZmluZWQgdmFsdWVzICovXG5mdW5jdGlvbiBudW1iZXJUb0JpZ0ludCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IEJpZ0ludCh2YWx1ZSkgOiB1bmRlZmluZWQ7XG59XG5mdW5jdGlvbiBpc0xvY2FsVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuICEhdHJhY2sgJiYgISh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spICYmIHRyYWNrLmlzTG9jYWw7XG59XG5mdW5jdGlvbiBpc0F1ZGlvVHJhY2sodHJhY2spIHtcbiAgcmV0dXJuICEhdHJhY2sgJiYgdHJhY2sua2luZCA9PSBUcmFjay5LaW5kLkF1ZGlvO1xufVxuZnVuY3Rpb24gaXNWaWRlb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiAhIXRyYWNrICYmIHRyYWNrLmtpbmQgPT0gVHJhY2suS2luZC5WaWRlbztcbn1cbmZ1bmN0aW9uIGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiBpc0xvY2FsVHJhY2sodHJhY2spICYmIGlzVmlkZW9UcmFjayh0cmFjayk7XG59XG5mdW5jdGlvbiBpc0xvY2FsQXVkaW9UcmFjayh0cmFjaykge1xuICByZXR1cm4gaXNMb2NhbFRyYWNrKHRyYWNrKSAmJiBpc0F1ZGlvVHJhY2sodHJhY2spO1xufVxuZnVuY3Rpb24gaXNSZW1vdGVUcmFjayh0cmFjaykge1xuICByZXR1cm4gISF0cmFjayAmJiAhdHJhY2suaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIGlzUmVtb3RlUHViKHB1Yikge1xuICByZXR1cm4gISFwdWIgJiYgIXB1Yi5pc0xvY2FsO1xufVxuZnVuY3Rpb24gaXNSZW1vdGVWaWRlb1RyYWNrKHRyYWNrKSB7XG4gIHJldHVybiBpc1JlbW90ZVRyYWNrKHRyYWNrKSAmJiBpc1ZpZGVvVHJhY2sodHJhY2spO1xufVxuZnVuY3Rpb24gaXNMb2NhbFBhcnRpY2lwYW50KHApIHtcbiAgcmV0dXJuIHAuaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIGlzUmVtb3RlUGFydGljaXBhbnQocCkge1xuICByZXR1cm4gIXAuaXNMb2NhbDtcbn1cbmZ1bmN0aW9uIHNwbGl0VXRmOChzLCBuKSB7XG4gIC8vIGFkYXB0ZWQgZnJvbSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL2EvNjA0Mzc5N1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGV0IGVuY29kZWQgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUocyk7XG4gIHdoaWxlIChlbmNvZGVkLmxlbmd0aCA+IG4pIHtcbiAgICBsZXQgayA9IG47XG4gICAgd2hpbGUgKGsgPiAwKSB7XG4gICAgICBjb25zdCBieXRlID0gZW5jb2RlZFtrXTtcbiAgICAgIGlmIChieXRlICE9PSB1bmRlZmluZWQgJiYgKGJ5dGUgJiAweGMwKSAhPT0gMHg4MCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGstLTtcbiAgICB9XG4gICAgcmVzdWx0LnB1c2goZW5jb2RlZC5zbGljZSgwLCBrKSk7XG4gICAgZW5jb2RlZCA9IGVuY29kZWQuc2xpY2Uoayk7XG4gIH1cbiAgaWYgKGVuY29kZWQubGVuZ3RoID4gMCkge1xuICAgIHJlc3VsdC5wdXNoKGVuY29kZWQpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cykge1xuICB2YXIgX2EsIF9iO1xuICB2YXIgX2MsIF9kO1xuICBjb25zdCB7XG4gICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IsXG4gICAgYXVkaW9Qcm9jZXNzb3IsXG4gICAgdmlkZW9Qcm9jZXNzb3JcbiAgfSA9IGV4dHJhY3RQcm9jZXNzb3JzRnJvbU9wdGlvbnMob3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDoge30pO1xuICBjb25zdCBkZWZhdWx0QXVkaW9Qcm9jZXNzb3IgPSBhdWRpb0RlZmF1bHRzID09PSBudWxsIHx8IGF1ZGlvRGVmYXVsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF1ZGlvRGVmYXVsdHMucHJvY2Vzc29yO1xuICBjb25zdCBkZWZhdWx0VmlkZW9Qcm9jZXNzb3IgPSB2aWRlb0RlZmF1bHRzID09PSBudWxsIHx8IHZpZGVvRGVmYXVsdHMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpZGVvRGVmYXVsdHMucHJvY2Vzc29yO1xuICBjb25zdCBjbG9uZWRPcHRpb25zID0gb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IgIT09IG51bGwgJiYgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IgIT09IHZvaWQgMCA/IG9wdGlvbnNXaXRob3V0UHJvY2Vzc29yIDoge307XG4gIGlmIChjbG9uZWRPcHRpb25zLmF1ZGlvID09PSB0cnVlKSBjbG9uZWRPcHRpb25zLmF1ZGlvID0ge307XG4gIGlmIChjbG9uZWRPcHRpb25zLnZpZGVvID09PSB0cnVlKSBjbG9uZWRPcHRpb25zLnZpZGVvID0ge307XG4gIC8vIHVzZSBkZWZhdWx0c1xuICBpZiAoY2xvbmVkT3B0aW9ucy5hdWRpbykge1xuICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKGNsb25lZE9wdGlvbnMuYXVkaW8sIGF1ZGlvRGVmYXVsdHMpO1xuICAgIChfYSA9IChfYyA9IGNsb25lZE9wdGlvbnMuYXVkaW8pLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfYy5kZXZpY2VJZCA9IHtcbiAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICB9O1xuICAgIGlmIChhdWRpb1Byb2Nlc3NvciB8fCBkZWZhdWx0QXVkaW9Qcm9jZXNzb3IpIHtcbiAgICAgIGNsb25lZE9wdGlvbnMuYXVkaW8ucHJvY2Vzc29yID0gYXVkaW9Qcm9jZXNzb3IgIT09IG51bGwgJiYgYXVkaW9Qcm9jZXNzb3IgIT09IHZvaWQgMCA/IGF1ZGlvUHJvY2Vzc29yIDogZGVmYXVsdEF1ZGlvUHJvY2Vzc29yO1xuICAgIH1cbiAgfVxuICBpZiAoY2xvbmVkT3B0aW9ucy52aWRlbykge1xuICAgIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKGNsb25lZE9wdGlvbnMudmlkZW8sIHZpZGVvRGVmYXVsdHMpO1xuICAgIChfYiA9IChfZCA9IGNsb25lZE9wdGlvbnMudmlkZW8pLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBfZC5kZXZpY2VJZCA9IHtcbiAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICB9O1xuICAgIGlmICh2aWRlb1Byb2Nlc3NvciB8fCBkZWZhdWx0VmlkZW9Qcm9jZXNzb3IpIHtcbiAgICAgIGNsb25lZE9wdGlvbnMudmlkZW8ucHJvY2Vzc29yID0gdmlkZW9Qcm9jZXNzb3IgIT09IG51bGwgJiYgdmlkZW9Qcm9jZXNzb3IgIT09IHZvaWQgMCA/IHZpZGVvUHJvY2Vzc29yIDogZGVmYXVsdFZpZGVvUHJvY2Vzc29yO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkT3B0aW9ucztcbn1cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0V2l0aG91dE92ZXJ3cml0aW5nKG1haW5PYmplY3QsIG9iamVjdFRvTWVyZ2UpIHtcbiAgT2JqZWN0LmtleXMob2JqZWN0VG9NZXJnZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgIGlmIChtYWluT2JqZWN0W2tleV0gPT09IHVuZGVmaW5lZCkgbWFpbk9iamVjdFtrZXldID0gb2JqZWN0VG9NZXJnZVtrZXldO1xuICB9KTtcbiAgcmV0dXJuIG1haW5PYmplY3Q7XG59XG5mdW5jdGlvbiBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICB2YXIgX2MsIF9kO1xuICBjb25zdCBjb25zdHJhaW50cyA9IHt9O1xuICBpZiAob3B0aW9ucy52aWRlbykge1xuICAgIC8vIGRlZmF1bHQgdmlkZW8gb3B0aW9uc1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGNvbnN0IHZpZGVvT3B0aW9ucyA9IHt9O1xuICAgICAgY29uc3QgdGFyZ2V0ID0gdmlkZW9PcHRpb25zO1xuICAgICAgY29uc3Qgc291cmNlID0gb3B0aW9ucy52aWRlbztcbiAgICAgIE9iamVjdC5rZXlzKHNvdXJjZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgIGNhc2UgJ3Jlc29sdXRpb24nOlxuICAgICAgICAgICAgLy8gZmxhdHRlbiBWaWRlb1Jlc29sdXRpb24gZmllbGRzXG4gICAgICAgICAgICBtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyh0YXJnZXQsIHNvdXJjZS5yZXNvbHV0aW9uKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0cmFpbnRzLnZpZGVvID0gdmlkZW9PcHRpb25zO1xuICAgICAgKF9hID0gKF9jID0gY29uc3RyYWludHMudmlkZW8pLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBfYy5kZXZpY2VJZCA9IHtcbiAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMudmlkZW8gPSBvcHRpb25zLnZpZGVvID8ge1xuICAgICAgICBkZXZpY2VJZDoge1xuICAgICAgICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgICAgICAgfVxuICAgICAgfSA6IGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdHJhaW50cy52aWRlbyA9IGZhbHNlO1xuICB9XG4gIGlmIChvcHRpb25zLmF1ZGlvKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0Jykge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSBvcHRpb25zLmF1ZGlvO1xuICAgICAgKF9iID0gKF9kID0gY29uc3RyYWludHMuYXVkaW8pLmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBfZC5kZXZpY2VJZCA9IHtcbiAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3RyYWludHMuYXVkaW8gPSB7XG4gICAgICAgIGRldmljZUlkOiB7XG4gICAgICAgICAgaWRlYWw6ICdkZWZhdWx0J1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdHJhaW50cy5hdWRpbyA9IGZhbHNlO1xuICB9XG4gIHJldHVybiBjb25zdHJhaW50cztcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHNpbGVuY2Ugb24gYSBnaXZlbiBbW1RyYWNrXV0gaW5zdGFuY2UuXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYWNrIHNlZW1zIHRvIGJlIGVudGlyZWx5IHNpbGVudC5cbiAqL1xuZnVuY3Rpb24gZGV0ZWN0U2lsZW5jZSh0cmFja18xKSB7XG4gIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICh0cmFjaykge1xuICAgIGxldCB0aW1lT2Zmc2V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAyMDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjdHggPSBnZXROZXdBdWRpb0NvbnRleHQoKTtcbiAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgY29uc3QgYW5hbHlzZXIgPSBjdHguY3JlYXRlQW5hbHlzZXIoKTtcbiAgICAgICAgYW5hbHlzZXIuZmZ0U2l6ZSA9IDIwNDg7XG4gICAgICAgIGNvbnN0IGJ1ZmZlckxlbmd0aCA9IGFuYWx5c2VyLmZyZXF1ZW5jeUJpbkNvdW50O1xuICAgICAgICBjb25zdCBkYXRhQXJyYXkgPSBuZXcgVWludDhBcnJheShidWZmZXJMZW5ndGgpO1xuICAgICAgICBjb25zdCBzb3VyY2UgPSBjdHguY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UobmV3IE1lZGlhU3RyZWFtKFt0cmFjay5tZWRpYVN0cmVhbVRyYWNrXSkpO1xuICAgICAgICBzb3VyY2UuY29ubmVjdChhbmFseXNlcik7XG4gICAgICAgIHlpZWxkIHNsZWVwKHRpbWVPZmZzZXQpO1xuICAgICAgICBhbmFseXNlci5nZXRCeXRlVGltZURvbWFpbkRhdGEoZGF0YUFycmF5KTtcbiAgICAgICAgY29uc3Qgc29tZU5vaXNlID0gZGF0YUFycmF5LnNvbWUoc2FtcGxlID0+IHNhbXBsZSAhPT0gMTI4ICYmIHNhbXBsZSAhPT0gMCk7XG4gICAgICAgIGN0eC5jbG9zZSgpO1xuICAgICAgICByZXR1cm4gIXNvbWVOb2lzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9KCk7XG4gIH0pO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0TmV3QXVkaW9Db250ZXh0KCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IEF1ZGlvQ29udGV4dCA9XG4gIC8vIEB0cy1pZ25vcmVcbiAgdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdy5BdWRpb0NvbnRleHQgfHwgd2luZG93LndlYmtpdEF1ZGlvQ29udGV4dCk7XG4gIGlmIChBdWRpb0NvbnRleHQpIHtcbiAgICBjb25zdCBhdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KHtcbiAgICAgIGxhdGVuY3lIaW50OiAnaW50ZXJhY3RpdmUnXG4gICAgfSk7XG4gICAgLy8gSWYgdGhlIGF1ZGlvIGNvbnRleHQgaXMgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHJlc3VtZSBpdCB3aGVuIHRoZSB1c2VyIGNsaWNrcyBvbiB0aGUgcGFnZVxuICAgIGlmIChhdWRpb0NvbnRleHQuc3RhdGUgPT09ICdzdXNwZW5kZWQnICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSB3aW5kb3cuZG9jdW1lbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ib2R5KSkge1xuICAgICAgY29uc3QgaGFuZGxlUmVzdW1lID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKGF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgICAgIHlpZWxkIGF1ZGlvQ29udGV4dC5yZXN1bWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0Vycm9yIHRyeWluZyB0byBhdXRvLXJlc3VtZSBhdWRpbyBjb250ZXh0JywgZSk7XG4gICAgICAgIH1cbiAgICAgICAgKF9hID0gd2luZG93LmRvY3VtZW50LmJvZHkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIGhhbmRsZVJlc3VtZSk7XG4gICAgICB9KTtcbiAgICAgIHdpbmRvdy5kb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlUmVzdW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGF1ZGlvQ29udGV4dDtcbiAgfVxufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gc291cmNlVG9LaW5kKHNvdXJjZSkge1xuICBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZSkge1xuICAgIHJldHVybiAnYXVkaW9pbnB1dCc7XG4gIH0gZWxzZSBpZiAoc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgcmV0dXJuICd2aWRlb2lucHV0JztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBzY3JlZW5DYXB0dXJlVG9EaXNwbGF5TWVkaWFTdHJlYW1PcHRpb25zKG9wdGlvbnMpIHtcbiAgdmFyIF9hLCBfYjtcbiAgbGV0IHZpZGVvQ29uc3RyYWludHMgPSAoX2EgPSBvcHRpb25zLnZpZGVvKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlO1xuICAvLyB0cmVhdCAwIGFzIHVuY2FwcGVkXG4gIGlmIChvcHRpb25zLnJlc29sdXRpb24gJiYgb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoID4gMCAmJiBvcHRpb25zLnJlc29sdXRpb24uaGVpZ2h0ID4gMCkge1xuICAgIHZpZGVvQ29uc3RyYWludHMgPSB0eXBlb2YgdmlkZW9Db25zdHJhaW50cyA9PT0gJ2Jvb2xlYW4nID8ge30gOiB2aWRlb0NvbnN0cmFpbnRzO1xuICAgIGlmIChpc1NhZmFyaSgpKSB7XG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0NvbnN0cmFpbnRzKSwge1xuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLndpZHRoXG4gICAgICAgIH0sXG4gICAgICAgIGhlaWdodDoge1xuICAgICAgICAgIG1heDogb3B0aW9ucy5yZXNvbHV0aW9uLmhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBmcmFtZVJhdGU6IG9wdGlvbnMucmVzb2x1dGlvbi5mcmFtZVJhdGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWRlb0NvbnN0cmFpbnRzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB2aWRlb0NvbnN0cmFpbnRzKSwge1xuICAgICAgICB3aWR0aDoge1xuICAgICAgICAgIGlkZWFsOiBvcHRpb25zLnJlc29sdXRpb24ud2lkdGhcbiAgICAgICAgfSxcbiAgICAgICAgaGVpZ2h0OiB7XG4gICAgICAgICAgaWRlYWw6IG9wdGlvbnMucmVzb2x1dGlvbi5oZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgZnJhbWVSYXRlOiBvcHRpb25zLnJlc29sdXRpb24uZnJhbWVSYXRlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBhdWRpbzogKF9iID0gb3B0aW9ucy5hdWRpbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2UsXG4gICAgdmlkZW86IHZpZGVvQ29uc3RyYWludHMsXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciBzdXBwb3J0IGZvciBleHBlcmltZW50YWwgZGlzcGxheSBtZWRpYSBmZWF0dXJlc1xuICAgIGNvbnRyb2xsZXI6IG9wdGlvbnMuY29udHJvbGxlcixcbiAgICBzZWxmQnJvd3NlclN1cmZhY2U6IG9wdGlvbnMuc2VsZkJyb3dzZXJTdXJmYWNlLFxuICAgIHN1cmZhY2VTd2l0Y2hpbmc6IG9wdGlvbnMuc3VyZmFjZVN3aXRjaGluZyxcbiAgICBzeXN0ZW1BdWRpbzogb3B0aW9ucy5zeXN0ZW1BdWRpbyxcbiAgICBwcmVmZXJDdXJyZW50VGFiOiBvcHRpb25zLnByZWZlckN1cnJlbnRUYWJcbiAgfTtcbn1cbmZ1bmN0aW9uIG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKG1pbWVUeXBlKSB7XG4gIHJldHVybiBtaW1lVHlwZS5zcGxpdCgnLycpWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5mdW5jdGlvbiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyh0cmFja3MpIHtcbiAgY29uc3QgaW5mb3MgPSBbXTtcbiAgdHJhY2tzLmZvckVhY2godHJhY2sgPT4ge1xuICAgIGlmICh0cmFjay50cmFjayAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpbmZvcy5wdXNoKG5ldyBUcmFja1B1Ymxpc2hlZFJlc3BvbnNlKHtcbiAgICAgICAgY2lkOiB0cmFjay50cmFjay5tZWRpYVN0cmVhbUlELFxuICAgICAgICB0cmFjazogdHJhY2sudHJhY2tJbmZvXG4gICAgICB9KSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGluZm9zO1xufVxuZnVuY3Rpb24gZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykge1xuICBpZiAoJ21lZGlhU3RyZWFtVHJhY2snIGluIHRyYWNrKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRyYWNrSUQ6IHRyYWNrLnNpZCxcbiAgICAgIHNvdXJjZTogdHJhY2suc291cmNlLFxuICAgICAgbXV0ZWQ6IHRyYWNrLmlzTXV0ZWQsXG4gICAgICBlbmFibGVkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQsXG4gICAgICBraW5kOiB0cmFjay5raW5kLFxuICAgICAgc3RyZWFtSUQ6IHRyYWNrLm1lZGlhU3RyZWFtSUQsXG4gICAgICBzdHJlYW1UcmFja0lEOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkXG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHJhY2tJRDogdHJhY2sudHJhY2tTaWQsXG4gICAgICBlbmFibGVkOiB0cmFjay5pc0VuYWJsZWQsXG4gICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgIHRyYWNrSW5mbzogT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIG1pbWVUeXBlOiB0cmFjay5taW1lVHlwZSxcbiAgICAgICAgbmFtZTogdHJhY2sudHJhY2tOYW1lLFxuICAgICAgICBlbmNyeXB0ZWQ6IHRyYWNrLmlzRW5jcnlwdGVkLFxuICAgICAgICBraW5kOiB0cmFjay5raW5kLFxuICAgICAgICBzb3VyY2U6IHRyYWNrLnNvdXJjZVxuICAgICAgfSwgdHJhY2sudHJhY2sgPyBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrLnRyYWNrKSA6IHt9KVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIHN1cHBvcnRzU3luY2hyb25pemF0aW9uU291cmNlcygpIHtcbiAgcmV0dXJuIHR5cGVvZiBSVENSdHBSZWNlaXZlciAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2dldFN5bmNocm9uaXphdGlvblNvdXJjZXMnIGluIFJUQ1J0cFJlY2VpdmVyO1xufVxuZnVuY3Rpb24gZGlmZkF0dHJpYnV0ZXMob2xkVmFsdWVzLCBuZXdWYWx1ZXMpIHtcbiAgdmFyIF9hO1xuICBpZiAob2xkVmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBvbGRWYWx1ZXMgPSB7fTtcbiAgfVxuICBpZiAobmV3VmFsdWVzID09PSB1bmRlZmluZWQpIHtcbiAgICBuZXdWYWx1ZXMgPSB7fTtcbiAgfVxuICBjb25zdCBhbGxLZXlzID0gWy4uLk9iamVjdC5rZXlzKG5ld1ZhbHVlcyksIC4uLk9iamVjdC5rZXlzKG9sZFZhbHVlcyldO1xuICBjb25zdCBkaWZmID0ge307XG4gIGZvciAoY29uc3Qga2V5IG9mIGFsbEtleXMpIHtcbiAgICBpZiAob2xkVmFsdWVzW2tleV0gIT09IG5ld1ZhbHVlc1trZXldKSB7XG4gICAgICBkaWZmW2tleV0gPSAoX2EgPSBuZXdWYWx1ZXNba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufVxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyhvcHRpb25zKSB7XG4gIGNvbnN0IG5ld09wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zKTtcbiAgbGV0IGF1ZGlvUHJvY2Vzc29yO1xuICBsZXQgdmlkZW9Qcm9jZXNzb3I7XG4gIGlmICh0eXBlb2YgbmV3T3B0aW9ucy5hdWRpbyA9PT0gJ29iamVjdCcgJiYgbmV3T3B0aW9ucy5hdWRpby5wcm9jZXNzb3IpIHtcbiAgICBhdWRpb1Byb2Nlc3NvciA9IG5ld09wdGlvbnMuYXVkaW8ucHJvY2Vzc29yO1xuICAgIG5ld09wdGlvbnMuYXVkaW8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ld09wdGlvbnMuYXVkaW8pLCB7XG4gICAgICBwcm9jZXNzb3I6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgbmV3T3B0aW9ucy52aWRlbyA9PT0gJ29iamVjdCcgJiYgbmV3T3B0aW9ucy52aWRlby5wcm9jZXNzb3IpIHtcbiAgICB2aWRlb1Byb2Nlc3NvciA9IG5ld09wdGlvbnMudmlkZW8ucHJvY2Vzc29yO1xuICAgIG5ld09wdGlvbnMudmlkZW8gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG5ld09wdGlvbnMudmlkZW8pLCB7XG4gICAgICBwcm9jZXNzb3I6IHVuZGVmaW5lZFxuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgYXVkaW9Qcm9jZXNzb3IsXG4gICAgdmlkZW9Qcm9jZXNzb3IsXG4gICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3I6IGNsb25lRGVlcChuZXdPcHRpb25zKVxuICB9O1xufVxuZnVuY3Rpb24gZ2V0VHJhY2tTb3VyY2VGcm9tUHJvdG8oc291cmNlKSB7XG4gIHN3aXRjaCAoc291cmNlKSB7XG4gICAgY2FzZSBUcmFja1NvdXJjZS5DQU1FUkE6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICBjYXNlIFRyYWNrU291cmNlLk1JQ1JPUEhPTkU6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgY2FzZSBUcmFja1NvdXJjZS5TQ1JFRU5fU0hBUkU6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGNhc2UgVHJhY2tTb3VyY2UuU0NSRUVOX1NIQVJFX0FVRElPOlxuICAgICAgcmV0dXJuIFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gVHJhY2suU291cmNlLlVua25vd247XG4gIH1cbn1cblxuLyoqXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmNsYXNzIEUyRUVNYW5hZ2VyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9uV29ya2VyTWVzc2FnZSA9IGV2ID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGtpbmQsXG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSBldi5kYXRhO1xuICAgICAgc3dpdGNoIChraW5kKSB7XG4gICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICBsaXZla2l0TG9nZ2VyLmVycm9yKGRhdGEuZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGRhdGEuZXJyb3IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdpbml0QWNrJzpcbiAgICAgICAgICBpZiAoZGF0YS5lbmFibGVkKSB7XG4gICAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmdldEtleXMoKS5mb3JFYWNoKGtleUluZm8gPT4ge1xuICAgICAgICAgICAgICB0aGlzLnBvc3RLZXkoa2V5SW5mbyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2VuYWJsZSc6XG4gICAgICAgICAgaWYgKGRhdGEuZW5hYmxlZCkge1xuICAgICAgICAgICAgdGhpcy5rZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcbiAgICAgICAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmVuY3J5cHRpb25FbmFibGVkICE9PSBkYXRhLmVuYWJsZWQgJiYgZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5ID09PSAoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZGF0YS5lbmFibGVkLCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICAgICAgICB0aGlzLmVuY3J5cHRpb25FbmFibGVkID0gZGF0YS5lbmFibGVkO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5wYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IChfYiA9IHRoaXMucm9vbSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eShkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoXCJjb3VsZG4ndCBzZXQgZW5jcnlwdGlvbiBzdGF0dXMsIHBhcnRpY2lwYW50IG5vdCBmb3VuZFwiLmNvbmNhdChkYXRhLnBhcnRpY2lwYW50SWRlbnRpdHkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmNyeXB0aW9uRXZlbnQuUGFydGljaXBhbnRFbmNyeXB0aW9uU3RhdHVzQ2hhbmdlZCwgZGF0YS5lbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdyYXRjaGV0S2V5JzpcbiAgICAgICAgICB0aGlzLmtleVByb3ZpZGVyLmVtaXQoS2V5UHJvdmlkZXJFdmVudC5LZXlSYXRjaGV0ZWQsIGRhdGEubWF0ZXJpYWwsIGRhdGEua2V5SW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5vbldvcmtlckVycm9yID0gZXYgPT4ge1xuICAgICAgbGl2ZWtpdExvZ2dlci5lcnJvcignZTJlZSB3b3JrZXIgZW5jb3VudGVyZWQgYW4gZXJyb3I6Jywge1xuICAgICAgICBlcnJvcjogZXYuZXJyb3JcbiAgICAgIH0pO1xuICAgICAgdGhpcy5lbWl0KEVuY3J5cHRpb25FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGV2LmVycm9yKTtcbiAgICB9O1xuICAgIHRoaXMua2V5UHJvdmlkZXIgPSBvcHRpb25zLmtleVByb3ZpZGVyO1xuICAgIHRoaXMud29ya2VyID0gb3B0aW9ucy53b3JrZXI7XG4gICAgdGhpcy5lbmNyeXB0aW9uRW5hYmxlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldHVwKHJvb20pIHtcbiAgICBpZiAoIWlzRTJFRVN1cHBvcnRlZCgpKSB7XG4gICAgICB0aHJvdyBuZXcgRGV2aWNlVW5zdXBwb3J0ZWRFcnJvcigndHJpZWQgdG8gc2V0dXAgZW5kLXRvLWVuZCBlbmNyeXB0aW9uIG9uIGFuIHVuc3VwcG9ydGVkIGJyb3dzZXInKTtcbiAgICB9XG4gICAgbGl2ZWtpdExvZ2dlci5pbmZvKCdzZXR0aW5nIHVwIGUyZWUnKTtcbiAgICBpZiAocm9vbSAhPT0gdGhpcy5yb29tKSB7XG4gICAgICB0aGlzLnJvb20gPSByb29tO1xuICAgICAgdGhpcy5zZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIHRoaXMua2V5UHJvdmlkZXIpO1xuICAgICAgLy8gdGhpcy53b3JrZXIgPSBuZXcgV29ya2VyKCcnKTtcbiAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAga2luZDogJ2luaXQnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAga2V5UHJvdmlkZXJPcHRpb25zOiB0aGlzLmtleVByb3ZpZGVyLmdldE9wdGlvbnMoKSxcbiAgICAgICAgICBsb2dsZXZlbDogd29ya2VyTG9nZ2VyLmdldExldmVsKClcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLndvcmtlcikge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJpbml0aWFsaXppbmcgd29ya2VyXCIsIHtcbiAgICAgICAgICB3b3JrZXI6IHRoaXMud29ya2VyXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLndvcmtlci5vbm1lc3NhZ2UgPSB0aGlzLm9uV29ya2VyTWVzc2FnZTtcbiAgICAgICAgdGhpcy53b3JrZXIub25lcnJvciA9IHRoaXMub25Xb3JrZXJFcnJvcjtcbiAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZChlbmFibGVkLCBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZyhcInNldCBlMmVlIHRvIFwiLmNvbmNhdChlbmFibGVkLCBcIiBmb3IgcGFydGljaXBhbnQgXCIpLmNvbmNhdChwYXJ0aWNpcGFudElkZW50aXR5KSk7XG4gICAgdGhpcy5wb3N0RW5hYmxlKGVuYWJsZWQsIHBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHNldFNpZlRyYWlsZXIodHJhaWxlcikge1xuICAgIGlmICghdHJhaWxlciB8fCB0cmFpbGVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKFwiaWdub3Jpbmcgc2VydmVyIHNlbnQgdHJhaWxlciBhcyBpdCdzIGVtcHR5XCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBvc3RTaWZUcmFpbGVyKHRyYWlsZXIpO1xuICAgIH1cbiAgfVxuICBzZXR1cEVuZ2luZShlbmdpbmUpIHtcbiAgICBlbmdpbmUub24oRW5naW5lRXZlbnQuUlRQVmlkZW9NYXBVcGRhdGUsIHJ0cE1hcCA9PiB7XG4gICAgICB0aGlzLnBvc3RSVFBNYXAocnRwTWFwKTtcbiAgICB9KTtcbiAgfVxuICBzZXR1cEV2ZW50TGlzdGVuZXJzKHJvb20sIGtleVByb3ZpZGVyKSB7XG4gICAgcm9vbS5vbihSb29tRXZlbnQuVHJhY2tQdWJsaXNoZWQsIChwdWIsIHBhcnRpY2lwYW50KSA9PiB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQocHViLnRyYWNrSW5mby5lbmNyeXB0aW9uICE9PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSwgcGFydGljaXBhbnQuaWRlbnRpdHkpKTtcbiAgICByb29tLm9uKFJvb21FdmVudC5Db25uZWN0aW9uU3RhdGVDaGFuZ2VkLCBzdGF0ZSA9PiB7XG4gICAgICBpZiAoc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgcm9vbS5yZW1vdGVQYXJ0aWNpcGFudHMuZm9yRWFjaChwYXJ0aWNpcGFudCA9PiB7XG4gICAgICAgICAgcGFydGljaXBhbnQudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRQYXJ0aWNpcGFudENyeXB0b3JFbmFibGVkKHB1Yi50cmFja0luZm8uZW5jcnlwdGlvbiAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkUsIHBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSkub24oUm9vbUV2ZW50LlRyYWNrVW5zdWJzY3JpYmVkLCAodHJhY2ssIF8sIHBhcnRpY2lwYW50KSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdyZW1vdmVUcmFuc2Zvcm0nLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgICAgdHJhY2tJZDogdHJhY2subWVkaWFTdHJlYW1JRFxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgKF9hID0gdGhpcy53b3JrZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wb3N0TWVzc2FnZShtc2cpO1xuICAgIH0pLm9uKFJvb21FdmVudC5UcmFja1N1YnNjcmliZWQsICh0cmFjaywgcHViLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgdGhpcy5zZXR1cEUyRUVSZWNlaXZlcih0cmFjaywgcGFydGljaXBhbnQuaWRlbnRpdHksIHB1Yi50cmFja0luZm8pO1xuICAgIH0pLm9uKFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5yb29tKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJleHBlY3RlZCByb29tIHRvIGJlIHByZXNlbnQgb24gc2lnbmFsIGNvbm5lY3RcIik7XG4gICAgICB9XG4gICAgICBrZXlQcm92aWRlci5nZXRLZXlzKCkuZm9yRWFjaChrZXlJbmZvID0+IHtcbiAgICAgICAgdGhpcy5wb3N0S2V5KGtleUluZm8pO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQodGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaXNFMkVFRW5hYmxlZCwgdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkpO1xuICAgIH0pO1xuICAgIHJvb20ubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHB1YmxpY2F0aW9uID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFU2VuZGVyKHB1YmxpY2F0aW9uLnRyYWNrLCBwdWJsaWNhdGlvbi50cmFjay5zZW5kZXIpO1xuICAgIH0pKTtcbiAgICBrZXlQcm92aWRlci5vbihLZXlQcm92aWRlckV2ZW50LlNldEtleSwga2V5SW5mbyA9PiB0aGlzLnBvc3RLZXkoa2V5SW5mbykpLm9uKEtleVByb3ZpZGVyRXZlbnQuUmF0Y2hldFJlcXVlc3QsIChwYXJ0aWNpcGFudElkLCBrZXlJbmRleCkgPT4gdGhpcy5wb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZCwga2V5SW5kZXgsIGtleVByb3ZpZGVyLmdldE9wdGlvbnMoKS5hbGxvd0tleUV4dHJhY3Rpb24pKTtcbiAgfVxuICBwb3N0UmF0Y2hldFJlcXVlc3QocGFydGljaXBhbnRJZGVudGl0eSwga2V5SW5kZXgsIGV4dHJhY3RhYmxlKSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCByYXRjaGV0IGtleSwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgY29uc3QgbXNnID0ge1xuICAgICAga2luZDogJ3JhdGNoZXRSZXF1ZXN0JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAga2V5SW5kZXgsXG4gICAgICAgIGV4dHJhY3RhYmxlXG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2cpO1xuICB9XG4gIHBvc3RLZXkoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5LFxuICAgICAga2V5SW5kZXhcbiAgICB9ID0gX3JlZjtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBzZXQga2V5LCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBraW5kOiAnc2V0S2V5JyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgaXNQdWJsaXNoZXI6IHBhcnRpY2lwYW50SWRlbnRpdHkgPT09ICgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSxcbiAgICAgICAga2V5LFxuICAgICAgICBrZXlJbmRleFxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBwb3N0RW5hYmxlKGVuYWJsZWQsIHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICBpZiAodGhpcy53b3JrZXIpIHtcbiAgICAgIGNvbnN0IGVuYWJsZU1zZyA9IHtcbiAgICAgICAga2luZDogJ2VuYWJsZScsXG4gICAgICAgIGRhdGE6IHtcbiAgICAgICAgICBlbmFibGVkLFxuICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKGVuYWJsZU1zZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBSZWZlcmVuY2VFcnJvcignZmFpbGVkIHRvIGVuYWJsZSBlMmVlLCB3b3JrZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgfVxuICB9XG4gIHBvc3RSVFBNYXAobWFwKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghdGhpcy53b3JrZXIpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignY291bGQgbm90IHBvc3QgcnRwIG1hcCwgd29ya2VyIGlzIG1pc3NpbmcnKTtcbiAgICB9XG4gICAgaWYgKCEoKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignY291bGQgbm90IHBvc3QgcnRwIG1hcCwgbG9jYWwgcGFydGljaXBhbnQgaWRlbnRpdHkgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBraW5kOiAnc2V0UlRQTWFwJyxcbiAgICAgIGRhdGE6IHtcbiAgICAgICAgbWFwLFxuICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgfVxuICBwb3N0U2lmVHJhaWxlcih0cmFpbGVyKSB7XG4gICAgaWYgKCF0aGlzLndvcmtlcikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2NvdWxkIG5vdCBwb3N0IFNJRiB0cmFpbGVyLCB3b3JrZXIgaXMgbWlzc2luZycpO1xuICAgIH1cbiAgICBjb25zdCBtc2cgPSB7XG4gICAgICBraW5kOiAnc2V0U2lmVHJhaWxlcicsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIHRyYWlsZXJcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMud29ya2VyLnBvc3RNZXNzYWdlKG1zZyk7XG4gIH1cbiAgc2V0dXBFMkVFUmVjZWl2ZXIodHJhY2ssIHJlbW90ZUlkLCB0cmFja0luZm8pIHtcbiAgICBpZiAoIXRyYWNrLnJlY2VpdmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghKHRyYWNrSW5mbyA9PT0gbnVsbCB8fCB0cmFja0luZm8gPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrSW5mby5taW1lVHlwZSkgfHwgdHJhY2tJbmZvLm1pbWVUeXBlID09PSAnJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignTWltZVR5cGUgbWlzc2luZyBmcm9tIHRyYWNrSW5mbywgY2Fubm90IHNldCB1cCBFMkVFIGNyeXB0b3InKTtcbiAgICB9XG4gICAgdGhpcy5oYW5kbGVSZWNlaXZlcih0cmFjay5yZWNlaXZlciwgdHJhY2subWVkaWFTdHJlYW1JRCwgcmVtb3RlSWQsIHRyYWNrLmtpbmQgPT09ICd2aWRlbycgPyBtaW1lVHlwZVRvVmlkZW9Db2RlY1N0cmluZyh0cmFja0luZm8ubWltZVR5cGUpIDogdW5kZWZpbmVkKTtcbiAgfVxuICBzZXR1cEUyRUVTZW5kZXIodHJhY2ssIHNlbmRlcikge1xuICAgIGlmICghaXNMb2NhbFRyYWNrKHRyYWNrKSB8fCAhc2VuZGVyKSB7XG4gICAgICBpZiAoIXNlbmRlcikgbGl2ZWtpdExvZ2dlci53YXJuKCdlYXJseSByZXR1cm4gYmVjYXVzZSBzZW5kZXIgaXMgbm90IHJlYWR5Jyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuaGFuZGxlU2VuZGVyKHNlbmRlciwgdHJhY2subWVkaWFTdHJlYW1JRCwgdW5kZWZpbmVkKTtcbiAgfVxuICAvKipcbiAgICogSGFuZGxlcyB0aGUgZ2l2ZW4ge0Bjb2RlIFJUQ1J0cFJlY2VpdmVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XG4gICAqIGEgZnJhbWUgZGVjb2Rlci5cbiAgICpcbiAgICovXG4gIGhhbmRsZVJlY2VpdmVyKHJlY2VpdmVyLCB0cmFja0lkLCBwYXJ0aWNpcGFudElkZW50aXR5LCBjb2RlYykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMud29ya2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NjcmlwdFRyYW5zZm9ybVN1cHBvcnRlZCgpKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAga2luZDogJ2RlY29kZScsXG4gICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eSxcbiAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgIGNvZGVjXG4gICAgICAgIH07XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVjZWl2ZXIudHJhbnNmb3JtID0gbmV3IFJUQ1J0cFNjcmlwdFRyYW5zZm9ybSh0aGlzLndvcmtlciwgb3B0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoRTJFRV9GTEFHIGluIHJlY2VpdmVyICYmIGNvZGVjKSB7XG4gICAgICAgICAgLy8gb25seSB1cGRhdGUgY29kZWNcbiAgICAgICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgICAgICBraW5kOiAndXBkYXRlQ29kZWMnLFxuICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICB0cmFja0lkLFxuICAgICAgICAgICAgICBjb2RlYyxcbiAgICAgICAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogcGFydGljaXBhbnRJZGVudGl0eVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgd3JpdGFibGUgPSByZWNlaXZlci53cml0YWJsZVN0cmVhbTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBsZXQgcmVhZGFibGUgPSByZWNlaXZlci5yZWFkYWJsZVN0cmVhbTtcbiAgICAgICAgaWYgKCF3cml0YWJsZSB8fCAhcmVhZGFibGUpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3QgcmVjZWl2ZXJTdHJlYW1zID0gcmVjZWl2ZXIuY3JlYXRlRW5jb2RlZFN0cmVhbXMoKTtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgcmVjZWl2ZXIud3JpdGFibGVTdHJlYW0gPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgICAgd3JpdGFibGUgPSByZWNlaXZlclN0cmVhbXMud3JpdGFibGU7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIHJlY2VpdmVyLnJlYWRhYmxlU3RyZWFtID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICAgIHJlYWRhYmxlID0gcmVjZWl2ZXJTdHJlYW1zLnJlYWRhYmxlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1zZyA9IHtcbiAgICAgICAgICBraW5kOiAnZGVjb2RlJyxcbiAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICByZWFkYWJsZVN0cmVhbTogcmVhZGFibGUsXG4gICAgICAgICAgICB3cml0YWJsZVN0cmVhbTogd3JpdGFibGUsXG4gICAgICAgICAgICB0cmFja0lkOiB0cmFja0lkLFxuICAgICAgICAgICAgY29kZWMsXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLndvcmtlci5wb3N0TWVzc2FnZShtc2csIFtyZWFkYWJsZSwgd3JpdGFibGVdKTtcbiAgICAgIH1cbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHJlY2VpdmVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBIYW5kbGVzIHRoZSBnaXZlbiB7QGNvZGUgUlRDUnRwU2VuZGVyfSBieSBjcmVhdGluZyBhIHtAY29kZSBUcmFuc2Zvcm1TdHJlYW19IHdoaWNoIHdpbGwgaW5qZWN0XG4gICAqIGEgZnJhbWUgZW5jb2Rlci5cbiAgICpcbiAgICovXG4gIGhhbmRsZVNlbmRlcihzZW5kZXIsIHRyYWNrSWQsIGNvZGVjKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChFMkVFX0ZMQUcgaW4gc2VuZGVyIHx8ICF0aGlzLndvcmtlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISgoX2EgPSB0aGlzLnJvb20pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KSB8fCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSA9PT0gJycpIHtcbiAgICAgIHRocm93IFR5cGVFcnJvcignbG9jYWwgaWRlbnRpdHkgbmVlZHMgdG8gYmUga25vd24gaW4gb3JkZXIgdG8gc2V0IHVwIGVuY3J5cHRlZCBzZW5kZXInKTtcbiAgICB9XG4gICAgaWYgKGlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkKCkpIHtcbiAgICAgIGxpdmVraXRMb2dnZXIuaW5mbygnaW5pdGlhbGl6ZSBzY3JpcHQgdHJhbnNmb3JtJyk7XG4gICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICBraW5kOiAnZW5jb2RlJyxcbiAgICAgICAgcGFydGljaXBhbnRJZGVudGl0eTogdGhpcy5yb29tLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHksXG4gICAgICAgIHRyYWNrSWQsXG4gICAgICAgIGNvZGVjXG4gICAgICB9O1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgc2VuZGVyLnRyYW5zZm9ybSA9IG5ldyBSVENSdHBTY3JpcHRUcmFuc2Zvcm0odGhpcy53b3JrZXIsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ2luaXRpYWxpemUgZW5jb2RlZCBzdHJlYW1zJyk7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBjb25zdCBzZW5kZXJTdHJlYW1zID0gc2VuZGVyLmNyZWF0ZUVuY29kZWRTdHJlYW1zKCk7XG4gICAgICBjb25zdCBtc2cgPSB7XG4gICAgICAgIGtpbmQ6ICdlbmNvZGUnLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgcmVhZGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMucmVhZGFibGUsXG4gICAgICAgICAgd3JpdGFibGVTdHJlYW06IHNlbmRlclN0cmVhbXMud3JpdGFibGUsXG4gICAgICAgICAgY29kZWMsXG4gICAgICAgICAgdHJhY2tJZCxcbiAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eVxuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgdGhpcy53b3JrZXIucG9zdE1lc3NhZ2UobXNnLCBbc2VuZGVyU3RyZWFtcy5yZWFkYWJsZSwgc2VuZGVyU3RyZWFtcy53cml0YWJsZV0pO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgc2VuZGVyW0UyRUVfRkxBR10gPSB0cnVlO1xuICB9XG59XG5cbmNvbnN0IGRlZmF1bHRJZCA9ICdkZWZhdWx0JztcbmNsYXNzIERldmljZU1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLl9wcmV2aW91c0RldmljZXMgPSBbXTtcbiAgfVxuICBzdGF0aWMgZ2V0SW5zdGFuY2UoKSB7XG4gICAgaWYgKHRoaXMuaW5zdGFuY2UgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5pbnN0YW5jZSA9IG5ldyBEZXZpY2VNYW5hZ2VyKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmluc3RhbmNlO1xuICB9XG4gIGdldCBwcmV2aW91c0RldmljZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ByZXZpb3VzRGV2aWNlcztcbiAgfVxuICBnZXREZXZpY2VzKGtpbmRfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChraW5kKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHJlcXVlc3RQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICgoKF9hID0gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2l6ZSkgPiAwKSB7XG4gICAgICAgICAgbGl2ZWtpdExvZ2dlci5kZWJ1ZygnYXdhaXRpbmcgZ2V0VXNlck1lZGlhIHByb21pc2UnKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKGtpbmQpIHtcbiAgICAgICAgICAgICAgeWllbGQgRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmdldChraW5kKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHlpZWxkIFByb21pc2UuYWxsKERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC52YWx1ZXMoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdlcnJvciB3YWl0aW5nIGZvciBtZWRpYSBwZXJtaXNzb25zJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBkZXZpY2VzID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5lbnVtZXJhdGVEZXZpY2VzKCk7XG4gICAgICAgIGlmIChyZXF1ZXN0UGVybWlzc2lvbnMgJiZcbiAgICAgICAgLy8gZm9yIHNhZmFyaSB3ZSBuZWVkIHRvIHNraXAgdGhpcyBjaGVjaywgYXMgb3RoZXJ3aXNlIGl0IHdpbGwgcmUtYWNxdWlyZSB1c2VyIG1lZGlhIGFuZCBmYWlsIG9uIGlPUyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc5MzYzXG4gICAgICAgICEoaXNTYWZhcmkoKSAmJiBfdGhpcy5oYXNEZXZpY2VJblVzZShraW5kKSkpIHtcbiAgICAgICAgICBjb25zdCBpc0R1bW15RGV2aWNlT3JFbXB0eSA9IGRldmljZXMuZmlsdGVyKGQgPT4gZC5raW5kID09PSBraW5kKS5sZW5ndGggPT09IDAgfHwgZGV2aWNlcy5zb21lKGRldmljZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub0xhYmVsID0gZGV2aWNlLmxhYmVsID09PSAnJztcbiAgICAgICAgICAgIGNvbnN0IGlzUmVsZXZhbnQgPSBraW5kID8gZGV2aWNlLmtpbmQgPT09IGtpbmQgOiB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG5vTGFiZWwgJiYgaXNSZWxldmFudDtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBpZiAoaXNEdW1teURldmljZU9yRW1wdHkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zVG9BY3F1aXJlID0ge1xuICAgICAgICAgICAgICB2aWRlbzoga2luZCAhPT0gJ2F1ZGlvaW5wdXQnICYmIGtpbmQgIT09ICdhdWRpb291dHB1dCcsXG4gICAgICAgICAgICAgIGF1ZGlvOiBraW5kICE9PSAndmlkZW9pbnB1dCcgJiYge1xuICAgICAgICAgICAgICAgIGRldmljZUlkOiB7XG4gICAgICAgICAgICAgICAgICBpZGVhbDogJ2RlZmF1bHQnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgc3RyZWFtID0geWllbGQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEocGVybWlzc2lvbnNUb0FjcXVpcmUpO1xuICAgICAgICAgICAgZGV2aWNlcyA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZW51bWVyYXRlRGV2aWNlcygpO1xuICAgICAgICAgICAgc3RyZWFtLmdldFRyYWNrcygpLmZvckVhY2godHJhY2sgPT4ge1xuICAgICAgICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuX3ByZXZpb3VzRGV2aWNlcyA9IGRldmljZXM7XG4gICAgICAgIGlmIChraW5kKSB7XG4gICAgICAgICAgZGV2aWNlcyA9IGRldmljZXMuZmlsdGVyKGRldmljZSA9PiBkZXZpY2Uua2luZCA9PT0ga2luZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRldmljZXM7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgbm9ybWFsaXplRGV2aWNlSWQoa2luZCwgZGV2aWNlSWQsIGdyb3VwSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKGRldmljZUlkICE9PSBkZWZhdWx0SWQpIHtcbiAgICAgICAgcmV0dXJuIGRldmljZUlkO1xuICAgICAgfVxuICAgICAgLy8gcmVzb2x2ZSBhY3R1YWwgZGV2aWNlIGlkIGlmIGl0J3MgJ2RlZmF1bHQnOiBDaHJvbWUgcmV0dXJucyBpdCB3aGVuIG5vXG4gICAgICAvLyBkZXZpY2UgaGFzIGJlZW4gY2hvc2VuXG4gICAgICBjb25zdCBkZXZpY2VzID0geWllbGQgdGhpcy5nZXREZXZpY2VzKGtpbmQpO1xuICAgICAgY29uc3QgZGVmYXVsdERldmljZSA9IGRldmljZXMuZmluZChkID0+IGQuZGV2aWNlSWQgPT09IGRlZmF1bHRJZCk7XG4gICAgICBpZiAoIWRlZmF1bHREZXZpY2UpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdjb3VsZCBub3QgcmVsaWFibHkgZGV0ZXJtaW5lIGRlZmF1bHQgZGV2aWNlJyk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBkZXZpY2UgPSBkZXZpY2VzLmZpbmQoZCA9PiBkLmRldmljZUlkICE9PSBkZWZhdWx0SWQgJiYgZC5ncm91cElkID09PSAoZ3JvdXBJZCAhPT0gbnVsbCAmJiBncm91cElkICE9PSB2b2lkIDAgPyBncm91cElkIDogZGVmYXVsdERldmljZS5ncm91cElkKSk7XG4gICAgICBpZiAoIWRldmljZSkge1xuICAgICAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ2NvdWxkIG5vdCByZWxpYWJseSBkZXRlcm1pbmUgZGVmYXVsdCBkZXZpY2UnKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkZXZpY2UgPT09IG51bGwgfHwgZGV2aWNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkZXZpY2UuZGV2aWNlSWQ7XG4gICAgfSk7XG4gIH1cbiAgaGFzRGV2aWNlSW5Vc2Uoa2luZCkge1xuICAgIHJldHVybiBraW5kID8gRGV2aWNlTWFuYWdlci51c2VyTWVkaWFQcm9taXNlTWFwLmhhcyhraW5kKSA6IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zaXplID4gMDtcbiAgfVxufVxuRGV2aWNlTWFuYWdlci5tZWRpYURldmljZUtpbmRzID0gWydhdWRpb2lucHV0JywgJ2F1ZGlvb3V0cHV0JywgJ3ZpZGVvaW5wdXQnXTtcbkRldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcCA9IG5ldyBNYXAoKTtcblxudmFyIFF1ZXVlVGFza1N0YXR1cztcbihmdW5jdGlvbiAoUXVldWVUYXNrU3RhdHVzKSB7XG4gIFF1ZXVlVGFza1N0YXR1c1tRdWV1ZVRhc2tTdGF0dXNbXCJXQUlUSU5HXCJdID0gMF0gPSBcIldBSVRJTkdcIjtcbiAgUXVldWVUYXNrU3RhdHVzW1F1ZXVlVGFza1N0YXR1c1tcIlJVTk5JTkdcIl0gPSAxXSA9IFwiUlVOTklOR1wiO1xuICBRdWV1ZVRhc2tTdGF0dXNbUXVldWVUYXNrU3RhdHVzW1wiQ09NUExFVEVEXCJdID0gMl0gPSBcIkNPTVBMRVRFRFwiO1xufSkoUXVldWVUYXNrU3RhdHVzIHx8IChRdWV1ZVRhc2tTdGF0dXMgPSB7fSkpO1xuY2xhc3MgQXN5bmNRdWV1ZSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudGFza011dGV4ID0gbmV3IF8oKTtcbiAgICB0aGlzLm5leHRUYXNrSW5kZXggPSAwO1xuICB9XG4gIHJ1bih0YXNrKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRhc2tJbmZvID0ge1xuICAgICAgICBpZDogdGhpcy5uZXh0VGFza0luZGV4KyssXG4gICAgICAgIGVucXVldWVkQXQ6IERhdGUubm93KCksXG4gICAgICAgIHN0YXR1czogUXVldWVUYXNrU3RhdHVzLldBSVRJTkdcbiAgICAgIH07XG4gICAgICB0aGlzLnBlbmRpbmdUYXNrcy5zZXQodGFza0luZm8uaWQsIHRhc2tJbmZvKTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMudGFza011dGV4LmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRhc2tJbmZvLmV4ZWN1dGVkQXQgPSBEYXRlLm5vdygpO1xuICAgICAgICB0YXNrSW5mby5zdGF0dXMgPSBRdWV1ZVRhc2tTdGF0dXMuUlVOTklORztcbiAgICAgICAgcmV0dXJuIHlpZWxkIHRhc2soKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRhc2tJbmZvLnN0YXR1cyA9IFF1ZXVlVGFza1N0YXR1cy5DT01QTEVURUQ7XG4gICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmRlbGV0ZSh0YXNrSW5mby5pZCk7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGZsdXNoKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5ydW4oKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge30pKTtcbiAgICB9KTtcbiAgfVxuICBzbmFwc2hvdCgpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdUYXNrcy52YWx1ZXMoKSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUnRjVXJsKHVybCwgc2VhcmNoUGFyYW1zKSB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9XZWJzb2NrZXRVcmwodXJsKSk7XG4gIHNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgdXJsT2JqLnNlYXJjaFBhcmFtcy5zZXQoa2V5LCB2YWx1ZSk7XG4gIH0pO1xuICByZXR1cm4gYXBwZW5kVXJsUGF0aCh1cmxPYmosICdydGMnKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRlVXJsKHJ0Y1dzVXJsKSB7XG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodG9IdHRwVXJsKHJ0Y1dzVXJsKSk7XG4gIHJldHVybiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgJ3ZhbGlkYXRlJyk7XG59XG5mdW5jdGlvbiBlbnN1cmVUcmFpbGluZ1NsYXNoKHBhdGgpIHtcbiAgcmV0dXJuIHBhdGguZW5kc1dpdGgoJy8nKSA/IHBhdGggOiBcIlwiLmNvbmNhdChwYXRoLCBcIi9cIik7XG59XG5mdW5jdGlvbiBhcHBlbmRVcmxQYXRoKHVybE9iaiwgcGF0aCkge1xuICB1cmxPYmoucGF0aG5hbWUgPSBcIlwiLmNvbmNhdChlbnN1cmVUcmFpbGluZ1NsYXNoKHVybE9iai5wYXRobmFtZSkpLmNvbmNhdChwYXRoKTtcbiAgcmV0dXJuIHVybE9iai50b1N0cmluZygpO1xufVxuXG5jb25zdCBwYXNzVGhyb3VnaFF1ZXVlU2lnbmFscyA9IFsnc3luY1N0YXRlJywgJ3RyaWNrbGUnLCAnb2ZmZXInLCAnYW5zd2VyJywgJ3NpbXVsYXRlJywgJ2xlYXZlJ107XG5mdW5jdGlvbiBjYW5QYXNzVGhyb3VnaFF1ZXVlKHJlcSkge1xuICBjb25zdCBjYW5QYXNzID0gcGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMuaW5kZXhPZihyZXEuY2FzZSkgPj0gMDtcbiAgbGl2ZWtpdExvZ2dlci50cmFjZSgncmVxdWVzdCBhbGxvd2VkIHRvIGJ5cGFzcyBxdWV1ZTonLCB7XG4gICAgY2FuUGFzcyxcbiAgICByZXFcbiAgfSk7XG4gIHJldHVybiBjYW5QYXNzO1xufVxudmFyIFNpZ25hbENvbm5lY3Rpb25TdGF0ZTtcbihmdW5jdGlvbiAoU2lnbmFsQ29ubmVjdGlvblN0YXRlKSB7XG4gIFNpZ25hbENvbm5lY3Rpb25TdGF0ZVtTaWduYWxDb25uZWN0aW9uU3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMF0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkNPTk5FQ1RFRFwiXSA9IDFdID0gXCJDT05ORUNURURcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIlJFQ09OTkVDVElOR1wiXSA9IDJdID0gXCJSRUNPTk5FQ1RJTkdcIjtcbiAgU2lnbmFsQ29ubmVjdGlvblN0YXRlW1NpZ25hbENvbm5lY3Rpb25TdGF0ZVtcIkRJU0NPTk5FQ1RJTkdcIl0gPSAzXSA9IFwiRElTQ09OTkVDVElOR1wiO1xuICBTaWduYWxDb25uZWN0aW9uU3RhdGVbU2lnbmFsQ29ubmVjdGlvblN0YXRlW1wiRElTQ09OTkVDVEVEXCJdID0gNF0gPSBcIkRJU0NPTk5FQ1RFRFwiO1xufSkoU2lnbmFsQ29ubmVjdGlvblN0YXRlIHx8IChTaWduYWxDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuLyoqIEBpbnRlcm5hbCAqL1xuY2xhc3MgU2lnbmFsQ2xpZW50IHtcbiAgZ2V0IGN1cnJlbnRTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZTtcbiAgfVxuICBnZXQgaXNEaXNjb25uZWN0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HIHx8IHRoaXMuc3RhdGUgPT09IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gIH1cbiAgZ2V0IGlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RJTkcgfHwgdGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgfVxuICBnZXROZXh0UmVxdWVzdElkKCkge1xuICAgIHRoaXMuX3JlcXVlc3RJZCArPSAxO1xuICAgIHJldHVybiB0aGlzLl9yZXF1ZXN0SWQ7XG4gIH1cbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IHVzZUpTT04gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIgX2E7XG4gICAgLyoqIHNpZ25hbCBydHQgaW4gbWlsbGlzZWNvbmRzICovXG4gICAgdGhpcy5ydHQgPSAwO1xuICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuRElTQ09OTkVDVEVEO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLl9yZXF1ZXN0SWQgPSAwO1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLnJlc2V0Q2FsbGJhY2tzID0gKCkgPT4ge1xuICAgICAgdGhpcy5vbkFuc3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25MZWF2ZSA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMub25OZWdvdGlhdGVSZXF1ZXN0ZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uT2ZmZXIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uVG9rZW5SZWZyZXNoID0gdW5kZWZpbmVkO1xuICAgICAgdGhpcy5vblRyaWNrbGUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLm9uQ2xvc2UgPSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlNpZ25hbCk7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSBsb2dnZXJPcHRpb25zLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnVzZUpTT04gPSB1c2VKU09OO1xuICAgIHRoaXMucmVxdWVzdFF1ZXVlID0gbmV3IEFzeW5jUXVldWUoKTtcbiAgICB0aGlzLnF1ZXVlZFJlcXVlc3RzID0gW107XG4gICAgdGhpcy5jbG9zaW5nTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNURUQ7XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5sb2dnZXJDb250ZXh0Q2IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB7fTtcbiAgfVxuICBqb2luKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0U2lnbmFsKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIGR1cmluZyBhIGZ1bGwgcmVjb25uZWN0LCB3ZSdkIHdhbnQgdG8gc3RhcnQgdGhlIHNlcXVlbmNlIGV2ZW4gaWYgY3VycmVudGx5XG4gICAgICAvLyBjb25uZWN0ZWRcbiAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVElORztcbiAgICAgIHRoaXMub3B0aW9ucyA9IG9wdHM7XG4gICAgICBjb25zdCByZXMgPSB5aWVsZCB0aGlzLmNvbm5lY3QodXJsLCB0b2tlbiwgb3B0cywgYWJvcnRTaWduYWwpO1xuICAgICAgcmV0dXJuIHJlcztcbiAgICB9KTtcbiAgfVxuICByZWNvbm5lY3QodXJsLCB0b2tlbiwgc2lkLCByZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLm9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignYXR0ZW1wdGVkIHRvIHJlY29ubmVjdCB3aXRob3V0IHNpZ25hbCBvcHRpb25zIGJlaW5nIHNldCwgaWdub3JpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgICAgIC8vIGNsZWFyIHBpbmcgaW50ZXJ2YWwgYW5kIHJlc3RhcnQgaXQgb25jZSByZWNvbm5lY3RlZFxuICAgICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgICAgY29uc3QgcmVzID0geWllbGQgdGhpcy5jb25uZWN0KHVybCwgdG9rZW4sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5vcHRpb25zKSwge1xuICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgIHNpZCxcbiAgICAgICAgcmVjb25uZWN0UmVhc29uOiByZWFzb25cbiAgICAgIH0pKTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSk7XG4gIH1cbiAgY29ubmVjdCh1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHRoaXMuY29ubmVjdE9wdGlvbnMgPSBvcHRzO1xuICAgIGNvbnN0IGNsaWVudEluZm8gPSBnZXRDbGllbnRJbmZvKCk7XG4gICAgY29uc3QgcGFyYW1zID0gY3JlYXRlQ29ubmVjdGlvblBhcmFtcyh0b2tlbiwgY2xpZW50SW5mbywgb3B0cyk7XG4gICAgY29uc3QgcnRjVXJsID0gY3JlYXRlUnRjVXJsKHVybCwgcGFyYW1zKTtcbiAgICBjb25zdCB2YWxpZGF0ZVVybCA9IGNyZWF0ZVZhbGlkYXRlVXJsKHJ0Y1VybCk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY29ubmVjdGlvbkxvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyBiZWVuIGNhbmNlbGxlZCAoc2lnbmFsKScsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHdzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcigncm9vbSBjb25uZWN0aW9uIGhhcyB0aW1lZCBvdXQgKHNpZ25hbCknLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpKTtcbiAgICAgICAgfSwgb3B0cy53ZWJzb2NrZXRUaW1lb3V0KTtcbiAgICAgICAgaWYgKGFib3J0U2lnbmFsID09PSBudWxsIHx8IGFib3J0U2lnbmFsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydFNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgYWJvcnRIYW5kbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgY29uc3QgcmVkYWN0ZWRVcmwgPSBuZXcgVVJMKHJ0Y1VybCk7XG4gICAgICAgIGlmIChyZWRhY3RlZFVybC5zZWFyY2hQYXJhbXMuaGFzKCdhY2Nlc3NfdG9rZW4nKSkge1xuICAgICAgICAgIHJlZGFjdGVkVXJsLnNlYXJjaFBhcmFtcy5zZXQoJ2FjY2Vzc190b2tlbicsICc8cmVkYWN0ZWQ+Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJjb25uZWN0aW5nIHRvIFwiLmNvbmNhdChyZWRhY3RlZFVybCksIE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgIHJlY29ubmVjdDogb3B0cy5yZWNvbm5lY3QsXG4gICAgICAgICAgcmVjb25uZWN0UmVhc29uOiBvcHRzLnJlY29ubmVjdFJlYXNvblxuICAgICAgICB9LCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmNsb3NlKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChydGNVcmwpO1xuICAgICAgICB0aGlzLndzLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuICAgICAgICB0aGlzLndzLm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQod3NUaW1lb3V0KTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy53cy5vbmVycm9yID0gZXYgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh3c1RpbWVvdXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcCA9IHlpZWxkIGZldGNoKHZhbGlkYXRlVXJsKTtcbiAgICAgICAgICAgICAgaWYgKHJlc3Auc3RhdHVzLnRvRml4ZWQoMCkuc3RhcnRzV2l0aCgnNCcpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0geWllbGQgcmVzcC50ZXh0KCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IobXNnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCwgcmVzcC5zdGF0dXMpKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IENvbm5lY3Rpb25FcnJvcihcIkVuY291bnRlcmVkIHVua25vd24gd2Vic29ja2V0IGVycm9yIGR1cmluZyBjb25uZWN0aW9uOiBcIi5jb25jYXQoZXYudG9TdHJpbmcoKSksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yLCByZXNwLnN0YXR1cykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKGUgaW5zdGFuY2VvZiBFcnJvciA/IGUubWVzc2FnZSA6ICdzZXJ2ZXIgd2FzIG5vdCByZWFjaGFibGUnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gb3RoZXIgZXJyb3JzLCBoYW5kbGVcbiAgICAgICAgICB0aGlzLmhhbmRsZVdTRXJyb3IoZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53cy5vbm1lc3NhZ2UgPSBldiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgICAgLy8gbm90IGNvbnNpZGVyZWQgY29ubmVjdGVkIHVudGlsIEpvaW5SZXNwb25zZSBpcyByZWNlaXZlZFxuICAgICAgICAgIGxldCByZXNwO1xuICAgICAgICAgIGlmICh0eXBlb2YgZXYuZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGNvbnN0IGpzb24gPSBKU09OLnBhcnNlKGV2LmRhdGEpO1xuICAgICAgICAgICAgcmVzcCA9IFNpZ25hbFJlc3BvbnNlLmZyb21Kc29uKGpzb24sIHtcbiAgICAgICAgICAgICAgaWdub3JlVW5rbm93bkZpZWxkczogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChldi5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgICAgIHJlc3AgPSBTaWduYWxSZXNwb25zZS5mcm9tQmluYXJ5KG5ldyBVaW50OEFycmF5KGV2LmRhdGEpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJjb3VsZCBub3QgZGVjb2RlIHdlYnNvY2tldCBtZXNzYWdlOiBcIi5jb25jYXQodHlwZW9mIGV2LmRhdGEpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgbGV0IHNob3VsZFByb2Nlc3NNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAvLyBoYW5kbGUgam9pbiBtZXNzYWdlIG9ubHlcbiAgICAgICAgICAgIGlmICgoKF9hID0gcmVzcC5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FzZSkgPT09ICdqb2luJykge1xuICAgICAgICAgICAgICB0aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgICAgICAgICAgYWJvcnRTaWduYWwgPT09IG51bGwgfHwgYWJvcnRTaWduYWwgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0U2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgdGhpcy5waW5nVGltZW91dER1cmF0aW9uID0gcmVzcC5tZXNzYWdlLnZhbHVlLnBpbmdUaW1lb3V0O1xuICAgICAgICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbER1cmF0aW9uID0gcmVzcC5tZXNzYWdlLnZhbHVlLnBpbmdJbnRlcnZhbDtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAmJiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3BpbmcgY29uZmlnJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24sXG4gICAgICAgICAgICAgICAgICBpbnRlcnZhbDogdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvblxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0UGluZ0ludGVydmFsKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLm1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HICYmIHJlc3AubWVzc2FnZS5jYXNlICE9PSAnbGVhdmUnKSB7XG4gICAgICAgICAgICAgIC8vIGluIHJlY29ubmVjdGluZywgYW55IG1lc3NhZ2UgcmVjZWl2ZWQgbWVhbnMgc2lnbmFsIHJlY29ubmVjdGVkXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGUgPSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEO1xuICAgICAgICAgICAgICBhYm9ydFNpZ25hbCA9PT0gbnVsbCB8fCBhYm9ydFNpZ25hbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRTaWduYWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0UGluZ0ludGVydmFsKCk7XG4gICAgICAgICAgICAgIGlmICgoKF9iID0gcmVzcC5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FzZSkgPT09ICdyZWNvbm5lY3QnKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNwLm1lc3NhZ2UudmFsdWUpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdkZWNsYXJpbmcgc2lnbmFsIHJlY29ubmVjdGVkIHdpdGhvdXQgcmVjb25uZWN0IHJlc3BvbnNlIHJlY2VpdmVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICAgICAgc2hvdWxkUHJvY2Vzc01lc3NhZ2UgPSB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaXNFc3RhYmxpc2hpbmdDb25uZWN0aW9uICYmIHJlc3AubWVzc2FnZS5jYXNlID09PSAnbGVhdmUnKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdSZWNlaXZlZCBsZWF2ZSByZXF1ZXN0IHdoaWxlIHRyeWluZyB0byAocmUpY29ubmVjdCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5MZWF2ZVJlcXVlc3QsIHVuZGVmaW5lZCwgcmVzcC5tZXNzYWdlLnZhbHVlLnJlYXNvbikpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghb3B0cy5yZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgLy8gbm9uLXJlY29ubmVjdCBjYXNlLCBzaG91bGQgcmVjZWl2ZSBqb2luIHJlc3BvbnNlIGZpcnN0XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKFwiZGlkIG5vdCByZWNlaXZlIGpvaW4gcmVzcG9uc2UsIGdvdCBcIi5jb25jYXQoKF9jID0gcmVzcC5tZXNzYWdlKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FzZSwgXCIgaW5zdGVhZFwiKSwgQ29ubmVjdGlvbkVycm9yUmVhc29uLkludGVybmFsRXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghc2hvdWxkUHJvY2Vzc01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5zaWduYWxMYXRlbmN5KSB7XG4gICAgICAgICAgICB5aWVsZCBzbGVlcCh0aGlzLnNpZ25hbExhdGVuY3kpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlc3ApO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy53cy5vbmNsb3NlID0gZXYgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLmlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ1dlYnNvY2tldCBnb3QgY2xvc2VkIGR1cmluZyBhIChyZSljb25uZWN0aW9uIGF0dGVtcHQnLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwid2Vic29ja2V0IGNsb3NlZFwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIHJlYXNvbjogZXYucmVhc29uLFxuICAgICAgICAgICAgY29kZTogZXYuY29kZSxcbiAgICAgICAgICAgIHdhc0NsZWFuOiBldi53YXNDbGVhbixcbiAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHRoaXMuaGFuZGxlT25DbG9zZShldi5yZWFzb24pO1xuICAgICAgICB9O1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQgdXBkYXRlU3RhdGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgX3RoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzLmNsZWFyUGluZ0ludGVydmFsKCk7XG4gICAgICAgICAgaWYgKHVwZGF0ZVN0YXRlKSB7XG4gICAgICAgICAgICBfdGhpcy5zdGF0ZSA9IFNpZ25hbENvbm5lY3Rpb25TdGF0ZS5ESVNDT05ORUNUSU5HO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMud3MpIHtcbiAgICAgICAgICAgIF90aGlzLndzLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgICAgICBfdGhpcy53cy5vbm9wZW4gPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMud3Mub25jbG9zZSA9IG51bGw7XG4gICAgICAgICAgICAvLyBjYWxsaW5nIGB3cy5jbG9zZSgpYCBvbmx5IHN0YXJ0cyB0aGUgY2xvc2luZyBoYW5kc2hha2UgKENMT1NJTkcgc3RhdGUpLCBwcmVmZXIgdG8gd2FpdCB1bnRpbCBzdGF0ZSBpcyBhY3R1YWxseSBDTE9TRURcbiAgICAgICAgICAgIGNvbnN0IGNsb3NlUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICAgICAgICBpZiAoX3RoaXMud3MpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy53cy5vbmNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChfdGhpcy53cy5yZWFkeVN0YXRlIDwgX3RoaXMud3MuQ0xPU0lORykge1xuICAgICAgICAgICAgICBfdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgICAgICAvLyAyNTBtcyBncmFjZSBwZXJpb2QgZm9yIHdzIHRvIGNsb3NlIGdyYWNlZnVsbHlcbiAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKFtjbG9zZVByb21pc2UsIHNsZWVwKDI1MCldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLndzID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBpZiAodXBkYXRlU3RhdGUpIHtcbiAgICAgICAgICAgIF90aGlzLnN0YXRlID0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRDtcbiAgICAgICAgICB9XG4gICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIH1cbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvLyBpbml0aWFsIG9mZmVyIGFmdGVyIGpvaW5pbmdcbiAgc2VuZE9mZmVyKG9mZmVyKSB7XG4gICAgdGhpcy5sb2cuZGVidWcoJ3NlbmRpbmcgb2ZmZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIG9mZmVyU2RwOiBvZmZlci5zZHBcbiAgICB9KSk7XG4gICAgdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnb2ZmZXInLFxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ob2ZmZXIpXG4gICAgfSk7XG4gIH1cbiAgLy8gYW5zd2VyIGEgc2VydmVyLWluaXRpYXRlZCBvZmZlclxuICBzZW5kQW5zd2VyKGFuc3dlcikge1xuICAgIHRoaXMubG9nLmRlYnVnKCdzZW5kaW5nIGFuc3dlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgYW5zd2VyU2RwOiBhbnN3ZXIuc2RwXG4gICAgfSkpO1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdhbnN3ZXInLFxuICAgICAgdmFsdWU6IHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24oYW5zd2VyKVxuICAgIH0pO1xuICB9XG4gIHNlbmRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlLCB0YXJnZXQpIHtcbiAgICB0aGlzLmxvZy5kZWJ1Zygnc2VuZGluZyBpY2UgY2FuZGlkYXRlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBjYW5kaWRhdGVcbiAgICB9KSk7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3RyaWNrbGUnLFxuICAgICAgdmFsdWU6IG5ldyBUcmlja2xlUmVxdWVzdCh7XG4gICAgICAgIGNhbmRpZGF0ZUluaXQ6IEpTT04uc3RyaW5naWZ5KGNhbmRpZGF0ZSksXG4gICAgICAgIHRhcmdldFxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxuICBzZW5kTXV0ZVRyYWNrKHRyYWNrU2lkLCBtdXRlZCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdtdXRlJyxcbiAgICAgIHZhbHVlOiBuZXcgTXV0ZVRyYWNrUmVxdWVzdCh7XG4gICAgICAgIHNpZDogdHJhY2tTaWQsXG4gICAgICAgIG11dGVkXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRBZGRUcmFjayhyZXEpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnYWRkVHJhY2snLFxuICAgICAgdmFsdWU6IHJlcVxuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKG1ldGFkYXRhXzEsIG5hbWVfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChtZXRhZGF0YSwgbmFtZSkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBsZXQgYXR0cmlidXRlcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdElkID0gX3RoaXMyLmdldE5leHRSZXF1ZXN0SWQoKTtcbiAgICAgICAgeWllbGQgX3RoaXMyLnNlbmRSZXF1ZXN0KHtcbiAgICAgICAgICBjYXNlOiAndXBkYXRlTWV0YWRhdGEnLFxuICAgICAgICAgIHZhbHVlOiBuZXcgVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSh7XG4gICAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgICBtZXRhZGF0YSxcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICAgICAgfSlcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXF1ZXN0SWQ7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpIHtcbiAgICB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICd0cmFja1NldHRpbmcnLFxuICAgICAgdmFsdWU6IHNldHRpbmdzXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVN1YnNjcmlwdGlvbihzdWIpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uJyxcbiAgICAgIHZhbHVlOiBzdWJcbiAgICB9KTtcbiAgfVxuICBzZW5kU3luY1N0YXRlKHN5bmMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3luY1N0YXRlJyxcbiAgICAgIHZhbHVlOiBzeW5jXG4gICAgfSk7XG4gIH1cbiAgc2VuZFVwZGF0ZVZpZGVvTGF5ZXJzKHRyYWNrU2lkLCBsYXllcnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAndXBkYXRlTGF5ZXJzJyxcbiAgICAgIHZhbHVlOiBuZXcgVXBkYXRlVmlkZW9MYXllcnMoe1xuICAgICAgICB0cmFja1NpZCxcbiAgICAgICAgbGF5ZXJzXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRVcGRhdGVTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHMsIHRyYWNrUGVybWlzc2lvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc3Vic2NyaXB0aW9uUGVybWlzc2lvbicsXG4gICAgICB2YWx1ZTogbmV3IFN1YnNjcmlwdGlvblBlcm1pc3Npb24oe1xuICAgICAgICBhbGxQYXJ0aWNpcGFudHMsXG4gICAgICAgIHRyYWNrUGVybWlzc2lvbnNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZFNpbXVsYXRlU2NlbmFyaW8oc2NlbmFyaW8pIHtcbiAgICByZXR1cm4gdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAnc2ltdWxhdGUnLFxuICAgICAgdmFsdWU6IHNjZW5hcmlvXG4gICAgfSk7XG4gIH1cbiAgc2VuZFBpbmcoKSB7XG4gICAgLyoqIHNlbmQgYm90aCBvZiBwaW5nIGFuZCBwaW5nUmVxIGZvciBjb21wYXRpYmlsaXR5IHRvIG9sZCBhbmQgbmV3IHNlcnZlciAqL1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbdGhpcy5zZW5kUmVxdWVzdCh7XG4gICAgICBjYXNlOiAncGluZycsXG4gICAgICB2YWx1ZTogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKVxuICAgIH0pLCB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdwaW5nUmVxJyxcbiAgICAgIHZhbHVlOiBuZXcgUGluZyh7XG4gICAgICAgIHRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShEYXRlLm5vdygpKSxcbiAgICAgICAgcnR0OiBwcm90b0ludDY0LnBhcnNlKHRoaXMucnR0KVxuICAgICAgfSlcbiAgICB9KV0pO1xuICB9XG4gIHNlbmRVcGRhdGVMb2NhbEF1ZGlvVHJhY2sodHJhY2tTaWQsIGZlYXR1cmVzKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZFJlcXVlc3Qoe1xuICAgICAgY2FzZTogJ3VwZGF0ZUF1ZGlvVHJhY2snLFxuICAgICAgdmFsdWU6IG5ldyBVcGRhdGVMb2NhbEF1ZGlvVHJhY2soe1xuICAgICAgICB0cmFja1NpZCxcbiAgICAgICAgZmVhdHVyZXNcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgc2VuZExlYXZlKCkge1xuICAgIHJldHVybiB0aGlzLnNlbmRSZXF1ZXN0KHtcbiAgICAgIGNhc2U6ICdsZWF2ZScsXG4gICAgICB2YWx1ZTogbmV3IExlYXZlUmVxdWVzdCh7XG4gICAgICAgIHJlYXNvbjogRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVELFxuICAgICAgICAvLyBzZXJ2ZXIgZG9lc24ndCBwcm9jZXNzIHRoaXMgZmllbGQsIGtlZXBpbmcgaXQgaGVyZSB0byBpbmRpY2F0ZSB0aGUgaW50ZW50IG9mIGEgZnVsbCBkaXNjb25uZWN0XG4gICAgICAgIGFjdGlvbjogTGVhdmVSZXF1ZXN0X0FjdGlvbi5ESVNDT05ORUNUXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG4gIHNlbmRSZXF1ZXN0KG1lc3NhZ2VfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGxldCBmcm9tUXVldWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIGNhcHR1cmUgYWxsIHJlcXVlc3RzIHdoaWxlIHJlY29ubmVjdGluZyBhbmQgcHV0IHRoZW0gaW4gYSBxdWV1ZVxuICAgICAgICAvLyB1bmxlc3MgdGhlIHJlcXVlc3Qgb3JpZ2luYXRlcyBmcm9tIHRoZSBxdWV1ZSwgdGhlbiBkb24ndCBlbnF1ZXVlIGFnYWluXG4gICAgICAgIGNvbnN0IGNhblF1ZXVlID0gIWZyb21RdWV1ZSAmJiAhY2FuUGFzc1Rocm91Z2hRdWV1ZShtZXNzYWdlKTtcbiAgICAgICAgaWYgKGNhblF1ZXVlICYmIF90aGlzMy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORykge1xuICAgICAgICAgIF90aGlzMy5xdWV1ZWRSZXF1ZXN0cy5wdXNoKCgpID0+IF9fYXdhaXRlcihfdGhpczMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5zZW5kUmVxdWVzdChtZXNzYWdlLCB0cnVlKTtcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBwcmV2aW91c2x5IHF1ZXVlZCByZXF1ZXN0cyBhcmUgYmVpbmcgc2VudCBmaXJzdFxuICAgICAgICBpZiAoIWZyb21RdWV1ZSkge1xuICAgICAgICAgIHlpZWxkIF90aGlzMy5yZXF1ZXN0UXVldWUuZmx1c2goKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3RoaXMzLnNpZ25hbExhdGVuY3kpIHtcbiAgICAgICAgICB5aWVsZCBzbGVlcChfdGhpczMuc2lnbmFsTGF0ZW5jeSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFfdGhpczMud3MgfHwgX3RoaXMzLndzLnJlYWR5U3RhdGUgIT09IF90aGlzMy53cy5PUEVOKSB7XG4gICAgICAgICAgX3RoaXMzLmxvZy5lcnJvcihcImNhbm5vdCBzZW5kIHNpZ25hbCByZXF1ZXN0IGJlZm9yZSBjb25uZWN0ZWQsIHR5cGU6IFwiLmNvbmNhdChtZXNzYWdlID09PSBudWxsIHx8IG1lc3NhZ2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG1lc3NhZ2UuY2FzZSksIF90aGlzMy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxID0gbmV3IFNpZ25hbFJlcXVlc3Qoe1xuICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKF90aGlzMy51c2VKU09OKSB7XG4gICAgICAgICAgICBfdGhpczMud3Muc2VuZChyZXEudG9Kc29uU3RyaW5nKCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczMud3Muc2VuZChyZXEudG9CaW5hcnkoKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgX3RoaXMzLmxvZy5lcnJvcignZXJyb3Igc2VuZGluZyBzaWduYWwgbWVzc2FnZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIGhhbmRsZVNpZ25hbFJlc3BvbnNlKHJlcykge1xuICAgIHZhciBfYSwgX2I7XG4gICAgY29uc3QgbXNnID0gcmVzLm1lc3NhZ2U7XG4gICAgaWYgKG1zZyA9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB1bnN1cHBvcnRlZCBtZXNzYWdlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IHBpbmdIYW5kbGVkID0gZmFsc2U7XG4gICAgaWYgKG1zZy5jYXNlID09PSAnYW5zd2VyJykge1xuICAgICAgY29uc3Qgc2QgPSBmcm9tUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24obXNnLnZhbHVlKTtcbiAgICAgIGlmICh0aGlzLm9uQW5zd2VyKSB7XG4gICAgICAgIHRoaXMub25BbnN3ZXIoc2QpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdvZmZlcicpIHtcbiAgICAgIGNvbnN0IHNkID0gZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uKG1zZy52YWx1ZSk7XG4gICAgICBpZiAodGhpcy5vbk9mZmVyKSB7XG4gICAgICAgIHRoaXMub25PZmZlcihzZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyaWNrbGUnKSB7XG4gICAgICBjb25zdCBjYW5kaWRhdGUgPSBKU09OLnBhcnNlKG1zZy52YWx1ZS5jYW5kaWRhdGVJbml0KTtcbiAgICAgIGlmICh0aGlzLm9uVHJpY2tsZSkge1xuICAgICAgICB0aGlzLm9uVHJpY2tsZShjYW5kaWRhdGUsIG1zZy52YWx1ZS50YXJnZXQpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICd1cGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblBhcnRpY2lwYW50VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25QYXJ0aWNpcGFudFVwZGF0ZSgoX2EgPSBtc2cudmFsdWUucGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrUHVibGlzaGVkJykge1xuICAgICAgaWYgKHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3NwZWFrZXJzQ2hhbmdlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uU3BlYWtlcnNDaGFuZ2VkKSB7XG4gICAgICAgIHRoaXMub25TcGVha2Vyc0NoYW5nZWQoKF9iID0gbXNnLnZhbHVlLnNwZWFrZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ2xlYXZlJykge1xuICAgICAgaWYgKHRoaXMub25MZWF2ZSkge1xuICAgICAgICB0aGlzLm9uTGVhdmUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnbXV0ZScpIHtcbiAgICAgIGlmICh0aGlzLm9uUmVtb3RlTXV0ZUNoYW5nZWQpIHtcbiAgICAgICAgdGhpcy5vblJlbW90ZU11dGVDaGFuZ2VkKG1zZy52YWx1ZS5zaWQsIG1zZy52YWx1ZS5tdXRlZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3Jvb21VcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblJvb21VcGRhdGUgJiYgbXNnLnZhbHVlLnJvb20pIHtcbiAgICAgICAgdGhpcy5vblJvb21VcGRhdGUobXNnLnZhbHVlLnJvb20pO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdjb25uZWN0aW9uUXVhbGl0eScpIHtcbiAgICAgIGlmICh0aGlzLm9uQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25RdWFsaXR5KG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3N0cmVhbVN0YXRlVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdHJlYW1TdGF0ZVVwZGF0ZSkge1xuICAgICAgICB0aGlzLm9uU3RyZWFtU3RhdGVVcGRhdGUobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmliZWRRdWFsaXR5VXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZShtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdzdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlJykge1xuICAgICAgaWYgKHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3JlZnJlc2hUb2tlbicpIHtcbiAgICAgIGlmICh0aGlzLm9uVG9rZW5SZWZyZXNoKSB7XG4gICAgICAgIHRoaXMub25Ub2tlblJlZnJlc2gobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAndHJhY2tVbnB1Ymxpc2hlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKSB7XG4gICAgICAgIHRoaXMub25Mb2NhbFRyYWNrVW5wdWJsaXNoZWQobXNnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG1zZy5jYXNlID09PSAnc3Vic2NyaXB0aW9uUmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblN1YnNjcmlwdGlvbkVycm9yKSB7XG4gICAgICAgIHRoaXMub25TdWJzY3JpcHRpb25FcnJvcihtc2cudmFsdWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdwb25nJykgOyBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3BvbmdSZXNwJykge1xuICAgICAgdGhpcy5ydHQgPSBEYXRlLm5vdygpIC0gTnVtYmVyLnBhcnNlSW50KG1zZy52YWx1ZS5sYXN0UGluZ1RpbWVzdGFtcC50b1N0cmluZygpKTtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgICAgcGluZ0hhbmRsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobXNnLmNhc2UgPT09ICdyZXF1ZXN0UmVzcG9uc2UnKSB7XG4gICAgICBpZiAodGhpcy5vblJlcXVlc3RSZXNwb25zZSkge1xuICAgICAgICB0aGlzLm9uUmVxdWVzdFJlc3BvbnNlKG1zZy52YWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChtc2cuY2FzZSA9PT0gJ3RyYWNrU3Vic2NyaWJlZCcpIHtcbiAgICAgIGlmICh0aGlzLm9uTG9jYWxUcmFja1N1YnNjcmliZWQpIHtcbiAgICAgICAgdGhpcy5vbkxvY2FsVHJhY2tTdWJzY3JpYmVkKG1zZy52YWx1ZS50cmFja1NpZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1bnN1cHBvcnRlZCBtZXNzYWdlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIG1zZ0Nhc2U6IG1zZy5jYXNlXG4gICAgICB9KSk7XG4gICAgfVxuICAgIGlmICghcGluZ0hhbmRsZWQpIHtcbiAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgIH1cbiAgfVxuICBzZXRSZWNvbm5lY3RlZCgpIHtcbiAgICB3aGlsZSAodGhpcy5xdWV1ZWRSZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICBjb25zdCByZXEgPSB0aGlzLnF1ZXVlZFJlcXVlc3RzLnNoaWZ0KCk7XG4gICAgICBpZiAocmVxKSB7XG4gICAgICAgIHRoaXMucmVxdWVzdFF1ZXVlLnJ1bihyZXEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBoYW5kbGVPbkNsb3NlKHJlYXNvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkRJU0NPTk5FQ1RFRCkgcmV0dXJuO1xuICAgICAgY29uc3Qgb25DbG9zZUNhbGxiYWNrID0gdGhpcy5vbkNsb3NlO1xuICAgICAgeWllbGQgdGhpcy5jbG9zZSgpO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJ3ZWJzb2NrZXQgY29ubmVjdGlvbiBjbG9zZWQ6IFwiLmNvbmNhdChyZWFzb24pLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgcmVhc29uXG4gICAgICB9KSk7XG4gICAgICBpZiAob25DbG9zZUNhbGxiYWNrKSB7XG4gICAgICAgIG9uQ2xvc2VDYWxsYmFjayhyZWFzb24pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVdTRXJyb3IoZXYpIHtcbiAgICB0aGlzLmxvZy5lcnJvcignd2Vic29ja2V0IGVycm9yJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBlcnJvcjogZXZcbiAgICB9KSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgcGluZyB0aW1lb3V0IGFuZCBzdGFydHMgYSBuZXcgdGltZW91dC5cbiAgICogQ2FsbCB0aGlzIGFmdGVyIHJlY2VpdmluZyBhIHBvbmcgbWVzc2FnZVxuICAgKi9cbiAgcmVzZXRQaW5nVGltZW91dCgpIHtcbiAgICB0aGlzLmNsZWFyUGluZ1RpbWVvdXQoKTtcbiAgICBpZiAoIXRoaXMucGluZ1RpbWVvdXREdXJhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigncGluZyB0aW1lb3V0IGR1cmF0aW9uIG5vdCBzZXQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBpbmdUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmxvZy53YXJuKFwicGluZyB0aW1lb3V0IHRyaWdnZXJlZC4gbGFzdCBwb25nIHJlY2VpdmVkIGF0OiBcIi5jb25jYXQobmV3IERhdGUoRGF0ZS5ub3coKSAtIHRoaXMucGluZ1RpbWVvdXREdXJhdGlvbiAqIDEwMDApLnRvVVRDU3RyaW5nKCkpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5oYW5kbGVPbkNsb3NlKCdwaW5nIHRpbWVvdXQnKTtcbiAgICB9LCB0aGlzLnBpbmdUaW1lb3V0RHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuICAvKipcbiAgICogQ2xlYXJzIHBpbmcgdGltZW91dCAoZG9lcyBub3Qgc3RhcnQgYSBuZXcgdGltZW91dClcbiAgICovXG4gIGNsZWFyUGluZ1RpbWVvdXQoKSB7XG4gICAgaWYgKHRoaXMucGluZ1RpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnBpbmdUaW1lb3V0KTtcbiAgICB9XG4gIH1cbiAgc3RhcnRQaW5nSW50ZXJ2YWwoKSB7XG4gICAgdGhpcy5jbGVhclBpbmdJbnRlcnZhbCgpO1xuICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCgpO1xuICAgIGlmICghdGhpcy5waW5nSW50ZXJ2YWxEdXJhdGlvbikge1xuICAgICAgdGhpcy5sb2cud2FybigncGluZyBpbnRlcnZhbCBkdXJhdGlvbiBub3Qgc2V0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2cuZGVidWcoJ3N0YXJ0IHBpbmcgaW50ZXJ2YWwnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgIHRoaXMucGluZ0ludGVydmFsID0gQ3JpdGljYWxUaW1lcnMuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgdGhpcy5zZW5kUGluZygpO1xuICAgIH0sIHRoaXMucGluZ0ludGVydmFsRHVyYXRpb24gKiAxMDAwKTtcbiAgfVxuICBjbGVhclBpbmdJbnRlcnZhbCgpIHtcbiAgICB0aGlzLmxvZy5kZWJ1ZygnY2xlYXJpbmcgcGluZyBpbnRlcnZhbCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5jbGVhclBpbmdUaW1lb3V0KCk7XG4gICAgaWYgKHRoaXMucGluZ0ludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMucGluZ0ludGVydmFsKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZyb21Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbihzZCkge1xuICBjb25zdCByc2QgPSB7XG4gICAgdHlwZTogJ29mZmVyJyxcbiAgICBzZHA6IHNkLnNkcFxuICB9O1xuICBzd2l0Y2ggKHNkLnR5cGUpIHtcbiAgICBjYXNlICdhbnN3ZXInOlxuICAgIGNhc2UgJ29mZmVyJzpcbiAgICBjYXNlICdwcmFuc3dlcic6XG4gICAgY2FzZSAncm9sbGJhY2snOlxuICAgICAgcnNkLnR5cGUgPSBzZC50eXBlO1xuICAgICAgYnJlYWs7XG4gIH1cbiAgcmV0dXJuIHJzZDtcbn1cbmZ1bmN0aW9uIHRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24ocnNkKSB7XG4gIGNvbnN0IHNkID0gbmV3IFNlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgc2RwOiByc2Quc2RwLFxuICAgIHR5cGU6IHJzZC50eXBlXG4gIH0pO1xuICByZXR1cm4gc2Q7XG59XG5mdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uUGFyYW1zKHRva2VuLCBpbmZvLCBvcHRzKSB7XG4gIHZhciBfYTtcbiAgY29uc3QgcGFyYW1zID0gbmV3IFVSTFNlYXJjaFBhcmFtcygpO1xuICBwYXJhbXMuc2V0KCdhY2Nlc3NfdG9rZW4nLCB0b2tlbik7XG4gIC8vIG9wdHNcbiAgaWYgKG9wdHMucmVjb25uZWN0KSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0JywgJzEnKTtcbiAgICBpZiAob3B0cy5zaWQpIHtcbiAgICAgIHBhcmFtcy5zZXQoJ3NpZCcsIG9wdHMuc2lkKTtcbiAgICB9XG4gIH1cbiAgcGFyYW1zLnNldCgnYXV0b19zdWJzY3JpYmUnLCBvcHRzLmF1dG9TdWJzY3JpYmUgPyAnMScgOiAnMCcpO1xuICAvLyBDbGllbnRJbmZvXG4gIHBhcmFtcy5zZXQoJ3NkaycsIGlzUmVhY3ROYXRpdmUoKSA/ICdyZWFjdG5hdGl2ZScgOiAnanMnKTtcbiAgcGFyYW1zLnNldCgndmVyc2lvbicsIGluZm8udmVyc2lvbik7XG4gIHBhcmFtcy5zZXQoJ3Byb3RvY29sJywgaW5mby5wcm90b2NvbC50b1N0cmluZygpKTtcbiAgaWYgKGluZm8uZGV2aWNlTW9kZWwpIHtcbiAgICBwYXJhbXMuc2V0KCdkZXZpY2VfbW9kZWwnLCBpbmZvLmRldmljZU1vZGVsKTtcbiAgfVxuICBpZiAoaW5mby5vcykge1xuICAgIHBhcmFtcy5zZXQoJ29zJywgaW5mby5vcyk7XG4gIH1cbiAgaWYgKGluZm8ub3NWZXJzaW9uKSB7XG4gICAgcGFyYW1zLnNldCgnb3NfdmVyc2lvbicsIGluZm8ub3NWZXJzaW9uKTtcbiAgfVxuICBpZiAoaW5mby5icm93c2VyKSB7XG4gICAgcGFyYW1zLnNldCgnYnJvd3NlcicsIGluZm8uYnJvd3Nlcik7XG4gIH1cbiAgaWYgKGluZm8uYnJvd3NlclZlcnNpb24pIHtcbiAgICBwYXJhbXMuc2V0KCdicm93c2VyX3ZlcnNpb24nLCBpbmZvLmJyb3dzZXJWZXJzaW9uKTtcbiAgfVxuICBpZiAob3B0cy5hZGFwdGl2ZVN0cmVhbSkge1xuICAgIHBhcmFtcy5zZXQoJ2FkYXB0aXZlX3N0cmVhbScsICcxJyk7XG4gIH1cbiAgaWYgKG9wdHMucmVjb25uZWN0UmVhc29uKSB7XG4gICAgcGFyYW1zLnNldCgncmVjb25uZWN0X3JlYXNvbicsIG9wdHMucmVjb25uZWN0UmVhc29uLnRvU3RyaW5nKCkpO1xuICB9XG4gIC8vIEB0cy1pZ25vcmVcbiAgaWYgKChfYSA9IG5hdmlnYXRvci5jb25uZWN0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudHlwZSkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBwYXJhbXMuc2V0KCduZXR3b3JrJywgbmF2aWdhdG9yLmNvbm5lY3Rpb24udHlwZSk7XG4gIH1cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxudmFyIGxpYiA9IHt9O1xuXG52YXIgcGFyc2VyID0ge307XG5cbnZhciBncmFtbWFyID0ge2V4cG9ydHM6IHt9fTtcblxudmFyIGhhc1JlcXVpcmVkR3JhbW1hcjtcbmZ1bmN0aW9uIHJlcXVpcmVHcmFtbWFyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRHcmFtbWFyKSByZXR1cm4gZ3JhbW1hci5leHBvcnRzO1xuICBoYXNSZXF1aXJlZEdyYW1tYXIgPSAxO1xuICB2YXIgZ3JhbW1hciQxID0gZ3JhbW1hci5leHBvcnRzID0ge1xuICAgIHY6IFt7XG4gICAgICBuYW1lOiAndmVyc2lvbicsXG4gICAgICByZWc6IC9eKFxcZCopJC9cbiAgICB9XSxcbiAgICBvOiBbe1xuICAgICAgLy8gbz0tIDIwNTE4IDAgSU4gSVA0IDIwMy4wLjExMy4xXG4gICAgICAvLyBOQjogc2Vzc2lvbklkIHdpbGwgYmUgYSBTdHJpbmcgaW4gbW9zdCBjYXNlcyBiZWNhdXNlIGl0IGlzIGh1Z2VcbiAgICAgIG5hbWU6ICdvcmlnaW4nLFxuICAgICAgcmVnOiAvXihcXFMqKSAoXFxkKikgKFxcZCopIChcXFMqKSBJUChcXGQpIChcXFMqKS8sXG4gICAgICBuYW1lczogWyd1c2VybmFtZScsICdzZXNzaW9uSWQnLCAnc2Vzc2lvblZlcnNpb24nLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgICBmb3JtYXQ6ICclcyAlcyAlZCAlcyBJUCVkICVzJ1xuICAgIH1dLFxuICAgIC8vIGRlZmF1bHQgcGFyc2luZyBvZiB0aGVzZSBvbmx5ICh0aG91Z2ggc29tZSBvZiB0aGVzZSBmZWVsIG91dGRhdGVkKVxuICAgIHM6IFt7XG4gICAgICBuYW1lOiAnbmFtZSdcbiAgICB9XSxcbiAgICBpOiBbe1xuICAgICAgbmFtZTogJ2Rlc2NyaXB0aW9uJ1xuICAgIH1dLFxuICAgIHU6IFt7XG4gICAgICBuYW1lOiAndXJpJ1xuICAgIH1dLFxuICAgIGU6IFt7XG4gICAgICBuYW1lOiAnZW1haWwnXG4gICAgfV0sXG4gICAgcDogW3tcbiAgICAgIG5hbWU6ICdwaG9uZSdcbiAgICB9XSxcbiAgICB6OiBbe1xuICAgICAgbmFtZTogJ3RpbWV6b25lcydcbiAgICB9XSxcbiAgICAvLyBUT0RPOiB0aGlzIG9uZSBjYW4gYWN0dWFsbHkgYmUgcGFyc2VkIHByb3Blcmx5Li4uXG4gICAgcjogW3tcbiAgICAgIG5hbWU6ICdyZXBlYXRzJ1xuICAgIH1dLFxuICAgIC8vIFRPRE86IHRoaXMgb25lIGNhbiBhbHNvIGJlIHBhcnNlZCBwcm9wZXJseVxuICAgIC8vIGs6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcbiAgICB0OiBbe1xuICAgICAgLy8gdD0wIDBcbiAgICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgICAgcmVnOiAvXihcXGQqKSAoXFxkKikvLFxuICAgICAgbmFtZXM6IFsnc3RhcnQnLCAnc3RvcCddLFxuICAgICAgZm9ybWF0OiAnJWQgJWQnXG4gICAgfV0sXG4gICAgYzogW3tcbiAgICAgIC8vIGM9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxuICAgICAgbmFtZTogJ2Nvbm5lY3Rpb24nLFxuICAgICAgcmVnOiAvXklOIElQKFxcZCkgKFxcUyopLyxcbiAgICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcbiAgICAgIGZvcm1hdDogJ0lOIElQJWQgJXMnXG4gICAgfV0sXG4gICAgYjogW3tcbiAgICAgIC8vIGI9QVM6NDAwMFxuICAgICAgcHVzaDogJ2JhbmR3aWR0aCcsXG4gICAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ2xpbWl0J10sXG4gICAgICBmb3JtYXQ6ICclczolcydcbiAgICB9XSxcbiAgICBtOiBbe1xuICAgICAgLy8gbT12aWRlbyA1MTc0NCBSVFAvQVZQIDEyNiA5NyA5OCAzNCAzMVxuICAgICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxuICAgICAgLy8gVE9ETzogcnRwL2ZtdHAgc2hvdWxkIGJlIGZpbHRlcmVkIGJ5IHRoZSBwYXlsb2FkcyBmb3VuZCBoZXJlP1xuICAgICAgcmVnOiAvXihcXHcqKSAoXFxkKikgKFtcXHcvXSopKD86ICguKikpPy8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ3BvcnQnLCAncHJvdG9jb2wnLCAncGF5bG9hZHMnXSxcbiAgICAgIGZvcm1hdDogJyVzICVkICVzICVzJ1xuICAgIH1dLFxuICAgIGE6IFt7XG4gICAgICAvLyBhPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXG4gICAgICBwdXNoOiAncnRwJyxcbiAgICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtLl0qKSg/OlxccypcXC8oXFxkKikoPzpcXHMqXFwvKFxcUyopKT8pPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvZGVjJywgJ3JhdGUnLCAnZW5jb2RpbmcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIG8uZW5jb2RpbmcgPyAncnRwbWFwOiVkICVzLyVzLyVzJyA6IG8ucmF0ZSA/ICdydHBtYXA6JWQgJXMvJXMnIDogJ3J0cG1hcDolZCAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1mbXRwOjEwOCBwcm9maWxlLWxldmVsLWlkPTI0O29iamVjdD0yMztiaXRyYXRlPTY0MDAwXG4gICAgICAvLyBhPWZtdHA6MTExIG1pbnB0aW1lPTEwOyB1c2VpbmJhbmRmZWM9MVxuICAgICAgcHVzaDogJ2ZtdHAnLFxuICAgICAgcmVnOiAvXmZtdHA6KFxcZCopIChbXFxTfCBdKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogJ2ZtdHA6JWQgJXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jb250cm9sOnN0cmVhbWlkPTBcbiAgICAgIG5hbWU6ICdjb250cm9sJyxcbiAgICAgIHJlZzogL15jb250cm9sOiguKikvLFxuICAgICAgZm9ybWF0OiAnY29udHJvbDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPXJ0Y3A6NjUxNzkgSU4gSVA0IDE5My44NC43Ny4xOTRcbiAgICAgIG5hbWU6ICdydGNwJyxcbiAgICAgIHJlZzogL15ydGNwOihcXGQqKSg/OiAoXFxTKikgSVAoXFxkKSAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydwb3J0JywgJ25ldFR5cGUnLCAnaXBWZXInLCAnYWRkcmVzcyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5hZGRyZXNzICE9IG51bGwgPyAncnRjcDolZCAlcyBJUCVkICVzJyA6ICdydGNwOiVkJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXJ0Y3AtZmI6OTggdHJyLWludCAxMDBcbiAgICAgIHB1c2g6ICdydGNwRmJUcnJJbnQnLFxuICAgICAgcmVnOiAvXnJ0Y3AtZmI6KFxcKnxcXGQqKSB0cnItaW50IChcXGQqKS8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6ICdydGNwLWZiOiVzIHRyci1pbnQgJWQnXG4gICAgfSwge1xuICAgICAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICAgICAgcHVzaDogJ3J0Y3BGYicsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIChbXFx3LV9dKikoPzogKFtcXHctX10qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndHlwZScsICdzdWJ0eXBlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnN1YnR5cGUgIT0gbnVsbCA/ICdydGNwLWZiOiVzICVzICVzJyA6ICdydGNwLWZiOiVzICVzJztcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPWV4dG1hcDoyIHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnRvZmZzZXRcbiAgICAgIC8vIGE9ZXh0bWFwOjEvcmVjdm9ubHkgVVJJLWdwcy1zdHJpbmdcbiAgICAgIC8vIGE9ZXh0bWFwOjMgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDpzbXB0ZS10YyAyNUA2MDAvMjRcbiAgICAgIHB1c2g6ICdleHQnLFxuICAgICAgcmVnOiAvXmV4dG1hcDooXFxkKykoPzpcXC8oXFx3KykpPyg/OiAodXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6ZW5jcnlwdCkpPyAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsndmFsdWUnLCAnZGlyZWN0aW9uJywgJ2VuY3J5cHQtdXJpJywgJ3VyaScsICdjb25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICdleHRtYXA6JWQnICsgKG8uZGlyZWN0aW9uID8gJy8lcycgOiAnJXYnKSArIChvWydlbmNyeXB0LXVyaSddID8gJyAlcycgOiAnJXYnKSArICcgJXMnICsgKG8uY29uZmlnID8gJyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1leHRtYXAtYWxsb3ctbWl4ZWRcbiAgICAgIG5hbWU6ICdleHRtYXBBbGxvd01peGVkJyxcbiAgICAgIHJlZzogL14oZXh0bWFwLWFsbG93LW1peGVkKS9cbiAgICB9LCB7XG4gICAgICAvLyBhPWNyeXB0bzoxIEFFU19DTV8xMjhfSE1BQ19TSEExXzgwIGlubGluZTpQUzF1UUNWZWVDRkNhblZtY2prcFB5d2pOV2hjWUQwbVhYdHhhVkJSfDJeMjB8MTozMlxuICAgICAgcHVzaDogJ2NyeXB0bycsXG4gICAgICByZWc6IC9eY3J5cHRvOihcXGQqKSAoW1xcd19dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ3N1aXRlJywgJ2NvbmZpZycsICdzZXNzaW9uQ29uZmlnJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnNlc3Npb25Db25maWcgIT0gbnVsbCA/ICdjcnlwdG86JWQgJXMgJXMgJXMnIDogJ2NyeXB0bzolZCAlcyAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1zZXR1cDphY3RwYXNzXG4gICAgICBuYW1lOiAnc2V0dXAnLFxuICAgICAgcmVnOiAvXnNldHVwOihcXHcqKS8sXG4gICAgICBmb3JtYXQ6ICdzZXR1cDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWNvbm5lY3Rpb246bmV3XG4gICAgICBuYW1lOiAnY29ubmVjdGlvblR5cGUnLFxuICAgICAgcmVnOiAvXmNvbm5lY3Rpb246KG5ld3xleGlzdGluZykvLFxuICAgICAgZm9ybWF0OiAnY29ubmVjdGlvbjolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPW1pZDoxXG4gICAgICBuYW1lOiAnbWlkJyxcbiAgICAgIHJlZzogL15taWQ6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ21pZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPW1zaWQ6MGM4YjA2NGQtZDgwNy00M2I0LWI0MzQtZjkyYTg4OWQ4NTg3IDk4MTc4Njg1LWQ0MDktNDZlMC04ZTE2LTdlZjBkYjBkYjY0YVxuICAgICAgbmFtZTogJ21zaWQnLFxuICAgICAgcmVnOiAvXm1zaWQ6KC4qKS8sXG4gICAgICBmb3JtYXQ6ICdtc2lkOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cHRpbWU6MjBcbiAgICAgIG5hbWU6ICdwdGltZScsXG4gICAgICByZWc6IC9ecHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ3B0aW1lOiVkJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9bWF4cHRpbWU6NjBcbiAgICAgIG5hbWU6ICdtYXhwdGltZScsXG4gICAgICByZWc6IC9ebWF4cHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ21heHB0aW1lOiVkJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9c2VuZHJlY3ZcbiAgICAgIG5hbWU6ICdkaXJlY3Rpb24nLFxuICAgICAgcmVnOiAvXihzZW5kcmVjdnxyZWN2b25seXxzZW5kb25seXxpbmFjdGl2ZSkvXG4gICAgfSwge1xuICAgICAgLy8gYT1pY2UtbGl0ZVxuICAgICAgbmFtZTogJ2ljZWxpdGUnLFxuICAgICAgcmVnOiAvXihpY2UtbGl0ZSkvXG4gICAgfSwge1xuICAgICAgLy8gYT1pY2UtdWZyYWc6RjdnSVxuICAgICAgbmFtZTogJ2ljZVVmcmFnJyxcbiAgICAgIHJlZzogL15pY2UtdWZyYWc6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS11ZnJhZzolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWljZS1wd2Q6eDljbWwvWXppY2hWMitYbGhpTXU4Z1xuICAgICAgbmFtZTogJ2ljZVB3ZCcsXG4gICAgICByZWc6IC9eaWNlLXB3ZDooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXB3ZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWZpbmdlcnByaW50OlNIQS0xIDAwOjExOjIyOjMzOjQ0OjU1OjY2Ojc3Ojg4Ojk5OkFBOkJCOkNDOkREOkVFOkZGOjAwOjExOjIyOjMzXG4gICAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxuICAgICAgcmVnOiAvXmZpbmdlcnByaW50OihcXFMqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdoYXNoJ10sXG4gICAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWNhbmRpZGF0ZTowIDEgVURQIDIxMTM2NjczMjcgMjAzLjAuMTEzLjEgNTQ0MDAgdHlwIGhvc3RcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjExNjI4NzUwODEgMSB1ZHAgMjExMzkzNzE1MSAxOTIuMTY4LjM0Ljc1IDYwMDE3IHR5cCBob3N0IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZTozMjg5OTEyOTU3IDIgdWRwIDE4NDU1MDE2OTUgMTkzLjg0Ljc3LjE5NCA2MDAxNyB0eXAgc3JmbHggcmFkZHIgMTkyLjE2OC4zNC43NSBycG9ydCA2MDAxNyBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MjI5ODE1NjIwIDEgdGNwIDE1MTgyODA0NDcgMTkyLjE2OC4xNTAuMTkgNjAwMTcgdHlwIGhvc3QgdGNwdHlwZSBhY3RpdmUgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB0Y3AgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IHRjcHR5cGUgcGFzc2l2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgcHVzaDogJ2NhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXmNhbmRpZGF0ZTooXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgKFxcUyopIChcXGQqKSB0eXAgKFxcUyopKD86IHJhZGRyIChcXFMqKSBycG9ydCAoXFxkKikpPyg/OiB0Y3B0eXBlIChcXFMqKSk/KD86IGdlbmVyYXRpb24gKFxcZCopKT8oPzogbmV0d29yay1pZCAoXFxkKikpPyg/OiBuZXR3b3JrLWNvc3QgKFxcZCopKT8vLFxuICAgICAgbmFtZXM6IFsnZm91bmRhdGlvbicsICdjb21wb25lbnQnLCAndHJhbnNwb3J0JywgJ3ByaW9yaXR5JywgJ2lwJywgJ3BvcnQnLCAndHlwZScsICdyYWRkcicsICdycG9ydCcsICd0Y3B0eXBlJywgJ2dlbmVyYXRpb24nLCAnbmV0d29yay1pZCcsICduZXR3b3JrLWNvc3QnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdjYW5kaWRhdGU6JXMgJWQgJXMgJWQgJXMgJWQgdHlwICVzJztcbiAgICAgICAgc3RyICs9IG8ucmFkZHIgIT0gbnVsbCA/ICcgcmFkZHIgJXMgcnBvcnQgJWQnIDogJyV2JXYnO1xuXG4gICAgICAgIC8vIE5COiBjYW5kaWRhdGUgaGFzIHRocmVlIG9wdGlvbmFsIGNodW5rcywgc28gJXZvaWQgbWlkZGxlcyBvbmUgaWYgaXQncyBtaXNzaW5nXG4gICAgICAgIHN0ciArPSBvLnRjcHR5cGUgIT0gbnVsbCA/ICcgdGNwdHlwZSAlcycgOiAnJXYnO1xuICAgICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyBnZW5lcmF0aW9uICVkJztcbiAgICAgICAgfVxuICAgICAgICBzdHIgKz0gb1snbmV0d29yay1pZCddICE9IG51bGwgPyAnIG5ldHdvcmstaWQgJWQnIDogJyV2JztcbiAgICAgICAgc3RyICs9IG9bJ25ldHdvcmstY29zdCddICE9IG51bGwgPyAnIG5ldHdvcmstY29zdCAlZCcgOiAnJXYnO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9ZW5kLW9mLWNhbmRpZGF0ZXMgKGtlZXAgYWZ0ZXIgdGhlIGNhbmRpZGF0ZXMgbGluZSBmb3IgcmVhZGFiaWxpdHkpXG4gICAgICBuYW1lOiAnZW5kT2ZDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL14oZW5kLW9mLWNhbmRpZGF0ZXMpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cmVtb3RlLWNhbmRpZGF0ZXM6MSAyMDMuMC4xMTMuMSA1NDQwMCAyIDIwMy4wLjExMy4xIDU0NDAxIC4uLlxuICAgICAgbmFtZTogJ3JlbW90ZUNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXnJlbW90ZS1jYW5kaWRhdGVzOiguKikvLFxuICAgICAgZm9ybWF0OiAncmVtb3RlLWNhbmRpZGF0ZXM6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1pY2Utb3B0aW9uczpnb29nbGUtaWNlXG4gICAgICBuYW1lOiAnaWNlT3B0aW9ucycsXG4gICAgICByZWc6IC9eaWNlLW9wdGlvbnM6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1vcHRpb25zOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9c3NyYzoyNTY2MTA3NTY5IGNuYW1lOnQ5WVU4TTFVeFRGOFkxQTFcbiAgICAgIHB1c2g6ICdzc3JjcycsXG4gICAgICByZWc6IC9ec3NyYzooXFxkKikgKFtcXHdfLV0qKSg/OjooLiopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnYXR0cmlidXRlJywgJ3ZhbHVlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnc3NyYzolZCc7XG4gICAgICAgIGlmIChvLmF0dHJpYnV0ZSAhPSBudWxsKSB7XG4gICAgICAgICAgc3RyICs9ICcgJXMnO1xuICAgICAgICAgIGlmIChvLnZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSAnOiVzJztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXNzcmMtZ3JvdXA6RkVDIDEgMlxuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQy1GUiAzMDA0MzY0MTk1IDEwODA3NzIyNDFcbiAgICAgIHB1c2g6ICdzc3JjR3JvdXBzJyxcbiAgICAgIC8vIHRva2VuLWNoYXIgPSAleDIxIC8gJXgyMy0yNyAvICV4MkEtMkIgLyAleDJELTJFIC8gJXgzMC0zOSAvICV4NDEtNUEgLyAleDVFLTdFXG4gICAgICByZWc6IC9ec3NyYy1ncm91cDooW1xceDIxXFx4MjNcXHgyNFxceDI1XFx4MjZcXHgyN1xceDJBXFx4MkJcXHgyRFxceDJFXFx3XSopICguKikvLFxuICAgICAgbmFtZXM6IFsnc2VtYW50aWNzJywgJ3NzcmNzJ10sXG4gICAgICBmb3JtYXQ6ICdzc3JjLWdyb3VwOiVzICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9bXNpZC1zZW1hbnRpYzogV01TIEp2bGFtNVgzU1gxT1A2cG4yMHpXb2d2YUtKejVIamY5T25sVlxuICAgICAgbmFtZTogJ21zaWRTZW1hbnRpYycsXG4gICAgICByZWc6IC9ebXNpZC1zZW1hbnRpYzpcXHM/KFxcdyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpYycsICd0b2tlbiddLFxuICAgICAgZm9ybWF0OiAnbXNpZC1zZW1hbnRpYzogJXMgJXMnIC8vIHNwYWNlIGFmdGVyICc6JyBpcyBub3QgYWNjaWRlbnRhbFxuICAgIH0sIHtcbiAgICAgIC8vIGE9Z3JvdXA6QlVORExFIGF1ZGlvIHZpZGVvXG4gICAgICBwdXNoOiAnZ3JvdXBzJyxcbiAgICAgIHJlZzogL15ncm91cDooXFx3KikgKC4qKS8sXG4gICAgICBuYW1lczogWyd0eXBlJywgJ21pZHMnXSxcbiAgICAgIGZvcm1hdDogJ2dyb3VwOiVzICVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cnRjcC1tdXhcbiAgICAgIG5hbWU6ICdydGNwTXV4JyxcbiAgICAgIHJlZzogL14ocnRjcC1tdXgpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9cnRjcC1yc2l6ZVxuICAgICAgbmFtZTogJ3J0Y3BSc2l6ZScsXG4gICAgICByZWc6IC9eKHJ0Y3AtcnNpemUpL1xuICAgIH0sIHtcbiAgICAgIC8vIGE9c2N0cG1hcDo1MDAwIHdlYnJ0Yy1kYXRhY2hhbm5lbCAxMDI0XG4gICAgICBuYW1lOiAnc2N0cG1hcCcsXG4gICAgICByZWc6IC9ec2N0cG1hcDooW1xcd18vXSopIChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWydzY3RwbWFwTnVtYmVyJywgJ2FwcCcsICdtYXhNZXNzYWdlU2l6ZSddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gby5tYXhNZXNzYWdlU2l6ZSAhPSBudWxsID8gJ3NjdHBtYXA6JXMgJXMgJXMnIDogJ3NjdHBtYXA6JXMgJXMnO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9eC1nb29nbGUtZmxhZzpjb25mZXJlbmNlXG4gICAgICBuYW1lOiAneEdvb2dsZUZsYWcnLFxuICAgICAgcmVnOiAvXngtZ29vZ2xlLWZsYWc6KFteXFxzXSopLyxcbiAgICAgIGZvcm1hdDogJ3gtZ29vZ2xlLWZsYWc6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcbiAgICAgIHB1c2g6ICdyaWRzJyxcbiAgICAgIHJlZzogL15yaWQ6KFtcXGRcXHddKykgKFxcdyspKD86IChbXFxTfCBdKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiBvLnBhcmFtcyA/ICdyaWQ6JXMgJXMgJXMnIDogJ3JpZDolcyAlcyc7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gYT1pbWFnZWF0dHI6OTcgc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXSByZWN2IFt4PTMzMCx5PTI1MF1cbiAgICAgIC8vIGE9aW1hZ2VhdHRyOiogc2VuZCBbeD04MDAseT02NDBdIHJlY3YgKlxuICAgICAgLy8gYT1pbWFnZWF0dHI6MTAwIHJlY3YgW3g9MzIwLHk9MjQwXVxuICAgICAgcHVzaDogJ2ltYWdlYXR0cnMnLFxuICAgICAgcmVnOiBuZXcgUmVnRXhwKFxuICAgICAgLy8gYT1pbWFnZWF0dHI6OTdcbiAgICAgICdeaW1hZ2VhdHRyOihcXFxcZCt8XFxcXCopJyArXG4gICAgICAvLyBzZW5kIFt4PTgwMCx5PTY0MCxzYXI9MS4xLHE9MC42XSBbeD00ODAseT0zMjBdXG4gICAgICAnW1xcXFxzXFxcXHRdKyhzZW5kfHJlY3YpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKiknICtcbiAgICAgIC8vIHJlY3YgW3g9MzMwLHk9MjUwXVxuICAgICAgJyg/OltcXFxcc1xcXFx0XSsocmVjdnxzZW5kKVtcXFxcc1xcXFx0XSsoXFxcXCp8XFxcXFtcXFxcUytcXFxcXSg/OltcXFxcc1xcXFx0XStcXFxcW1xcXFxTK1xcXFxdKSopKT8nKSxcbiAgICAgIG5hbWVzOiBbJ3B0JywgJ2RpcjEnLCAnYXR0cnMxJywgJ2RpcjInLCAnYXR0cnMyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LCB7XG4gICAgICAvLyBhPXNpbXVsY2FzdDpzZW5kIDEsMiwzO340LH41IHJlY3YgNjt+Nyx+OFxuICAgICAgLy8gYT1zaW11bGNhc3Q6cmVjdiAxOzQsNSBzZW5kIDY7N1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdCcsXG4gICAgICByZWc6IG5ldyBSZWdFeHAoXG4gICAgICAvLyBhPXNpbXVsY2FzdDpcbiAgICAgICdec2ltdWxjYXN0OicgK1xuICAgICAgLy8gc2VuZCAxLDIsMzt+NCx+NVxuICAgICAgJyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspJyArXG4gICAgICAvLyBzcGFjZSArIHJlY3YgNjt+Nyx+OFxuICAgICAgJyg/OlxcXFxzPyhzZW5kfHJlY3YpIChbYS16QS1aMC05XFxcXC1ffjssXSspKT8nICtcbiAgICAgIC8vIGVuZFxuICAgICAgJyQnKSxcbiAgICAgIG5hbWVzOiBbJ2RpcjEnLCAnbGlzdDEnLCAnZGlyMicsICdsaXN0MiddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gJ3NpbXVsY2FzdDolcyAlcycgKyAoby5kaXIyID8gJyAlcyAlcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gb2xkIHNpbXVsY2FzdCBkcmFmdCAwMyAoaW1wbGVtZW50ZWQgYnkgRmlyZWZveClcbiAgICAgIC8vICAgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNkcC1zaW11bGNhc3QtMDNcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiByZWN2IHB0PTk3Ozk4IHNlbmQgcHQ9OTdcbiAgICAgIC8vIGE9c2ltdWxjYXN0OiBzZW5kIHJpZD01OzY7NyBwYXVzZWQ9Niw3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0XzAzJyxcbiAgICAgIHJlZzogL15zaW11bGNhc3Q6W1xcc1xcdF0rKFtcXFMrXFxzXFx0XSspJC8sXG4gICAgICBuYW1lczogWyd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAnc2ltdWxjYXN0OiAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyNVxuICAgICAgLy8gYT1mcmFtZXJhdGU6MjkuOTdcbiAgICAgIG5hbWU6ICdmcmFtZXJhdGUnLFxuICAgICAgcmVnOiAvXmZyYW1lcmF0ZTooXFxkKyg/OiR8XFwuXFxkKykpLyxcbiAgICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcbiAgICB9LCB7XG4gICAgICAvLyBSRkM0NTcwXG4gICAgICAvLyBhPXNvdXJjZS1maWx0ZXI6IGluY2wgSU4gSVA0IDIzOS41LjIuMzEgMTAuMS4xNS41XG4gICAgICBuYW1lOiAnc291cmNlRmlsdGVyJyxcbiAgICAgIHJlZzogL15zb3VyY2UtZmlsdGVyOiAqKGV4Y2x8aW5jbCkgKFxcUyopIChJUDR8SVA2fFxcKikgKFxcUyopICguKikvLFxuICAgICAgbmFtZXM6IFsnZmlsdGVyTW9kZScsICduZXRUeXBlJywgJ2FkZHJlc3NUeXBlcycsICdkZXN0QWRkcmVzcycsICdzcmNMaXN0J10sXG4gICAgICBmb3JtYXQ6ICdzb3VyY2UtZmlsdGVyOiAlcyAlcyAlcyAlcyAlcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWJ1bmRsZS1vbmx5XG4gICAgICBuYW1lOiAnYnVuZGxlT25seScsXG4gICAgICByZWc6IC9eKGJ1bmRsZS1vbmx5KS9cbiAgICB9LCB7XG4gICAgICAvLyBhPWxhYmVsOjFcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICByZWc6IC9ebGFiZWw6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdsYWJlbDolcydcbiAgICB9LCB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTVcbiAgICAgIG5hbWU6ICdzY3RwUG9ydCcsXG4gICAgICByZWc6IC9ec2N0cC1wb3J0OihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnc2N0cC1wb3J0OiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNlxuICAgICAgbmFtZTogJ21heE1lc3NhZ2VTaXplJyxcbiAgICAgIHJlZzogL15tYXgtbWVzc2FnZS1zaXplOihcXGQrKSQvLFxuICAgICAgZm9ybWF0OiAnbWF4LW1lc3NhZ2Utc2l6ZTolcydcbiAgICB9LCB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPXRzLXJlZmNsazpwdHA9SUVFRTE1ODgtMjAwODozOS1BNy05NC1GRi1GRS0wNy1DQi1EMDozN1xuICAgICAgcHVzaDogJ3RzUmVmQ2xvY2tzJyxcbiAgICAgIHJlZzogL150cy1yZWZjbGs6KFteXFxzPV0qKSg/Oj0oXFxTKikpPy8sXG4gICAgICBuYW1lczogWydjbGtzcmMnLCAnY2xrc3JjRXh0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAndHMtcmVmY2xrOiVzJyArIChvLmNsa3NyY0V4dCAhPSBudWxsID8gJz0lcycgOiAnJyk7XG4gICAgICB9XG4gICAgfSwge1xuICAgICAgLy8gUkZDNzI3M1xuICAgICAgLy8gYT1tZWRpYWNsazpkaXJlY3Q9OTYzMjE0NDI0XG4gICAgICBuYW1lOiAnbWVkaWFDbGsnLFxuICAgICAgcmVnOiAvXm1lZGlhY2xrOig/OmlkPShcXFMqKSk/ICooW15cXHM9XSopKD86PShcXFMqKSk/KD86ICpyYXRlPShcXGQrKVxcLyhcXGQrKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21lZGlhQ2xvY2tOYW1lJywgJ21lZGlhQ2xvY2tWYWx1ZScsICdyYXRlTnVtZXJhdG9yJywgJ3JhdGVEZW5vbWluYXRvciddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ21lZGlhY2xrOic7XG4gICAgICAgIHN0ciArPSBvLmlkICE9IG51bGwgPyAnaWQ9JXMgJXMnIDogJyV2JXMnO1xuICAgICAgICBzdHIgKz0gby5tZWRpYUNsb2NrVmFsdWUgIT0gbnVsbCA/ICc9JXMnIDogJyc7XG4gICAgICAgIHN0ciArPSBvLnJhdGVOdW1lcmF0b3IgIT0gbnVsbCA/ICcgcmF0ZT0lcycgOiAnJztcbiAgICAgICAgc3RyICs9IG8ucmF0ZURlbm9taW5hdG9yICE9IG51bGwgPyAnLyVzJyA6ICcnO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sIHtcbiAgICAgIC8vIGE9a2V5d2RzOmtleXdvcmRzXG4gICAgICBuYW1lOiAna2V5d29yZHMnLFxuICAgICAgcmVnOiAvXmtleXdkczooLispJC8sXG4gICAgICBmb3JtYXQ6ICdrZXl3ZHM6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jb250ZW50Om1haW5cbiAgICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICAgIHJlZzogL15jb250ZW50OiguKykvLFxuICAgICAgZm9ybWF0OiAnY29udGVudDolcydcbiAgICB9LFxuICAgIC8vIEJGQ1AgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODNcbiAgICB7XG4gICAgICAvLyBhPWZsb29yY3RybDpjLXNcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JDdHJsJyxcbiAgICAgIHJlZzogL15mbG9vcmN0cmw6KGMtb25seXxzLW9ubHl8Yy1zKS8sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmN0cmw6JXMnXG4gICAgfSwge1xuICAgICAgLy8gYT1jb25maWQ6MVxuICAgICAgbmFtZTogJ2JmY3BDb25mSWQnLFxuICAgICAgcmVnOiAvXmNvbmZpZDooXFxkKykvLFxuICAgICAgZm9ybWF0OiAnY29uZmlkOiVzJ1xuICAgIH0sIHtcbiAgICAgIC8vIGE9dXNlcmlkOjFcbiAgICAgIG5hbWU6ICdiZmNwVXNlcklkJyxcbiAgICAgIHJlZzogL151c2VyaWQ6KFxcZCspLyxcbiAgICAgIGZvcm1hdDogJ3VzZXJpZDolcydcbiAgICB9LCB7XG4gICAgICAvLyBhPWZsb29yaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BGbG9vcklkJyxcbiAgICAgIHJlZzogL15mbG9vcmlkOiguKykgKD86bS1zdHJlYW18bXN0cm0pOiguKykvLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbVN0cmVhbSddLFxuICAgICAgZm9ybWF0OiAnZmxvb3JpZDolcyBtc3RybTolcydcbiAgICB9LCB7XG4gICAgICAvLyBhbnkgYT0gdGhhdCB3ZSBkb24ndCB1bmRlcnN0YW5kIGlzIGtlcHQgdmVyYmF0aW0gb24gbWVkaWEuaW52YWxpZFxuICAgICAgcHVzaDogJ2ludmFsaWQnLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXVxuICAgIH1dXG4gIH07XG5cbiAgLy8gc2V0IHNlbnNpYmxlIGRlZmF1bHRzIHRvIGF2b2lkIHBvbGx1dGluZyB0aGUgZ3JhbW1hciB3aXRoIGJvcmluZyBkZXRhaWxzXG4gIE9iamVjdC5rZXlzKGdyYW1tYXIkMSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgdmFyIG9ianMgPSBncmFtbWFyJDFba2V5XTtcbiAgICBvYmpzLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgaWYgKCFvYmoucmVnKSB7XG4gICAgICAgIG9iai5yZWcgPSAvKC4qKS87XG4gICAgICB9XG4gICAgICBpZiAoIW9iai5mb3JtYXQpIHtcbiAgICAgICAgb2JqLmZvcm1hdCA9ICclcyc7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gZ3JhbW1hci5leHBvcnRzO1xufVxuXG52YXIgaGFzUmVxdWlyZWRQYXJzZXI7XG5mdW5jdGlvbiByZXF1aXJlUGFyc2VyKCkge1xuICBpZiAoaGFzUmVxdWlyZWRQYXJzZXIpIHJldHVybiBwYXJzZXI7XG4gIGhhc1JlcXVpcmVkUGFyc2VyID0gMTtcbiAgKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gICAgdmFyIHRvSW50SWZJbnQgPSBmdW5jdGlvbiAodikge1xuICAgICAgcmV0dXJuIFN0cmluZyhOdW1iZXIodikpID09PSB2ID8gTnVtYmVyKHYpIDogdjtcbiAgICB9O1xuICAgIHZhciBhdHRhY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKG1hdGNoLCBsb2NhdGlvbiwgbmFtZXMsIHJhd05hbWUpIHtcbiAgICAgIGlmIChyYXdOYW1lICYmICFuYW1lcykge1xuICAgICAgICBsb2NhdGlvbltyYXdOYW1lXSA9IHRvSW50SWZJbnQobWF0Y2hbMV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChtYXRjaFtpICsgMV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9jYXRpb25bbmFtZXNbaV1dID0gdG9JbnRJZkludChtYXRjaFtpICsgMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBhcnNlUmVnID0gZnVuY3Rpb24gKG9iaiwgbG9jYXRpb24sIGNvbnRlbnQpIHtcbiAgICAgIHZhciBuZWVkc0JsYW5rID0gb2JqLm5hbWUgJiYgb2JqLm5hbWVzO1xuICAgICAgaWYgKG9iai5wdXNoICYmICFsb2NhdGlvbltvYmoucHVzaF0pIHtcbiAgICAgICAgbG9jYXRpb25bb2JqLnB1c2hdID0gW107XG4gICAgICB9IGVsc2UgaWYgKG5lZWRzQmxhbmsgJiYgIWxvY2F0aW9uW29iai5uYW1lXSkge1xuICAgICAgICBsb2NhdGlvbltvYmoubmFtZV0gPSB7fTtcbiAgICAgIH1cbiAgICAgIHZhciBrZXlMb2NhdGlvbiA9IG9iai5wdXNoID8ge30gOlxuICAgICAgLy8gYmxhbmsgb2JqZWN0IHRoYXQgd2lsbCBiZSBwdXNoZWRcbiAgICAgIG5lZWRzQmxhbmsgPyBsb2NhdGlvbltvYmoubmFtZV0gOiBsb2NhdGlvbjsgLy8gb3RoZXJ3aXNlLCBuYW1lZCBsb2NhdGlvbiBvciByb290XG5cbiAgICAgIGF0dGFjaFByb3BlcnRpZXMoY29udGVudC5tYXRjaChvYmoucmVnKSwga2V5TG9jYXRpb24sIG9iai5uYW1lcywgb2JqLm5hbWUpO1xuICAgICAgaWYgKG9iai5wdXNoKSB7XG4gICAgICAgIGxvY2F0aW9uW29iai5wdXNoXS5wdXNoKGtleUxvY2F0aW9uKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHZhciBncmFtbWFyID0gcmVxdWlyZUdyYW1tYXIoKTtcbiAgICB2YXIgdmFsaWRMaW5lID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0LmJpbmQoL14oW2Etel0pPSguKikvKTtcbiAgICBleHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKHNkcCkge1xuICAgICAgdmFyIHNlc3Npb24gPSB7fSxcbiAgICAgICAgbWVkaWEgPSBbXSxcbiAgICAgICAgbG9jYXRpb24gPSBzZXNzaW9uOyAvLyBwb2ludHMgYXQgd2hlcmUgcHJvcGVydGllcyBnbyB1bmRlciAob25lIG9mIHRoZSBhYm92ZSlcblxuICAgICAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICAgICAgc2RwLnNwbGl0KC8oXFxyXFxufFxccnxcXG4pLykuZmlsdGVyKHZhbGlkTGluZSkuZm9yRWFjaChmdW5jdGlvbiAobCkge1xuICAgICAgICB2YXIgdHlwZSA9IGxbMF07XG4gICAgICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdtJykge1xuICAgICAgICAgIG1lZGlhLnB1c2goe1xuICAgICAgICAgICAgcnRwOiBbXSxcbiAgICAgICAgICAgIGZtdHA6IFtdXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGggLSAxXTsgLy8gcG9pbnQgYXQgbGF0ZXN0IG1lZGlhIGxpbmVcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IChncmFtbWFyW3R5cGVdIHx8IFtdKS5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgICAgIGlmIChvYmoucmVnLnRlc3QoY29udGVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVJlZyhvYmosIGxvY2F0aW9uLCBjb250ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgc2Vzc2lvbi5tZWRpYSA9IG1lZGlhOyAvLyBsaW5rIGl0IHVwXG4gICAgICByZXR1cm4gc2Vzc2lvbjtcbiAgICB9O1xuICAgIHZhciBwYXJhbVJlZHVjZXIgPSBmdW5jdGlvbiAoYWNjLCBleHByKSB7XG4gICAgICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gICAgICBpZiAocy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgYWNjW3NbMF1dID0gdG9JbnRJZkludChzWzFdKTtcbiAgICAgIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgICAgIGFjY1tzWzBdXSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhY2M7XG4gICAgfTtcbiAgICBleHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xuICAgICAgcmV0dXJuIHN0ci5zcGxpdCgvO1xccz8vKS5yZWR1Y2UocGFyYW1SZWR1Y2VyLCB7fSk7XG4gICAgfTtcblxuICAgIC8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gYWxpYXMgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4wXG4gICAgZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBleHBvcnRzLnBhcnNlUGFyYW1zO1xuICAgIGV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIudG9TdHJpbmcoKS5zcGxpdCgnICcpLm1hcChOdW1iZXIpO1xuICAgIH07XG4gICAgZXhwb3J0cy5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICB2YXIgY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcgJykubWFwKHRvSW50SWZJbnQpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMykge1xuICAgICAgICBjYW5kaWRhdGVzLnB1c2goe1xuICAgICAgICAgIGNvbXBvbmVudDogcGFydHNbaV0sXG4gICAgICAgICAgaXA6IHBhcnRzW2kgKyAxXSxcbiAgICAgICAgICBwb3J0OiBwYXJ0c1tpICsgMl1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FuZGlkYXRlcztcbiAgICB9O1xuICAgIGV4cG9ydHMucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLnN1YnN0cmluZygxLCBpdGVtLmxlbmd0aCAtIDEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBleHBvcnRzLnBhcnNlU2ltdWxjYXN0U3RyZWFtTGlzdCA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgIHJldHVybiBzdHIuc3BsaXQoJzsnKS5tYXAoZnVuY3Rpb24gKHN0cmVhbSkge1xuICAgICAgICByZXR1cm4gc3RyZWFtLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgICB2YXIgc2NpZCxcbiAgICAgICAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIGlmIChmb3JtYXRbMF0gIT09ICd+Jykge1xuICAgICAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2NpZCA9IHRvSW50SWZJbnQoZm9ybWF0LnN1YnN0cmluZygxLCBmb3JtYXQubGVuZ3RoKSk7XG4gICAgICAgICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc2NpZDogc2NpZCxcbiAgICAgICAgICAgIHBhdXNlZDogcGF1c2VkXG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9KShwYXJzZXIpO1xuICByZXR1cm4gcGFyc2VyO1xufVxuXG52YXIgd3JpdGVyO1xudmFyIGhhc1JlcXVpcmVkV3JpdGVyO1xuZnVuY3Rpb24gcmVxdWlyZVdyaXRlcigpIHtcbiAgaWYgKGhhc1JlcXVpcmVkV3JpdGVyKSByZXR1cm4gd3JpdGVyO1xuICBoYXNSZXF1aXJlZFdyaXRlciA9IDE7XG4gIHZhciBncmFtbWFyID0gcmVxdWlyZUdyYW1tYXIoKTtcblxuICAvLyBjdXN0b21pemVkIHV0aWwuZm9ybWF0IC0gZGlzY2FyZHMgZXhjZXNzIGFyZ3VtZW50cyBhbmQgY2FuIHZvaWQgbWlkZGxlIG9uZXNcbiAgdmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG4gIHZhciBmb3JtYXQgPSBmdW5jdGlvbiAoZm9ybWF0U3RyKSB7XG4gICAgdmFyIGkgPSAxO1xuICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgIHZhciBsZW4gPSBhcmdzLmxlbmd0aDtcbiAgICByZXR1cm4gZm9ybWF0U3RyLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbiAoeCkge1xuICAgICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICAgIHJldHVybiB4OyAvLyBtaXNzaW5nIGFyZ3VtZW50XG4gICAgICB9XG4gICAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICAgIGkgKz0gMTtcbiAgICAgIHN3aXRjaCAoeCkge1xuICAgICAgICBjYXNlICclJSc6XG4gICAgICAgICAgcmV0dXJuICclJztcbiAgICAgICAgY2FzZSAnJXMnOlxuICAgICAgICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbiAgICAgICAgY2FzZSAnJWQnOlxuICAgICAgICAgIHJldHVybiBOdW1iZXIoYXJnKTtcbiAgICAgICAgY2FzZSAnJXYnOlxuICAgICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBOQjogd2UgZGlzY2FyZCBleGNlc3MgYXJndW1lbnRzIC0gdGhleSBhcmUgdHlwaWNhbGx5IHVuZGVmaW5lZCBmcm9tIG1ha2VMaW5lXG4gIH07XG4gIHZhciBtYWtlTGluZSA9IGZ1bmN0aW9uICh0eXBlLCBvYmosIGxvY2F0aW9uKSB7XG4gICAgdmFyIHN0ciA9IG9iai5mb3JtYXQgaW5zdGFuY2VvZiBGdW5jdGlvbiA/IG9iai5mb3JtYXQob2JqLnB1c2ggPyBsb2NhdGlvbiA6IGxvY2F0aW9uW29iai5uYW1lXSkgOiBvYmouZm9ybWF0O1xuICAgIHZhciBhcmdzID0gW3R5cGUgKyAnPScgKyBzdHJdO1xuICAgIGlmIChvYmoubmFtZXMpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLm5hbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBuID0gb2JqLm5hbWVzW2ldO1xuICAgICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdW25dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBmb3IgbUxpbmUgYW5kIHB1c2ggYXR0cmlidXRlc1xuICAgICAgICAgIGFyZ3MucHVzaChsb2NhdGlvbltvYmoubmFtZXNbaV1dKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcbiAgICB9XG4gICAgcmV0dXJuIGZvcm1hdC5hcHBseShudWxsLCBhcmdzKTtcbiAgfTtcblxuICAvLyBSRkMgc3BlY2lmaWVkIG9yZGVyXG4gIC8vIFRPRE86IGV4dGVuZCB0aGlzIHdpdGggYWxsIHRoZSByZXN0XG4gIHZhciBkZWZhdWx0T3V0ZXJPcmRlciA9IFsndicsICdvJywgJ3MnLCAnaScsICd1JywgJ2UnLCAncCcsICdjJywgJ2InLCAndCcsICdyJywgJ3onLCAnYSddO1xuICB2YXIgZGVmYXVsdElubmVyT3JkZXIgPSBbJ2knLCAnYycsICdiJywgJ2EnXTtcbiAgd3JpdGVyID0gZnVuY3Rpb24gKHNlc3Npb24sIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICAvLyBlbnN1cmUgY2VydGFpbiBwcm9wZXJ0aWVzIGV4aXN0XG4gICAgaWYgKHNlc3Npb24udmVyc2lvbiA9PSBudWxsKSB7XG4gICAgICBzZXNzaW9uLnZlcnNpb24gPSAwOyAvLyAndj0wJyBtdXN0IGJlIHRoZXJlIChvbmx5IGRlZmluZWQgdmVyc2lvbiBhdG0pXG4gICAgfVxuICAgIGlmIChzZXNzaW9uLm5hbWUgPT0gbnVsbCkge1xuICAgICAgc2Vzc2lvbi5uYW1lID0gJyAnOyAvLyAncz0gJyBtdXN0IGJlIHRoZXJlIGlmIG5vIG1lYW5pbmdmdWwgbmFtZSBzZXRcbiAgICB9XG4gICAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgICAgaWYgKG1MaW5lLnBheWxvYWRzID09IG51bGwpIHtcbiAgICAgICAgbUxpbmUucGF5bG9hZHMgPSAnJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgICB2YXIgaW5uZXJPcmRlciA9IG9wdHMuaW5uZXJPcmRlciB8fCBkZWZhdWx0SW5uZXJPcmRlcjtcbiAgICB2YXIgc2RwID0gW107XG5cbiAgICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gICAgb3V0ZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBzZXNzaW9uKSk7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgICAgc2Vzc2lvbltvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvLyB0aGVuIGZvciBlYWNoIG1lZGlhIGxpbmUsIGZvbGxvdyB0aGUgaW5uZXJPcmRlclxuICAgIHNlc3Npb24ubWVkaWEuZm9yRWFjaChmdW5jdGlvbiAobUxpbmUpIHtcbiAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xuICAgICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgaWYgKG9iai5uYW1lIGluIG1MaW5lICYmIG1MaW5lW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChvYmoucHVzaCBpbiBtTGluZSAmJiBtTGluZVtvYmoucHVzaF0gIT0gbnVsbCkge1xuICAgICAgICAgICAgbUxpbmVbb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gc2RwLmpvaW4oJ1xcclxcbicpICsgJ1xcclxcbic7XG4gIH07XG4gIHJldHVybiB3cml0ZXI7XG59XG5cbnZhciBoYXNSZXF1aXJlZExpYjtcbmZ1bmN0aW9uIHJlcXVpcmVMaWIoKSB7XG4gIGlmIChoYXNSZXF1aXJlZExpYikgcmV0dXJuIGxpYjtcbiAgaGFzUmVxdWlyZWRMaWIgPSAxO1xuICB2YXIgcGFyc2VyID0gcmVxdWlyZVBhcnNlcigpO1xuICB2YXIgd3JpdGVyID0gcmVxdWlyZVdyaXRlcigpO1xuICB2YXIgZ3JhbW1hciA9IHJlcXVpcmVHcmFtbWFyKCk7XG4gIGxpYi5ncmFtbWFyID0gZ3JhbW1hcjtcbiAgbGliLndyaXRlID0gd3JpdGVyO1xuICBsaWIucGFyc2UgPSBwYXJzZXIucGFyc2U7XG4gIGxpYi5wYXJzZVBhcmFtcyA9IHBhcnNlci5wYXJzZVBhcmFtcztcbiAgbGliLnBhcnNlRm10cENvbmZpZyA9IHBhcnNlci5wYXJzZUZtdHBDb25maWc7IC8vIEFsaWFzIG9mIHBhcnNlUGFyYW1zKCkuXG4gIGxpYi5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XG4gIGxpYi5wYXJzZVJlbW90ZUNhbmRpZGF0ZXMgPSBwYXJzZXIucGFyc2VSZW1vdGVDYW5kaWRhdGVzO1xuICBsaWIucGFyc2VJbWFnZUF0dHJpYnV0ZXMgPSBwYXJzZXIucGFyc2VJbWFnZUF0dHJpYnV0ZXM7XG4gIGxpYi5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xuICByZXR1cm4gbGliO1xufVxuXG52YXIgbGliRXhwb3J0cyA9IHJlcXVpcmVMaWIoKTtcblxuZnVuY3Rpb24gcihyLCBlLCBuKSB7XG4gIHZhciBpLCB0LCBvO1xuICB2b2lkIDAgPT09IGUgJiYgKGUgPSA1MCksIHZvaWQgMCA9PT0gbiAmJiAobiA9IHt9KTtcbiAgdmFyIGEgPSBudWxsICE9IChpID0gbi5pc0ltbWVkaWF0ZSkgJiYgaSxcbiAgICB1ID0gbnVsbCAhPSAodCA9IG4uY2FsbGJhY2spICYmIHQsXG4gICAgYyA9IG4ubWF4V2FpdCxcbiAgICB2ID0gRGF0ZS5ub3coKSxcbiAgICBsID0gW107XG4gIGZ1bmN0aW9uIGYoKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gYykge1xuICAgICAgdmFyIHIgPSBEYXRlLm5vdygpIC0gdjtcbiAgICAgIGlmIChyICsgZSA+PSBjKSByZXR1cm4gYyAtIHI7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIHZhciBkID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBlID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxuICAgICAgbiA9IHRoaXM7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChpLCB0KSB7XG4gICAgICB2YXIgYyA9IGEgJiYgdm9pZCAwID09PSBvO1xuICAgICAgaWYgKHZvaWQgMCAhPT0gbyAmJiBjbGVhclRpbWVvdXQobyksIG8gPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKG8gPSB2b2lkIDAsIHYgPSBEYXRlLm5vdygpLCAhYSkge1xuICAgICAgICAgIHZhciBpID0gci5hcHBseShuLCBlKTtcbiAgICAgICAgICB1ICYmIHUoaSksIGwuZm9yRWFjaChmdW5jdGlvbiAocikge1xuICAgICAgICAgICAgcmV0dXJuICgwLCByLnJlc29sdmUpKGkpO1xuICAgICAgICAgIH0pLCBsID0gW107XG4gICAgICAgIH1cbiAgICAgIH0sIGYoKSksIGMpIHtcbiAgICAgICAgdmFyIGQgPSByLmFwcGx5KG4sIGUpO1xuICAgICAgICByZXR1cm4gdSAmJiB1KGQpLCBpKGQpO1xuICAgICAgfVxuICAgICAgbC5wdXNoKHtcbiAgICAgICAgcmVzb2x2ZTogaSxcbiAgICAgICAgcmVqZWN0OiB0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIGQuY2FuY2VsID0gZnVuY3Rpb24gKHIpIHtcbiAgICB2b2lkIDAgIT09IG8gJiYgY2xlYXJUaW1lb3V0KG8pLCBsLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgIHJldHVybiAoMCwgZS5yZWplY3QpKHIpO1xuICAgIH0pLCBsID0gW107XG4gIH0sIGQ7XG59XG5cbi8qIFRoZSBzdmMgY29kZWMgKGF2MS92cDkpIHdvdWxkIHVzZSBhIHZlcnkgbG93IGJpdHJhdGUgYXQgdGhlIGJlZ2luaW5nIGFuZFxuaW5jcmVhc2Ugc2xvd2x5IGJ5IHRoZSBiYW5kd2lkdGggZXN0aW1hdG9yIHVudGlsIGl0IHJlYWNoIHRoZSB0YXJnZXQgYml0cmF0ZS4gVGhlXG5wcm9jZXNzIGNvbW1vbmx5IGNvc3QgbW9yZSB0aGFuIDEwIHNlY29uZHMgY2F1c2Ugc3Vic2NyaWJlciB3aWxsIGdldCBibHVyIHZpZGVvIGF0XG50aGUgZmlyc3QgZmV3IHNlY29uZHMuIFNvIHdlIHVzZSBhIDcwJSBvZiB0YXJnZXQgYml0cmF0ZSBoZXJlIGFzIHRoZSBzdGFydCBiaXRyYXRlIHRvXG5lbGltaW5hdGUgdGhpcyBpc3N1ZS5cbiovXG5jb25zdCBzdGFydEJpdHJhdGVGb3JTVkMgPSAwLjc7XG5jb25zdCBkZWJvdW5jZUludGVydmFsID0gMjA7XG5jb25zdCBQQ0V2ZW50cyA9IHtcbiAgTmVnb3RpYXRpb25TdGFydGVkOiAnbmVnb3RpYXRpb25TdGFydGVkJyxcbiAgTmVnb3RpYXRpb25Db21wbGV0ZTogJ25lZ290aWF0aW9uQ29tcGxldGUnLFxuICBSVFBWaWRlb1BheWxvYWRUeXBlczogJ3J0cFZpZGVvUGF5bG9hZFR5cGVzJ1xufTtcbi8qKiBAaW50ZXJuYWwgKi9cbmNsYXNzIFBDVHJhbnNwb3J0IGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBnZXQgcGMoKSB7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhpcy5fcGMgPSB0aGlzLmNyZWF0ZVBDKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9wYztcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuZGRFeHRJRCA9IDA7XG4gICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xuICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IGZhbHNlO1xuICAgIHRoaXMucmVuZWdvdGlhdGUgPSBmYWxzZTtcbiAgICB0aGlzLnRyYWNrQml0cmF0ZXMgPSBbXTtcbiAgICB0aGlzLnJlbW90ZVN0ZXJlb01pZHMgPSBbXTtcbiAgICB0aGlzLnJlbW90ZU5hY2tNaWRzID0gW107XG4gICAgLy8gZGVib3VuY2VkIG5lZ290aWF0ZSBpbnRlcmZhY2VcbiAgICB0aGlzLm5lZ290aWF0ZSA9IHIob25FcnJvciA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmVtaXQoUENFdmVudHMuTmVnb3RpYXRpb25TdGFydGVkKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZE9mZmVyKCk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSksIGRlYm91bmNlSW50ZXJ2YWwpO1xuICAgIHRoaXMuY2xvc2UgPSAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX3BjKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWdhdGhlcmluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub25uZWdvdGlhdGlvbm5lZWRlZCA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbnNpZ25hbGluZ3N0YXRlY2hhbmdlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uaWNlY2FuZGlkYXRlID0gbnVsbDtcbiAgICAgIHRoaXMuX3BjLm9uZGF0YWNoYW5uZWwgPSBudWxsO1xuICAgICAgdGhpcy5fcGMub250cmFjayA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYy5vbmljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICB0aGlzLl9wYyA9IG51bGw7XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLlBDVHJhbnNwb3J0KTtcbiAgICB0aGlzLmxvZ2dlck9wdGlvbnMgPSBsb2dnZXJPcHRpb25zO1xuICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX3BjID0gdGhpcy5jcmVhdGVQQygpO1xuICB9XG4gIGNyZWF0ZVBDKCkge1xuICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHRoaXMuY29uZmlnKTtcbiAgICBwYy5vbmljZWNhbmRpZGF0ZSA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghZXYuY2FuZGlkYXRlKSByZXR1cm47XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ2FuZGlkYXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldi5jYW5kaWRhdGUpO1xuICAgIH07XG4gICAgcGMub25pY2VjYW5kaWRhdGVlcnJvciA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGVFcnJvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcGMub25pY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uSWNlQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5pY2VDb25uZWN0aW9uU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25zaWduYWxpbmdzdGF0ZWNoYW5nZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25TaWduYWxpbmdTdGF0ZWNoYW5nZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgcGMuc2lnbmFsaW5nU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25jb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uQ29ubmVjdGlvblN0YXRlQ2hhbmdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBwYy5jb25uZWN0aW9uU3RhdGUpO1xuICAgIH07XG4gICAgcGMub25kYXRhY2hhbm5lbCA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25EYXRhQ2hhbm5lbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcGMub250cmFjayA9IGV2ID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25UcmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgZXYpO1xuICAgIH07XG4gICAgcmV0dXJuIHBjO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyT3B0aW9ucykubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICB9XG4gIGdldCBpc0lDRUNvbm5lY3RlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGMgIT09IG51bGwgJiYgKHRoaXMucGMuaWNlQ29ubmVjdGlvblN0YXRlID09PSAnY29ubmVjdGVkJyB8fCB0aGlzLnBjLmljZUNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2NvbXBsZXRlZCcpO1xuICB9XG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb24gJiYgIXRoaXMucmVzdGFydGluZ0ljZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucGVuZGluZ0NhbmRpZGF0ZXMucHVzaChjYW5kaWRhdGUpO1xuICAgIH0pO1xuICB9XG4gIHNldFJlbW90ZURlc2NyaXB0aW9uKHNkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGxldCBtdW5nZWRTRFAgPSB1bmRlZmluZWQ7XG4gICAgICBpZiAoc2QudHlwZSA9PT0gJ29mZmVyJykge1xuICAgICAgICBsZXQge1xuICAgICAgICAgIHN0ZXJlb01pZHMsXG4gICAgICAgICAgbmFja01pZHNcbiAgICAgICAgfSA9IGV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIoc2QpO1xuICAgICAgICB0aGlzLnJlbW90ZVN0ZXJlb01pZHMgPSBzdGVyZW9NaWRzO1xuICAgICAgICB0aGlzLnJlbW90ZU5hY2tNaWRzID0gbmFja01pZHM7XG4gICAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2UoKF9hID0gc2Quc2RwKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ2F1ZGlvJykge1xuICAgICAgICAgICAgLy8gbXVuZyBzZHAgZm9yIG9wdXMgYml0cmF0ZSBzZXR0aW5nc1xuICAgICAgICAgICAgdGhpcy50cmFja0JpdHJhdGVzLnNvbWUodHJhY2ticiA9PiB7XG4gICAgICAgICAgICAgIGlmICghdHJhY2tici50cmFuc2NlaXZlciB8fCBtZWRpYS5taWQgIT0gdHJhY2tici50cmFuc2NlaXZlci5taWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XG4gICAgICAgICAgICAgIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJ0cC5jb2RlYy50b1VwcGVyQ2FzZSgpID09PSB0cmFja2JyLmNvZGVjLnRvVXBwZXJDYXNlKCkpIHtcbiAgICAgICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGlmIChjb2RlY1BheWxvYWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsZXQgZm10cEZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gY29kZWNQYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyA9IGZtdHAuY29uZmlnLnNwbGl0KCc7JykuZmlsdGVyKGF0dHIgPT4gIWF0dHIuaW5jbHVkZXMoJ21heGF2ZXJhZ2ViaXRyYXRlJykpLmpvaW4oJzsnKTtcbiAgICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSBcIjttYXhhdmVyYWdlYml0cmF0ZT1cIi5jb25jYXQodHJhY2tici5tYXhiciAqIDEwMDApO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm10cEZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoIWZtdHBGb3VuZCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFja2JyLm1heGJyID4gMCkge1xuICAgICAgICAgICAgICAgICAgbWVkaWEuZm10cC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWNQYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICBjb25maWc6IFwibWF4YXZlcmFnZWJpdHJhdGU9XCIuY29uY2F0KHRyYWNrYnIubWF4YnIgKiAxMDAwKVxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbXVuZ2VkU0RQID0gbGliRXhwb3J0cy53cml0ZShzZHBQYXJzZWQpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAoc2QsIG11bmdlZFNEUCwgdHJ1ZSk7XG4gICAgICB0aGlzLnBlbmRpbmdDYW5kaWRhdGVzLmZvckVhY2goY2FuZGlkYXRlID0+IHtcbiAgICAgICAgdGhpcy5wYy5hZGRJY2VDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5wZW5kaW5nQ2FuZGlkYXRlcyA9IFtdO1xuICAgICAgdGhpcy5yZXN0YXJ0aW5nSWNlID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5yZW5lZ290aWF0ZSkge1xuICAgICAgICB0aGlzLnJlbmVnb3RpYXRlID0gZmFsc2U7XG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZE9mZmVyKCk7XG4gICAgICB9IGVsc2UgaWYgKHNkLnR5cGUgPT09ICdhbnN3ZXInKSB7XG4gICAgICAgIHRoaXMuZW1pdChQQ0V2ZW50cy5OZWdvdGlhdGlvbkNvbXBsZXRlKTtcbiAgICAgICAgaWYgKHNkLnNkcCkge1xuICAgICAgICAgIGNvbnN0IHNkcFBhcnNlZCA9IGxpYkV4cG9ydHMucGFyc2Uoc2Quc2RwKTtcbiAgICAgICAgICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgICAgICAgICBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgICAgICB0aGlzLmVtaXQoUENFdmVudHMuUlRQVmlkZW9QYXlsb2FkVHlwZXMsIG1lZGlhLnJ0cCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBbmRTZW5kT2ZmZXIob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAodGhpcy5vbk9mZmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5pY2VSZXN0YXJ0KSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIElDRScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMucmVzdGFydGluZ0ljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5fcGMgJiYgdGhpcy5fcGMuc2lnbmFsaW5nU3RhdGUgPT09ICdoYXZlLWxvY2FsLW9mZmVyJykge1xuICAgICAgICAvLyB3ZSdyZSB3YWl0aW5nIGZvciB0aGUgcGVlciB0byBhY2NlcHQgb3VyIG9mZmVyLCBzbyB3ZSdsbCBqdXN0IHdhaXRcbiAgICAgICAgLy8gdGhlIG9ubHkgZXhjZXB0aW9uIHRvIHRoaXMgaXMgd2hlbiBJQ0UgcmVzdGFydCBpcyBuZWVkZWRcbiAgICAgICAgY29uc3QgY3VycmVudFNEID0gdGhpcy5fcGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgIGlmICgob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmljZVJlc3RhcnQpICYmIGN1cnJlbnRTRCkge1xuICAgICAgICAgIC8vIFRPRE86IGhhbmRsZSB3aGVuIElDRSByZXN0YXJ0IGlzIG5lZWRlZCBidXQgd2UgZG9uJ3QgaGF2ZSBhIHJlbW90ZSBkZXNjcmlwdGlvblxuICAgICAgICAgIC8vIHRoZSBiZXN0IHRoaW5nIHRvIGRvIGlzIHRvIHJlY3JlYXRlIHRoZSBwZWVyY29ubmVjdGlvblxuICAgICAgICAgIHlpZWxkIHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGN1cnJlbnRTRCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5yZW5lZ290aWF0ZSA9IHRydWU7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl9wYyB8fCB0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGNyZWF0ZU9mZmVyIHdpdGggY2xvc2VkIHBlZXIgY29ubmVjdGlvbicsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGFjdHVhbGx5IG5lZ290aWF0ZVxuICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0YXJ0aW5nIHRvIG5lZ290aWF0ZScsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICBjb25zdCBvZmZlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlT2ZmZXIob3B0aW9ucyk7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnb3JpZ2luYWwgb2ZmZXInLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgc2RwOiBvZmZlci5zZHBcbiAgICAgIH0sIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgY29uc3Qgc2RwUGFyc2VkID0gbGliRXhwb3J0cy5wYXJzZSgoX2EgPSBvZmZlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhKTtcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIFtdLCBbXSk7XG4gICAgICAgIH0gZWxzZSBpZiAobWVkaWEudHlwZSA9PT0gJ3ZpZGVvJykge1xuICAgICAgICAgIHRoaXMudHJhY2tCaXRyYXRlcy5zb21lKHRyYWNrYnIgPT4ge1xuICAgICAgICAgICAgaWYgKCFtZWRpYS5tc2lkIHx8ICF0cmFja2JyLmNpZCB8fCAhbWVkaWEubXNpZC5pbmNsdWRlcyh0cmFja2JyLmNpZCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNvZGVjUGF5bG9hZCA9IDA7XG4gICAgICAgICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgICAgICAgICAgICBpZiAocnRwLmNvZGVjLnRvVXBwZXJDYXNlKCkgPT09IHRyYWNrYnIuY29kZWMudG9VcHBlckNhc2UoKSkge1xuICAgICAgICAgICAgICAgIGNvZGVjUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNvZGVjUGF5bG9hZCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc1NWQ0NvZGVjKHRyYWNrYnIuY29kZWMpKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyhtZWRpYSwgc2RwUGFyc2VkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFRPRE86IGF2MSBzbG93IHN0YXJ0aW5nIGlzc3VlIGFscmVhZHkgZml4ZWQgaW4gY2hyb21lIDEyNCwgY2xlYW4gdGhpcyBhZnRlciBzb21lIHZlcnNpb25zXG4gICAgICAgICAgICAvLyBtdW5nIHNkcCBmb3IgYXYxIGJpdHJhdGUgc2V0dGluZyB0aGF0IGNhbid0IGFwcGx5IGJ5IHNlbmRFbmNvZGluZ1xuICAgICAgICAgICAgaWYgKHRyYWNrYnIuY29kZWMgIT09ICdhdjEnKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhcnRCaXRyYXRlID0gTWF0aC5yb3VuZCh0cmFja2JyLm1heGJyICogc3RhcnRCaXRyYXRlRm9yU1ZDKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZm10cCBvZiBtZWRpYS5mbXRwKSB7XG4gICAgICAgICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IGNvZGVjUGF5bG9hZCkge1xuICAgICAgICAgICAgICAgIC8vIGlmIGFub3RoZXIgdHJhY2sncyBmbXRwIGFscmVhZHkgaXMgc2V0LCB3ZSBjYW5ub3Qgb3ZlcnJpZGUgdGhlIGJpdHJhdGVcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGhhcyB0aGUgdW5mb3J0dW5hdGUgY29uc2VxdWVuY2Ugb2YgYmVpbmcgZm9yY2VkIHRvIHVzZSB0aGVcbiAgICAgICAgICAgICAgICAvLyBpbml0aWFsIHRyYWNrJ3MgYml0cmF0ZSBmb3IgYWxsIHRyYWNrc1xuICAgICAgICAgICAgICAgIGlmICghZm10cC5jb25maWcuaW5jbHVkZXMoJ3gtZ29vZ2xlLXN0YXJ0LWJpdHJhdGUnKSkge1xuICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gXCI7eC1nb29nbGUtc3RhcnQtYml0cmF0ZT1cIi5jb25jYXQoc3RhcnRCaXRyYXRlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TXVuZ2VkU0RQKG9mZmVyLCBsaWJFeHBvcnRzLndyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgdGhpcy5vbk9mZmVyKG9mZmVyKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBbmRTZXRBbnN3ZXIoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMucGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IGFuc3dlci5zZHApICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgIHNkcFBhcnNlZC5tZWRpYS5mb3JFYWNoKG1lZGlhID0+IHtcbiAgICAgICAgZW5zdXJlSVBBZGRyTWF0Y2hWZXJzaW9uKG1lZGlhKTtcbiAgICAgICAgaWYgKG1lZGlhLnR5cGUgPT09ICdhdWRpbycpIHtcbiAgICAgICAgICBlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8obWVkaWEsIHRoaXMucmVtb3RlU3RlcmVvTWlkcywgdGhpcy5yZW1vdGVOYWNrTWlkcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5zZXRNdW5nZWRTRFAoYW5zd2VyLCBsaWJFeHBvcnRzLndyaXRlKHNkcFBhcnNlZCkpO1xuICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCk7XG4gIH1cbiAgYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KSB7XG4gICAgcmV0dXJuIHRoaXMucGMuYWRkVHJhbnNjZWl2ZXIobWVkaWFTdHJlYW1UcmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRUcmFjayh0cmFjaykge1xuICAgIGlmICghdGhpcy5fcGMpIHtcbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBjbG9zZWQsIGNhbm5vdCBhZGQgdHJhY2snKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3BjLmFkZFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFja0NvZGVjQml0cmF0ZShpbmZvKSB7XG4gICAgdGhpcy50cmFja0JpdHJhdGVzLnB1c2goaW5mbyk7XG4gIH1cbiAgc2V0Q29uZmlndXJhdGlvbihydGNDb25maWcpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1BDIGNsb3NlZCwgY2Fubm90IGNvbmZpZ3VyZScpO1xuICAgIH1cbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXRDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gIH1cbiAgY2FuUmVtb3ZlVHJhY2soKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAhISgoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW92ZVRyYWNrKTtcbiAgfVxuICByZW1vdmVUcmFjayhzZW5kZXIpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgfVxuICBnZXRDb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25uZWN0aW9uU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldElDRUNvbm5lY3Rpb25TdGF0ZSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmljZUNvbm5lY3Rpb25TdGF0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ2Nsb3NlZCc7XG4gIH1cbiAgZ2V0U2lnbmFsbGluZ1N0YXRlKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsaW5nU3RhdGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdjbG9zZWQnO1xuICB9XG4gIGdldFRyYW5zY2VpdmVycygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLl9wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFRyYW5zY2VpdmVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRTZW5kZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMuX3BjKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U2VuZGVycygpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcbiAgfVxuICBnZXRMb2NhbERlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5fcGMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbERlc2NyaXB0aW9uO1xuICB9XG4gIGdldFJlbW90ZURlc2NyaXB0aW9uKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5wYykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlbW90ZURlc2NyaXB0aW9uO1xuICB9XG4gIGdldFN0YXRzKCkge1xuICAgIHJldHVybiB0aGlzLnBjLmdldFN0YXRzKCk7XG4gIH1cbiAgZ2V0Q29ubmVjdGVkQWRkcmVzcygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCF0aGlzLl9wYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSAnJztcbiAgICAgIGNvbnN0IGNhbmRpZGF0ZVBhaXJzID0gbmV3IE1hcCgpO1xuICAgICAgLy8gaWQgLT4gY2FuZGlkYXRlIGlwXG4gICAgICBjb25zdCBjYW5kaWRhdGVzID0gbmV3IE1hcCgpO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgc3dpdGNoICh2LnR5cGUpIHtcbiAgICAgICAgICBjYXNlICd0cmFuc3BvcnQnOlxuICAgICAgICAgICAgc2VsZWN0ZWRDYW5kaWRhdGVQYWlySWQgPSB2LnNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAnY2FuZGlkYXRlLXBhaXInOlxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJyAmJiB2LnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgIHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID0gdi5pZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbmRpZGF0ZVBhaXJzLnNldCh2LmlkLCB2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ3JlbW90ZS1jYW5kaWRhdGUnOlxuICAgICAgICAgICAgY2FuZGlkYXRlcy5zZXQodi5pZCwgXCJcIi5jb25jYXQodi5hZGRyZXNzLCBcIjpcIikuY29uY2F0KHYucG9ydCkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaWYgKHNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkID09PSAnJykge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2VsZWN0ZWRJRCA9IChfYSA9IGNhbmRpZGF0ZVBhaXJzLmdldChzZWxlY3RlZENhbmRpZGF0ZVBhaXJJZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdGVDYW5kaWRhdGVJZDtcbiAgICAgIGlmIChzZWxlY3RlZElEID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYW5kaWRhdGVzLmdldChzZWxlY3RlZElEKTtcbiAgICB9KTtcbiAgfVxuICBzZXRNdW5nZWRTRFAoc2QsIG11bmdlZCwgcmVtb3RlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChtdW5nZWQpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWxTZHAgPSBzZC5zZHA7XG4gICAgICAgIHNkLnNkcCA9IG11bmdlZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgbXVuZ2VkIFwiLmNvbmNhdChyZW1vdGUgPyAncmVtb3RlJyA6ICdsb2NhbCcsIFwiIGRlc2NyaXB0aW9uXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMucGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKFwibm90IGFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlLCBcIiwgZmFsbGluZyBiYWNrIHRvIHVubW9kaWZpZWQgc2RwXCIpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlLFxuICAgICAgICAgICAgc2RwOiBtdW5nZWRcbiAgICAgICAgICB9KSk7XG4gICAgICAgICAgc2Quc2RwID0gb3JpZ2luYWxTZHA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChyZW1vdGUpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldFJlbW90ZURlc2NyaXB0aW9uKHNkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnBjLnNldExvY2FsRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGxldCBtc2cgPSAndW5rbm93biBlcnJvcic7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBtc2cgPSBlLm1lc3NhZ2U7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgbXNnID0gZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaWVsZHMgPSB7XG4gICAgICAgICAgZXJyb3I6IG1zZyxcbiAgICAgICAgICBzZHA6IHNkLnNkcFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIXJlbW90ZSAmJiB0aGlzLnBjLnJlbW90ZURlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgZmllbGRzLnJlbW90ZVNkcCA9IHRoaXMucGMucmVtb3RlRGVzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJ1bmFibGUgdG8gc2V0IFwiLmNvbmNhdChzZC50eXBlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZmllbGRzXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhyb3cgbmV3IE5lZ290aWF0aW9uRXJyb3IobXNnKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlbnN1cmVWaWRlb0RERXh0ZW5zaW9uRm9yU1ZDKG1lZGlhLCBzZHApIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGRkRm91bmQgPSAoX2EgPSBtZWRpYS5leHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zb21lKGV4dCA9PiB7XG4gICAgICBpZiAoZXh0LnVyaSA9PT0gZGRFeHRlbnNpb25VUkkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSk7XG4gICAgaWYgKCFkZEZvdW5kKSB7XG4gICAgICBpZiAodGhpcy5kZEV4dElEID09PSAwKSB7XG4gICAgICAgIGxldCBtYXhJRCA9IDA7XG4gICAgICAgIHNkcC5tZWRpYS5mb3JFYWNoKG0gPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBpZiAobS50eXBlICE9PSAndmlkZW8nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIChfYSA9IG0uZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9yRWFjaChleHQgPT4ge1xuICAgICAgICAgICAgaWYgKGV4dC52YWx1ZSA+IG1heElEKSB7XG4gICAgICAgICAgICAgIG1heElEID0gZXh0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kZEV4dElEID0gbWF4SUQgKyAxO1xuICAgICAgfVxuICAgICAgKF9iID0gbWVkaWEuZXh0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucHVzaCh7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRkRXh0SUQsXG4gICAgICAgIHVyaTogZGRFeHRlbnNpb25VUklcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZW5zdXJlQXVkaW9OYWNrQW5kU3RlcmVvKG1lZGlhLCBzdGVyZW9NaWRzLCBuYWNrTWlkcykge1xuICAvLyBmb3VuZCBvcHVzIGNvZGVjIHRvIGFkZCBuYWNrIGZiXG4gIGxldCBvcHVzUGF5bG9hZCA9IDA7XG4gIG1lZGlhLnJ0cC5zb21lKHJ0cCA9PiB7XG4gICAgaWYgKHJ0cC5jb2RlYyA9PT0gJ29wdXMnKSB7XG4gICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSk7XG4gIC8vIGFkZCBuYWNrIHJ0Y3BmYiBpZiBub3QgZXhpc3RcbiAgaWYgKG9wdXNQYXlsb2FkID4gMCkge1xuICAgIGlmICghbWVkaWEucnRjcEZiKSB7XG4gICAgICBtZWRpYS5ydGNwRmIgPSBbXTtcbiAgICB9XG4gICAgaWYgKG5hY2tNaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCkgJiYgIW1lZGlhLnJ0Y3BGYi5zb21lKGZiID0+IGZiLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkICYmIGZiLnR5cGUgPT09ICduYWNrJykpIHtcbiAgICAgIG1lZGlhLnJ0Y3BGYi5wdXNoKHtcbiAgICAgICAgcGF5bG9hZDogb3B1c1BheWxvYWQsXG4gICAgICAgIHR5cGU6ICduYWNrJ1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzdGVyZW9NaWRzLmluY2x1ZGVzKG1lZGlhLm1pZCkpIHtcbiAgICAgIG1lZGlhLmZtdHAuc29tZShmbXRwID0+IHtcbiAgICAgICAgaWYgKGZtdHAucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQpIHtcbiAgICAgICAgICBpZiAoIWZtdHAuY29uZmlnLmluY2x1ZGVzKCdzdGVyZW89MScpKSB7XG4gICAgICAgICAgICBmbXRwLmNvbmZpZyArPSAnO3N0ZXJlbz0xJztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBleHRyYWN0U3RlcmVvQW5kTmFja0F1ZGlvRnJvbU9mZmVyKG9mZmVyKSB7XG4gIHZhciBfYTtcbiAgY29uc3Qgc3RlcmVvTWlkcyA9IFtdO1xuICBjb25zdCBuYWNrTWlkcyA9IFtdO1xuICBjb25zdCBzZHBQYXJzZWQgPSBsaWJFeHBvcnRzLnBhcnNlKChfYSA9IG9mZmVyLnNkcCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICBsZXQgb3B1c1BheWxvYWQgPSAwO1xuICBzZHBQYXJzZWQubWVkaWEuZm9yRWFjaChtZWRpYSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChtZWRpYS50eXBlID09PSAnYXVkaW8nKSB7XG4gICAgICBtZWRpYS5ydHAuc29tZShydHAgPT4ge1xuICAgICAgICBpZiAocnRwLmNvZGVjID09PSAnb3B1cycpIHtcbiAgICAgICAgICBvcHVzUGF5bG9hZCA9IHJ0cC5wYXlsb2FkO1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0pO1xuICAgICAgaWYgKChfYSA9IG1lZGlhLnJ0Y3BGYikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNvbWUoZmIgPT4gZmIucGF5bG9hZCA9PT0gb3B1c1BheWxvYWQgJiYgZmIudHlwZSA9PT0gJ25hY2snKSkge1xuICAgICAgICBuYWNrTWlkcy5wdXNoKG1lZGlhLm1pZCk7XG4gICAgICB9XG4gICAgICBtZWRpYS5mbXRwLnNvbWUoZm10cCA9PiB7XG4gICAgICAgIGlmIChmbXRwLnBheWxvYWQgPT09IG9wdXNQYXlsb2FkKSB7XG4gICAgICAgICAgaWYgKGZtdHAuY29uZmlnLmluY2x1ZGVzKCdzcHJvcC1zdGVyZW89MScpKSB7XG4gICAgICAgICAgICBzdGVyZW9NaWRzLnB1c2gobWVkaWEubWlkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBzdGVyZW9NaWRzLFxuICAgIG5hY2tNaWRzXG4gIH07XG59XG5mdW5jdGlvbiBlbnN1cmVJUEFkZHJNYXRjaFZlcnNpb24obWVkaWEpIHtcbiAgLy8gQ2hyb21lIGNvdWxkIGdlbmVyYXRlIHNkcCB3aXRoIGMgPSBJTiBJUDQgPGlwdjYgYWRkcj5cbiAgLy8gaW4gZWRnZSBjYXNlIGFuZCByZXR1cm4gZXJyb3Igd2hlbiBzZXQgc2RwLlRoaXMgaXMgbm90IGFcbiAgLy8gc2RrIGVycm9yIGJ1dCBjb3JyZWN0IGl0IGlmIHRoZSBpc3N1ZSBkZXRlY3RlZC5cbiAgaWYgKG1lZGlhLmNvbm5lY3Rpb24pIHtcbiAgICBjb25zdCBpc1Y2ID0gbWVkaWEuY29ubmVjdGlvbi5pcC5pbmRleE9mKCc6JykgPj0gMDtcbiAgICBpZiAobWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID09PSA0ICYmIGlzVjYgfHwgbWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID09PSA2ICYmICFpc1Y2KSB7XG4gICAgICAvLyBmYWxsYmFjayB0byBkdW1teSBhZGRyZXNzXG4gICAgICBtZWRpYS5jb25uZWN0aW9uLmlwID0gJzAuMC4wLjAnO1xuICAgICAgbWVkaWEuY29ubmVjdGlvbi52ZXJzaW9uID0gNDtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgZGVmYXVsdFZpZGVvQ29kZWMgPSAndnA4JztcbmNvbnN0IHB1Ymxpc2hEZWZhdWx0cyA9IHtcbiAgYXVkaW9QcmVzZXQ6IEF1ZGlvUHJlc2V0cy5tdXNpYyxcbiAgZHR4OiB0cnVlLFxuICByZWQ6IHRydWUsXG4gIGZvcmNlU3RlcmVvOiBmYWxzZSxcbiAgc2ltdWxjYXN0OiB0cnVlLFxuICBzY3JlZW5TaGFyZUVuY29kaW5nOiBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMxNS5lbmNvZGluZyxcbiAgc3RvcE1pY1RyYWNrT25NdXRlOiBmYWxzZSxcbiAgdmlkZW9Db2RlYzogZGVmYXVsdFZpZGVvQ29kZWMsXG4gIGJhY2t1cENvZGVjOiB0cnVlXG59O1xuY29uc3QgYXVkaW9EZWZhdWx0cyA9IHtcbiAgZGV2aWNlSWQ6IHtcbiAgICBpZGVhbDogJ2RlZmF1bHQnXG4gIH0sXG4gIGF1dG9HYWluQ29udHJvbDogdHJ1ZSxcbiAgZWNob0NhbmNlbGxhdGlvbjogdHJ1ZSxcbiAgbm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcbiAgdm9pY2VJc29sYXRpb246IHRydWVcbn07XG5jb25zdCB2aWRlb0RlZmF1bHRzID0ge1xuICBkZXZpY2VJZDoge1xuICAgIGlkZWFsOiAnZGVmYXVsdCdcbiAgfSxcbiAgcmVzb2x1dGlvbjogVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvblxufTtcbmNvbnN0IHJvb21PcHRpb25EZWZhdWx0cyA9IHtcbiAgYWRhcHRpdmVTdHJlYW06IGZhbHNlLFxuICBkeW5hY2FzdDogZmFsc2UsXG4gIHN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2g6IHRydWUsXG4gIHJlY29ubmVjdFBvbGljeTogbmV3IERlZmF1bHRSZWNvbm5lY3RQb2xpY3koKSxcbiAgZGlzY29ubmVjdE9uUGFnZUxlYXZlOiB0cnVlLFxuICB3ZWJBdWRpb01peDogZmFsc2Vcbn07XG5jb25zdCByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzID0ge1xuICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICBtYXhSZXRyaWVzOiAxLFxuICBwZWVyQ29ubmVjdGlvblRpbWVvdXQ6IDE1MDAwLFxuICB3ZWJzb2NrZXRUaW1lb3V0OiAxNTAwMFxufTtcblxudmFyIFBDVHJhbnNwb3J0U3RhdGU7XG4oZnVuY3Rpb24gKFBDVHJhbnNwb3J0U3RhdGUpIHtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiTkVXXCJdID0gMF0gPSBcIk5FV1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDT05ORUNUSU5HXCJdID0gMV0gPSBcIkNPTk5FQ1RJTkdcIjtcbiAgUENUcmFuc3BvcnRTdGF0ZVtQQ1RyYW5zcG9ydFN0YXRlW1wiQ09OTkVDVEVEXCJdID0gMl0gPSBcIkNPTk5FQ1RFRFwiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJGQUlMRURcIl0gPSAzXSA9IFwiRkFJTEVEXCI7XG4gIFBDVHJhbnNwb3J0U3RhdGVbUENUcmFuc3BvcnRTdGF0ZVtcIkNMT1NJTkdcIl0gPSA0XSA9IFwiQ0xPU0lOR1wiO1xuICBQQ1RyYW5zcG9ydFN0YXRlW1BDVHJhbnNwb3J0U3RhdGVbXCJDTE9TRURcIl0gPSA1XSA9IFwiQ0xPU0VEXCI7XG59KShQQ1RyYW5zcG9ydFN0YXRlIHx8IChQQ1RyYW5zcG9ydFN0YXRlID0ge30pKTtcbmNsYXNzIFBDVHJhbnNwb3J0TWFuYWdlciB7XG4gIGdldCBuZWVkc1B1Ymxpc2hlcigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuICBnZXQgbmVlZHNTdWJzY3JpYmVyKCkge1xuICAgIHJldHVybiB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZDtcbiAgfVxuICBnZXQgY3VycmVudFN0YXRlKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlO1xuICB9XG4gIGNvbnN0cnVjdG9yKHJ0Y0NvbmZpZywgc3Vic2NyaWJlclByaW1hcnksIGxvZ2dlck9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSA9ICgpID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSB0aGlzLnN0YXRlO1xuICAgICAgY29uc3QgY29ubmVjdGlvblN0YXRlcyA9IHRoaXMucmVxdWlyZWRUcmFuc3BvcnRzLm1hcCh0ciA9PiB0ci5nZXRDb25uZWN0aW9uU3RhdGUoKSk7XG4gICAgICBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ2Nvbm5lY3RlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnZmFpbGVkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEO1xuICAgICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGVzLnNvbWUoc3QgPT4gc3QgPT09ICdjb25uZWN0aW5nJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVElORztcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ2Nsb3NlZCcpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLkNMT1NFRDtcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5zb21lKHN0ID0+IHN0ID09PSAnY2xvc2VkJykpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0lORztcbiAgICAgIH0gZWxzZSBpZiAoY29ubmVjdGlvblN0YXRlcy5ldmVyeShzdCA9PiBzdCA9PT0gJ25ldycpKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBQQ1RyYW5zcG9ydFN0YXRlLk5FVztcbiAgICAgIH1cbiAgICAgIGlmIChwcmV2aW91c1N0YXRlICE9PSB0aGlzLnN0YXRlKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwicGMgc3RhdGUgY2hhbmdlOiBmcm9tIFwiLmNvbmNhdChQQ1RyYW5zcG9ydFN0YXRlW3ByZXZpb3VzU3RhdGVdLCBcIiB0byBcIikuY29uY2F0KFBDVHJhbnNwb3J0U3RhdGVbdGhpcy5zdGF0ZV0pLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAoX2EgPSB0aGlzLm9uU3RhdGVDaGFuZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIHRoaXMuc3RhdGUsIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpLCB0aGlzLnN1YnNjcmliZXIuZ2V0Q29ubmVjdGlvblN0YXRlKCkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5sb2cgPSBnZXRMb2dnZXIoKF9hID0gbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QQ01hbmFnZXIpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9ICFzdWJzY3JpYmVyUHJpbWFyeTtcbiAgICB0aGlzLmlzU3Vic2NyaWJlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHN1YnNjcmliZXJQcmltYXJ5O1xuICAgIHRoaXMucHVibGlzaGVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5zdWJzY3JpYmVyID0gbmV3IFBDVHJhbnNwb3J0KHJ0Y0NvbmZpZywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5wdWJsaXNoZXIub25Db25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25JY2VDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMuc3Vic2NyaWJlci5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5wdWJsaXNoZXIub25TaWduYWxpbmdTdGF0ZWNoYW5nZSA9IHRoaXMudXBkYXRlU3RhdGU7XG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UgPSB0aGlzLnVwZGF0ZVN0YXRlO1xuICAgIHRoaXMucHVibGlzaGVyLm9uSWNlQ2FuZGlkYXRlID0gY2FuZGlkYXRlID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIChfYSA9IHRoaXMub25JY2VDYW5kaWRhdGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGNhbmRpZGF0ZSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZXIub25JY2VDYW5kaWRhdGUgPSBjYW5kaWRhdGUgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vbkljZUNhbmRpZGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgY2FuZGlkYXRlLCBTaWduYWxUYXJnZXQuU1VCU0NSSUJFUik7XG4gICAgfTtcbiAgICAvLyBpbiBzdWJzY3JpYmVyIHByaW1hcnkgbW9kZSwgc2VydmVyIHNpZGUgb3BlbnMgc3ViIGRhdGEgY2hhbm5lbHMuXG4gICAgdGhpcy5zdWJzY3JpYmVyLm9uRGF0YUNoYW5uZWwgPSBldiA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLm9uRGF0YUNoYW5uZWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGV2KTtcbiAgICB9O1xuICAgIHRoaXMuc3Vic2NyaWJlci5vblRyYWNrID0gZXYgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vblRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBldik7XG4gICAgfTtcbiAgICB0aGlzLnB1Ymxpc2hlci5vbk9mZmVyID0gb2ZmZXIgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gdGhpcy5vblB1Ymxpc2hlck9mZmVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzLCBvZmZlcik7XG4gICAgfTtcbiAgICB0aGlzLnN0YXRlID0gUENUcmFuc3BvcnRTdGF0ZS5ORVc7XG4gICAgdGhpcy5jb25uZWN0aW9uTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5yZW1vdGVPZmZlckxvY2sgPSBuZXcgXygpO1xuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIChfYiA9IChfYSA9IHRoaXMubG9nZ2VyT3B0aW9ucykubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICB9XG4gIHJlcXVpcmVQdWJsaXNoZXIoKSB7XG4gICAgbGV0IHJlcXVpcmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgdGhpcy5pc1B1Ymxpc2hlckNvbm5lY3Rpb25SZXF1aXJlZCA9IHJlcXVpcmU7XG4gICAgdGhpcy51cGRhdGVTdGF0ZSgpO1xuICB9XG4gIHJlcXVpcmVTdWJzY3JpYmVyKCkge1xuICAgIGxldCByZXF1aXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIHRoaXMuaXNTdWJzY3JpYmVyQ29ubmVjdGlvblJlcXVpcmVkID0gcmVxdWlyZTtcbiAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gIH1cbiAgY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuY3JlYXRlQW5kU2VuZE9mZmVyKG9wdGlvbnMpO1xuICB9XG4gIHNldFB1Ymxpc2hlckFuc3dlcihzZCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5zZXRSZW1vdGVEZXNjcmlwdGlvbihzZCk7XG4gIH1cbiAgcmVtb3ZlVHJhY2soc2VuZGVyKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaGVyLnJlbW92ZVRyYWNrKHNlbmRlcik7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnB1Ymxpc2hlciAmJiB0aGlzLnB1Ymxpc2hlci5nZXRTaWduYWxsaW5nU3RhdGUoKSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgY29uc3QgcHVibGlzaGVyID0gdGhpcy5wdWJsaXNoZXI7XG4gICAgICAgIGZvciAoY29uc3Qgc2VuZGVyIG9mIHB1Ymxpc2hlci5nZXRTZW5kZXJzKCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gVE9ETzogcmVhY3QtbmF0aXZlLXdlYnJ0YyBkb2Vzbid0IGhhdmUgcmVtb3ZlVHJhY2sgeWV0LlxuICAgICAgICAgICAgaWYgKHB1Ymxpc2hlci5jYW5SZW1vdmVUcmFjaygpKSB7XG4gICAgICAgICAgICAgIHB1Ymxpc2hlci5yZW1vdmVUcmFjayhzZW5kZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCByZW1vdmVUcmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgUHJvbWlzZS5hbGwoW3RoaXMucHVibGlzaGVyLmNsb3NlKCksIHRoaXMuc3Vic2NyaWJlci5jbG9zZSgpXSk7XG4gICAgICB0aGlzLnVwZGF0ZVN0YXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgdHJpZ2dlckljZVJlc3RhcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc3Vic2NyaWJlci5yZXN0YXJ0aW5nSWNlID0gdHJ1ZTtcbiAgICAgIC8vIG9ubHkgcmVzdGFydCBwdWJsaXNoZXIgaWYgaXQncyBuZWVkZWRcbiAgICAgIGlmICh0aGlzLm5lZWRzUHVibGlzaGVyKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuY3JlYXRlQW5kU2VuZFB1Ymxpc2hlck9mZmVyKHtcbiAgICAgICAgICBpY2VSZXN0YXJ0OiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGFyZ2V0ID09PSBTaWduYWxUYXJnZXQuUFVCTElTSEVSKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucHVibGlzaGVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeWllbGQgdGhpcy5zdWJzY3JpYmVyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVN1YnNjcmliZXJBbnN3ZXJGcm9tT2ZmZXIoc2QpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHNlcnZlciBvZmZlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBSVENTZHBUeXBlOiBzZC50eXBlLFxuICAgICAgICBzZHA6IHNkLnNkcCxcbiAgICAgICAgc2lnbmFsaW5nU3RhdGU6IHRoaXMuc3Vic2NyaWJlci5nZXRTaWduYWxsaW5nU3RhdGUoKS50b1N0cmluZygpXG4gICAgICB9KSk7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnJlbW90ZU9mZmVyTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLnN1YnNjcmliZXIuc2V0UmVtb3RlRGVzY3JpcHRpb24oc2QpO1xuICAgICAgICAvLyBhbnN3ZXIgdGhlIG9mZmVyXG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHlpZWxkIHRoaXMuc3Vic2NyaWJlci5jcmVhdGVBbmRTZXRBbnN3ZXIoKTtcbiAgICAgICAgcmV0dXJuIGFuc3dlcjtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZUNvbmZpZ3VyYXRpb24oY29uZmlnLCBpY2VSZXN0YXJ0KSB7XG4gICAgdGhpcy5wdWJsaXNoZXIuc2V0Q29uZmlndXJhdGlvbihjb25maWcpO1xuICAgIHRoaXMuc3Vic2NyaWJlci5zZXRDb25maWd1cmF0aW9uKGNvbmZpZyk7XG4gICAgaWYgKGljZVJlc3RhcnQpIHtcbiAgICAgIHRoaXMudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICB9XG4gIH1cbiAgZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uKGFib3J0Q29udHJvbGxlciwgdGltZW91dCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLmNvbm5lY3Rpb25Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkICYmIHRoaXMucHVibGlzaGVyLmdldENvbm5lY3Rpb25TdGF0ZSgpICE9PSAnY29ubmVjdGVkJyAmJiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2Nvbm5lY3RpbmcnKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ25lZ290aWF0aW9uIHJlcXVpcmVkLCBzdGFydCBuZWdvdGlhdGluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwoKF9hID0gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAodHJhbnNwb3J0ID0+IHRoaXMuZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkKHRyYW5zcG9ydCwgYWJvcnRDb250cm9sbGVyLCB0aW1lb3V0KSkpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBuZWdvdGlhdGlvblRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIHRpbWVkIG91dCcpO1xuICAgICAgICB9LCB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dCk7XG4gICAgICAgIGNvbnN0IGFib3J0SGFuZGxlciA9ICgpID0+IHtcbiAgICAgICAgICBjbGVhclRpbWVvdXQobmVnb3RpYXRpb25UaW1lb3V0KTtcbiAgICAgICAgICByZWplY3QoJ25lZ290aWF0aW9uIGFib3J0ZWQnKTtcbiAgICAgICAgfTtcbiAgICAgICAgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgIHRoaXMucHVibGlzaGVyLm9uY2UoUENFdmVudHMuTmVnb3RpYXRpb25TdGFydGVkLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnB1Ymxpc2hlci5vbmNlKFBDRXZlbnRzLk5lZ290aWF0aW9uQ29tcGxldGUsICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXIubmVnb3RpYXRlKGUgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChuZWdvdGlhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIodHJhY2ssIHRyYW5zY2VpdmVySW5pdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFuc2NlaXZlcih0cmFjaywgdHJhbnNjZWl2ZXJJbml0KTtcbiAgfVxuICBhZGRQdWJsaXNoZXJUcmFjayh0cmFjaykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5hZGRUcmFjayh0cmFjayk7XG4gIH1cbiAgY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwobGFiZWwsIGRhdGFDaGFubmVsRGljdCkge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgZGF0YUNoYW5uZWxEaWN0KTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlyc3QgcmVxdWlyZWQgdHJhbnNwb3J0J3MgYWRkcmVzcyBpZiBubyBleHBsaWNpdCB0YXJnZXQgaXMgc3BlY2lmaWVkXG4gICAqL1xuICBnZXRDb25uZWN0ZWRBZGRyZXNzKHRhcmdldCkge1xuICAgIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5QVUJMSVNIRVIpIHtcbiAgICAgIHJldHVybiB0aGlzLnB1Ymxpc2hlci5nZXRDb25uZWN0ZWRBZGRyZXNzKCk7XG4gICAgfSBlbHNlIGlmICh0YXJnZXQgPT09IFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKSB7XG4gICAgICByZXR1cm4gdGhpcy5wdWJsaXNoZXIuZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZXF1aXJlZFRyYW5zcG9ydHNbMF0uZ2V0Q29ubmVjdGVkQWRkcmVzcygpO1xuICB9XG4gIGdldCByZXF1aXJlZFRyYW5zcG9ydHMoKSB7XG4gICAgY29uc3QgdHJhbnNwb3J0cyA9IFtdO1xuICAgIGlmICh0aGlzLmlzUHVibGlzaGVyQ29ubmVjdGlvblJlcXVpcmVkKSB7XG4gICAgICB0cmFuc3BvcnRzLnB1c2godGhpcy5wdWJsaXNoZXIpO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQpIHtcbiAgICAgIHRyYW5zcG9ydHMucHVzaCh0aGlzLnN1YnNjcmliZXIpO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNwb3J0cztcbiAgfVxuICBlbnN1cmVUcmFuc3BvcnRDb25uZWN0ZWQocGNUcmFuc3BvcnRfMSwgYWJvcnRDb250cm9sbGVyXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAocGNUcmFuc3BvcnQsIGFib3J0Q29udHJvbGxlcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCB0aW1lb3V0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0aGlzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBjb25uZWN0aW9uU3RhdGUgPSBwY1RyYW5zcG9ydC5nZXRDb25uZWN0aW9uU3RhdGUoKTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgY29uc3QgYWJvcnRIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYWJvcnQgdHJhbnNwb3J0IGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgQ3JpdGljYWxUaW1lcnMuY2xlYXJUaW1lb3V0KGNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgaWYgKGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgICAgICAgYWJvcnRIYW5kbGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFib3J0Q29udHJvbGxlciA9PT0gbnVsbCB8fCBhYm9ydENvbnRyb2xsZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlci5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBhYm9ydEhhbmRsZXIpO1xuICAgICAgICAgIGNvbnN0IGNvbm5lY3RUaW1lb3V0ID0gQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBhYm9ydENvbnRyb2xsZXIgPT09IG51bGwgfHwgYWJvcnRDb250cm9sbGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgYWJvcnRIYW5kbGVyKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdjb3VsZCBub3QgZXN0YWJsaXNoIHBjIGNvbm5lY3Rpb24nLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcikpO1xuICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgIHdoaWxlICh0aGlzLnN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgeWllbGQgc2xlZXAoNTApOyAvLyBGSVhNRSB3ZSBzaG91bGRuJ3QgcmVseSBvbiBgc2xlZXBgIGluIHRoZSBjb25uZWN0aW9uIHBhdGhzLCBhcyBpdCBpbnZva2VzIGBzZXRUaW1lb3V0YCB3aGljaCBjYW4gYmUgZHJhc3RpY2FsbHkgdGhyb3R0bGVkIGJ5IGJyb3dzZXIgaW1wbGVtZW50YXRpb25zXG4gICAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgICAgICAgIHJlamVjdChuZXcgQ29ubmVjdGlvbkVycm9yKCdyb29tIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2FuY2VsbGVkJywgQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCkpO1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dChjb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyID09PSBudWxsIHx8IGFib3J0Q29udHJvbGxlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyLnNpZ25hbC5yZW1vdmVFdmVudExpc3RlbmVyKCdhYm9ydCcsIGFib3J0SGFuZGxlcik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9KSk7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbn1cblxuLy8gU1BEWC1GaWxlQ29weXJpZ2h0VGV4dDogMjAyNCBMaXZlS2l0LCBJbmMuXG4vL1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcbi8qKlxuICogU3BlY2lhbGl6ZWQgZXJyb3IgaGFuZGxpbmcgZm9yIFJQQyBtZXRob2RzLlxuICpcbiAqIEluc3RhbmNlcyBvZiB0aGlzIHR5cGUsIHdoZW4gdGhyb3duIGluIGEgbWV0aG9kIGhhbmRsZXIsIHdpbGwgaGF2ZSB0aGVpciBgbWVzc2FnZWBcbiAqIHNlcmlhbGl6ZWQgYW5kIHNlbnQgYWNyb3NzIHRoZSB3aXJlLiBUaGUgc2VuZGVyIHdpbGwgcmVjZWl2ZSBhbiBlcXVpdmFsZW50IGVycm9yIG9uIHRoZSBvdGhlciBzaWRlLlxuICpcbiAqIEJ1aWx0LWluIHR5cGVzIGFyZSBpbmNsdWRlZCBidXQgZGV2ZWxvcGVycyBtYXkgdXNlIGFueSBzdHJpbmcsIHdpdGggYSBtYXggbGVuZ3RoIG9mIDI1NiBieXRlcy5cbiAqL1xuY2xhc3MgUnBjRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCB3aXRoIHRoZSBnaXZlbiBjb2RlIGFuZCBtZXNzYWdlLCBwbHVzIGFuIG9wdGlvbmFsIGRhdGEgcGF5bG9hZC5cbiAgICpcbiAgICogSWYgdGhyb3duIGluIGFuIFJQQyBtZXRob2QgaGFuZGxlciwgdGhlIGVycm9yIHdpbGwgYmUgc2VudCBiYWNrIHRvIHRoZSBjYWxsZXIuXG4gICAqXG4gICAqIEVycm9yIGNvZGVzIDEwMDEtMTk5OSBhcmUgcmVzZXJ2ZWQgZm9yIGJ1aWx0LWluIGVycm9ycyAoc2VlIFJwY0Vycm9yLkVycm9yQ29kZSBmb3IgdGhlaXIgbWVhbmluZ3MpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29kZSwgbWVzc2FnZSwgZGF0YSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY29kZSA9IGNvZGU7XG4gICAgdGhpcy5tZXNzYWdlID0gdHJ1bmNhdGVCeXRlcyhtZXNzYWdlLCBScGNFcnJvci5NQVhfTUVTU0FHRV9CWVRFUyk7XG4gICAgdGhpcy5kYXRhID0gZGF0YSA/IHRydW5jYXRlQnl0ZXMoZGF0YSwgUnBjRXJyb3IuTUFYX0RBVEFfQllURVMpIDogdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHN0YXRpYyBmcm9tUHJvdG8ocHJvdG8pIHtcbiAgICByZXR1cm4gbmV3IFJwY0Vycm9yKHByb3RvLmNvZGUsIHByb3RvLm1lc3NhZ2UsIHByb3RvLmRhdGEpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRvUHJvdG8oKSB7XG4gICAgcmV0dXJuIG5ldyBScGNFcnJvciQxKHtcbiAgICAgIGNvZGU6IHRoaXMuY29kZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGVycm9yIG9iamVjdCBmcm9tIHRoZSBjb2RlLCB3aXRoIGFuIGF1dG8tcG9wdWxhdGVkIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RhdGljIGJ1aWx0SW4oa2V5LCBkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBScGNFcnJvcihScGNFcnJvci5FcnJvckNvZGVba2V5XSwgUnBjRXJyb3IuRXJyb3JNZXNzYWdlW2tleV0sIGRhdGEpO1xuICB9XG59XG5ScGNFcnJvci5NQVhfTUVTU0FHRV9CWVRFUyA9IDI1NjtcblJwY0Vycm9yLk1BWF9EQVRBX0JZVEVTID0gMTUzNjA7IC8vIDE1IEtCXG5ScGNFcnJvci5FcnJvckNvZGUgPSB7XG4gIEFQUExJQ0FUSU9OX0VSUk9SOiAxNTAwLFxuICBDT05ORUNUSU9OX1RJTUVPVVQ6IDE1MDEsXG4gIFJFU1BPTlNFX1RJTUVPVVQ6IDE1MDIsXG4gIFJFQ0lQSUVOVF9ESVNDT05ORUNURUQ6IDE1MDMsXG4gIFJFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFOiAxNTA0LFxuICBTRU5EX0ZBSUxFRDogMTUwNSxcbiAgVU5TVVBQT1JURURfTUVUSE9EOiAxNDAwLFxuICBSRUNJUElFTlRfTk9UX0ZPVU5EOiAxNDAxLFxuICBSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFOiAxNDAyLFxuICBVTlNVUFBPUlRFRF9TRVJWRVI6IDE0MDMsXG4gIFVOU1VQUE9SVEVEX1ZFUlNJT046IDE0MDRcbn07XG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5ScGNFcnJvci5FcnJvck1lc3NhZ2UgPSB7XG4gIEFQUExJQ0FUSU9OX0VSUk9SOiAnQXBwbGljYXRpb24gZXJyb3IgaW4gbWV0aG9kIGhhbmRsZXInLFxuICBDT05ORUNUSU9OX1RJTUVPVVQ6ICdDb25uZWN0aW9uIHRpbWVvdXQnLFxuICBSRVNQT05TRV9USU1FT1VUOiAnUmVzcG9uc2UgdGltZW91dCcsXG4gIFJFQ0lQSUVOVF9ESVNDT05ORUNURUQ6ICdSZWNpcGllbnQgZGlzY29ubmVjdGVkJyxcbiAgUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0U6ICdSZXNwb25zZSBwYXlsb2FkIHRvbyBsYXJnZScsXG4gIFNFTkRfRkFJTEVEOiAnRmFpbGVkIHRvIHNlbmQnLFxuICBVTlNVUFBPUlRFRF9NRVRIT0Q6ICdNZXRob2Qgbm90IHN1cHBvcnRlZCBhdCBkZXN0aW5hdGlvbicsXG4gIFJFQ0lQSUVOVF9OT1RfRk9VTkQ6ICdSZWNpcGllbnQgbm90IGZvdW5kJyxcbiAgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRTogJ1JlcXVlc3QgcGF5bG9hZCB0b28gbGFyZ2UnLFxuICBVTlNVUFBPUlRFRF9TRVJWRVI6ICdSUEMgbm90IHN1cHBvcnRlZCBieSBzZXJ2ZXInLFxuICBVTlNVUFBPUlRFRF9WRVJTSU9OOiAnVW5zdXBwb3J0ZWQgUlBDIHZlcnNpb24nXG59O1xuLypcbiAqIE1heGltdW0gcGF5bG9hZCBzaXplIGZvciBSUEMgcmVxdWVzdHMgYW5kIHJlc3BvbnNlcy4gSWYgYSBwYXlsb2FkIGV4Y2VlZHMgdGhpcyBzaXplLFxuICogdGhlIFJQQyBjYWxsIHdpbGwgZmFpbCB3aXRoIGEgUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRSgxNDAyKSBvciBSRVNQT05TRV9QQVlMT0FEX1RPT19MQVJHRSgxNTA0KSBlcnJvci5cbiAqL1xuY29uc3QgTUFYX1BBWUxPQURfQllURVMgPSAxNTM2MDsgLy8gMTUgS0Jcbi8qKlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGJ5dGVMZW5ndGgoc3RyKSB7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgcmV0dXJuIGVuY29kZXIuZW5jb2RlKHN0cikubGVuZ3RoO1xufVxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gdHJ1bmNhdGVCeXRlcyhzdHIsIG1heEJ5dGVzKSB7XG4gIGlmIChieXRlTGVuZ3RoKHN0cikgPD0gbWF4Qnl0ZXMpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGxldCBsb3cgPSAwO1xuICBsZXQgaGlnaCA9IHN0ci5sZW5ndGg7XG4gIGNvbnN0IGVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICBjb25zdCBtaWQgPSBNYXRoLmZsb29yKChsb3cgKyBoaWdoICsgMSkgLyAyKTtcbiAgICBpZiAoZW5jb2Rlci5lbmNvZGUoc3RyLnNsaWNlKDAsIG1pZCkpLmxlbmd0aCA8PSBtYXhCeXRlcykge1xuICAgICAgbG93ID0gbWlkO1xuICAgIH0gZWxzZSB7XG4gICAgICBoaWdoID0gbWlkIC0gMTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN0ci5zbGljZSgwLCBsb3cpO1xufVxuXG5jb25zdCBtb25pdG9yRnJlcXVlbmN5ID0gMjAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVCaXRyYXRlKGN1cnJlbnRTdGF0cywgcHJldlN0YXRzKSB7XG4gIGlmICghcHJldlN0YXRzKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgbGV0IGJ5dGVzTm93O1xuICBsZXQgYnl0ZXNQcmV2O1xuICBpZiAoJ2J5dGVzUmVjZWl2ZWQnIGluIGN1cnJlbnRTdGF0cykge1xuICAgIGJ5dGVzTm93ID0gY3VycmVudFN0YXRzLmJ5dGVzUmVjZWl2ZWQ7XG4gICAgYnl0ZXNQcmV2ID0gcHJldlN0YXRzLmJ5dGVzUmVjZWl2ZWQ7XG4gIH0gZWxzZSBpZiAoJ2J5dGVzU2VudCcgaW4gY3VycmVudFN0YXRzKSB7XG4gICAgYnl0ZXNOb3cgPSBjdXJyZW50U3RhdHMuYnl0ZXNTZW50O1xuICAgIGJ5dGVzUHJldiA9IHByZXZTdGF0cy5ieXRlc1NlbnQ7XG4gIH1cbiAgaWYgKGJ5dGVzTm93ID09PSB1bmRlZmluZWQgfHwgYnl0ZXNQcmV2ID09PSB1bmRlZmluZWQgfHwgY3VycmVudFN0YXRzLnRpbWVzdGFtcCA9PT0gdW5kZWZpbmVkIHx8IHByZXZTdGF0cy50aW1lc3RhbXAgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHJldHVybiAoYnl0ZXNOb3cgLSBieXRlc1ByZXYpICogOCAqIDEwMDAgLyAoY3VycmVudFN0YXRzLnRpbWVzdGFtcCAtIHByZXZTdGF0cy50aW1lc3RhbXApO1xufVxuXG5jb25zdCBkZWZhdWx0RGltZW5zaW9uc1RpbWVvdXQgPSAxMDAwO1xuY2xhc3MgTG9jYWxUcmFjayBleHRlbmRzIFRyYWNrIHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBnZXQgc2VuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLl9zZW5kZXI7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXQgc2VuZGVyKHNlbmRlcikge1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcbiAgfVxuICBnZXQgY29uc3RyYWludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnN0cmFpbnRzO1xuICB9XG4gIC8qKlxuICAgKlxuICAgKiBAcGFyYW0gbWVkaWFUcmFja1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcGFyYW0gY29uc3RyYWludHMgTWVkaWFUcmFja0NvbnN0cmFpbnRzIHRoYXQgYXJlIGJlaW5nIHVzZWQgd2hlbiByZXN0YXJ0aW5nIG9yIHJlYWNxdWlyaW5nIHRyYWNrc1xuICAgKiBAcGFyYW0gdXNlclByb3ZpZGVkVHJhY2sgU2lnbmFscyB0byB0aGUgU0RLIHdoZXRoZXIgb3Igbm90IHRoZSBtZWRpYVRyYWNrIHNob3VsZCBiZSBtYW5hZ2VkIChpLmUuIHJlbGVhc2VkIGFuZCByZWFjcXVpcmVkKSBpbnRlcm5hbGx5IGJ5IHRoZSBTREtcbiAgICovXG4gIGNvbnN0cnVjdG9yKG1lZGlhVHJhY2ssIGtpbmQsIGNvbnN0cmFpbnRzKSB7XG4gICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBmYWxzZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiA0ID8gYXJndW1lbnRzWzRdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMubWFudWFsbHlTdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xuICAgIHRoaXMuaGFuZGxlVHJhY2tNdXRlRXZlbnQgPSAoKSA9PiB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIoKS5jYXRjaCgoKSA9PiB0aGlzLmxvZy5kZWJ1ZygndHJhY2sgbXV0ZSBib3VuY2UgZ290IGNhbmNlbGxlZCBieSBhbiB1bm11dGUgZXZlbnQnLCB0aGlzLmxvZ0NvbnRleHQpKTtcbiAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIgPSByKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMucGF1c2VVcHN0cmVhbSgpO1xuICAgIH0pLCA1MDAwKTtcbiAgICB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIuY2FuY2VsKCd1bm11dGUnKTtcbiAgICAgIHlpZWxkIHRoaXMucmVzdW1lVXBzdHJlYW0oKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZUVuZGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuaXNJbkJhY2tncm91bmQpIHtcbiAgICAgICAgdGhpcy5yZWFjcXVpcmVUcmFjayA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sucmVtb3ZlRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMucmVhY3F1aXJlVHJhY2sgPSBmYWxzZTtcbiAgICB0aGlzLnByb3ZpZGVkQnlVc2VyID0gdXNlclByb3ZpZGVkVHJhY2s7XG4gICAgdGhpcy5tdXRlTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5wYXVzZVVwc3RyZWFtTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5wcm9jZXNzb3JMb2NrID0gbmV3IF8oKTtcbiAgICB0aGlzLnJlc3RhcnRMb2NrID0gbmV3IF8oKTtcbiAgICB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sobWVkaWFUcmFjaywgdHJ1ZSk7XG4gICAgLy8gYWRkZWQgdG8gc2F0aXNmeSBUUyBjb21waWxlciwgY29uc3RyYWludHMgYXJlIHN5bmNlZCB3aXRoIE1lZGlhU3RyZWFtVHJhY2tcbiAgICB0aGlzLl9jb25zdHJhaW50cyA9IG1lZGlhVHJhY2suZ2V0Q29uc3RyYWludHMoKTtcbiAgICBpZiAoY29uc3RyYWludHMpIHtcbiAgICAgIHRoaXMuX2NvbnN0cmFpbnRzID0gY29uc3RyYWludHM7XG4gICAgfVxuICB9XG4gIGdldCBpZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5pZDtcbiAgfVxuICBnZXQgZGltZW5zaW9ucygpIHtcbiAgICBpZiAodGhpcy5raW5kICE9PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgaWYgKHdpZHRoICYmIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGgsXG4gICAgICAgIGhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBnZXQgaXNVcHN0cmVhbVBhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNVcHN0cmVhbVBhdXNlZDtcbiAgfVxuICBnZXQgaXNVc2VyUHJvdmlkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMucHJvdmlkZWRCeVVzZXI7XG4gIH1cbiAgZ2V0IG1lZGlhU3RyZWFtVHJhY2soKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5wcm9jZXNzb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcm9jZXNzZWRUcmFjaykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdGhpcy5fbWVkaWFTdHJlYW1UcmFjaztcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIHJldHVybnMgbWVkaWFTdHJlYW1UcmFjayBzZXR0aW5ncyBvZiB0aGUgY2FwdHVyaW5nIG1lZGlhc3RyZWFtdHJhY2sgc291cmNlIC0gaWdub3JpbmcgcHJvY2Vzc29yc1xuICAgKi9cbiAgZ2V0U291cmNlVHJhY2tTZXR0aW5ncygpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpO1xuICB9XG4gIHNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2ssIGZvcmNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChuZXdUcmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjayAmJiAhZm9yY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX21lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgLy8gZGV0YWNoXG4gICAgICAgIHRoaXMuYXR0YWNoZWRFbGVtZW50cy5mb3JFYWNoKGVsID0+IHtcbiAgICAgICAgICBkZXRhY2hUcmFjayh0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmRlYm91bmNlZFRyYWNrTXV0ZUhhbmRsZXIuY2FuY2VsKCduZXctdHJhY2snKTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5tZWRpYVN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbbmV3VHJhY2tdKTtcbiAgICAgIGlmIChuZXdUcmFjaykge1xuICAgICAgICBuZXdUcmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuaGFuZGxlRW5kZWQpO1xuICAgICAgICAvLyB3aGVuIHVuZGVybHlpbmcgdHJhY2sgZW1pdHMgbXV0ZSwgaXQgaW5kaWNhdGVzIHRoYXQgdGhlIGRldmljZSBpcyB1bmFibGVcbiAgICAgICAgLy8gdG8gcHJvZHVjZSBtZWRpYS4gSW4gdGhpcyBjYXNlIHdlJ2xsIG5lZWQgdG8gc2lnbmFsIHdpdGggcmVtb3RlIHRoYXRcbiAgICAgICAgLy8gdGhlIHRyYWNrIGlzIFwibXV0ZWRcIlxuICAgICAgICAvLyBub3RlIHRoaXMgaXMgZGlmZmVyZW50IGZyb20gTG9jYWxUcmFjay5tdXRlIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAgICAgLy8gdG91Y2ggTWVkaWFTdHJlYW1UcmFjay5lbmFibGVkXG4gICAgICAgIG5ld1RyYWNrLmFkZEV2ZW50TGlzdGVuZXIoJ211dGUnLCB0aGlzLmhhbmRsZVRyYWNrTXV0ZUV2ZW50KTtcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcigndW5tdXRlJywgdGhpcy5oYW5kbGVUcmFja1VubXV0ZUV2ZW50KTtcbiAgICAgICAgdGhpcy5fY29uc3RyYWludHMgPSBuZXdUcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgfVxuICAgICAgbGV0IHByb2Nlc3NlZFRyYWNrO1xuICAgICAgaWYgKHRoaXMucHJvY2Vzc29yICYmIG5ld1RyYWNrKSB7XG4gICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucHJvY2Vzc29yTG9jay5sb2NrKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgcHJvY2Vzc29yJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICBpZiAodGhpcy5raW5kID09PSAndW5rbm93bicpIHtcbiAgICAgICAgICAgIHRocm93IFR5cGVFcnJvcignY2Fubm90IHNldCBwcm9jZXNzb3Igb24gdHJhY2sgb2YgdW5rbm93biBraW5kJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLnByb2Nlc3NvckVsZW1lbnQpIHtcbiAgICAgICAgICAgIGF0dGFjaFRvRWxlbWVudChuZXdUcmFjaywgdGhpcy5wcm9jZXNzb3JFbGVtZW50KTtcbiAgICAgICAgICAgIC8vIGVuc3VyZSB0aGUgcHJvY2Vzc29yRWxlbWVudCBpdHNlbGYgc3RheXMgbXV0ZWRcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHlpZWxkIHRoaXMucHJvY2Vzc29yLnJlc3RhcnQoe1xuICAgICAgICAgICAgdHJhY2s6IG5ld1RyYWNrLFxuICAgICAgICAgICAga2luZDogdGhpcy5raW5kLFxuICAgICAgICAgICAgZWxlbWVudDogdGhpcy5wcm9jZXNzb3JFbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcHJvY2Vzc2VkVHJhY2sgPSB0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaztcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2VuZGVyICYmICgoX2EgPSB0aGlzLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2VuZGVyLnJlcGxhY2VUcmFjayhwcm9jZXNzZWRUcmFjayAhPT0gbnVsbCAmJiBwcm9jZXNzZWRUcmFjayAhPT0gdm9pZCAwID8gcHJvY2Vzc2VkVHJhY2sgOiBuZXdUcmFjayk7XG4gICAgICB9XG4gICAgICAvLyBpZiBgbmV3VHJhY2tgIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBleGlzdGluZyB0cmFjaywgc3RvcCB0aGVcbiAgICAgIC8vIG9sZGVyIHRyYWNrIGp1c3QgYmVmb3JlIHJlcGxhY2luZyBpdFxuICAgICAgaWYgKCF0aGlzLnByb3ZpZGVkQnlVc2VyICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2sgIT09IG5ld1RyYWNrKSB7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suc3RvcCgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjayA9IG5ld1RyYWNrO1xuICAgICAgaWYgKG5ld1RyYWNrKSB7XG4gICAgICAgIC8vIHN5bmMgbXV0ZWQgc3RhdGUgd2l0aCB0aGUgZW5hYmxlZCBzdGF0ZSBvZiB0aGUgbmV3bHkgcHJvdmlkZWQgdHJhY2tcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkID0gIXRoaXMuaXNNdXRlZDtcbiAgICAgICAgLy8gd2hlbiBhIHZhbGlkIHRyYWNrIGlzIHJlcGxhY2UsIHdlJ2Qgd2FudCB0byBzdGFydCBwcm9kdWNpbmdcbiAgICAgICAgeWllbGQgdGhpcy5yZXN1bWVVcHN0cmVhbSgpO1xuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgYXR0YWNoVG9FbGVtZW50KHByb2Nlc3NlZFRyYWNrICE9PSBudWxsICYmIHByb2Nlc3NlZFRyYWNrICE9PSB2b2lkIDAgPyBwcm9jZXNzZWRUcmFjayA6IG5ld1RyYWNrLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JEaW1lbnNpb25zKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICBsZXQgdGltZW91dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZGVmYXVsdERpbWVuc2lvbnNUaW1lb3V0O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKF90aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBnZXQgZGltZW5zaW9ucyBmb3IgYXVkaW8gdHJhY2tzJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSBnZXRCcm93c2VyKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5vcykgPT09ICdpT1MnKSB7XG4gICAgICAgICAgLy8gYnJvd3NlcnMgcmVwb3J0IHdyb25nIGluaXRpYWwgcmVzb2x1dGlvbiBvbiBpT1MuXG4gICAgICAgICAgLy8gd2hlbiBzbGlnaHRseSBkZWxheWluZyB0aGUgY2FsbCB0byAuZ2V0U2V0dGluZ3MoKSwgdGhlIGNvcnJlY3QgcmVzb2x1dGlvbiBpcyBiZWluZyByZXBvcnRlZFxuICAgICAgICAgIHlpZWxkIHNsZWVwKDEwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdGFydGVkID0gRGF0ZS5ub3coKTtcbiAgICAgICAgd2hpbGUgKERhdGUubm93KCkgLSBzdGFydGVkIDwgdGltZW91dCkge1xuICAgICAgICAgIGNvbnN0IGRpbXMgPSBfdGhpcy5kaW1lbnNpb25zO1xuICAgICAgICAgIGlmIChkaW1zKSB7XG4gICAgICAgICAgICByZXR1cm4gZGltcztcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndW5hYmxlIHRvIGdldCB0cmFjayBkaW1lbnNpb25zIGFmdGVyIHRpbWVvdXQnKTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICBzZXREZXZpY2VJZChkZXZpY2VJZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQgPT09IGRldmljZUlkICYmIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKS5kZXZpY2VJZCA9PT0gdW53cmFwQ29uc3RyYWludChkZXZpY2VJZCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCA9IGRldmljZUlkO1xuICAgICAgLy8gd2hlbiB0cmFjayBpcyBtdXRlZCwgdW5kZXJseWluZyBtZWRpYSBzdHJlYW0gdHJhY2sgaXMgc3RvcHBlZCBhbmRcbiAgICAgIC8vIHdpbGwgYmUgcmVzdGFydGVkIGxhdGVyXG4gICAgICBpZiAodGhpcy5pc011dGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgIHJldHVybiB1bndyYXBDb25zdHJhaW50KGRldmljZUlkKSA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAcmV0dXJucyBEZXZpY2VJRCBvZiB0aGUgZGV2aWNlIHRoYXQgaXMgY3VycmVudGx5IGJlaW5nIHVzZWQgZm9yIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldERldmljZUlkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbGV0IG5vcm1hbGl6ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICAvLyBzY3JlZW4gc2hhcmUgZG9lc24ndCBoYXZlIGEgdXNhYmxlIGRldmljZSBpZFxuICAgICAgICBpZiAoX3RoaXMyLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkZXZpY2VJZCxcbiAgICAgICAgICBncm91cElkXG4gICAgICAgIH0gPSBfdGhpczIuX21lZGlhU3RyZWFtVHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgICAgICAgY29uc3Qga2luZCA9IF90aGlzMi5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvID8gJ2F1ZGlvaW5wdXQnIDogJ3ZpZGVvaW5wdXQnO1xuICAgICAgICByZXR1cm4gbm9ybWFsaXplID8gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLm5vcm1hbGl6ZURldmljZUlkKGtpbmQsIGRldmljZUlkLCBncm91cElkKSA6IGRldmljZUlkO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIG11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMuc2V0VHJhY2tNdXRlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zZXRUcmFja011dGVkKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHJlcGxhY2VUcmFjayh0cmFjaywgdXNlclByb3ZpZGVkT3JPcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKCd1bmFibGUgdG8gcmVwbGFjZSBhbiB1bnB1Ymxpc2hlZCB0cmFjaycpO1xuICAgICAgfVxuICAgICAgbGV0IHVzZXJQcm92aWRlZFRyYWNrO1xuICAgICAgbGV0IHN0b3BQcm9jZXNzb3I7XG4gICAgICBpZiAodHlwZW9mIHVzZXJQcm92aWRlZE9yT3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHVzZXJQcm92aWRlZFRyYWNrID0gdXNlclByb3ZpZGVkT3JPcHRpb25zO1xuICAgICAgfSBlbHNlIGlmICh1c2VyUHJvdmlkZWRPck9wdGlvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1c2VyUHJvdmlkZWRUcmFjayA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucy51c2VyUHJvdmlkZWRUcmFjaztcbiAgICAgICAgc3RvcFByb2Nlc3NvciA9IHVzZXJQcm92aWRlZE9yT3B0aW9ucy5zdG9wUHJvY2Vzc29yO1xuICAgICAgfVxuICAgICAgdGhpcy5wcm92aWRlZEJ5VXNlciA9IHVzZXJQcm92aWRlZFRyYWNrICE9PSBudWxsICYmIHVzZXJQcm92aWRlZFRyYWNrICE9PSB2b2lkIDAgPyB1c2VyUHJvdmlkZWRUcmFjayA6IHRydWU7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygncmVwbGFjZSBNZWRpYVN0cmVhbVRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHlpZWxkIHRoaXMuc2V0TWVkaWFTdHJlYW1UcmFjayh0cmFjayk7XG4gICAgICAvLyB0aGlzIG11c3QgYmUgc3luY2VkICphZnRlciogc2V0dGluZyBtZWRpYVN0cmVhbVRyYWNrIGFib3ZlLCBzaW5jZSBpdCByZWxpZXNcbiAgICAgIC8vIG9uIHRoZSBwcmV2aW91cyBzdGF0ZSBpbiBvcmRlciB0byBjbGVhbnVwXG4gICAgICBpZiAoc3RvcFByb2Nlc3NvciAmJiB0aGlzLnByb2Nlc3Nvcikge1xuICAgICAgICB5aWVsZCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0pO1xuICB9XG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5tYW51YWxseVN0b3BwZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMucmVzdGFydExvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKCFjb25zdHJhaW50cykge1xuICAgICAgICAgIGNvbnN0cmFpbnRzID0gdGhpcy5fY29uc3RyYWludHM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZGV2aWNlSWQsXG4gICAgICAgICAgICBmYWNpbmdNb2RlXG4gICAgICAgICAgfSA9IGNvbnN0cmFpbnRzLFxuICAgICAgICAgIG90aGVyQ29uc3RyYWludHMgPSBfX3Jlc3QoY29uc3RyYWludHMsIFtcImRldmljZUlkXCIsIFwiZmFjaW5nTW9kZVwiXSk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKCdyZXN0YXJ0aW5nIHRyYWNrIHdpdGggY29uc3RyYWludHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBjb25zdHJhaW50c1xuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0ge1xuICAgICAgICAgIGF1ZGlvOiBmYWxzZSxcbiAgICAgICAgICB2aWRlbzogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLnZpZGVvID0gZGV2aWNlSWQgfHwgZmFjaW5nTW9kZSA/IHtcbiAgICAgICAgICAgIGRldmljZUlkLFxuICAgICAgICAgICAgZmFjaW5nTW9kZVxuICAgICAgICAgIH0gOiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvID0gZGV2aWNlSWQgPyB7XG4gICAgICAgICAgICBkZXZpY2VJZFxuICAgICAgICAgIH0gOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRoZXNlIHN0ZXBzIGFyZSBkdXBsaWNhdGVkIGZyb20gc2V0TWVkaWFTdHJlYW1UcmFjayBiZWNhdXNlIHdlIG11c3Qgc3RvcFxuICAgICAgICAvLyB0aGUgcHJldmlvdXMgdHJhY2tzIGJlZm9yZSBuZXcgdHJhY2tzIGNhbiBiZSBhY3F1aXJlZFxuICAgICAgICB0aGlzLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5tZWRpYVN0cmVhbVRyYWNrLCBlbCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICAgIC8vIG9uIFNhZmFyaSwgdGhlIG9sZCBhdWRpbyB0cmFjayBtdXN0IGJlIHN0b3BwZWQgYmVmb3JlIGF0dGVtcHRpbmcgdG8gYWNxdWlyZVxuICAgICAgICAvLyB0aGUgbmV3IHRyYWNrLCBvdGhlcndpc2UgdGhlIG5ldyB0cmFjayB3aWxsIHN0b3Agd2l0aFxuICAgICAgICAvLyAnQSBNZWRpYVN0cmVhbVRyYWNrIGVuZGVkIGR1ZSB0byBhIGNhcHR1cmUgZmFpbHVyZWBcbiAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICAgIC8vIGNyZWF0ZSBuZXcgdHJhY2sgYW5kIGF0dGFjaFxuICAgICAgICBjb25zdCBtZWRpYVN0cmVhbSA9IHlpZWxkIG5hdmlnYXRvci5tZWRpYURldmljZXMuZ2V0VXNlck1lZGlhKHN0cmVhbUNvbnN0cmFpbnRzKTtcbiAgICAgICAgY29uc3QgbmV3VHJhY2sgPSBtZWRpYVN0cmVhbS5nZXRUcmFja3MoKVswXTtcbiAgICAgICAgeWllbGQgbmV3VHJhY2suYXBwbHlDb25zdHJhaW50cyhvdGhlckNvbnN0cmFpbnRzKTtcbiAgICAgICAgbmV3VHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5kZWQnLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlLWFjcXVpcmVkIE1lZGlhU3RyZWFtVHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB5aWVsZCB0aGlzLnNldE1lZGlhU3RyZWFtVHJhY2sobmV3VHJhY2spO1xuICAgICAgICB0aGlzLl9jb25zdHJhaW50cyA9IGNvbnN0cmFpbnRzO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5tYW51YWxseVN0b3BwZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgc3RvcHBlZCBkdXJpbmcgYSByZXN0YXJ0LCBzdG9wcGluZyByZXN0YXJ0ZWQgdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xuICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyBcIi5jb25jYXQodGhpcy5raW5kLCBcIiB0cmFjayBcIikuY29uY2F0KG11dGVkID8gJ211dGVkJyA6ICd1bm11dGVkJyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgaWYgKHRoaXMuaXNNdXRlZCA9PT0gbXV0ZWQgJiYgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkICE9PSBtdXRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmVuYWJsZWQgPSAhbXV0ZWQ7XG4gICAgdGhpcy5lbWl0KG11dGVkID8gVHJhY2tFdmVudC5NdXRlZCA6IFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcyk7XG4gIH1cbiAgZ2V0IG5lZWRzUmVBY3F1aXNpdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlICE9PSAnbGl2ZScgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5tdXRlZCB8fCAhdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5lbmFibGVkIHx8IHRoaXMucmVhY3F1aXJlVHJhY2s7XG4gIH1cbiAgaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZDoge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIF9zdXBlci5oYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZC5jYWxsKHRoaXMpO1xuICAgICAgaWYgKCFpc01vYmlsZSgpKSByZXR1cm47XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInZpc2liaWxpdHkgY2hhbmdlZCwgaXMgaW4gQmFja2dyb3VuZDogXCIuY29uY2F0KHRoaXMuaXNJbkJhY2tncm91bmQpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKCF0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMubmVlZHNSZUFjcXVpc2l0aW9uICYmICF0aGlzLmlzVXNlclByb3ZpZGVkICYmICF0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJ0cmFjayBuZWVkcyB0byBiZSByZWFjcXVpcmVkLCByZXN0YXJ0aW5nIFwiLmNvbmNhdCh0aGlzLnNvdXJjZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHlpZWxkIHRoaXMucmVzdGFydCgpO1xuICAgICAgICB0aGlzLnJlYWNxdWlyZVRyYWNrID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc3RvcCgpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5tYW51YWxseVN0b3BwZWQgPSB0cnVlO1xuICAgIHN1cGVyLnN0b3AoKTtcbiAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2VuZGVkJywgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdtdXRlJywgdGhpcy5oYW5kbGVUcmFja011dGVFdmVudCk7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCd1bm11dGUnLCB0aGlzLmhhbmRsZVRyYWNrVW5tdXRlRXZlbnQpO1xuICAgIChfYSA9IHRoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVzdHJveSgpO1xuICAgIHRoaXMucHJvY2Vzc29yID0gdW5kZWZpbmVkO1xuICB9XG4gIC8qKlxuICAgKiBwYXVzZXMgcHVibGlzaGluZyB0byB0aGUgc2VydmVyIHdpdGhvdXQgZGlzYWJsaW5nIHRoZSBsb2NhbCBNZWRpYVN0cmVhbVRyYWNrXG4gICAqIHRoaXMgaXMgdXNlZCB0byBkaXNwbGF5IGEgdXNlcidzIG93biB2aWRlbyBsb2NhbGx5IHdoaWxlIHBhdXNpbmcgcHVibGlzaGluZyB0b1xuICAgKiB0aGUgc2VydmVyLlxuICAgKiB0aGlzIEFQSSBpcyB1bnN1cHBvcnRlZCBvbiBTYWZhcmkgPCAxMiBkdWUgdG8gYSBidWdcbiAgICoqL1xuICBwYXVzZVVwc3RyZWFtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLnBhdXNlVXBzdHJlYW1Mb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLl9pc1Vwc3RyZWFtUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgICB0aGlzLmxvZy53YXJuKCd1bmFibGUgdG8gcGF1c2UgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwc3RyZWFtUGF1c2VkLCB0aGlzKTtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICAgICAgaWYgKChicm93c2VyID09PSBudWxsIHx8IGJyb3dzZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGJyb3dzZXIubmFtZSkgPT09ICdTYWZhcmknICYmIGNvbXBhcmVWZXJzaW9ucyhicm93c2VyLnZlcnNpb24sICcxMi4wJykgPCAwKSB7XG4gICAgICAgICAgLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE4NDkxMVxuICAgICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdwYXVzZVVwc3RyZWFtIGlzIG5vdCBzdXBwb3J0ZWQgb24gU2FmYXJpIDwgMTIuJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCgoX2EgPSB0aGlzLnNlbmRlci50cmFuc3BvcnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZSkgIT09ICdjbG9zZWQnKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wYXVzZVVwc3RyZWFtTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAodGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3VuYWJsZSB0byByZXN1bWUgdXBzdHJlYW0gZm9yIGFuIHVucHVibGlzaGVkIHRyYWNrJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNVcHN0cmVhbVBhdXNlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMpO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMuc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAvLyB0aGlzIG9wZXJhdGlvbiBpcyBub29wIGlmIG1lZGlhc3RyZWFtdHJhY2sgaXMgYWxyZWFkeSBiZWluZyBzZW50XG4gICAgICAgICAgeWllbGQgdGhpcy5zZW5kZXIucmVwbGFjZVRyYWNrKHRoaXMubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIHRoZSBSVENTdGF0c1JlcG9ydCBmb3IgdGhlIExvY2FsVHJhY2sncyB1bmRlcmx5aW5nIFJUQ1J0cFNlbmRlclxuICAgKiBTZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1JUQ1N0YXRzUmVwb3J0XG4gICAqXG4gICAqIEByZXR1cm5zIFByb21pc2U8UlRDU3RhdHNSZXBvcnQ+IHwgdW5kZWZpbmVkXG4gICAqL1xuICBnZXRSVENTdGF0c1JlcG9ydCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCEoKF9hID0gdGhpcy5zZW5kZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHNSZXBvcnQgPSB5aWVsZCB0aGlzLnNlbmRlci5nZXRTdGF0cygpO1xuICAgICAgcmV0dXJuIHN0YXRzUmVwb3J0O1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGEgcHJvY2Vzc29yIG9uIHRoaXMgdHJhY2suXG4gICAqIFNlZSBodHRwczovL2dpdGh1Yi5jb20vbGl2ZWtpdC90cmFjay1wcm9jZXNzb3JzLWpzIGZvciBleGFtcGxlIHVzYWdlXG4gICAqXG4gICAqIEBleHBlcmltZW50YWxcbiAgICpcbiAgICogQHBhcmFtIHByb2Nlc3NvclxuICAgKiBAcGFyYW0gc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3JfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uIChwcm9jZXNzb3IpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgbGV0IHNob3dQcm9jZXNzZWRTdHJlYW1Mb2NhbGx5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB0cnVlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgX3RoaXMzLnByb2Nlc3NvckxvY2subG9jaygpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIF90aGlzMy5sb2cuZGVidWcoJ3NldHRpbmcgdXAgcHJvY2Vzc29yJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NvckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KF90aGlzMy5raW5kKTtcbiAgICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICAgICAga2luZDogX3RoaXMzLmtpbmQsXG4gICAgICAgICAgICB0cmFjazogX3RoaXMzLl9tZWRpYVN0cmVhbVRyYWNrLFxuICAgICAgICAgICAgZWxlbWVudDogcHJvY2Vzc29yRWxlbWVudCxcbiAgICAgICAgICAgIGF1ZGlvQ29udGV4dDogX3RoaXMzLmF1ZGlvQ29udGV4dFxuICAgICAgICAgIH07XG4gICAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICAgICAgX3RoaXMzLmxvZy5kZWJ1ZygncHJvY2Vzc29yIGluaXRpYWxpemVkJywgX3RoaXMzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIGlmIChfdGhpczMucHJvY2Vzc29yKSB7XG4gICAgICAgICAgICB5aWVsZCBfdGhpczMuc3RvcFByb2Nlc3NvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMzLmtpbmQgPT09ICd1bmtub3duJykge1xuICAgICAgICAgICAgdGhyb3cgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHByb2Nlc3NvciBvbiB0cmFjayBvZiB1bmtub3duIGtpbmQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYXR0YWNoVG9FbGVtZW50KF90aGlzMy5fbWVkaWFTdHJlYW1UcmFjaywgcHJvY2Vzc29yRWxlbWVudCk7XG4gICAgICAgICAgcHJvY2Vzc29yRWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgICAgICAgcHJvY2Vzc29yRWxlbWVudC5wbGF5KCkuY2F0Y2goZXJyb3IgPT4gX3RoaXMzLmxvZy5lcnJvcignZmFpbGVkIHRvIHBsYXkgcHJvY2Vzc29yIGVsZW1lbnQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICB9KSkpO1xuICAgICAgICAgIF90aGlzMy5wcm9jZXNzb3IgPSBwcm9jZXNzb3I7XG4gICAgICAgICAgX3RoaXMzLnByb2Nlc3NvckVsZW1lbnQgPSBwcm9jZXNzb3JFbGVtZW50O1xuICAgICAgICAgIGlmIChfdGhpczMucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVsIG9mIF90aGlzMy5hdHRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICAgICAgICAgIGlmIChlbCAhPT0gX3RoaXMzLnByb2Nlc3NvckVsZW1lbnQgJiYgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpIHtcbiAgICAgICAgICAgICAgICBkZXRhY2hUcmFjayhfdGhpczMuX21lZGlhU3RyZWFtVHJhY2ssIGVsKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hUb0VsZW1lbnQoX3RoaXMzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjaywgZWwpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCAoX2EgPSBfdGhpczMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVwbGFjZVRyYWNrKF90aGlzMy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBfdGhpczMuZW1pdChUcmFja0V2ZW50LlRyYWNrUHJvY2Vzc29yVXBkYXRlLCBfdGhpczMucHJvY2Vzc29yKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB1bmxvY2soKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIGdldFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gdGhpcy5wcm9jZXNzb3I7XG4gIH1cbiAgLyoqXG4gICAqIFN0b3BzIHRoZSB0cmFjayBwcm9jZXNzb3JcbiAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9saXZla2l0L3RyYWNrLXByb2Nlc3NvcnMtanMgZm9yIGV4YW1wbGUgdXNhZ2VcbiAgICpcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgc3RvcFByb2Nlc3NvcigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcbiAgICAgIGxldCBrZWVwRWxlbWVudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBpZiAoIV90aGlzNC5wcm9jZXNzb3IpIHJldHVybjtcbiAgICAgICAgX3RoaXM0LmxvZy5kZWJ1Zygnc3RvcHBpbmcgcHJvY2Vzc29yJywgX3RoaXM0LmxvZ0NvbnRleHQpO1xuICAgICAgICAoX2EgPSBfdGhpczQucHJvY2Vzc29yLnByb2Nlc3NlZFRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RvcCgpO1xuICAgICAgICB5aWVsZCBfdGhpczQucHJvY2Vzc29yLmRlc3Ryb3koKTtcbiAgICAgICAgX3RoaXM0LnByb2Nlc3NvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFrZWVwRWxlbWVudCkge1xuICAgICAgICAgIChfYiA9IF90aGlzNC5wcm9jZXNzb3JFbGVtZW50KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVtb3ZlKCk7XG4gICAgICAgICAgX3RoaXM0LnByb2Nlc3NvckVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYXBwbHkgb3JpZ2luYWwgdHJhY2sgY29uc3RyYWludHMgaW4gY2FzZSB0aGUgcHJvY2Vzc29yIGNoYW5nZWQgdGhlbVxuICAgICAgICB5aWVsZCBfdGhpczQuX21lZGlhU3RyZWFtVHJhY2suYXBwbHlDb25zdHJhaW50cyhfdGhpczQuX2NvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gZm9yY2UgcmUtc2V0dGluZyBvZiB0aGUgbWVkaWFTdHJlYW1UcmFjayBvbiB0aGUgc2VuZGVyXG4gICAgICAgIHlpZWxkIF90aGlzNC5zZXRNZWRpYVN0cmVhbVRyYWNrKF90aGlzNC5fbWVkaWFTdHJlYW1UcmFjaywgdHJ1ZSk7XG4gICAgICAgIF90aGlzNC5lbWl0KFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIExvY2FsQXVkaW9UcmFjayBleHRlbmRzIExvY2FsVHJhY2sge1xuICAvKipcbiAgICogYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgZW5oYW5jZWQgbm9pc2UgY2FuY2VsbGF0aW9uIGlzIGN1cnJlbnRseSBiZWluZyB1c2VkIG9uIHRoaXMgdHJhY2tcbiAgICovXG4gIGdldCBlbmhhbmNlZE5vaXNlQ2FuY2VsbGF0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQ7XG4gIH1cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBtZWRpYVRyYWNrXG4gICAqIEBwYXJhbSBjb25zdHJhaW50cyBNZWRpYVRyYWNrQ29uc3RyYWludHMgdGhhdCBhcmUgYmVpbmcgdXNlZCB3aGVuIHJlc3RhcnRpbmcgb3IgcmVhY3F1aXJpbmcgdHJhY2tzXG4gICAqIEBwYXJhbSB1c2VyUHJvdmlkZWRUcmFjayBTaWduYWxzIHRvIHRoZSBTREsgd2hldGhlciBvciBub3QgdGhlIG1lZGlhVHJhY2sgc2hvdWxkIGJlIG1hbmFnZWQgKGkuZS4gcmVsZWFzZWQgYW5kIHJlYWNxdWlyZWQpIGludGVybmFsbHkgYnkgdGhlIFNES1xuICAgKi9cbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgY29uc3RyYWludHMpIHtcbiAgICBsZXQgdXNlclByb3ZpZGVkVHJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHRydWU7XG4gICAgbGV0IGF1ZGlvQ29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIGxldCBsb2dnZXJPcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDQgPyBhcmd1bWVudHNbNF0gOiB1bmRlZmluZWQ7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgVHJhY2suS2luZC5BdWRpbywgY29uc3RyYWludHMsIHVzZXJQcm92aWRlZFRyYWNrLCBsb2dnZXJPcHRpb25zKTtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5zdG9wT25NdXRlID0gZmFsc2U7XG4gICAgdGhpcy5pc0tyaXNwTm9pc2VGaWx0ZXJFbmFibGVkID0gZmFsc2U7XG4gICAgdGhpcy5tb25pdG9yU2VuZGVyID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnNlbmRlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdGF0cztcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXRzID0geWllbGQgdGhpcy5nZXRTZW5kZXJTdGF0cygpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcignY291bGQgbm90IGdldCBhdWRpbyBzZW5kZXIgc3RhdHMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZVxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF0cyAmJiB0aGlzLnByZXZTdGF0cykge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckVuYWJsZSA9ICgpID0+IHtcbiAgICAgIHRoaXMuaXNLcmlzcE5vaXNlRmlsdGVyRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcIktyaXNwIG5vaXNlIGZpbHRlciBlbmFibGVkXCIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUgPSAoKSA9PiB7XG4gICAgICB0aGlzLmlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiS3Jpc3Agbm9pc2UgZmlsdGVyIGRpc2FibGVkXCIsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5BdWRpb1RyYWNrRmVhdHVyZVVwZGF0ZSwgdGhpcywgQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OLCBmYWxzZSk7XG4gICAgfTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGlzYWJsZWQgc3BlY2lhbCBoYW5kbGluZyBhcyBpdCB3aWxsIGNhdXNlIEJUIGhlYWRzZXRzIHRvIHN3aXRjaCBjb21tdW5pY2F0aW9uIG1vZGVzXG4gICAgICAgIGlmICh0aGlzLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLk1pY3JvcGhvbmUgJiYgdGhpcy5zdG9wT25NdXRlICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBtaWNyb3Bob25lIGluZGljYXRvciBpcyB0dXJuZWQgb2ZmXG4gICAgICAgICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgX3N1cGVyLm11dGUuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1bmxvY2soKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB1bm11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICB1bm11dGU6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci51bm11dGVcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5tdXRlTG9jay5sb2NrKCk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdUcmFjayBhbHJlYWR5IHVubXV0ZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRldmljZUhhc0NoYW5nZWQgPSB0aGlzLl9jb25zdHJhaW50cy5kZXZpY2VJZCAmJiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkuZGV2aWNlSWQgIT09IHVud3JhcENvbnN0cmFpbnQodGhpcy5fY29uc3RyYWludHMuZGV2aWNlSWQpO1xuICAgICAgICBpZiAodGhpcy5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lICYmICh0aGlzLnN0b3BPbk11dGUgfHwgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnIHx8IGRldmljZUhhc0NoYW5nZWQpICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIG1pYyB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGNvbnN0cmFpbnRzO1xuICAgICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtQ29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMoe1xuICAgICAgICAgIGF1ZGlvOiBvcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICBjb25zdHJhaW50cyA9IHN0cmVhbUNvbnN0cmFpbnRzLmF1ZGlvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB5aWVsZCB0aGlzLnJlc3RhcnQoY29uc3RyYWludHMpO1xuICAgIH0pO1xuICB9XG4gIHJlc3RhcnQoY29uc3RyYWludHMpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHJlc3RhcnQ6IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5yZXN0YXJ0XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgX3N1cGVyLnJlc3RhcnQuY2FsbCh0aGlzLCBjb25zdHJhaW50cyk7XG4gICAgICB0aGlzLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH0pO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBzdGFydE1vbml0b3IoKSB7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3IpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5wcm9jZXNzb3JMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghaXNSZWFjdE5hdGl2ZSgpICYmICF0aGlzLmF1ZGlvQ29udGV4dCkge1xuICAgICAgICAgIHRocm93IEVycm9yKCdBdWRpbyBjb250ZXh0IG5lZWRzIHRvIGJlIHNldCBvbiBMb2NhbEF1ZGlvVHJhY2sgaW4gb3JkZXIgdG8gZW5hYmxlIHByb2Nlc3NvcnMnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnN0b3BQcm9jZXNzb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9jZXNzb3JPcHRpb25zID0ge1xuICAgICAgICAgIGtpbmQ6IHRoaXMua2luZCxcbiAgICAgICAgICB0cmFjazogdGhpcy5fbWVkaWFTdHJlYW1UcmFjayxcbiAgICAgICAgICAvLyBSTiB3b24ndCBoYXZlIG9yIHVzZSBBdWRpb0NvbnRleHRcbiAgICAgICAgICBhdWRpb0NvbnRleHQ6IHRoaXMuYXVkaW9Db250ZXh0XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwic2V0dGluZyB1cCBhdWRpbyBwcm9jZXNzb3IgXCIuY29uY2F0KHByb2Nlc3Nvci5uYW1lKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgeWllbGQgcHJvY2Vzc29yLmluaXQocHJvY2Vzc29yT3B0aW9ucyk7XG4gICAgICAgIHRoaXMucHJvY2Vzc29yID0gcHJvY2Vzc29yO1xuICAgICAgICBpZiAodGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICB5aWVsZCAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2VUcmFjayh0aGlzLnByb2Nlc3Nvci5wcm9jZXNzZWRUcmFjayk7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZW5hYmxlLWxrLWtyaXNwLW5vaXNlLWZpbHRlcicsIHRoaXMuaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckVuYWJsZSk7XG4gICAgICAgICAgdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2suYWRkRXZlbnRMaXN0ZW5lcignZGlzYWJsZS1say1rcmlzcC1ub2lzZS1maWx0ZXInLCB0aGlzLmhhbmRsZUtyaXNwTm9pc2VGaWx0ZXJEaXNhYmxlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSwgdGhpcy5wcm9jZXNzb3IpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoYXVkaW9Db250ZXh0KSB7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBhdWRpb0NvbnRleHQ7XG4gIH1cbiAgZ2V0U2VuZGVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICBsZXQgYXVkaW9TdGF0cztcbiAgICAgIHN0YXRzLmZvckVhY2godiA9PiB7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgYXVkaW9TdGF0cyA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdhdWRpbycsXG4gICAgICAgICAgICBzdHJlYW1JZDogdi5pZCxcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgICBieXRlc1NlbnQ6IHYuYnl0ZXNTZW50LFxuICAgICAgICAgICAgdGltZXN0YW1wOiB2LnRpbWVzdGFtcCxcbiAgICAgICAgICAgIHJvdW5kVHJpcFRpbWU6IHYucm91bmRUcmlwVGltZSxcbiAgICAgICAgICAgIGppdHRlcjogdi5qaXR0ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBhdWRpb1N0YXRzO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrRm9yU2lsZW5jZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdHJhY2tJc1NpbGVudCA9IHlpZWxkIGRldGVjdFNpbGVuY2UodGhpcyk7XG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNNdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ3NpbGVuY2UgZGV0ZWN0ZWQgb24gbG9jYWwgYXVkaW8gdHJhY2snLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvU2lsZW5jZURldGVjdGVkKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFja0lzU2lsZW50O1xuICAgIH0pO1xuICB9XG59XG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGxvZ2dlck9wdGlvbnMpIHtcbiAgc3dpdGNoIChtZWRpYVN0cmVhbVRyYWNrLmtpbmQpIHtcbiAgICBjYXNlICdhdWRpbyc6XG4gICAgICByZXR1cm4gbmV3IExvY2FsQXVkaW9UcmFjayhtZWRpYVN0cmVhbVRyYWNrLCBjb25zdHJhaW50cywgZmFsc2UsIHVuZGVmaW5lZCwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgY2FzZSAndmlkZW8nOlxuICAgICAgcmV0dXJuIG5ldyBMb2NhbFZpZGVvVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgY29uc3RyYWludHMsIGZhbHNlLCBsb2dnZXJPcHRpb25zKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFRyYWNrSW52YWxpZEVycm9yKFwidW5zdXBwb3J0ZWQgdHJhY2sgdHlwZTogXCIuY29uY2F0KG1lZGlhU3RyZWFtVHJhY2sua2luZCkpO1xuICB9XG59XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHByZXNldHMxNjkgPSBPYmplY3QudmFsdWVzKFZpZGVvUHJlc2V0cyk7XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IHByZXNldHM0MyA9IE9iamVjdC52YWx1ZXMoVmlkZW9QcmVzZXRzNDMpO1xuLyogQGludGVybmFsICovXG5jb25zdCBwcmVzZXRzU2NyZWVuU2hhcmUgPSBPYmplY3QudmFsdWVzKFNjcmVlblNoYXJlUHJlc2V0cyk7XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzMTY5ID0gW1ZpZGVvUHJlc2V0cy5oMTgwLCBWaWRlb1ByZXNldHMuaDM2MF07XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDMgPSBbVmlkZW9QcmVzZXRzNDMuaDE4MCwgVmlkZW9QcmVzZXRzNDMuaDM2MF07XG4vKiBAaW50ZXJuYWwgKi9cbmNvbnN0IGNvbXB1dGVEZWZhdWx0U2NyZWVuU2hhcmVTaW11bGNhc3RQcmVzZXRzID0gZnJvbVByZXNldCA9PiB7XG4gIGNvbnN0IGxheWVycyA9IFt7XG4gICAgc2NhbGVSZXNvbHV0aW9uRG93bkJ5OiAyLFxuICAgIGZwczogZnJvbVByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGVcbiAgfV07XG4gIHJldHVybiBsYXllcnMubWFwKHQgPT4ge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIG5ldyBWaWRlb1ByZXNldChNYXRoLmZsb29yKGZyb21QcmVzZXQud2lkdGggLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksIE1hdGguZmxvb3IoZnJvbVByZXNldC5oZWlnaHQgLyB0LnNjYWxlUmVzb2x1dGlvbkRvd25CeSksIE1hdGgubWF4KDE1MDAwMCwgTWF0aC5mbG9vcihmcm9tUHJlc2V0LmVuY29kaW5nLm1heEJpdHJhdGUgLyAoTWF0aC5wb3codC5zY2FsZVJlc29sdXRpb25Eb3duQnksIDIpICogKCgoX2EgPSBmcm9tUHJlc2V0LmVuY29kaW5nLm1heEZyYW1lcmF0ZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMzApIC8gKChfYiA9IHQuZnBzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAzMCkpKSkpLCB0LmZwcywgZnJvbVByZXNldC5lbmNvZGluZy5wcmlvcml0eSk7XG4gIH0pO1xufTtcbi8vIC8qKlxuLy8gICpcbi8vICAqIEBpbnRlcm5hbFxuLy8gICogQGV4cGVyaW1lbnRhbFxuLy8gICovXG4vLyBjb25zdCBjb21wdXRlRGVmYXVsdE11bHRpQ29kZWNTaW11bGNhc3RFbmNvZGluZ3MgPSAod2lkdGg6IG51bWJlciwgaGVpZ2h0OiBudW1iZXIpID0+IHtcbi8vICAgLy8gdXNlIHZwOCBhcyBhIGRlZmF1bHRcbi8vICAgY29uc3QgdnA4ID0gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhmYWxzZSwgd2lkdGgsIGhlaWdodCk7XG4vLyAgIGNvbnN0IHZwOSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuOSB9O1xuLy8gICBjb25zdCBoMjY0ID0geyAuLi52cDgsIG1heEJpdHJhdGU6IHZwOC5tYXhCaXRyYXRlICogMS4xIH07XG4vLyAgIGNvbnN0IGF2MSA9IHsgLi4udnA4LCBtYXhCaXRyYXRlOiB2cDgubWF4Qml0cmF0ZSAqIDAuNyB9O1xuLy8gICByZXR1cm4ge1xuLy8gICAgIHZwOCxcbi8vICAgICB2cDksXG4vLyAgICAgaDI2NCxcbi8vICAgICBhdjEsXG4vLyAgIH07XG4vLyB9O1xuY29uc3QgdmlkZW9SaWRzID0gWydxJywgJ2gnLCAnZiddO1xuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBjb21wdXRlVmlkZW9FbmNvZGluZ3MoaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCwgb3B0aW9ucykge1xuICB2YXIgX2EsIF9iO1xuICBsZXQgdmlkZW9FbmNvZGluZyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0VuY29kaW5nO1xuICBpZiAoaXNTY3JlZW5TaGFyZSkge1xuICAgIHZpZGVvRW5jb2RpbmcgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NyZWVuU2hhcmVFbmNvZGluZztcbiAgfVxuICBjb25zdCB1c2VTaW11bGNhc3QgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2ltdWxjYXN0O1xuICBjb25zdCBzY2FsYWJpbGl0eU1vZGUgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2NhbGFiaWxpdHlNb2RlO1xuICBjb25zdCB2aWRlb0NvZGVjID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnZpZGVvQ29kZWM7XG4gIGlmICghdmlkZW9FbmNvZGluZyAmJiAhdXNlU2ltdWxjYXN0ICYmICFzY2FsYWJpbGl0eU1vZGUgfHwgIXdpZHRoIHx8ICFoZWlnaHQpIHtcbiAgICAvLyB3aGVuIHdlIGFyZW4ndCBzaW11bGNhc3Rpbmcgb3Igc3ZjLCB3aWxsIG5lZWQgdG8gcmV0dXJuIGEgc2luZ2xlIGVuY29kaW5nIHdpdGhvdXRcbiAgICAvLyBjYXBwaW5nIGJhbmR3aWR0aC4gd2UgYWx3YXlzIHJlcXVpcmUgYSBlbmNvZGluZyBmb3IgZHluYWNhc3RcbiAgICByZXR1cm4gW3t9XTtcbiAgfVxuICBpZiAoIXZpZGVvRW5jb2RpbmcpIHtcbiAgICAvLyBmaW5kIHRoZSByaWdodCBlbmNvZGluZyBiYXNlZCBvbiB3aWR0aC9oZWlnaHRcbiAgICB2aWRlb0VuY29kaW5nID0gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCB2aWRlb0NvZGVjKTtcbiAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKCd1c2luZyB2aWRlbyBlbmNvZGluZycsIHZpZGVvRW5jb2RpbmcpO1xuICB9XG4gIGNvbnN0IHNvdXJjZUZyYW1lcmF0ZSA9IHZpZGVvRW5jb2RpbmcubWF4RnJhbWVyYXRlO1xuICBjb25zdCBvcmlnaW5hbCA9IG5ldyBWaWRlb1ByZXNldCh3aWR0aCwgaGVpZ2h0LCB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUsIHZpZGVvRW5jb2RpbmcubWF4RnJhbWVyYXRlLCB2aWRlb0VuY29kaW5nLnByaW9yaXR5KTtcbiAgaWYgKHNjYWxhYmlsaXR5TW9kZSAmJiBpc1NWQ0NvZGVjKHZpZGVvQ29kZWMpKSB7XG4gICAgY29uc3Qgc20gPSBuZXcgU2NhbGFiaWxpdHlNb2RlKHNjYWxhYmlsaXR5TW9kZSk7XG4gICAgY29uc3QgZW5jb2RpbmdzID0gW107XG4gICAgaWYgKHNtLnNwYXRpYWwgPiAzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnN1cHBvcnRlZCBzY2FsYWJpbGl0eU1vZGU6IFwiLmNvbmNhdChzY2FsYWJpbGl0eU1vZGUpKTtcbiAgICB9XG4gICAgLy8gQmVmb3JlIE0xMTMgaW4gQ2hyb21lLCBkZWZpbmluZyBtdWx0aXBsZSBlbmNvZGluZ3Mgd2l0aCBhbiBTVkMgY29kZWMgaW5kaWNhdGVkXG4gICAgLy8gdGhhdCBTVkMgbW9kZSBzaG91bGQgYmUgdXNlZC4gU2FmYXJpIHN0aWxsIHdvcmtzIHRoaXMgd2F5LlxuICAgIC8vIFRoaXMgaXMgYSBiaXQgY29uZnVzaW5nIGJ1dCBpcyBkdWUgdG8gaG93IGxpYndlYnJ0YyBpbnRlcnByZXRlZCB0aGUgZW5jb2RpbmdzIGZpZWxkXG4gICAgLy8gYmVmb3JlIE0xMTMuXG4gICAgLy8gQW5ub3VuY2VkIGhlcmU6IGh0dHBzOi8vZ3JvdXBzLmdvb2dsZS5jb20vZy9kaXNjdXNzLXdlYnJ0Yy9jLy1RUTNweHJsLWZ3P3BsaT0xXG4gICAgY29uc3QgYnJvd3NlciA9IGdldEJyb3dzZXIoKTtcbiAgICBpZiAoaXNTYWZhcmkoKSB8fFxuICAgIC8vIEV2ZW4gdGhvIFJOIHJ1bnMgTTExNCwgaXQgZG9lcyBub3QgcHJvZHVjZSBTVkMgbGF5ZXJzIHdoZW4gYSBzaW5nbGUgZW5jb2RpbmdcbiAgICAvLyBpcyBwcm92aWRlZC4gU28gd2UnbGwgdXNlIHRoZSBsZWdhY3kgU1ZDIHNwZWNpZmljYXRpb24gZm9yIG5vdy5cbiAgICAvLyBUT0RPOiB3aGVuIHdlIHVwc3RyZWFtIGxpYndlYnJ0YywgdGhpcyB3aWxsIG5lZWQgYWRkaXRpb25hbCB2ZXJpZmljYXRpb25cbiAgICBpc1JlYWN0TmF0aXZlKCkgfHwgKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ0Nocm9tZScgJiYgY29tcGFyZVZlcnNpb25zKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci52ZXJzaW9uLCAnMTEzJykgPCAwKSB7XG4gICAgICBjb25zdCBiaXRyYXRlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDIgOiAzO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbS5zcGF0aWFsOyBpICs9IDEpIHtcbiAgICAgICAgLy8gaW4gbGVnYWN5IFNWQywgc2NhbGVSZXNvbHV0aW9uRG93bkJ5IGNhbm5vdCBiZSBzZXRcbiAgICAgICAgZW5jb2RpbmdzLnB1c2goe1xuICAgICAgICAgIHJpZDogdmlkZW9SaWRzWzIgLSBpXSxcbiAgICAgICAgICBtYXhCaXRyYXRlOiB2aWRlb0VuY29kaW5nLm1heEJpdHJhdGUgLyBNYXRoLnBvdyhiaXRyYXRlc1JhdGlvLCBpKSxcbiAgICAgICAgICBtYXhGcmFtZXJhdGU6IG9yaWdpbmFsLmVuY29kaW5nLm1heEZyYW1lcmF0ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGxlZ2FjeSBTVkMsIHNjYWxhYmlsaXR5TW9kZSBpcyBzZXQgb25seSBvbiB0aGUgZmlyc3QgZW5jb2RpbmdcbiAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUgPSBzY2FsYWJpbGl0eU1vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5ncy5wdXNoKHtcbiAgICAgICAgbWF4Qml0cmF0ZTogdmlkZW9FbmNvZGluZy5tYXhCaXRyYXRlLFxuICAgICAgICBtYXhGcmFtZXJhdGU6IG9yaWdpbmFsLmVuY29kaW5nLm1heEZyYW1lcmF0ZSxcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBzY2FsYWJpbGl0eU1vZGU6IHNjYWxhYmlsaXR5TW9kZVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChvcmlnaW5hbC5lbmNvZGluZy5wcmlvcml0eSkge1xuICAgICAgZW5jb2RpbmdzWzBdLnByaW9yaXR5ID0gb3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICBlbmNvZGluZ3NbMF0ubmV0d29ya1ByaW9yaXR5ID0gb3JpZ2luYWwuZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgfVxuICAgIGxpdmVraXRMb2dnZXIuZGVidWcoXCJ1c2luZyBzdmMgZW5jb2RpbmdcIiwge1xuICAgICAgZW5jb2RpbmdzXG4gICAgfSk7XG4gICAgcmV0dXJuIGVuY29kaW5ncztcbiAgfVxuICBpZiAoIXVzZVNpbXVsY2FzdCkge1xuICAgIHJldHVybiBbdmlkZW9FbmNvZGluZ107XG4gIH1cbiAgbGV0IHByZXNldHMgPSBbXTtcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICBwcmVzZXRzID0gKF9hID0gc29ydFByZXNldHMob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnNjcmVlblNoYXJlU2ltdWxjYXN0TGF5ZXJzKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZGVmYXVsdFNpbXVsY2FzdExheWVycyhpc1NjcmVlblNoYXJlLCBvcmlnaW5hbCk7XG4gIH0gZWxzZSB7XG4gICAgcHJlc2V0cyA9IChfYiA9IHNvcnRQcmVzZXRzKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb1NpbXVsY2FzdExheWVycykpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpO1xuICB9XG4gIGxldCBtaWRQcmVzZXQ7XG4gIGlmIChwcmVzZXRzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCBsb3dQcmVzZXQgPSBwcmVzZXRzWzBdO1xuICAgIGlmIChwcmVzZXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIFssIG1pZFByZXNldF0gPSBwcmVzZXRzO1xuICAgIH1cbiAgICAvLyBOT1RFOlxuICAgIC8vICAgMS4gT3JkZXJpbmcgb2YgdGhlc2UgZW5jb2RpbmdzIGlzIGltcG9ydGFudC4gQ2hyb21lIHNlZW1zXG4gICAgLy8gICAgICB0byB1c2UgdGhlIGluZGV4IGludG8gZW5jb2RpbmdzIHRvIGRlY2lkZSB3aGljaCBsYXllclxuICAgIC8vICAgICAgdG8gZGlzYWJsZSB3aGVuIENQVSBjb25zdHJhaW5lZC5cbiAgICAvLyAgICAgIFNvIGVuY29kaW5ncyBzaG91bGQgYmUgb3JkZXJlZCBpbiBpbmNyZWFzaW5nIHNwYXRpYWxcbiAgICAvLyAgICAgIHJlc29sdXRpb24gb3JkZXIuXG4gICAgLy8gICAyLiBsaXZla2l0LXNlcnZlciB0cmFuc2xhdGVzIHJpZHMgaW50byBsYXllcnMuIFNvLCBhbGwgZW5jb2RpbmdzXG4gICAgLy8gICAgICBzaG91bGQgaGF2ZSB0aGUgYmFzZSBsYXllciBgcWAgYW5kIHRoZW4gbW9yZSBhZGRlZFxuICAgIC8vICAgICAgYmFzZWQgb24gb3RoZXIgY29uZGl0aW9ucy5cbiAgICBjb25zdCBzaXplID0gTWF0aC5tYXgod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKHNpemUgPj0gOTYwICYmIG1pZFByZXNldCkge1xuICAgICAgcmV0dXJuIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIFtsb3dQcmVzZXQsIG1pZFByZXNldCwgb3JpZ2luYWxdLCBzb3VyY2VGcmFtZXJhdGUpO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA+PSA0ODApIHtcbiAgICAgIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbbG93UHJlc2V0LCBvcmlnaW5hbF0sIHNvdXJjZUZyYW1lcmF0ZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBlbmNvZGluZ3NGcm9tUHJlc2V0cyh3aWR0aCwgaGVpZ2h0LCBbb3JpZ2luYWxdKTtcbn1cbmZ1bmN0aW9uIGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cykge1xuICB2YXIgX2EsIF9iLCBfYywgX2Q7XG4gIC8vIGJhY2t1cENvZGVjIHNob3VsZCBub3QgYmUgdHJ1ZSBhbnltb3JlLCBkZWZhdWx0IGNvZGVjIGlzIHNldCBpbiBMb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hcbiAgaWYgKCFvcHRzLmJhY2t1cENvZGVjIHx8IG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUgfHwgb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyA9PT0gb3B0cy52aWRlb0NvZGVjKSB7XG4gICAgLy8gYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmcgaXMgZGlzYWJsZWRcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZpZGVvQ29kZWMgIT09IG9wdHMuYmFja3VwQ29kZWMuY29kZWMpIHtcbiAgICBsaXZla2l0TG9nZ2VyLndhcm4oJ3JlcXVlc3RlZCBhIGRpZmZlcmVudCBjb2RlYyB0aGFuIHNwZWNpZmllZCBhcyBiYWNrdXAnLCB7XG4gICAgICBzZXJ2ZXJSZXF1ZXN0ZWQ6IHZpZGVvQ29kZWMsXG4gICAgICBiYWNrdXA6IG9wdHMuYmFja3VwQ29kZWMuY29kZWNcbiAgICB9KTtcbiAgfVxuICBvcHRzLnZpZGVvQ29kZWMgPSB2aWRlb0NvZGVjO1xuICAvLyB1c2UgYmFja3VwIGVuY29kaW5nIHNldHRpbmcgYXMgdmlkZW9FbmNvZGluZyBmb3IgYmFja3VwIGNvZGVjIHB1Ymxpc2hpbmdcbiAgb3B0cy52aWRlb0VuY29kaW5nID0gb3B0cy5iYWNrdXBDb2RlYy5lbmNvZGluZztcbiAgY29uc3Qgc2V0dGluZ3MgPSB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCk7XG4gIGNvbnN0IHdpZHRoID0gKF9hID0gc2V0dGluZ3Mud2lkdGgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYiA9IHRyYWNrLmRpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi53aWR0aDtcbiAgY29uc3QgaGVpZ2h0ID0gKF9jID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAoX2QgPSB0cmFjay5kaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuaGVpZ2h0O1xuICAvLyBkaXNhYmxlIHNpbXVsY2FzdCBmb3Igc2NyZWVuc2hhcmUgYmFja3VwIGNvZGVjIHNpbmNlIEwxVHggaXMgdXNlZCBieSBwcmltYXJ5IGNvZGVjXG4gIGlmICh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSAmJiBvcHRzLnNpbXVsY2FzdCkge1xuICAgIG9wdHMuc2ltdWxjYXN0ID0gZmFsc2U7XG4gIH1cbiAgY29uc3QgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBvcHRzKTtcbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cbi8qIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lQXBwcm9wcmlhdGVFbmNvZGluZyhpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0LCBjb2RlYykge1xuICBjb25zdCBwcmVzZXRzID0gcHJlc2V0c0ZvclJlc29sdXRpb24oaXNTY3JlZW5TaGFyZSwgd2lkdGgsIGhlaWdodCk7XG4gIGxldCB7XG4gICAgZW5jb2RpbmdcbiAgfSA9IHByZXNldHNbMF07XG4gIC8vIGhhbmRsZSBwb3J0cmFpdCBieSBzd2FwcGluZyBkaW1lbnNpb25zXG4gIGNvbnN0IHNpemUgPSBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVzZXRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcHJlc2V0ID0gcHJlc2V0c1tpXTtcbiAgICBlbmNvZGluZyA9IHByZXNldC5lbmNvZGluZztcbiAgICBpZiAocHJlc2V0LndpZHRoID49IHNpemUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICAvLyBwcmVzZXRzIGFyZSBiYXNlZCBvbiB0aGUgYXNzdW1wdGlvbiBvZiB2cDggYXMgYSBjb2RlY1xuICAvLyBmb3Igb3RoZXIgY29kZWNzIHdlIGFkanVzdCB0aGUgbWF4Qml0cmF0ZSBpZiBubyBzcGVjaWZpYyB2aWRlb0VuY29kaW5nIGhhcyBiZWVuIHByb3ZpZGVkXG4gIC8vIHVzZXJzIHNob3VsZCBvdmVycmlkZSB0aGVzZSB3aXRoIG9uZXMgdGhhdCBhcmUgb3B0aW1pemVkIGZvciB0aGVpciB1c2UgY2FzZVxuICAvLyBOT1RFOiBTVkMgY29kZWMgYml0cmF0ZXMgYXJlIGluY2x1c2l2ZSBvZiBhbGwgc2NhbGFiaWxpdHkgbGF5ZXJzLiB3aGlsZVxuICAvLyBiaXRyYXRlIGZvciBub24tU1ZDIGNvZGVjcyBkb2VzIG5vdCBpbmNsdWRlIG90aGVyIHNpbXVsY2FzdCBsYXllcnMuXG4gIGlmIChjb2RlYykge1xuICAgIHN3aXRjaCAoY29kZWMpIHtcbiAgICAgIGNhc2UgJ2F2MSc6XG4gICAgICAgIGVuY29kaW5nID0gT2JqZWN0LmFzc2lnbih7fSwgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZSAqIDAuNztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd2cDknOlxuICAgICAgICBlbmNvZGluZyA9IE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IGVuY29kaW5nLm1heEJpdHJhdGUgKiAwLjg1O1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5nO1xufVxuLyogQGludGVybmFsICovXG5mdW5jdGlvbiBwcmVzZXRzRm9yUmVzb2x1dGlvbihpc1NjcmVlblNoYXJlLCB3aWR0aCwgaGVpZ2h0KSB7XG4gIGlmIChpc1NjcmVlblNoYXJlKSB7XG4gICAgcmV0dXJuIHByZXNldHNTY3JlZW5TaGFyZTtcbiAgfVxuICBjb25zdCBhc3BlY3QgPSB3aWR0aCA+IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogaGVpZ2h0IC8gd2lkdGg7XG4gIGlmIChNYXRoLmFicyhhc3BlY3QgLSAxNi4wIC8gOSkgPCBNYXRoLmFicyhhc3BlY3QgLSA0LjAgLyAzKSkge1xuICAgIHJldHVybiBwcmVzZXRzMTY5O1xuICB9XG4gIHJldHVybiBwcmVzZXRzNDM7XG59XG4vKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIGRlZmF1bHRTaW11bGNhc3RMYXllcnMoaXNTY3JlZW5TaGFyZSwgb3JpZ2luYWwpIHtcbiAgaWYgKGlzU2NyZWVuU2hhcmUpIHtcbiAgICByZXR1cm4gY29tcHV0ZURlZmF1bHRTY3JlZW5TaGFyZVNpbXVsY2FzdFByZXNldHMob3JpZ2luYWwpO1xuICB9XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IG9yaWdpbmFsO1xuICBjb25zdCBhc3BlY3QgPSB3aWR0aCA+IGhlaWdodCA/IHdpZHRoIC8gaGVpZ2h0IDogaGVpZ2h0IC8gd2lkdGg7XG4gIGlmIChNYXRoLmFicyhhc3BlY3QgLSAxNi4wIC8gOSkgPCBNYXRoLmFicyhhc3BlY3QgLSA0LjAgLyAzKSkge1xuICAgIHJldHVybiBkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OTtcbiAgfVxuICByZXR1cm4gZGVmYXVsdFNpbXVsY2FzdFByZXNldHM0Mztcbn1cbi8vIHByZXNldHMgc2hvdWxkIGJlIG9yZGVyZWQgYnkgbG93LCBtZWRpdW0sIGhpZ2hcbmZ1bmN0aW9uIGVuY29kaW5nc0Zyb21QcmVzZXRzKHdpZHRoLCBoZWlnaHQsIHByZXNldHMsIHNvdXJjZUZyYW1lcmF0ZSkge1xuICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgcHJlc2V0cy5mb3JFYWNoKChwcmVzZXQsIGlkeCkgPT4ge1xuICAgIGlmIChpZHggPj0gdmlkZW9SaWRzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaXplID0gTWF0aC5taW4od2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgcmlkID0gdmlkZW9SaWRzW2lkeF07XG4gICAgY29uc3QgZW5jb2RpbmcgPSB7XG4gICAgICByaWQsXG4gICAgICBzY2FsZVJlc29sdXRpb25Eb3duQnk6IE1hdGgubWF4KDEsIHNpemUgLyBNYXRoLm1pbihwcmVzZXQud2lkdGgsIHByZXNldC5oZWlnaHQpKSxcbiAgICAgIG1heEJpdHJhdGU6IHByZXNldC5lbmNvZGluZy5tYXhCaXRyYXRlXG4gICAgfTtcbiAgICAvLyBlbnN1cmUgdGhhdCB0aGUgc291cmNlRnJhbWVyYXRlIGlzIHRoZSBoaWdoZXN0IGZyYW1lcmF0ZSBhcHBsaWVkIGFjcm9zcyBhbGwgbGF5ZXJzIHNvIHRoYXQgdGhlXG4gICAgLy8gb3JpZ2luYWwgZW5jb2RpbmcgZG9lc24ndCBnZXQgYnVtcGVkIHVuaW50ZW50aW9uYWxseSBieSBhbnkgb2YgdGhlIG90aGVyIGxheWVyc1xuICAgIGNvbnN0IG1heEZyYW1lcmF0ZSA9IHNvdXJjZUZyYW1lcmF0ZSAmJiBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlID8gTWF0aC5taW4oc291cmNlRnJhbWVyYXRlLCBwcmVzZXQuZW5jb2RpbmcubWF4RnJhbWVyYXRlKSA6IHByZXNldC5lbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgaWYgKG1heEZyYW1lcmF0ZSkge1xuICAgICAgZW5jb2RpbmcubWF4RnJhbWVyYXRlID0gbWF4RnJhbWVyYXRlO1xuICAgIH1cbiAgICBjb25zdCBjYW5TZXRQcmlvcml0eSA9IGlzRmlyZUZveCgpIHx8IGlkeCA9PT0gMDtcbiAgICBpZiAocHJlc2V0LmVuY29kaW5nLnByaW9yaXR5ICYmIGNhblNldFByaW9yaXR5KSB7XG4gICAgICBlbmNvZGluZy5wcmlvcml0eSA9IHByZXNldC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICAgIGVuY29kaW5nLm5ldHdvcmtQcmlvcml0eSA9IHByZXNldC5lbmNvZGluZy5wcmlvcml0eTtcbiAgICB9XG4gICAgZW5jb2RpbmdzLnB1c2goZW5jb2RpbmcpO1xuICB9KTtcbiAgLy8gUk4gaW9zIHNpbXVsY2FzdCByZXF1aXJlcyBhbGwgc2FtZSBmcmFtZXJhdGVzLlxuICBpZiAoaXNSZWFjdE5hdGl2ZSgpICYmIGdldFJlYWN0TmF0aXZlT3MoKSA9PT0gJ2lvcycpIHtcbiAgICBsZXQgdG9wRnJhbWVyYXRlID0gdW5kZWZpbmVkO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nID0+IHtcbiAgICAgIGlmICghdG9wRnJhbWVyYXRlKSB7XG4gICAgICAgIHRvcEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcubWF4RnJhbWVyYXRlICYmIGVuY29kaW5nLm1heEZyYW1lcmF0ZSA+IHRvcEZyYW1lcmF0ZSkge1xuICAgICAgICB0b3BGcmFtZXJhdGUgPSBlbmNvZGluZy5tYXhGcmFtZXJhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IG5vdGlmeU9uY2UgPSB0cnVlO1xuICAgIGVuY29kaW5ncy5mb3JFYWNoKGVuY29kaW5nID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmIChlbmNvZGluZy5tYXhGcmFtZXJhdGUgIT0gdG9wRnJhbWVyYXRlKSB7XG4gICAgICAgIGlmIChub3RpZnlPbmNlKSB7XG4gICAgICAgICAgbm90aWZ5T25jZSA9IGZhbHNlO1xuICAgICAgICAgIGxpdmVraXRMb2dnZXIuaW5mbyhcIlNpbXVsY2FzdCBvbiBpT1MgUmVhY3QtTmF0aXZlIHJlcXVpcmVzIGFsbCBlbmNvZGluZ3MgdG8gc2hhcmUgdGhlIHNhbWUgZnJhbWVyYXRlLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oXCJTZXR0aW5nIGZyYW1lcmF0ZSBvZiBlbmNvZGluZyBcXFwiXCIuY29uY2F0KChfYSA9IGVuY29kaW5nLnJpZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycsIFwiXFxcIiB0byBcIikuY29uY2F0KHRvcEZyYW1lcmF0ZSkpO1xuICAgICAgICBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPSB0b3BGcmFtZXJhdGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGVuY29kaW5ncztcbn1cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHNvcnRQcmVzZXRzKHByZXNldHMpIHtcbiAgaWYgKCFwcmVzZXRzKSByZXR1cm47XG4gIHJldHVybiBwcmVzZXRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBlbmNvZGluZzogYUVuY1xuICAgIH0gPSBhO1xuICAgIGNvbnN0IHtcbiAgICAgIGVuY29kaW5nOiBiRW5jXG4gICAgfSA9IGI7XG4gICAgaWYgKGFFbmMubWF4Qml0cmF0ZSA+IGJFbmMubWF4Qml0cmF0ZSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmIChhRW5jLm1heEJpdHJhdGUgPCBiRW5jLm1heEJpdHJhdGUpIHJldHVybiAtMTtcbiAgICBpZiAoYUVuYy5tYXhCaXRyYXRlID09PSBiRW5jLm1heEJpdHJhdGUgJiYgYUVuYy5tYXhGcmFtZXJhdGUgJiYgYkVuYy5tYXhGcmFtZXJhdGUpIHtcbiAgICAgIHJldHVybiBhRW5jLm1heEZyYW1lcmF0ZSA+IGJFbmMubWF4RnJhbWVyYXRlID8gMSA6IC0xO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfSk7XG59XG4vKiogQGludGVybmFsICovXG5jbGFzcyBTY2FsYWJpbGl0eU1vZGUge1xuICBjb25zdHJ1Y3RvcihzY2FsYWJpbGl0eU1vZGUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gc2NhbGFiaWxpdHlNb2RlLm1hdGNoKC9eTChcXGQpVChcXGQpKGh8X0tFWXxfS0VZX1NISUZUKXswLDF9JC8pO1xuICAgIGlmICghcmVzdWx0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHNjYWxhYmlsaXR5IG1vZGUnKTtcbiAgICB9XG4gICAgdGhpcy5zcGF0aWFsID0gcGFyc2VJbnQocmVzdWx0c1sxXSk7XG4gICAgdGhpcy50ZW1wb3JhbCA9IHBhcnNlSW50KHJlc3VsdHNbMl0pO1xuICAgIGlmIChyZXN1bHRzLmxlbmd0aCA+IDMpIHtcbiAgICAgIHN3aXRjaCAocmVzdWx0c1szXSkge1xuICAgICAgICBjYXNlICdoJzpcbiAgICAgICAgY2FzZSAnX0tFWSc6XG4gICAgICAgIGNhc2UgJ19LRVlfU0hJRlQnOlxuICAgICAgICAgIHRoaXMuc3VmZml4ID0gcmVzdWx0c1szXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBcIkxcIi5jb25jYXQodGhpcy5zcGF0aWFsLCBcIlRcIikuY29uY2F0KHRoaXMudGVtcG9yYWwpLmNvbmNhdCgoX2EgPSB0aGlzLnN1ZmZpeCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICB9XG59XG5mdW5jdGlvbiBnZXREZWZhdWx0RGVncmFkYXRpb25QcmVmZXJlbmNlKHRyYWNrKSB7XG4gIC8vIGEgZmV3IG9mIHJlYXNvbnMgd2UgaGF2ZSBkaWZmZXJlbnQgZGVmYXVsdCBwYXRoczpcbiAgLy8gMS4gd2l0aG91dCB0aGlzLCBDaHJvbWUgc2VlbXMgdG8gYWdncmVzc2l2ZWx5IHJlc2l6ZSB0aGUgU1ZDIHZpZGVvIHN0YXRpbmcgYHF1YWxpdHktbGltaXRhdGlvbjogYmFuZHdpZHRoYCBldmVuIHdoZW4gQlcgaXNuJ3QgYW4gaXNzdWVcbiAgLy8gMi4gc2luY2Ugd2UgYXJlIG92ZXJyaWRpbmcgY29udGVudEhpbnQgdG8gbW90aW9uICh0byB3b3JrYXJvdW5kIEwxVDMgcHVibGlzaGluZyksIGl0IG92ZXJyaWRlcyB0aGUgZGVmYXVsdCBkZWdyYWRhdGlvblByZWZlcmVuY2UgdG8gYGJhbGFuY2VkYFxuICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgfHwgdHJhY2suY29uc3RyYWludHMuaGVpZ2h0ICYmIHVud3JhcENvbnN0cmFpbnQodHJhY2suY29uc3RyYWludHMuaGVpZ2h0KSA+PSAxMDgwKSB7XG4gICAgcmV0dXJuICdtYWludGFpbi1yZXNvbHV0aW9uJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gJ2JhbGFuY2VkJztcbiAgfVxufVxuXG5jb25zdCByZWZyZXNoU3Vic2NyaWJlZENvZGVjQWZ0ZXJOZXdDb2RlYyA9IDUwMDA7XG5jbGFzcyBMb2NhbFZpZGVvVHJhY2sgZXh0ZW5kcyBMb2NhbFRyYWNrIHtcbiAgZ2V0IHNlbmRlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fc2VuZGVyO1xuICB9XG4gIHNldCBzZW5kZXIoc2VuZGVyKSB7XG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xuICAgIGlmICh0aGlzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSkge1xuICAgICAgdGhpcy5zZXREZWdyYWRhdGlvblByZWZlcmVuY2UodGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIG1lZGlhVHJhY2tcbiAgICogQHBhcmFtIGNvbnN0cmFpbnRzIE1lZGlhVHJhY2tDb25zdHJhaW50cyB0aGF0IGFyZSBiZWluZyB1c2VkIHdoZW4gcmVzdGFydGluZyBvciByZWFjcXVpcmluZyB0cmFja3NcbiAgICogQHBhcmFtIHVzZXJQcm92aWRlZFRyYWNrIFNpZ25hbHMgdG8gdGhlIFNESyB3aGV0aGVyIG9yIG5vdCB0aGUgbWVkaWFUcmFjayBzaG91bGQgYmUgbWFuYWdlZCAoaS5lLiByZWxlYXNlZCBhbmQgcmVhY3F1aXJlZCkgaW50ZXJuYWxseSBieSB0aGUgU0RLXG4gICAqL1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBjb25zdHJhaW50cykge1xuICAgIGxldCB1c2VyUHJvdmlkZWRUcmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICBsZXQgbG9nZ2VyT3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAzID8gYXJndW1lbnRzWzNdIDogdW5kZWZpbmVkO1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIFRyYWNrLktpbmQuVmlkZW8sIGNvbnN0cmFpbnRzLCB1c2VyUHJvdmlkZWRUcmFjaywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgLyogQGludGVybmFsICovXG4gICAgdGhpcy5zaW11bGNhc3RDb2RlY3MgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSAnYmFsYW5jZWQnO1xuICAgIHRoaXMubW9uaXRvclNlbmRlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5zZW5kZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgc3RhdHM7XG4gICAgICB0cnkge1xuICAgICAgICBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0U2VuZGVyU3RhdHMoKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBnZXQgYXVkaW8gc2VuZGVyIHN0YXRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0c01hcCA9IG5ldyBNYXAoc3RhdHMubWFwKHMgPT4gW3MucmlkLCBzXSkpO1xuICAgICAgaWYgKHRoaXMucHJldlN0YXRzKSB7XG4gICAgICAgIGxldCB0b3RhbEJpdHJhdGUgPSAwO1xuICAgICAgICBzdGF0c01hcC5mb3JFYWNoKChzLCBrZXkpID0+IHtcbiAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgY29uc3QgcHJldiA9IChfYSA9IHRoaXMucHJldlN0YXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0KGtleSk7XG4gICAgICAgICAgdG90YWxCaXRyYXRlICs9IGNvbXB1dGVCaXRyYXRlKHMsIHByZXYpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSB0b3RhbEJpdHJhdGU7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzTWFwO1xuICAgIH0pO1xuICAgIHRoaXMuc2VuZGVyTG9jayA9IG5ldyBfKCk7XG4gIH1cbiAgZ2V0IGlzU2ltdWxjYXN0KCkge1xuICAgIGlmICh0aGlzLnNlbmRlciAmJiB0aGlzLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCkuZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcihzaWduYWxDbGllbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgaWYgKCFpc1dlYigpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIHNhdmUgb3JpZ2luYWwgZW5jb2RpbmdzXG4gICAgLy8gVE9ETyA6IG1lcmdlIHNpbXVsY2FzdCB0cmFja3Mgc3RhdHNcbiAgICBjb25zdCBwYXJhbXMgPSAoX2EgPSB0aGlzLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFBhcmFtZXRlcnMoKTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICB0aGlzLmVuY29kaW5ncyA9IHBhcmFtcy5lbmNvZGluZ3M7XG4gICAgfVxuICAgIGlmICh0aGlzLm1vbml0b3JJbnRlcnZhbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIHRoaXMubW9uaXRvclNlbmRlcigpO1xuICAgIH0sIG1vbml0b3JGcmVxdWVuY3kpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5fbWVkaWFTdHJlYW1UcmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLmZvckVhY2godHJhY2tJbmZvID0+IHtcbiAgICAgIHRyYWNrSW5mby5tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICB9KTtcbiAgICBzdXBlci5zdG9wKCk7XG4gIH1cbiAgcGF1c2VVcHN0cmVhbSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHBhdXNlVXBzdHJlYW06IHtcbiAgICAgICAgZ2V0OiAoKSA9PiBzdXBlci5wYXVzZVVwc3RyZWFtXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8xLCBfYiwgX2M7XG4gICAgICB2YXIgX2Q7XG4gICAgICB5aWVsZCBfc3VwZXIucGF1c2VVcHN0cmVhbS5jYWxsKHRoaXMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2UgPSB0cnVlLCBfZiA9IF9fYXN5bmNWYWx1ZXModGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpLCBfZzsgX2cgPSB5aWVsZCBfZi5uZXh0KCksIF9hID0gX2cuZG9uZSwgIV9hOyBfZSA9IHRydWUpIHtcbiAgICAgICAgICBfYyA9IF9nLnZhbHVlO1xuICAgICAgICAgIF9lID0gZmFsc2U7XG4gICAgICAgICAgY29uc3Qgc2MgPSBfYztcbiAgICAgICAgICB5aWVsZCAoX2QgPSBzYy5zZW5kZXIpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5yZXBsYWNlVHJhY2sobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfZSAmJiAhX2EgJiYgKF9iID0gX2YucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lVXBzdHJlYW0oKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICByZXN1bWVVcHN0cmVhbToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnJlc3VtZVVwc3RyZWFtXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgZV8yLCBfYiwgX2M7XG4gICAgICB2YXIgX2Q7XG4gICAgICB5aWVsZCBfc3VwZXIucmVzdW1lVXBzdHJlYW0uY2FsbCh0aGlzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcbiAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgeWllbGQgKF9kID0gc2Muc2VuZGVyKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucmVwbGFjZVRyYWNrKHNjLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICBlXzIgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG11dGUoKSB7XG4gICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICBtdXRlOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXV0ZWQpIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnVHJhY2sgYWxyZWFkeSBtdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3N0b3BwaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgLy8gYWxzbyBzdG9wIHRoZSB0cmFjaywgc28gdGhhdCBjYW1lcmEgaW5kaWNhdG9yIGlzIHR1cm5lZCBvZmZcbiAgICAgICAgICB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIubXV0ZS5jYWxsKHRoaXMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHVubXV0ZSgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIHVubXV0ZToge1xuICAgICAgICBnZXQ6ICgpID0+IHN1cGVyLnVubXV0ZVxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB1bmxvY2sgPSB5aWVsZCB0aGlzLm11dGVMb2NrLmxvY2soKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICghdGhpcy5pc011dGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ1RyYWNrIGFscmVhZHkgdW5tdXRlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhICYmICF0aGlzLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlYWNxdWlyaW5nIGNhbWVyYSB0cmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0VHJhY2soKTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBfc3VwZXIudW5tdXRlLmNhbGwodGhpcyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgc2V0VHJhY2tNdXRlZChtdXRlZCkge1xuICAgIHN1cGVyLnNldFRyYWNrTXV0ZWQobXV0ZWQpO1xuICAgIGZvciAoY29uc3Qgc2Mgb2YgdGhpcy5zaW11bGNhc3RDb2RlY3MudmFsdWVzKCkpIHtcbiAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICB9XG4gIH1cbiAgZ2V0U2VuZGVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghKChfYSA9IHRoaXMuc2VuZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0U3RhdHMpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh2LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgY29uc3QgdnMgPSB7XG4gICAgICAgICAgICB0eXBlOiAndmlkZW8nLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICBmcmFtZUhlaWdodDogdi5mcmFtZUhlaWdodCxcbiAgICAgICAgICAgIGZyYW1lV2lkdGg6IHYuZnJhbWVXaWR0aCxcbiAgICAgICAgICAgIGZyYW1lc1BlclNlY29uZDogdi5mcmFtZXNQZXJTZWNvbmQsXG4gICAgICAgICAgICBmcmFtZXNTZW50OiB2LmZyYW1lc1NlbnQsXG4gICAgICAgICAgICBmaXJDb3VudDogdi5maXJDb3VudCxcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgICAgbmFja0NvdW50OiB2Lm5hY2tDb3VudCxcbiAgICAgICAgICAgIHBhY2tldHNTZW50OiB2LnBhY2tldHNTZW50LFxuICAgICAgICAgICAgYnl0ZXNTZW50OiB2LmJ5dGVzU2VudCxcbiAgICAgICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uUmVhc29uOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVhc29uLFxuICAgICAgICAgICAgcXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnM6IHYucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMsXG4gICAgICAgICAgICBxdWFsaXR5TGltaXRhdGlvblJlc29sdXRpb25DaGFuZ2VzOiB2LnF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMsXG4gICAgICAgICAgICByaWQ6IChfYSA9IHYucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2LmlkLFxuICAgICAgICAgICAgcmV0cmFuc21pdHRlZFBhY2tldHNTZW50OiB2LnJldHJhbnNtaXR0ZWRQYWNrZXRzU2VudCxcbiAgICAgICAgICAgIHRhcmdldEJpdHJhdGU6IHYudGFyZ2V0Qml0cmF0ZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXBcbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vwqBsb2NhdGUgdGhlIGFwcHJvcHJpYXRlIHJlbW90ZS1pbmJvdW5kLXJ0cCBpdGVtXG4gICAgICAgICAgY29uc3QgciA9IHN0YXRzLmdldCh2LnJlbW90ZUlkKTtcbiAgICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgdnMuaml0dGVyID0gci5qaXR0ZXI7XG4gICAgICAgICAgICB2cy5wYWNrZXRzTG9zdCA9IHIucGFja2V0c0xvc3Q7XG4gICAgICAgICAgICB2cy5yb3VuZFRyaXBUaW1lID0gci5yb3VuZFRyaXBUaW1lO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtcy5wdXNoKHZzKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICAvLyBtYWtlIHN1cmUgaGlnaGVzdCByZXMgbGF5ZXIgaXMgYWx3YXlzIGZpcnN0XG4gICAgICBpdGVtcy5zb3J0KChhLCBiKSA9PiB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoKF9hID0gYi5mcmFtZVdpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwKSAtICgoX2IgPSBhLmZyYW1lV2lkdGgpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IDApO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSk7XG4gIH1cbiAgc2V0UHVibGlzaGluZ1F1YWxpdHkobWF4UXVhbGl0eSkge1xuICAgIGNvbnN0IHF1YWxpdGllcyA9IFtdO1xuICAgIGZvciAobGV0IHEgPSBWaWRlb1F1YWxpdHkuTE9XOyBxIDw9IFZpZGVvUXVhbGl0eS5ISUdIOyBxICs9IDEpIHtcbiAgICAgIHF1YWxpdGllcy5wdXNoKG5ldyBTdWJzY3JpYmVkUXVhbGl0eSh7XG4gICAgICAgIHF1YWxpdHk6IHEsXG4gICAgICAgIGVuYWJsZWQ6IHEgPD0gbWF4UXVhbGl0eVxuICAgICAgfSkpO1xuICAgIH1cbiAgICB0aGlzLmxvZy5kZWJ1ZyhcInNldHRpbmcgcHVibGlzaGluZyBxdWFsaXR5LiBtYXggcXVhbGl0eSBcIi5jb25jYXQobWF4UXVhbGl0eSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgdGhpcy5zZXRQdWJsaXNoaW5nTGF5ZXJzKHF1YWxpdGllcyk7XG4gIH1cbiAgcmVzdGFydFRyYWNrKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzMsIF9iLCBfYztcbiAgICAgIHZhciBfZDtcbiAgICAgIGxldCBjb25zdHJhaW50cztcbiAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUNvbnN0cmFpbnRzID0gY29uc3RyYWludHNGb3JPcHRpb25zKHtcbiAgICAgICAgICB2aWRlbzogb3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW1Db25zdHJhaW50cy52aWRlbyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgY29uc3RyYWludHMgPSBzdHJlYW1Db25zdHJhaW50cy52aWRlbztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5yZXN0YXJ0KGNvbnN0cmFpbnRzKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZvciAodmFyIF9lID0gdHJ1ZSwgX2YgPSBfX2FzeW5jVmFsdWVzKHRoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2c7IF9nID0geWllbGQgX2YubmV4dCgpLCBfYSA9IF9nLmRvbmUsICFfYTsgX2UgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBfZy52YWx1ZTtcbiAgICAgICAgICBfZSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgaWYgKHNjLnNlbmRlciAmJiAoKF9kID0gc2Muc2VuZGVyLnRyYW5zcG9ydCkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLnN0YXRlKSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgIHNjLm1lZGlhU3RyZWFtVHJhY2sgPSB0aGlzLm1lZGlhU3RyZWFtVHJhY2suY2xvbmUoKTtcbiAgICAgICAgICAgIHlpZWxkIHNjLnNlbmRlci5yZXBsYWNlVHJhY2soc2MubWVkaWFTdHJlYW1UcmFjayk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzNfMSkge1xuICAgICAgICBlXzMgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfM18xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2UgJiYgIV9hICYmIChfYiA9IF9mLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2YpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzMpIHRocm93IGVfMy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFByb2Nlc3Nvcihwcm9jZXNzb3JfMSkge1xuICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgc2V0UHJvY2Vzc29yOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuc2V0UHJvY2Vzc29yXG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKHByb2Nlc3Nvcikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCBzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIGVfNCwgX2IsIF9jO1xuICAgICAgICB2YXIgX2QsIF9lO1xuICAgICAgICB5aWVsZCBfc3VwZXIuc2V0UHJvY2Vzc29yLmNhbGwoX3RoaXMsIHByb2Nlc3Nvciwgc2hvd1Byb2Nlc3NlZFN0cmVhbUxvY2FsbHkpO1xuICAgICAgICBpZiAoKF9kID0gX3RoaXMucHJvY2Vzc29yKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QucHJvY2Vzc2VkVHJhY2spIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZm9yICh2YXIgX2YgPSB0cnVlLCBfZyA9IF9fYXN5bmNWYWx1ZXMoX3RoaXMuc2ltdWxjYXN0Q29kZWNzLnZhbHVlcygpKSwgX2g7IF9oID0geWllbGQgX2cubmV4dCgpLCBfYSA9IF9oLmRvbmUsICFfYTsgX2YgPSB0cnVlKSB7XG4gICAgICAgICAgICAgIF9jID0gX2gudmFsdWU7XG4gICAgICAgICAgICAgIF9mID0gZmFsc2U7XG4gICAgICAgICAgICAgIGNvbnN0IHNjID0gX2M7XG4gICAgICAgICAgICAgIHlpZWxkIChfZSA9IHNjLnNlbmRlcikgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlcGxhY2VUcmFjayhfdGhpcy5wcm9jZXNzb3IucHJvY2Vzc2VkVHJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVfNF8xKSB7XG4gICAgICAgICAgICBlXzQgPSB7XG4gICAgICAgICAgICAgIGVycm9yOiBlXzRfMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFfZiAmJiAhX2EgJiYgKF9iID0gX2cucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZyk7XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICBpZiAoZV80KSB0aHJvdyBlXzQuZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0RGVncmFkYXRpb25QcmVmZXJlbmNlKHByZWZlcmVuY2UpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBwcmVmZXJlbmNlO1xuICAgICAgaWYgKHRoaXMuc2VuZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJzZXR0aW5nIGRlZ3JhZGF0aW9uUHJlZmVyZW5jZSB0byBcIi5jb25jYXQocHJlZmVyZW5jZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgIHBhcmFtcy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBwcmVmZXJlbmNlO1xuICAgICAgICAgIHRoaXMuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJmYWlsZWQgdG8gc2V0IGRlZ3JhZGF0aW9uUHJlZmVyZW5jZVwiLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBhZGRTaW11bGNhc3RUcmFjayhjb2RlYywgZW5jb2RpbmdzKSB7XG4gICAgaWYgKHRoaXMuc2ltdWxjYXN0Q29kZWNzLmhhcyhjb2RlYykpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKFwiXCIuY29uY2F0KGNvZGVjLCBcIiBhbHJlYWR5IGFkZGVkLCBza2lwcGluZyBhZGRpbmcgc2ltdWxjYXN0IGNvZGVjXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB7XG4gICAgICBjb2RlYyxcbiAgICAgIG1lZGlhU3RyZWFtVHJhY2s6IHRoaXMubWVkaWFTdHJlYW1UcmFjay5jbG9uZSgpLFxuICAgICAgc2VuZGVyOiB1bmRlZmluZWQsXG4gICAgICBlbmNvZGluZ3NcbiAgICB9O1xuICAgIHRoaXMuc2ltdWxjYXN0Q29kZWNzLnNldChjb2RlYywgc2ltdWxjYXN0Q29kZWNJbmZvKTtcbiAgICByZXR1cm4gc2ltdWxjYXN0Q29kZWNJbmZvO1xuICB9XG4gIHNldFNpbXVsY2FzdFRyYWNrU2VuZGVyKGNvZGVjLCBzZW5kZXIpIHtcbiAgICBjb25zdCBzaW11bGNhc3RDb2RlY0luZm8gPSB0aGlzLnNpbXVsY2FzdENvZGVjcy5nZXQoY29kZWMpO1xuICAgIGlmICghc2ltdWxjYXN0Q29kZWNJbmZvKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIgPSBzZW5kZXI7XG4gICAgLy8gYnJvd3NlciB3aWxsIHJlZW5hYmxlIGRpc2FibGVkIGNvZGVjL2xheWVycyBhZnRlciBuZXcgY29kZWMgaGFzIGJlZW4gcHVibGlzaGVkLFxuICAgIC8vIHNvIHJlZnJlc2ggc3Vic2NyaWJlZENvZGVjcyBhZnRlciBwdWJsaXNoIGEgbmV3IGNvZGVjXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zdWJzY3JpYmVkQ29kZWNzKSB7XG4gICAgICAgIHRoaXMuc2V0UHVibGlzaGluZ0NvZGVjcyh0aGlzLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgfVxuICAgIH0sIHJlZnJlc2hTdWJzY3JpYmVkQ29kZWNBZnRlck5ld0NvZGVjKTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgY29kZWNzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmcsIHJldHVybnMgbmV3IGNvZGVjcyB0aGF0IGhhdmUgbm90IHlldFxuICAgKiBiZWVuIHB1Ymxpc2hlZFxuICAgKi9cbiAgc2V0UHVibGlzaGluZ0NvZGVjcyhjb2RlY3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBjb2RlY3NfMSwgY29kZWNzXzFfMTtcbiAgICAgIHZhciBfYiwgZV81LCBfYywgX2Q7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0dGluZyBwdWJsaXNoaW5nIGNvZGVjcycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBjb2RlY3MsXG4gICAgICAgIGN1cnJlbnRDb2RlYzogdGhpcy5jb2RlY1xuICAgICAgfSkpO1xuICAgICAgLy8gb25seSBlbmFibGUgc2ltdWxjYXN0IGNvZGVjIGZvciBwcmVmZXJlbmNlIGNvZGVjIHNldHRlZFxuICAgICAgaWYgKCF0aGlzLmNvZGVjICYmIGNvZGVjcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc2V0UHVibGlzaGluZ0xheWVycyhjb2RlY3NbMF0ucXVhbGl0aWVzKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5zdWJzY3JpYmVkQ29kZWNzID0gY29kZWNzO1xuICAgICAgY29uc3QgbmV3Q29kZWNzID0gW107XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKF9hID0gdHJ1ZSwgY29kZWNzXzEgPSBfX2FzeW5jVmFsdWVzKGNvZGVjcyk7IGNvZGVjc18xXzEgPSB5aWVsZCBjb2RlY3NfMS5uZXh0KCksIF9iID0gY29kZWNzXzFfMS5kb25lLCAhX2I7IF9hID0gdHJ1ZSkge1xuICAgICAgICAgIF9kID0gY29kZWNzXzFfMS52YWx1ZTtcbiAgICAgICAgICBfYSA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGNvZGVjID0gX2Q7XG4gICAgICAgICAgaWYgKCF0aGlzLmNvZGVjIHx8IHRoaXMuY29kZWMgPT09IGNvZGVjLmNvZGVjKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNldFB1Ymxpc2hpbmdMYXllcnMoY29kZWMucXVhbGl0aWVzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2ltdWxjYXN0Q29kZWNJbmZvID0gdGhpcy5zaW11bGNhc3RDb2RlY3MuZ2V0KGNvZGVjLmNvZGVjKTtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdDb2RlYyBmb3IgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgIHNpbXVsY2FzdENvZGVjSW5mb1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgaWYgKCFzaW11bGNhc3RDb2RlY0luZm8gfHwgIXNpbXVsY2FzdENvZGVjSW5mby5zZW5kZXIpIHtcbiAgICAgICAgICAgICAgZm9yIChjb25zdCBxIG9mIGNvZGVjLnF1YWxpdGllcykge1xuICAgICAgICAgICAgICAgIGlmIChxLmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgIG5ld0NvZGVjcy5wdXNoKGNvZGVjLmNvZGVjKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwidHJ5IHNldFB1Ymxpc2hpbmdMYXllcnNGb3JTZW5kZXIgXCIuY29uY2F0KGNvZGVjLmNvZGVjKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcihzaW11bGNhc3RDb2RlY0luZm8uc2VuZGVyLCBzaW11bGNhc3RDb2RlY0luZm8uZW5jb2RpbmdzLCBjb2RlYy5xdWFsaXRpZXMsIHRoaXMuc2VuZGVyTG9jaywgdGhpcy5sb2csIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzVfMSkge1xuICAgICAgICBlXzUgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfNV8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2EgJiYgIV9iICYmIChfYyA9IGNvZGVjc18xLnJldHVybikpIHlpZWxkIF9jLmNhbGwoY29kZWNzXzEpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzUpIHRocm93IGVfNS5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ld0NvZGVjcztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqIFNldHMgbGF5ZXJzIHRoYXQgc2hvdWxkIGJlIHB1Ymxpc2hpbmdcbiAgICovXG4gIHNldFB1Ymxpc2hpbmdMYXllcnMocXVhbGl0aWVzKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdzZXR0aW5nIHB1Ymxpc2hpbmcgbGF5ZXJzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHF1YWxpdGllc1xuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLnNlbmRlciB8fCAhdGhpcy5lbmNvZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgeWllbGQgc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcih0aGlzLnNlbmRlciwgdGhpcy5lbmNvZGluZ3MsIHF1YWxpdGllcywgdGhpcy5zZW5kZXJMb2NrLCB0aGlzLmxvZywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICB9KTtcbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIWlzTW9iaWxlKCkpIHJldHVybjtcbiAgICAgIGlmICh0aGlzLmlzSW5CYWNrZ3JvdW5kICYmIHRoaXMuc291cmNlID09PSBUcmFjay5Tb3VyY2UuQ2FtZXJhKSB7XG4gICAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyKHNlbmRlciwgc2VuZGVyRW5jb2RpbmdzLCBxdWFsaXRpZXMsIHNlbmRlckxvY2ssIGxvZywgbG9nQ29udGV4dCkge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHNlbmRlckxvY2subG9jaygpO1xuICAgIGxvZy5kZWJ1Zygnc2V0UHVibGlzaGluZ0xheWVyc0ZvclNlbmRlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcbiAgICAgIHNlbmRlcixcbiAgICAgIHF1YWxpdGllcyxcbiAgICAgIHNlbmRlckVuY29kaW5nc1xuICAgIH0pKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyYW1zID0gc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZW5jb2RpbmdzXG4gICAgICB9ID0gcGFyYW1zO1xuICAgICAgaWYgKCFlbmNvZGluZ3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGVuY29kaW5ncy5sZW5ndGggIT09IHNlbmRlckVuY29kaW5ncy5sZW5ndGgpIHtcbiAgICAgICAgbG9nLndhcm4oJ2Nhbm5vdCBzZXQgcHVibGlzaGluZyBsYXllcnMsIGVuY29kaW5ncyBtaXNtYXRjaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgICAgc2VuZGVyRW5jb2RpbmdzXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgbGV0IGhhc0NoYW5nZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICBjb25zdCBjbG9zYWJsZVNwYXRpYWwgPSAoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLm5hbWUpID09PSAnQ2hyb21lJyAmJiBjb21wYXJlVmVyc2lvbnMoYnJvd3NlciA9PT0gbnVsbCB8fCBicm93c2VyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBicm93c2VyLnZlcnNpb24sICcxMzMnKSA+IDA7XG4gICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICBpZiAoY2xvc2FibGVTcGF0aWFsICYmIGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUpIHtcbiAgICAgICAgLy8gc3ZjIGR5bmFjYXN0IGVuY29kaW5nc1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGVuY29kaW5nc1swXTtcbiAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICBjb25zdCBtb2RlID0gbmV3IFNjYWxhYmlsaXR5TW9kZShlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICBsZXQgbWF4UXVhbGl0eSA9IFZpZGVvUXVhbGl0eSQxLk9GRjtcbiAgICAgICAgcXVhbGl0aWVzLmZvckVhY2gocSA9PiB7XG4gICAgICAgICAgaWYgKHEuZW5hYmxlZCAmJiAobWF4UXVhbGl0eSA9PT0gVmlkZW9RdWFsaXR5JDEuT0ZGIHx8IHEucXVhbGl0eSA+IG1heFF1YWxpdHkpKSB7XG4gICAgICAgICAgICBtYXhRdWFsaXR5ID0gcS5xdWFsaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtYXhRdWFsaXR5ID09PSBWaWRlb1F1YWxpdHkkMS5PRkYpIHtcbiAgICAgICAgICBpZiAoZW5jb2RpbmcuYWN0aXZlKSB7XG4gICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgICAgIGhhc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghZW5jb2RpbmcuYWN0aXZlIHx8IG1vZGUuc3BhdGlhbCAhPT0gbWF4UXVhbGl0eSArIDEpIHtcbiAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICBjb25zdCBvcmlnaW5hbE1vZGUgPSBuZXcgU2NhbGFiaWxpdHlNb2RlKHNlbmRlckVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGUpO1xuICAgICAgICAgIG1vZGUuc3BhdGlhbCA9IG1heFF1YWxpdHkgKyAxO1xuICAgICAgICAgIG1vZGUuc3VmZml4ID0gb3JpZ2luYWxNb2RlLnN1ZmZpeDtcbiAgICAgICAgICBpZiAobW9kZS5zcGF0aWFsID09PSAxKSB7XG4gICAgICAgICAgICAvLyBubyBzdWZmaXggZm9yIEwxVHhcbiAgICAgICAgICAgIG1vZGUuc3VmZml4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gbW9kZS50b1N0cmluZygpO1xuICAgICAgICAgIGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IE1hdGgucG93KDIsIDIgLSBtYXhRdWFsaXR5KTtcbiAgICAgICAgICBpZiAoc2VuZGVyRW5jb2RpbmdzWzBdLm1heEJpdHJhdGUpIHtcbiAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSBzZW5kZXJFbmNvZGluZ3NbMF0ubWF4Qml0cmF0ZSAvIChlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgKiBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gc2ltdWxjYXN0IGR5bmFjYXN0IGVuY29kaW5nc1xuICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICBsZXQgcmlkID0gKF9hID0gZW5jb2RpbmcucmlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJztcbiAgICAgICAgICBpZiAocmlkID09PSAnJykge1xuICAgICAgICAgICAgcmlkID0gJ3EnO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBxdWFsaXR5ID0gdmlkZW9RdWFsaXR5Rm9yUmlkKHJpZCk7XG4gICAgICAgICAgY29uc3Qgc3Vic2NyaWJlZFF1YWxpdHkgPSBxdWFsaXRpZXMuZmluZChxID0+IHEucXVhbGl0eSA9PT0gcXVhbGl0eSk7XG4gICAgICAgICAgaWYgKCFzdWJzY3JpYmVkUXVhbGl0eSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZW5jb2RpbmcuYWN0aXZlICE9PSBzdWJzY3JpYmVkUXVhbGl0eS5lbmFibGVkKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQ7XG4gICAgICAgICAgICBsb2cuZGVidWcoXCJzZXR0aW5nIGxheWVyIFwiLmNvbmNhdChzdWJzY3JpYmVkUXVhbGl0eS5xdWFsaXR5LCBcIiB0byBcIikuY29uY2F0KGVuY29kaW5nLmFjdGl2ZSA/ICdlbmFibGVkJyA6ICdkaXNhYmxlZCcpLCBsb2dDb250ZXh0KTtcbiAgICAgICAgICAgIC8vIEZpcmVGb3ggZG9lcyBub3Qgc3VwcG9ydCBzZXR0aW5nIGVuY29kaW5nLmFjdGl2ZSB0byBmYWxzZSwgc28gd2VcbiAgICAgICAgICAgIC8vIGhhdmUgYSB3b3JrYXJvdW5kIG9mIGxvd2VyaW5nIGl0cyBiaXRyYXRlIGFuZCByZXNvbHV0aW9uIHRvIHRoZSBtaW4uXG4gICAgICAgICAgICBpZiAoaXNGaXJlRm94KCkpIHtcbiAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZWRRdWFsaXR5LmVuYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSBzZW5kZXJFbmNvZGluZ3NbaWR4XS5zY2FsZVJlc29sdXRpb25Eb3duQnk7XG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4Qml0cmF0ZSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLm1heEJpdHJhdGU7XG4gICAgICAgICAgICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEZyYW1lUmF0ZSA9IHNlbmRlckVuY29kaW5nc1tpZHhdLm1heEZyYW1lUmF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPSA0O1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLm1heEJpdHJhdGUgPSAxMDtcbiAgICAgICAgICAgICAgICAvKiBAdHMtaWdub3JlICovXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcubWF4RnJhbWVSYXRlID0gMjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hhbmdlZCkge1xuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgICBsb2cuZGVidWcoXCJzZXR0aW5nIGVuY29kaW5nc1wiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZW5jb2RpbmdzOiBwYXJhbXMuZW5jb2RpbmdzXG4gICAgICAgIH0pKTtcbiAgICAgICAgeWllbGQgc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1zKTtcbiAgICAgIH1cbiAgICB9IGZpbmFsbHkge1xuICAgICAgdW5sb2NrKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHZpZGVvUXVhbGl0eUZvclJpZChyaWQpIHtcbiAgc3dpdGNoIChyaWQpIHtcbiAgICBjYXNlICdmJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuSElHSDtcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuTUVESVVNO1xuICAgIGNhc2UgJ3EnOlxuICAgICAgcmV0dXJuIFZpZGVvUXVhbGl0eS5MT1c7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBWaWRlb1F1YWxpdHkuSElHSDtcbiAgfVxufVxuZnVuY3Rpb24gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHdpZHRoLCBoZWlnaHQsIGVuY29kaW5ncywgc3ZjKSB7XG4gIC8vIGRlZmF1bHQgdG8gYSBzaW5nbGUgbGF5ZXIsIEhRXG4gIGlmICghZW5jb2RpbmdzKSB7XG4gICAgcmV0dXJuIFtuZXcgVmlkZW9MYXllcih7XG4gICAgICBxdWFsaXR5OiBWaWRlb1F1YWxpdHkuSElHSCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0LFxuICAgICAgYml0cmF0ZTogMCxcbiAgICAgIHNzcmM6IDBcbiAgICB9KV07XG4gIH1cbiAgaWYgKHN2Yykge1xuICAgIC8vIHN2YyBsYXllcnNcbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgY29uc3QgZW5jb2RpbmdTTSA9IGVuY29kaW5nc1swXS5zY2FsYWJpbGl0eU1vZGU7XG4gICAgY29uc3Qgc20gPSBuZXcgU2NhbGFiaWxpdHlNb2RlKGVuY29kaW5nU00pO1xuICAgIGNvbnN0IGxheWVycyA9IFtdO1xuICAgIGNvbnN0IHJlc1JhdGlvID0gc20uc3VmZml4ID09ICdoJyA/IDEuNSA6IDI7XG4gICAgY29uc3QgYml0cmF0ZXNSYXRpbyA9IHNtLnN1ZmZpeCA9PSAnaCcgPyAyIDogMztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNtLnNwYXRpYWw7IGkgKz0gMSkge1xuICAgICAgbGF5ZXJzLnB1c2gobmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgICBxdWFsaXR5OiBNYXRoLm1pbihWaWRlb1F1YWxpdHkuSElHSCwgc20uc3BhdGlhbCAtIDEpIC0gaSxcbiAgICAgICAgd2lkdGg6IE1hdGguY2VpbCh3aWR0aCAvIE1hdGgucG93KHJlc1JhdGlvLCBpKSksXG4gICAgICAgIGhlaWdodDogTWF0aC5jZWlsKGhlaWdodCAvIE1hdGgucG93KHJlc1JhdGlvLCBpKSksXG4gICAgICAgIGJpdHJhdGU6IGVuY29kaW5nc1swXS5tYXhCaXRyYXRlID8gTWF0aC5jZWlsKGVuY29kaW5nc1swXS5tYXhCaXRyYXRlIC8gTWF0aC5wb3coYml0cmF0ZXNSYXRpbywgaSkpIDogMCxcbiAgICAgICAgc3NyYzogMFxuICAgICAgfSkpO1xuICAgIH1cbiAgICByZXR1cm4gbGF5ZXJzO1xuICB9XG4gIHJldHVybiBlbmNvZGluZ3MubWFwKGVuY29kaW5nID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBjb25zdCBzY2FsZSA9IChfYSA9IGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogMTtcbiAgICBsZXQgcXVhbGl0eSA9IHZpZGVvUXVhbGl0eUZvclJpZCgoX2IgPSBlbmNvZGluZy5yaWQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnKTtcbiAgICByZXR1cm4gbmV3IFZpZGVvTGF5ZXIoe1xuICAgICAgcXVhbGl0eSxcbiAgICAgIHdpZHRoOiBNYXRoLmNlaWwod2lkdGggLyBzY2FsZSksXG4gICAgICBoZWlnaHQ6IE1hdGguY2VpbChoZWlnaHQgLyBzY2FsZSksXG4gICAgICBiaXRyYXRlOiAoX2MgPSBlbmNvZGluZy5tYXhCaXRyYXRlKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAwLFxuICAgICAgc3NyYzogMFxuICAgIH0pO1xuICB9KTtcbn1cblxuY29uc3QgbG9zc3lEYXRhQ2hhbm5lbCA9ICdfbG9zc3knO1xuY29uc3QgcmVsaWFibGVEYXRhQ2hhbm5lbCA9ICdfcmVsaWFibGUnO1xuY29uc3QgbWluUmVjb25uZWN0V2FpdCA9IDIgKiAxMDAwO1xuY29uc3QgbGVhdmVSZWNvbm5lY3QgPSAnbGVhdmUtcmVjb25uZWN0JztcbnZhciBQQ1N0YXRlO1xuKGZ1bmN0aW9uIChQQ1N0YXRlKSB7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIk5ld1wiXSA9IDBdID0gXCJOZXdcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiQ29ubmVjdGVkXCJdID0gMV0gPSBcIkNvbm5lY3RlZFwiO1xuICBQQ1N0YXRlW1BDU3RhdGVbXCJEaXNjb25uZWN0ZWRcIl0gPSAyXSA9IFwiRGlzY29ubmVjdGVkXCI7XG4gIFBDU3RhdGVbUENTdGF0ZVtcIlJlY29ubmVjdGluZ1wiXSA9IDNdID0gXCJSZWNvbm5lY3RpbmdcIjtcbiAgUENTdGF0ZVtQQ1N0YXRlW1wiQ2xvc2VkXCJdID0gNF0gPSBcIkNsb3NlZFwiO1xufSkoUENTdGF0ZSB8fCAoUENTdGF0ZSA9IHt9KSk7XG4vKiogQGludGVybmFsICovXG5jbGFzcyBSVENFbmdpbmUgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGdldCBpc0Nsb3NlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5faXNDbG9zZWQ7XG4gIH1cbiAgZ2V0IHBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5yZWNvbm5lY3RUaW1lb3V0O1xuICB9XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMucnRjQ29uZmlnID0ge307XG4gICAgdGhpcy5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSByb29tQ29ubmVjdE9wdGlvbkRlZmF1bHRzLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSBmYWxzZTtcbiAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gZmFsc2U7XG4gICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5OZXc7XG4gICAgdGhpcy5faXNDbG9zZWQgPSB0cnVlO1xuICAgIHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzID0ge307XG4gICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgdGhpcy5yZWNvbm5lY3RTdGFydCA9IDA7XG4gICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgLyoqIGtlZXBzIHRyYWNrIG9mIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBoYXMgYmVlbiB0cmllZCAqL1xuICAgIHRoaXMuam9pbkF0dGVtcHRzID0gMDtcbiAgICAvKiogc3BlY2lmaWVzIGhvdyBvZnRlbiBhbiBpbml0aWFsIGpvaW4gY29ubmVjdGlvbiBpcyBhbGxvd2VkIHRvIHJldHJ5ICovXG4gICAgdGhpcy5tYXhKb2luQXR0ZW1wdHMgPSAxO1xuICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbCA9IF9hID0+IF9fYXdhaXRlcih0aGlzLCBbX2FdLCB2b2lkIDAsIGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgbGV0IHtcbiAgICAgICAgY2hhbm5lbFxuICAgICAgfSA9IF9yZWY7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFubmVsLmxhYmVsID09PSByZWxpYWJsZURhdGFDaGFubmVsKSB7XG4gICAgICAgICAgX3RoaXMucmVsaWFibGVEQ1N1YiA9IGNoYW5uZWw7XG4gICAgICAgIH0gZWxzZSBpZiAoY2hhbm5lbC5sYWJlbCA9PT0gbG9zc3lEYXRhQ2hhbm5lbCkge1xuICAgICAgICAgIF90aGlzLmxvc3N5RENTdWIgPSBjaGFubmVsO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5sb2cuZGVidWcoXCJvbiBkYXRhIGNoYW5uZWwgXCIuY29uY2F0KGNoYW5uZWwuaWQsIFwiLCBcIikuY29uY2F0KGNoYW5uZWwubGFiZWwpLCBfdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgY2hhbm5lbC5vbm1lc3NhZ2UgPSBfdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZURhdGFNZXNzYWdlID0gbWVzc2FnZSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIHJlc3BlY3QgaW5jb21pbmcgZGF0YSBtZXNzYWdlIG9yZGVyIGJ5IHByb2Nlc3NpbmcgbWVzc2FnZSBldmVudHMgb25lIGFmdGVyIHRoZSBvdGhlclxuICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgdGhpcy5kYXRhUHJvY2Vzc0xvY2subG9jaygpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gZGVjb2RlXG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICAgIGJ1ZmZlciA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgfSBlbHNlIGlmIChtZXNzYWdlLmRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgICAgYnVmZmVyID0geWllbGQgbWVzc2FnZS5kYXRhLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ3Vuc3VwcG9ydGVkIGRhdGEgdHlwZScsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZGF0YTogbWVzc2FnZS5kYXRhXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkcCA9IERhdGFQYWNrZXQuZnJvbUJpbmFyeShuZXcgVWludDhBcnJheShidWZmZXIpKTtcbiAgICAgICAgaWYgKCgoX2EgPSBkcC52YWx1ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhc2UpID09PSAnc3BlYWtlcicpIHtcbiAgICAgICAgICAvLyBkaXNwYXRjaCBzcGVha2VyIHVwZGF0ZXNcbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQWN0aXZlU3BlYWtlcnNVcGRhdGUsIGRwLnZhbHVlLnZhbHVlLnNwZWFrZXJzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoKChfYiA9IGRwLnZhbHVlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FzZSkgPT09ICd1c2VyJykge1xuICAgICAgICAgICAgLy8gY29tcGF0aWJpbGl0eVxuICAgICAgICAgICAgYXBwbHlVc2VyRGF0YUNvbXBhdChkcCwgZHAudmFsdWUudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCBkcCk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlRGF0YUVycm9yID0gZXZlbnQgPT4ge1xuICAgICAgY29uc3QgY2hhbm5lbCA9IGV2ZW50LmN1cnJlbnRUYXJnZXQ7XG4gICAgICBjb25zdCBjaGFubmVsS2luZCA9IGNoYW5uZWwubWF4UmV0cmFuc21pdHMgPT09IDAgPyAnbG9zc3knIDogJ3JlbGlhYmxlJztcbiAgICAgIGlmIChldmVudCBpbnN0YW5jZW9mIEVycm9yRXZlbnQgJiYgZXZlbnQuZXJyb3IpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGVycm9yXG4gICAgICAgIH0gPSBldmVudC5lcnJvcjtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoXCJEYXRhQ2hhbm5lbCBlcnJvciBvbiBcIi5jb25jYXQoY2hhbm5lbEtpbmQsIFwiOiBcIikuY29uY2F0KGV2ZW50Lm1lc3NhZ2UpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIlVua25vd24gRGF0YUNoYW5uZWwgZXJyb3Igb24gXCIuY29uY2F0KGNoYW5uZWxLaW5kKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXZlbnRcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdyA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGNoYW5uZWwgPSBldmVudC5jdXJyZW50VGFyZ2V0O1xuICAgICAgY29uc3QgY2hhbm5lbEtpbmQgPSBjaGFubmVsLm1heFJldHJhbnNtaXRzID09PSAwID8gRGF0YVBhY2tldF9LaW5kLkxPU1NZIDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFO1xuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoY2hhbm5lbEtpbmQpO1xuICAgIH07XG4gICAgLy8gd2Vic29ja2V0IHJlY29ubmVjdCBiZWhhdmlvci4gaWYgd2Vic29ja2V0IGlzIGludGVycnVwdGVkLCBhbmQgdGhlIFBlZXJDb25uZWN0aW9uXG4gICAgLy8gY29udGludWVzIHRvIHdvcmssIHdlIGNhbiByZWNvbm5lY3QgdG8gd2Vic29ja2V0IHRvIGNvbnRpbnVlIHRoZSBzZXNzaW9uXG4gICAgLy8gYWZ0ZXIgYSBudW1iZXIgb2YgcmV0cmllcywgd2UnbGwgY2xvc2UgYW5kIGdpdmUgdXAgcGVybWFuZW50bHlcbiAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QgPSAoY29ubmVjdGlvbiwgZGlzY29ubmVjdFJlYXNvbikgPT4ge1xuICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLndhcm4oXCJcIi5jb25jYXQoY29ubmVjdGlvbiwgXCIgZGlzY29ubmVjdGVkXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgaWYgKHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPT09IDApIHtcbiAgICAgICAgLy8gb25seSByZXNldCBzdGFydCB0aW1lIG9uIHRoZSBmaXJzdCB0cnlcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RTdGFydCA9IERhdGUubm93KCk7XG4gICAgICB9XG4gICAgICBjb25zdCBkaXNjb25uZWN0ID0gZHVyYXRpb24gPT4ge1xuICAgICAgICB0aGlzLmxvZy53YXJuKFwiY291bGQgbm90IHJlY292ZXIgY29ubmVjdGlvbiBhZnRlciBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cywgXCIgYXR0ZW1wdHMsIFwiKS5jb25jYXQoZHVyYXRpb24sIFwibXMuIGdpdmluZyB1cFwiKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBkdXJhdGlvbiA9IERhdGUubm93KCkgLSB0aGlzLnJlY29ubmVjdFN0YXJ0O1xuICAgICAgbGV0IGRlbGF5ID0gdGhpcy5nZXROZXh0UmV0cnlEZWxheSh7XG4gICAgICAgIGVsYXBzZWRNczogZHVyYXRpb24sXG4gICAgICAgIHJldHJ5Q291bnQ6IHRoaXMucmVjb25uZWN0QXR0ZW1wdHNcbiAgICAgIH0pO1xuICAgICAgaWYgKGRlbGF5ID09PSBudWxsKSB7XG4gICAgICAgIGRpc2Nvbm5lY3QoZHVyYXRpb24pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoY29ubmVjdGlvbiA9PT0gbGVhdmVSZWNvbm5lY3QpIHtcbiAgICAgICAgZGVsYXkgPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2cuZGVidWcoXCJyZWNvbm5lY3RpbmcgaW4gXCIuY29uY2F0KGRlbGF5LCBcIm1zXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLnRva2VuICYmIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpIHtcbiAgICAgICAgLy8gdG9rZW4gbWF5IGhhdmUgYmVlbiByZWZyZXNoZWQsIHdlIGRvIG5vdCB3YW50IHRvIHJlY3JlYXRlIHRoZSByZWdpb25VcmxQcm92aWRlclxuICAgICAgICAvLyBzaW5jZSB0aGUgY3VycmVudCBlbmdpbmUgbWF5IGhhdmUgaW5oZXJpdGVkIGEgcmVnaW9uYWwgdXJsXG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIudXBkYXRlVG9rZW4odGhpcy50b2tlbik7XG4gICAgICB9XG4gICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBDcml0aWNhbFRpbWVycy5zZXRUaW1lb3V0KCgpID0+IHRoaXMuYXR0ZW1wdFJlY29ubmVjdChkaXNjb25uZWN0UmVhc29uKS5maW5hbGx5KCgpID0+IHRoaXMucmVjb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZCksIGRlbGF5KTtcbiAgICB9O1xuICAgIHRoaXMud2FpdEZvclJlc3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGlmICh0aGlzLnBjU3RhdGUgPT09IFBDU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uUmVzdGFydGVkID0gKCkgPT4ge1xuICAgICAgICAgIHRoaXMub2ZmKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgb25EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25EaXNjb25uZWN0ZWQgPSAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5vZmYoRW5naW5lRXZlbnQuUmVzdGFydGVkLCBvblJlc3RhcnRlZCk7XG4gICAgICAgICAgcmVqZWN0KCk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub25jZShFbmdpbmVFdmVudC5SZXN0YXJ0ZWQsIG9uUmVzdGFydGVkKTtcbiAgICAgICAgdGhpcy5vbmNlKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgb25EaXNjb25uZWN0ZWQpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUFuZEVtaXREQ0J1ZmZlclN0YXR1cyA9IGtpbmQgPT4ge1xuICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5pc0J1ZmZlclN0YXR1c0xvdyhraW5kKTtcbiAgICAgIGlmICh0eXBlb2Ygc3RhdHVzICE9PSAndW5kZWZpbmVkJyAmJiBzdGF0dXMgIT09IHRoaXMuZGNCdWZmZXJTdGF0dXMuZ2V0KGtpbmQpKSB7XG4gICAgICAgIHRoaXMuZGNCdWZmZXJTdGF0dXMuc2V0KGtpbmQsIHN0YXR1cyk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIHN0YXR1cywga2luZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmlzQnVmZmVyU3RhdHVzTG93ID0ga2luZCA9PiB7XG4gICAgICBjb25zdCBkYyA9IHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQpO1xuICAgICAgaWYgKGRjKSB7XG4gICAgICAgIHJldHVybiBkYy5idWZmZXJlZEFtb3VudCA8PSBkYy5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQnJvd3Nlck9uTGluZSA9ICgpID0+IHtcbiAgICAgIC8vIGluIGNhc2UgdGhlIGVuZ2luZSBpcyBjdXJyZW50bHkgcmVjb25uZWN0aW5nLCBhdHRlbXB0IGEgcmVjb25uZWN0IGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBicm93c2VyIHN0YXRlIGhhcyBjaGFuZ2VkIHRvICdvbkxpbmUnXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlID09PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuUkVDT05ORUNUSU5HKSB7XG4gICAgICAgIHRoaXMuY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCk7XG4gICAgICAgIHRoaXMuYXR0ZW1wdFJlY29ubmVjdChSZWNvbm5lY3RSZWFzb24uUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBvcHRpb25zLmxvZ2dlck5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IExvZ2dlck5hbWVzLkVuZ2luZSk7XG4gICAgdGhpcy5sb2dnZXJPcHRpb25zID0ge1xuICAgICAgbG9nZ2VyTmFtZTogb3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50ID0gbmV3IFNpZ25hbENsaWVudCh1bmRlZmluZWQsIHRoaXMubG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5jbGllbnQuc2lnbmFsTGF0ZW5jeSA9IHRoaXMub3B0aW9ucy5leHBTaWduYWxMYXRlbmN5O1xuICAgIHRoaXMucmVjb25uZWN0UG9saWN5ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdFBvbGljeTtcbiAgICB0aGlzLnJlZ2lzdGVyT25MaW5lTGlzdGVuZXIoKTtcbiAgICB0aGlzLmNsb3NpbmdMb2NrID0gbmV3IF8oKTtcbiAgICB0aGlzLmRhdGFQcm9jZXNzTG9jayA9IG5ldyBfKCk7XG4gICAgdGhpcy5kY0J1ZmZlclN0YXR1cyA9IG5ldyBNYXAoW1tEYXRhUGFja2V0X0tpbmQuTE9TU1ksIHRydWVdLCBbRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLCB0cnVlXV0pO1xuICAgIHRoaXMuY2xpZW50Lm9uUGFydGljaXBhbnRVcGRhdGUgPSB1cGRhdGVzID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5QYXJ0aWNpcGFudFVwZGF0ZSwgdXBkYXRlcyk7XG4gICAgdGhpcy5jbGllbnQub25Db25uZWN0aW9uUXVhbGl0eSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25Sb29tVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3Vic2NyaXB0aW9uRXJyb3IgPSByZXNwID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25FcnJvciwgcmVzcCk7XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uU3BlYWtlcnNDaGFuZ2VkID0gdXBkYXRlID0+IHRoaXMuZW1pdChFbmdpbmVFdmVudC5TcGVha2Vyc0NoYW5nZWQsIHVwZGF0ZSk7XG4gICAgdGhpcy5jbGllbnQub25TdHJlYW1TdGF0ZVVwZGF0ZSA9IHVwZGF0ZSA9PiB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3RyZWFtU3RhdGVDaGFuZ2VkLCB1cGRhdGUpO1xuICAgIHRoaXMuY2xpZW50Lm9uUmVxdWVzdFJlc3BvbnNlID0gcmVzcG9uc2UgPT4gdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlNpZ25hbFJlcXVlc3RSZXNwb25zZSwgcmVzcG9uc2UpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogKF9iID0gKF9hID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yb29tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubmFtZSxcbiAgICAgIHJvb21JRDogKF9kID0gKF9jID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yb29tKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2lkLFxuICAgICAgcGFydGljaXBhbnQ6IChfZiA9IChfZSA9IHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlKSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UucGFydGljaXBhbnQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5pZGVudGl0eSxcbiAgICAgIHBJRDogKF9oID0gKF9nID0gdGhpcy5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wYXJ0aWNpcGFudCkgPT09IG51bGwgfHwgX2ggPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9oLnNpZFxuICAgIH07XG4gIH1cbiAgam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgIHRoaXMuc2lnbmFsT3B0cyA9IG9wdHM7XG4gICAgICB0aGlzLm1heEpvaW5BdHRlbXB0cyA9IG9wdHMubWF4UmV0cmllcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuam9pbkF0dGVtcHRzICs9IDE7XG4gICAgICAgIHRoaXMuc2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MoKTtcbiAgICAgICAgY29uc3Qgam9pblJlc3BvbnNlID0geWllbGQgdGhpcy5jbGllbnQuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgIHRoaXMuX2lzQ2xvc2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubGF0ZXN0Sm9pblJlc3BvbnNlID0gam9pblJlc3BvbnNlO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXJQcmltYXJ5ID0gam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5O1xuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5jb25maWd1cmUoam9pblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjcmVhdGUgb2ZmZXJcbiAgICAgICAgaWYgKCF0aGlzLnN1YnNjcmliZXJQcmltYXJ5IHx8IGpvaW5SZXNwb25zZS5mYXN0UHVibGlzaCkge1xuICAgICAgICAgIHRoaXMubmVnb3RpYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGllbnRDb25maWd1cmF0aW9uID0gam9pblJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb247XG4gICAgICAgIC8vIGVtaXQgc2lnbmFsIGNvbm5lY3RlZCBldmVudCBhZnRlciBhIHNob3J0IGRlbGF5IHRvIGFsbG93IGZvciBqb2luIHJlc3BvbnNlIHRvIGJlIHByb2Nlc3NlZCBvbiByb29tXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxDb25uZWN0ZWQpO1xuICAgICAgICB9LCAxMCk7XG4gICAgICAgIHJldHVybiBqb2luUmVzcG9uc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgICAgaWYgKGUucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uU2VydmVyVW5yZWFjaGFibGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLndhcm4oXCJDb3VsZG4ndCBjb25uZWN0IHRvIHNlcnZlciwgYXR0ZW1wdCBcIi5jb25jYXQodGhpcy5qb2luQXR0ZW1wdHMsIFwiIG9mIFwiKS5jb25jYXQodGhpcy5tYXhKb2luQXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuam9pbkF0dGVtcHRzIDwgdGhpcy5tYXhKb2luQXR0ZW1wdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuam9pbih1cmwsIHRva2VuLCBvcHRzLCBhYm9ydFNpZ25hbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIHRoaXMuY2xvc2luZ0xvY2subG9jaygpO1xuICAgICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuX2lzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5qb2luQXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuQ2xvc2luZyk7XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyKCk7XG4gICAgICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVjb25uZWN0KCk7XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBDbGllbnQoKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVubG9jaygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGNsZWFudXBQZWVyQ29ubmVjdGlvbnMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMucGNNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyID0gdW5kZWZpbmVkO1xuICAgICAgY29uc3QgZGNDbGVhbnVwID0gZGMgPT4ge1xuICAgICAgICBpZiAoIWRjKSByZXR1cm47XG4gICAgICAgIGRjLmNsb3NlKCk7XG4gICAgICAgIGRjLm9uYnVmZmVyZWRhbW91bnRsb3cgPSBudWxsO1xuICAgICAgICBkYy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgZGMub25jbG9zaW5nID0gbnVsbDtcbiAgICAgICAgZGMub25lcnJvciA9IG51bGw7XG4gICAgICAgIGRjLm9ubWVzc2FnZSA9IG51bGw7XG4gICAgICAgIGRjLm9ub3BlbiA9IG51bGw7XG4gICAgICB9O1xuICAgICAgZGNDbGVhbnVwKHRoaXMubG9zc3lEQyk7XG4gICAgICBkY0NsZWFudXAodGhpcy5sb3NzeURDU3ViKTtcbiAgICAgIGRjQ2xlYW51cCh0aGlzLnJlbGlhYmxlREMpO1xuICAgICAgZGNDbGVhbnVwKHRoaXMucmVsaWFibGVEQ1N1Yik7XG4gICAgICB0aGlzLmxvc3N5REMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvc3N5RENTdWIgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlbGlhYmxlREMgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnJlbGlhYmxlRENTdWIgPSB1bmRlZmluZWQ7XG4gICAgfSk7XG4gIH1cbiAgY2xlYW51cENsaWVudCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5jbGllbnQuY2xvc2UoKTtcbiAgICAgIHRoaXMuY2xpZW50LnJlc2V0Q2FsbGJhY2tzKCk7XG4gICAgfSk7XG4gIH1cbiAgYWRkVHJhY2socmVxKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZ1RyYWNrUmVzb2x2ZXJzW3JlcS5jaWRdKSB7XG4gICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ2EgdHJhY2sgd2l0aCB0aGUgc2FtZSBJRCBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgY29uc3QgcHVibGljYXRpb25UaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXEuY2lkXTtcbiAgICAgICAgcmVqZWN0KG5ldyBDb25uZWN0aW9uRXJyb3IoJ3B1YmxpY2F0aW9uIG9mIGxvY2FsIHRyYWNrIHRpbWVkIG91dCwgbm8gcmVzcG9uc2UgZnJvbSBzZXJ2ZXInLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcikpO1xuICAgICAgfSwgMTAwMDApO1xuICAgICAgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVxLmNpZF0gPSB7XG4gICAgICAgIHJlc29sdmU6IGluZm8gPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChwdWJsaWNhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlc29sdmUoaW5mbyk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlamVjdDogKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dChwdWJsaWNhdGlvblRpbWVvdXQpO1xuICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ0NhbmNlbGxlZCBwdWJsaWNhdGlvbiBieSBjYWxsaW5nIHVucHVibGlzaCcpKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuY2xpZW50LnNlbmRBZGRUcmFjayhyZXEpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZW1vdmVzIHNlbmRlciBmcm9tIFBlZXJDb25uZWN0aW9uLCByZXR1cm5pbmcgdHJ1ZSBpZiBpdCB3YXMgcmVtb3ZlZCBzdWNjZXNzZnVsbHlcbiAgICogYW5kIGEgbmVnb3RpYXRpb24gaXMgbmVjZXNzYXJ5XG4gICAqIEBwYXJhbSBzZW5kZXJcbiAgICogQHJldHVybnNcbiAgICovXG4gIHJlbW92ZVRyYWNrKHNlbmRlcikge1xuICAgIGlmIChzZW5kZXIudHJhY2sgJiYgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbc2VuZGVyLnRyYWNrLmlkXSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZWplY3RcbiAgICAgIH0gPSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdO1xuICAgICAgaWYgKHJlamVjdCkge1xuICAgICAgICByZWplY3QoKTtcbiAgICAgIH1cbiAgICAgIGRlbGV0ZSB0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tzZW5kZXIudHJhY2suaWRdO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgdGhpcy5wY01hbmFnZXIucmVtb3ZlVHJhY2soc2VuZGVyKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byByZW1vdmUgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZXJyb3I6IGVcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHVwZGF0ZU11dGVTdGF0dXModHJhY2tTaWQsIG11dGVkKSB7XG4gICAgdGhpcy5jbGllbnQuc2VuZE11dGVUcmFjayh0cmFja1NpZCwgbXV0ZWQpO1xuICB9XG4gIGdldCBkYXRhU3Vic2NyaWJlclJlYWR5U3RhdGUoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJlbGlhYmxlRENTdWIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlO1xuICB9XG4gIGdldENvbm5lY3RlZFNlcnZlckFkZHJlc3MoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldENvbm5lY3RlZEFkZHJlc3MoKTtcbiAgICB9KTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgc2V0UmVnaW9uVXJsUHJvdmlkZXIocHJvdmlkZXIpIHtcbiAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gcHJvdmlkZXI7XG4gIH1cbiAgY29uZmlndXJlKGpvaW5SZXNwb25zZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgLy8gYWxyZWFkeSBjb25maWd1cmVkXG4gICAgICBpZiAodGhpcy5wY01hbmFnZXIgJiYgdGhpcy5wY01hbmFnZXIuY3VycmVudFN0YXRlICE9PSBQQ1RyYW5zcG9ydFN0YXRlLk5FVykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnBhcnRpY2lwYW50U2lkID0gKF9hID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkO1xuICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihqb2luUmVzcG9uc2UpO1xuICAgICAgdGhpcy5wY01hbmFnZXIgPSBuZXcgUENUcmFuc3BvcnRNYW5hZ2VyKHJ0Y0NvbmZpZywgam9pblJlc3BvbnNlLnN1YnNjcmliZXJQcmltYXJ5LCB0aGlzLmxvZ2dlck9wdGlvbnMpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlRyYW5zcG9ydHNDcmVhdGVkLCB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIsIHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIpO1xuICAgICAgdGhpcy5wY01hbmFnZXIub25JY2VDYW5kaWRhdGUgPSAoY2FuZGlkYXRlLCB0YXJnZXQpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuc2VuZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5wY01hbmFnZXIub25QdWJsaXNoZXJPZmZlciA9IG9mZmVyID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnQuc2VuZE9mZmVyKG9mZmVyKTtcbiAgICAgIH07XG4gICAgICB0aGlzLnBjTWFuYWdlci5vbkRhdGFDaGFubmVsID0gdGhpcy5oYW5kbGVEYXRhQ2hhbm5lbDtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uU3RhdGVDaGFuZ2UgPSAoY29ubmVjdGlvblN0YXRlLCBwdWJsaXNoZXJTdGF0ZSwgc3Vic2NyaWJlclN0YXRlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwicHJpbWFyeSBQQyBzdGF0ZSBjaGFuZ2VkIFwiLmNvbmNhdChjb25uZWN0aW9uU3RhdGUpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICBpZiAoWydjbG9zZWQnLCAnZGlzY29ubmVjdGVkJywgJ2ZhaWxlZCddLmluY2x1ZGVzKHB1Ymxpc2hlclN0YXRlKSkge1xuICAgICAgICAgIC8vIHJlc2V0IHB1Ymxpc2hlciBjb25uZWN0aW9uIHByb21pc2VcbiAgICAgICAgICB0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFBDVHJhbnNwb3J0U3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgICAgY29uc3Qgc2hvdWxkRW1pdCA9IHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5OZXc7XG4gICAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICAgICAgaWYgKHNob3VsZEVtaXQpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Db25uZWN0ZWQsIGpvaW5SZXNwb25zZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQpIHtcbiAgICAgICAgICAvLyBvbiBTYWZhcmksIFBlZXJDb25uZWN0aW9uIHdpbGwgc3dpdGNoIHRvICdkaXNjb25uZWN0ZWQnIGR1cmluZyByZW5lZ290aWF0aW9uXG4gICAgICAgICAgaWYgKHRoaXMucGNTdGF0ZSA9PT0gUENTdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucGNTdGF0ZSA9IFBDU3RhdGUuRGlzY29ubmVjdGVkO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdwZWVyY29ubmVjdGlvbiBmYWlsZWQnLCBzdWJzY3JpYmVyU3RhdGUgPT09ICdmYWlsZWQnID8gUmVjb25uZWN0UmVhc29uLlJSX1NVQlNDUklCRVJfRkFJTEVEIDogUmVjb25uZWN0UmVhc29uLlJSX1BVQkxJU0hFUl9GQUlMRUQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkZXRlY3QgY2FzZXMgd2hlcmUgYm90aCBzaWduYWwgY2xpZW50IGFuZCBwZWVyIGNvbm5lY3Rpb24gYXJlIHNldmVyZWQgYW5kIGFzc3VtZSB0aGF0IHVzZXIgaGFzIGxvc3QgbmV0d29yayBjb25uZWN0aW9uXG4gICAgICAgIGNvbnN0IGlzU2lnbmFsU2V2ZXJlZCA9IHRoaXMuY2xpZW50LmlzRGlzY29ubmVjdGVkIHx8IHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSA9PT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLlJFQ09OTkVDVElORztcbiAgICAgICAgY29uc3QgaXNQQ1NldmVyZWQgPSBbUENUcmFuc3BvcnRTdGF0ZS5GQUlMRUQsIFBDVHJhbnNwb3J0U3RhdGUuQ0xPU0lORywgUENUcmFuc3BvcnRTdGF0ZS5DTE9TRURdLmluY2x1ZGVzKGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgIGlmIChpc1NpZ25hbFNldmVyZWQgJiYgaXNQQ1NldmVyZWQgJiYgIXRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50Lk9mZmxpbmUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLm9uVHJhY2sgPSBldiA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5NZWRpYVRyYWNrQWRkZWQsIGV2LnRyYWNrLCBldi5zdHJlYW1zWzBdLCBldi5yZWNlaXZlcik7XG4gICAgICB9O1xuICAgICAgaWYgKCFzdXBwb3J0T3B0aW9uYWxEYXRhY2hhbm5lbCgoX2IgPSBqb2luUmVzcG9uc2Uuc2VydmVySW5mbykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnByb3RvY29sKSkge1xuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCkge1xuICAgIC8vIGNvbmZpZ3VyZSBzaWduYWxpbmcgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25BbnN3ZXIgPSBzZCA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCBzZXJ2ZXIgYW5zd2VyJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIFJUQ1NkcFR5cGU6IHNkLnR5cGVcbiAgICAgIH0pKTtcbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLnNldFB1Ymxpc2hlckFuc3dlcihzZCk7XG4gICAgfSk7XG4gICAgLy8gYWRkIGNhbmRpZGF0ZSBvbiB0cmlja2xlXG4gICAgdGhpcy5jbGllbnQub25Ucmlja2xlID0gKGNhbmRpZGF0ZSwgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9nLmRlYnVnKCdnb3QgSUNFIGNhbmRpZGF0ZSBmcm9tIHBlZXInLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgY2FuZGlkYXRlLFxuICAgICAgICB0YXJnZXRcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMucGNNYW5hZ2VyLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUsIHRhcmdldCk7XG4gICAgfTtcbiAgICAvLyB3aGVuIHNlcnZlciBjcmVhdGVzIGFuIG9mZmVyIGZvciB0aGUgY2xpZW50XG4gICAgdGhpcy5jbGllbnQub25PZmZlciA9IHNkID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgYW5zd2VyID0geWllbGQgdGhpcy5wY01hbmFnZXIuY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlcihzZCk7XG4gICAgICB0aGlzLmNsaWVudC5zZW5kQW5zd2VyKGFuc3dlcik7XG4gICAgfSk7XG4gICAgdGhpcy5jbGllbnQub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcmVzID0+IHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCdyZWNlaXZlZCB0cmFja1B1Ymxpc2hlZFJlc3BvbnNlJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGNpZDogcmVzLmNpZCxcbiAgICAgICAgdHJhY2s6IChfYSA9IHJlcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNpZFxuICAgICAgfSkpO1xuICAgICAgaWYgKCF0aGlzLnBlbmRpbmdUcmFja1Jlc29sdmVyc1tyZXMuY2lkXSkge1xuICAgICAgICB0aGlzLmxvZy5lcnJvcihcIm1pc3NpbmcgdHJhY2sgcmVzb2x2ZXIgZm9yIFwiLmNvbmNhdChyZXMuY2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgY2lkOiByZXMuY2lkXG4gICAgICAgIH0pKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qge1xuICAgICAgICByZXNvbHZlXG4gICAgICB9ID0gdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICBkZWxldGUgdGhpcy5wZW5kaW5nVHJhY2tSZXNvbHZlcnNbcmVzLmNpZF07XG4gICAgICByZXNvbHZlKHJlcy50cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHJlc3BvbnNlID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHJlc3BvbnNlKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uTG9jYWxUcmFja1N1YnNjcmliZWQgPSB0cmFja1NpZCA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrU2lkKTtcbiAgICB9O1xuICAgIHRoaXMuY2xpZW50Lm9uVG9rZW5SZWZyZXNoID0gdG9rZW4gPT4ge1xuICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25SZW1vdGVNdXRlQ2hhbmdlZCA9ICh0cmFja1NpZCwgbXV0ZWQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCB0cmFja1NpZCwgbXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5jbGllbnQub25TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoRW5naW5lRXZlbnQuU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUsIHVwZGF0ZSk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkNsb3NlID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KCdzaWduYWwnLCBSZWNvbm5lY3RSZWFzb24uUlJfU0lHTkFMX0RJU0NPTk5FQ1RFRCk7XG4gICAgfTtcbiAgICB0aGlzLmNsaWVudC5vbkxlYXZlID0gbGVhdmUgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ2NsaWVudCBsZWF2ZSByZXF1ZXN0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHJlYXNvbjogbGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLnJlYXNvblxuICAgICAgfSkpO1xuICAgICAgaWYgKGxlYXZlLnJlZ2lvbnMgJiYgdGhpcy5yZWdpb25VcmxQcm92aWRlcikge1xuICAgICAgICB0aGlzLmxvZy5kZWJ1ZygndXBkYXRpbmcgcmVnaW9ucycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuc2V0U2VydmVyUmVwb3J0ZWRSZWdpb25zKGxlYXZlLnJlZ2lvbnMpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChsZWF2ZS5hY3Rpb24pIHtcbiAgICAgICAgY2FzZSBMZWF2ZVJlcXVlc3RfQWN0aW9uLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgbGVhdmUgPT09IG51bGwgfHwgbGVhdmUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxlYXZlLnJlYXNvbik7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIExlYXZlUmVxdWVzdF9BY3Rpb24uUkVDT05ORUNUOlxuICAgICAgICAgIHRoaXMuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgICAgLy8gcmVjb25uZWN0IGltbWVkaWF0ZWx5IGluc3RlYWQgb2Ygd2FpdGluZyBmb3IgbmV4dCBhdHRlbXB0XG4gICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KGxlYXZlUmVjb25uZWN0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBMZWF2ZVJlcXVlc3RfQWN0aW9uLlJFU1VNRTpcbiAgICAgICAgICAvLyByZWNvbm5lY3QgaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB3YWl0aW5nIGZvciBuZXh0IGF0dGVtcHRcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QobGVhdmVSZWNvbm5lY3QpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgbWFrZVJUQ0NvbmZpZ3VyYXRpb24oc2VydmVyUmVzcG9uc2UpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgcnRjQ29uZmlnID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5ydGNDb25maWcpO1xuICAgIGlmICgoX2EgPSB0aGlzLnNpZ25hbE9wdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lMmVlRW5hYmxlZCkge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ0UyRUUgLSBzZXR0aW5nIHVwIHRyYW5zcG9ydHMgd2l0aCBpbnNlcnRhYmxlIHN0cmVhbXMnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgLy8gIHRoaXMgbWFrZXMgc3VyZSB0aGF0IG5vIGRhdGEgaXMgc2VudCBiZWZvcmUgdGhlIHRyYW5zZm9ybXMgYXJlIHJlYWR5XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBydGNDb25maWcuZW5jb2RlZEluc2VydGFibGVTdHJlYW1zID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gdXBkYXRlIElDRSBzZXJ2ZXJzIGJlZm9yZSBjcmVhdGluZyBQZWVyQ29ubmVjdGlvblxuICAgIGlmIChzZXJ2ZXJSZXNwb25zZS5pY2VTZXJ2ZXJzICYmICFydGNDb25maWcuaWNlU2VydmVycykge1xuICAgICAgY29uc3QgcnRjSWNlU2VydmVycyA9IFtdO1xuICAgICAgc2VydmVyUmVzcG9uc2UuaWNlU2VydmVycy5mb3JFYWNoKGljZVNlcnZlciA9PiB7XG4gICAgICAgIGNvbnN0IHJ0Y0ljZVNlcnZlciA9IHtcbiAgICAgICAgICB1cmxzOiBpY2VTZXJ2ZXIudXJsc1xuICAgICAgICB9O1xuICAgICAgICBpZiAoaWNlU2VydmVyLnVzZXJuYW1lKSBydGNJY2VTZXJ2ZXIudXNlcm5hbWUgPSBpY2VTZXJ2ZXIudXNlcm5hbWU7XG4gICAgICAgIGlmIChpY2VTZXJ2ZXIuY3JlZGVudGlhbCkge1xuICAgICAgICAgIHJ0Y0ljZVNlcnZlci5jcmVkZW50aWFsID0gaWNlU2VydmVyLmNyZWRlbnRpYWw7XG4gICAgICAgIH1cbiAgICAgICAgcnRjSWNlU2VydmVycy5wdXNoKHJ0Y0ljZVNlcnZlcik7XG4gICAgICB9KTtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VTZXJ2ZXJzID0gcnRjSWNlU2VydmVycztcbiAgICB9XG4gICAgaWYgKHNlcnZlclJlc3BvbnNlLmNsaWVudENvbmZpZ3VyYXRpb24gJiYgc2VydmVyUmVzcG9uc2UuY2xpZW50Q29uZmlndXJhdGlvbi5mb3JjZVJlbGF5ID09PSBDbGllbnRDb25maWdTZXR0aW5nLkVOQUJMRUQpIHtcbiAgICAgIHJ0Y0NvbmZpZy5pY2VUcmFuc3BvcnRQb2xpY3kgPSAncmVsYXknO1xuICAgIH1cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcnRjQ29uZmlnLnNkcFNlbWFudGljcyA9ICd1bmlmaWVkLXBsYW4nO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBydGNDb25maWcuY29udGludWFsR2F0aGVyaW5nUG9saWN5ID0gJ2dhdGhlcl9jb250aW51YWxseSc7XG4gICAgcmV0dXJuIHJ0Y0NvbmZpZztcbiAgfVxuICBjcmVhdGVEYXRhQ2hhbm5lbHMoKSB7XG4gICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBjbGVhciBvbGQgZGF0YSBjaGFubmVsIGNhbGxiYWNrcyBpZiByZWNyZWF0ZVxuICAgIGlmICh0aGlzLmxvc3N5REMpIHtcbiAgICAgIHRoaXMubG9zc3lEQy5vbm1lc3NhZ2UgPSBudWxsO1xuICAgICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWxpYWJsZURDKSB7XG4gICAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gbnVsbDtcbiAgICAgIHRoaXMucmVsaWFibGVEQy5vbmVycm9yID0gbnVsbDtcbiAgICB9XG4gICAgLy8gY3JlYXRlIGRhdGEgY2hhbm5lbHNcbiAgICB0aGlzLmxvc3N5REMgPSB0aGlzLnBjTWFuYWdlci5jcmVhdGVQdWJsaXNoZXJEYXRhQ2hhbm5lbChsb3NzeURhdGFDaGFubmVsLCB7XG4gICAgICAvLyB3aWxsIGRyb3Agb2xkZXIgcGFja2V0cyB0aGF0IGFycml2ZVxuICAgICAgb3JkZXJlZDogdHJ1ZSxcbiAgICAgIG1heFJldHJhbnNtaXRzOiAwXG4gICAgfSk7XG4gICAgdGhpcy5yZWxpYWJsZURDID0gdGhpcy5wY01hbmFnZXIuY3JlYXRlUHVibGlzaGVyRGF0YUNoYW5uZWwocmVsaWFibGVEYXRhQ2hhbm5lbCwge1xuICAgICAgb3JkZXJlZDogdHJ1ZVxuICAgIH0pO1xuICAgIC8vIGFsc28gaGFuZGxlIG1lc3NhZ2VzIG92ZXIgdGhlIHB1YiBjaGFubmVsLCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICB0aGlzLmxvc3N5REMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICB0aGlzLnJlbGlhYmxlREMub25tZXNzYWdlID0gdGhpcy5oYW5kbGVEYXRhTWVzc2FnZTtcbiAgICAvLyBoYW5kbGUgZGF0YWNoYW5uZWwgZXJyb3JzXG4gICAgdGhpcy5sb3NzeURDLm9uZXJyb3IgPSB0aGlzLmhhbmRsZURhdGFFcnJvcjtcbiAgICB0aGlzLnJlbGlhYmxlREMub25lcnJvciA9IHRoaXMuaGFuZGxlRGF0YUVycm9yO1xuICAgIC8vIHNldCB1cCBkYyBidWZmZXIgdGhyZXNob2xkLCBzZXQgdG8gNjRrQiAob3RoZXJ3aXNlIDAgYnkgZGVmYXVsdClcbiAgICB0aGlzLmxvc3N5REMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcbiAgICB0aGlzLnJlbGlhYmxlREMuYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQgPSA2NTUzNTtcbiAgICAvLyBoYW5kbGUgYnVmZmVyIGFtb3VudCBsb3cgZXZlbnRzXG4gICAgdGhpcy5sb3NzeURDLm9uYnVmZmVyZWRhbW91bnRsb3cgPSB0aGlzLmhhbmRsZUJ1ZmZlcmVkQW1vdW50TG93O1xuICAgIHRoaXMucmVsaWFibGVEQy5vbmJ1ZmZlcmVkYW1vdW50bG93ID0gdGhpcy5oYW5kbGVCdWZmZXJlZEFtb3VudExvdztcbiAgfVxuICBjcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICAgIHJldHVybiBzZW5kZXI7XG4gICAgICB9XG4gICAgICBpZiAoc3VwcG9ydHNBZGRUcmFjaygpKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ3VzaW5nIGFkZC10cmFjayBmYWxsYmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIGNvbnN0IHNlbmRlciA9IHlpZWxkIHRoaXMuY3JlYXRlUlRDUnRwU2VuZGVyKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgICByZXR1cm4gc2VuZGVyO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ1JlcXVpcmVkIHdlYlJUQyBBUElzIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBkZXZpY2UnKTtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTaW11bGNhc3RTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgLy8gc3RvcmUgUlRDUnRwU2VuZGVyXG4gICAgICBpZiAoc3VwcG9ydHNUcmFuc2NlaXZlcigpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNpbXVsY2FzdFRyYW5zY2VpdmVyU2VuZGVyKHRyYWNrLCBzaW11bGNhc3RUcmFjaywgb3B0cywgZW5jb2RpbmdzKTtcbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0c0FkZFRyYWNrKCkpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VzaW5nIGFkZC10cmFjayBmYWxsYmFjaycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdDYW5ub3Qgc3RyZWFtIG9uIHRoaXMgZGV2aWNlJyk7XG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlVHJhbnNjZWl2ZXJSVENSdHBTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCBzdHJlYW1zID0gW107XG4gICAgICBpZiAodHJhY2subWVkaWFTdHJlYW0pIHtcbiAgICAgICAgc3RyZWFtcy5wdXNoKHRyYWNrLm1lZGlhU3RyZWFtKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRyYWNrLmNvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXJJbml0ID0ge1xuICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgIHN0cmVhbXNcbiAgICAgIH07XG4gICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgIHRyYW5zY2VpdmVySW5pdC5zZW5kRW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgfVxuICAgICAgLy8gYWRkVHJhbnNjZWl2ZXIgZm9yIHJlYWN0LW5hdGl2ZSBpcyBhc3luYy4gd2ViIGlzIHN5bmNocm9ub3VzLCBidXQgYXdhaXQgd29uJ3QgZWZmZWN0IGl0LlxuICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB5aWVsZCB0aGlzLnBjTWFuYWdlci5hZGRQdWJsaXNoZXJUcmFuc2NlaXZlcih0cmFjay5tZWRpYVN0cmVhbVRyYWNrLCB0cmFuc2NlaXZlckluaXQpO1xuICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlcjtcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlcih0cmFjaywgc2ltdWxjYXN0VHJhY2ssIG9wdHMsIGVuY29kaW5ncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB0cmFuc2NlaXZlckluaXQgPSB7XG4gICAgICAgIGRpcmVjdGlvbjogJ3NlbmRvbmx5J1xuICAgICAgfTtcbiAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgdHJhbnNjZWl2ZXJJbml0LnNlbmRFbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICB9XG4gICAgICAvLyBhZGRUcmFuc2NlaXZlciBmb3IgcmVhY3QtbmF0aXZlIGlzIGFzeW5jLiB3ZWIgaXMgc3luY2hyb25vdXMsIGJ1dCBhd2FpdCB3b24ndCBlZmZlY3QgaXQuXG4gICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHlpZWxkIHRoaXMucGNNYW5hZ2VyLmFkZFB1Ymxpc2hlclRyYW5zY2VpdmVyKHNpbXVsY2FzdFRyYWNrLm1lZGlhU3RyZWFtVHJhY2ssIHRyYW5zY2VpdmVySW5pdCk7XG4gICAgICBpZiAoIW9wdHMudmlkZW9Db2RlYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0cmFjay5zZXRTaW11bGNhc3RUcmFja1NlbmRlcihvcHRzLnZpZGVvQ29kZWMsIHRyYW5zY2VpdmVyLnNlbmRlcik7XG4gICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyO1xuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVJUQ1J0cFNlbmRlcih0cmFjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdwdWJsaXNoZXIgaXMgY2xvc2VkJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5wY01hbmFnZXIuYWRkUHVibGlzaGVyVHJhY2sodHJhY2spO1xuICAgIH0pO1xuICB9XG4gIGF0dGVtcHRSZWNvbm5lY3QocmVhc29uKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgaWYgKHRoaXMuX2lzQ2xvc2VkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGd1YXJkIGZvciBhdHRlbXB0aW5nIHJlY29ubmVjdGlvbiBtdWx0aXBsZSB0aW1lcyB3aGlsZSBvbmUgYXR0ZW1wdCBpcyBzdGlsbCBub3QgZmluaXNoZWRcbiAgICAgIGlmICh0aGlzLmF0dGVtcHRpbmdSZWNvbm5lY3QpIHtcbiAgICAgICAgbGl2ZWtpdExvZ2dlci53YXJuKCdhbHJlYWR5IGF0dGVtcHRpbmcgcmVjb25uZWN0LCByZXR1cm5pbmcgZWFybHknLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoKChfYSA9IHRoaXMuY2xpZW50Q29uZmlndXJhdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VtZUNvbm5lY3Rpb24pID09PSBDbGllbnRDb25maWdTZXR0aW5nLkRJU0FCTEVEIHx8XG4gICAgICAvLyBzaWduYWxpbmcgc3RhdGUgY291bGQgY2hhbmdlIHRvIGNsb3NlZCBkdWUgdG8gaGFyZHdhcmUgc2xlZXBcbiAgICAgIC8vIHRob3NlIGNvbm5lY3Rpb25zIGNhbm5vdCBiZSByZXN1bWVkXG4gICAgICAoKF9jID0gKF9iID0gdGhpcy5wY01hbmFnZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jdXJyZW50U3RhdGUpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IFBDVHJhbnNwb3J0U3RhdGUuTkVXKSA9PT0gUENUcmFuc3BvcnRTdGF0ZS5ORVcpIHtcbiAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMuYXR0ZW1wdGluZ1JlY29ubmVjdCA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQpIHtcbiAgICAgICAgICB5aWVsZCB0aGlzLnJlc3RhcnRDb25uZWN0aW9uKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5yZXN1bWVDb25uZWN0aW9uKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhclBlbmRpbmdSZWNvbm5lY3QoKTtcbiAgICAgICAgdGhpcy5mdWxsUmVjb25uZWN0T25OZXh0ID0gZmFsc2U7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgKz0gMTtcbiAgICAgICAgbGV0IHJlY292ZXJhYmxlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3JlY2VpdmVkIHVucmVjb3ZlcmFibGUgZXJyb3InLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICAgIC8vIHVucmVjb3ZlcmFibGVcbiAgICAgICAgICByZWNvdmVyYWJsZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKCEoZSBpbnN0YW5jZW9mIFNpZ25hbFJlY29ubmVjdEVycm9yKSkge1xuICAgICAgICAgIC8vIGNhbm5vdCByZXN1bWVcbiAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZWNvdmVyYWJsZSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgncmVjb25uZWN0JywgUmVjb25uZWN0UmVhc29uLlJSX1VOS05PV04pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nLmluZm8oXCJjb3VsZCBub3QgcmVjb3ZlciBjb25uZWN0aW9uIGFmdGVyIFwiLmNvbmNhdCh0aGlzLnJlY29ubmVjdEF0dGVtcHRzLCBcIiBhdHRlbXB0cywgXCIpLmNvbmNhdChEYXRlLm5vdygpIC0gdGhpcy5yZWNvbm5lY3RTdGFydCwgXCJtcy4gZ2l2aW5nIHVwXCIpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5EaXNjb25uZWN0ZWQpO1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5hdHRlbXB0aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0TmV4dFJldHJ5RGVsYXkoY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5yZWNvbm5lY3RQb2xpY3kubmV4dFJldHJ5RGVsYXlJbk1zKGNvbnRleHQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2VuY291bnRlcmVkIGVycm9yIGluIHJlY29ubmVjdCBwb2xpY3knLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgZXJyb3I6IGVcbiAgICAgIH0pKTtcbiAgICB9XG4gICAgLy8gZXJyb3IgaW4gdXNlciBjb2RlIHdpdGggcHJvdmlkZWQgcmVjb25uZWN0IHBvbGljeSwgc3RvcCByZWNvbm5lY3RpbmdcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXN0YXJ0Q29ubmVjdGlvbihyZWdpb25VcmwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIXRoaXMudXJsIHx8ICF0aGlzLnRva2VuKSB7XG4gICAgICAgICAgLy8gcGVybWFuZW50IGZhaWx1cmUsIGRvbid0IGF0dGVtcHQgcmVjb25uZWN0aW9uXG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxvZy5pbmZvKFwicmVjb25uZWN0aW5nLCBhdHRlbXB0OiBcIi5jb25jYXQodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0aW5nKTtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudC5pc0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnNlbmRMZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMuY2xlYW51cFBlZXJDb25uZWN0aW9ucygpO1xuICAgICAgICB5aWVsZCB0aGlzLmNsZWFudXBDbGllbnQoKTtcbiAgICAgICAgbGV0IGpvaW5SZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpZiAoIXRoaXMuc2lnbmFsT3B0cykge1xuICAgICAgICAgICAgdGhpcy5sb2cud2FybignYXR0ZW1wdGVkIGNvbm5lY3Rpb24gcmVzdGFydCwgd2l0aG91dCBzaWduYWwgb3B0aW9ucyBwcmVzZW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBpbiBjYXNlIGEgcmVnaW9uVXJsIGlzIHBhc3NlZCwgdGhlIHJlZ2lvbiBVUkwgdGFrZXMgcHJlY2VkZW5jZVxuICAgICAgICAgIGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuam9pbihyZWdpb25VcmwgIT09IG51bGwgJiYgcmVnaW9uVXJsICE9PSB2b2lkIDAgPyByZWdpb25VcmwgOiB0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5zaWduYWxPcHRzKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGlmIChlIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGUucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHRva2VuIG1pZ2h0IGJlIGV4cGlyZWQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgbmV3IFNpZ25hbFJlY29ubmVjdEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkRmFpbE5leHQpIHtcbiAgICAgICAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gZmFsc2U7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xpZW50LnNldFJlY29ubmVjdGVkKCk7XG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIGpvaW5SZXNwb25zZSk7XG4gICAgICAgIHlpZWxkIHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcbiAgICAgICAgLy8gcmUtY2hlY2sgc2lnbmFsIGNvbm5lY3Rpb24gc3RhdGUgYmVmb3JlIHNldHRpbmcgZW5naW5lIGFzIHJlc3VtZWRcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZXNldEF0dGVtcHRzKCk7XG4gICAgICAgIC8vIHJlY29ubmVjdCBzdWNjZXNzXG4gICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN0YXJ0ZWQpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgbmV4dFJlZ2lvblVybCA9IHlpZWxkIChfYiA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICBpZiAobmV4dFJlZ2lvblVybCkge1xuICAgICAgICAgIHlpZWxkIHRoaXMucmVzdGFydENvbm5lY3Rpb24obmV4dFJlZ2lvblVybCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIG5vIG1vcmUgcmVnaW9ucyB0byB0cnkgKG9yIHdlJ3JlIG5vdCBvbiBjbG91ZClcbiAgICAgICAgICAoX2MgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzZXRBdHRlbXB0cygpO1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcmVzdW1lQ29ubmVjdGlvbihyZWFzb24pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgaWYgKCF0aGlzLnVybCB8fCAhdGhpcy50b2tlbikge1xuICAgICAgICAvLyBwZXJtYW5lbnQgZmFpbHVyZSwgZG9uJ3QgYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2NvdWxkIG5vdCByZWNvbm5lY3QsIHVybCBvciB0b2tlbiBub3Qgc2F2ZWQnKTtcbiAgICAgIH1cbiAgICAgIC8vIHRyaWdnZXIgcHVibGlzaGVyIHJlY29ubmVjdFxuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgncHVibGlzaGVyIGFuZCBzdWJzY3JpYmVyIGNvbm5lY3Rpb25zIHVuc2V0Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5pbmZvKFwicmVzdW1pbmcgc2lnbmFsIGNvbm5lY3Rpb24sIGF0dGVtcHQgXCIuY29uY2F0KHRoaXMucmVjb25uZWN0QXR0ZW1wdHMpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5lbWl0KEVuZ2luZUV2ZW50LlJlc3VtaW5nKTtcbiAgICAgIGxldCByZXM7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLnNldHVwU2lnbmFsQ2xpZW50Q2FsbGJhY2tzKCk7XG4gICAgICAgIHJlcyA9IHlpZWxkIHRoaXMuY2xpZW50LnJlY29ubmVjdCh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5wYXJ0aWNpcGFudFNpZCwgcmVhc29uKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZXJyb3IubWVzc2FnZSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICBlcnJvclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IgJiYgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uTm90QWxsb3dlZCkge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjb3VsZCBub3QgcmVjb25uZWN0LCB0b2tlbiBtaWdodCBiZSBleHBpcmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yICYmIGVycm9yLnJlYXNvbiA9PT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkxlYXZlUmVxdWVzdCkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkKTtcbiAgICAgIGlmIChyZXMpIHtcbiAgICAgICAgY29uc3QgcnRjQ29uZmlnID0gdGhpcy5tYWtlUlRDQ29uZmlndXJhdGlvbihyZXMpO1xuICAgICAgICB0aGlzLnBjTWFuYWdlci51cGRhdGVDb25maWd1cmF0aW9uKHJ0Y0NvbmZpZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdEaWQgbm90IHJlY2VpdmUgcmVjb25uZWN0IHJlc3BvbnNlJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNob3VsZEZhaWxOZXh0KSB7XG4gICAgICAgIHRoaXMuc2hvdWxkRmFpbE5leHQgPSBmYWxzZTtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzaW11bGF0ZWQgZmFpbHVyZScpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIudHJpZ2dlckljZVJlc3RhcnQoKTtcbiAgICAgIHlpZWxkIHRoaXMud2FpdEZvclBDUmVjb25uZWN0ZWQoKTtcbiAgICAgIC8vIHJlLWNoZWNrIHNpZ25hbCBjb25uZWN0aW9uIHN0YXRlIGJlZm9yZSBzZXR0aW5nIGVuZ2luZSBhcyByZXN1bWVkXG4gICAgICBpZiAodGhpcy5jbGllbnQuY3VycmVudFN0YXRlICE9PSBTaWduYWxDb25uZWN0aW9uU3RhdGUuQ09OTkVDVEVEKSB7XG4gICAgICAgIHRocm93IG5ldyBTaWduYWxSZWNvbm5lY3RFcnJvcignU2lnbmFsIGNvbm5lY3Rpb24gZ290IHNldmVyZWQgZHVyaW5nIHJlY29ubmVjdCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5jbGllbnQuc2V0UmVjb25uZWN0ZWQoKTtcbiAgICAgIC8vIHJlY3JlYXRlIHB1Ymxpc2ggZGF0YWNoYW5uZWwgaWYgaXQncyBpZCBpcyBudWxsXG4gICAgICAvLyAoZm9yIHNhZmFyaSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTg0Njg4KVxuICAgICAgaWYgKCgoX2EgPSB0aGlzLnJlbGlhYmxlREMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nICYmIHRoaXMucmVsaWFibGVEQy5pZCA9PT0gbnVsbCkge1xuICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgfVxuICAgICAgLy8gcmVzdW1lIHN1Y2Nlc3NcbiAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SZXN1bWVkKTtcbiAgICB9KTtcbiAgfVxuICB3YWl0Rm9yUENJbml0aWFsQ29ubmVjdGlvbih0aW1lb3V0LCBhYm9ydENvbnRyb2xsZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbihhYm9ydENvbnRyb2xsZXIsIHRpbWVvdXQpO1xuICAgIH0pO1xuICB9XG4gIHdhaXRGb3JQQ1JlY29ubmVjdGVkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLnBjU3RhdGUgPSBQQ1N0YXRlLlJlY29ubmVjdGluZztcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd3YWl0aW5nIGZvciBwZWVyIGNvbm5lY3Rpb24gdG8gcmVjb25uZWN0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHNsZWVwKG1pblJlY29ubmVjdFdhaXQpOyAvLyBGSVhNRSBzZXRUaW1lb3V0IGFnYWluIG5vdCBpZGVhbCBmb3IgYSBjb25uZWN0aW9uIGNyaXRpY2FsIHBhdGhcbiAgICAgICAgaWYgKCF0aGlzLnBjTWFuYWdlcikge1xuICAgICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHRoaXMucGNNYW5hZ2VyLmVuc3VyZVBDVHJhbnNwb3J0Q29ubmVjdGlvbih1bmRlZmluZWQsIHRoaXMucGVlckNvbm5lY3Rpb25UaW1lb3V0KTtcbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5Db25uZWN0ZWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIFRPRE8gZG8gd2UgbmVlZCBhIGBmYWlsZWRgIHN0YXRlIGhlcmUgZm9yIHRoZSBQQz9cbiAgICAgICAgdGhpcy5wY1N0YXRlID0gUENTdGF0ZS5EaXNjb25uZWN0ZWQ7XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFBDIGNvbm5lY3Rpb24sIFwiLmNvbmNhdChlLm1lc3NhZ2UpLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBwdWJsaXNoUnBjUmVzcG9uc2UoZGVzdGluYXRpb25JZGVudGl0eSwgcmVxdWVzdElkLCBwYXlsb2FkLCBlcnJvcikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllczogW2Rlc3RpbmF0aW9uSWRlbnRpdHldLFxuICAgICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3JwY1Jlc3BvbnNlJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY1Jlc3BvbnNlKHtcbiAgICAgICAgICAgIHJlcXVlc3RJZCxcbiAgICAgICAgICAgIHZhbHVlOiBlcnJvciA/IHtcbiAgICAgICAgICAgICAgY2FzZTogJ2Vycm9yJyxcbiAgICAgICAgICAgICAgdmFsdWU6IGVycm9yLnRvUHJvdG8oKVxuICAgICAgICAgICAgfSA6IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3BheWxvYWQnLFxuICAgICAgICAgICAgICB2YWx1ZTogcGF5bG9hZCAhPT0gbnVsbCAmJiBwYXlsb2FkICE9PSB2b2lkIDAgPyBwYXlsb2FkIDogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgcHVibGlzaFJwY0FjayhkZXN0aW5hdGlvbklkZW50aXR5LCByZXF1ZXN0SWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdycGNBY2snLFxuICAgICAgICAgIHZhbHVlOiBuZXcgUnBjQWNrKHtcbiAgICAgICAgICAgIHJlcXVlc3RJZFxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgfSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHNlbmREYXRhUGFja2V0KHBhY2tldCwga2luZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBtc2cgPSBwYWNrZXQudG9CaW5hcnkoKTtcbiAgICAgIC8vIG1ha2Ugc3VyZSB3ZSBkbyBoYXZlIGEgZGF0YSBjb25uZWN0aW9uXG4gICAgICB5aWVsZCB0aGlzLmVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZChraW5kKTtcbiAgICAgIGNvbnN0IGRjID0gdGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoa2luZCk7XG4gICAgICBpZiAoZGMpIHtcbiAgICAgICAgZGMuc2VuZChtc2cpO1xuICAgICAgfVxuICAgICAgdGhpcy51cGRhdGVBbmRFbWl0RENCdWZmZXJTdGF0dXMoa2luZCk7XG4gICAgfSk7XG4gIH1cbiAgd2FpdEZvckJ1ZmZlclN0YXR1c0xvdyhraW5kKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLmlzQnVmZmVyU3RhdHVzTG93KGtpbmQpKSB7XG4gICAgICAgIHJlc29sdmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2luZyA9ICgpID0+IHJlamVjdCgnRW5naW5lIGNsb3NlZCcpO1xuICAgICAgICB0aGlzLm9uY2UoRW5naW5lRXZlbnQuQ2xvc2luZywgb25DbG9zaW5nKTtcbiAgICAgICAgd2hpbGUgKCF0aGlzLmRjQnVmZmVyU3RhdHVzLmdldChraW5kKSkge1xuICAgICAgICAgIHlpZWxkIHNsZWVwKDEwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBvbkNsb3NpbmcpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9XG4gICAgfSkpO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZF8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGtpbmQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgbGV0IHN1YnNjcmliZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuc3Vic2NyaWJlclByaW1hcnk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBpZiAoIV90aGlzMi5wY01hbmFnZXIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVW5leHBlY3RlZENvbm5lY3Rpb25TdGF0ZSgnUEMgbWFuYWdlciBpcyBjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBzdWJzY3JpYmVyID8gX3RoaXMyLnBjTWFuYWdlci5zdWJzY3JpYmVyIDogX3RoaXMyLnBjTWFuYWdlci5wdWJsaXNoZXI7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydE5hbWUgPSBzdWJzY3JpYmVyID8gJ1N1YnNjcmliZXInIDogJ1B1Ymxpc2hlcic7XG4gICAgICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIlwiLmNvbmNhdCh0cmFuc3BvcnROYW1lLCBcIiBjb25uZWN0aW9uIG5vdCBzZXRcIiksIENvbm5lY3Rpb25FcnJvclJlYXNvbi5JbnRlcm5hbEVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgbmVlZE5lZ290aWF0aW9uID0gZmFsc2U7XG4gICAgICAgIGlmICghc3Vic2NyaWJlciAmJiAhX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKSkge1xuICAgICAgICAgIF90aGlzMi5jcmVhdGVEYXRhQ2hhbm5lbHMoKTtcbiAgICAgICAgICBuZWVkTmVnb3RpYXRpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghbmVlZE5lZ290aWF0aW9uICYmICFzdWJzY3JpYmVyICYmICFfdGhpczIucGNNYW5hZ2VyLnB1Ymxpc2hlci5pc0lDRUNvbm5lY3RlZCAmJiBfdGhpczIucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRJQ0VDb25uZWN0aW9uU3RhdGUoKSAhPT0gJ2NoZWNraW5nJykge1xuICAgICAgICAgIG5lZWROZWdvdGlhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWROZWdvdGlhdGlvbikge1xuICAgICAgICAgIC8vIHN0YXJ0IG5lZ290aWF0aW9uXG4gICAgICAgICAgX3RoaXMyLm5lZ290aWF0ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldENoYW5uZWwgPSBfdGhpczIuZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1YnNjcmliZXIpO1xuICAgICAgICBpZiAoKHRhcmdldENoYW5uZWwgPT09IG51bGwgfHwgdGFyZ2V0Q2hhbm5lbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGFyZ2V0Q2hhbm5lbC5yZWFkeVN0YXRlKSA9PT0gJ29wZW4nKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHdhaXQgdW50aWwgSUNFIGNvbm5lY3RlZFxuICAgICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKS5nZXRUaW1lKCkgKyBfdGhpczIucGVlckNvbm5lY3Rpb25UaW1lb3V0O1xuICAgICAgICB3aGlsZSAobmV3IERhdGUoKS5nZXRUaW1lKCkgPCBlbmRUaW1lKSB7XG4gICAgICAgICAgaWYgKHRyYW5zcG9ydC5pc0lDRUNvbm5lY3RlZCAmJiAoKF9hID0gX3RoaXMyLmRhdGFDaGFubmVsRm9yS2luZChraW5kLCBzdWJzY3JpYmVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlYWR5U3RhdGUpID09PSAnb3BlbicpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBDb25uZWN0aW9uRXJyb3IoXCJjb3VsZCBub3QgZXN0YWJsaXNoIFwiLmNvbmNhdCh0cmFuc3BvcnROYW1lLCBcIiBjb25uZWN0aW9uLCBzdGF0ZTogXCIpLmNvbmNhdCh0cmFuc3BvcnQuZ2V0SUNFQ29ubmVjdGlvblN0YXRlKCkpLCBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvcik7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgZW5zdXJlUHVibGlzaGVyQ29ubmVjdGVkKGtpbmQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLnB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlKSB7XG4gICAgICAgIHRoaXMucHVibGlzaGVyQ29ubmVjdGlvblByb21pc2UgPSB0aGlzLmVuc3VyZURhdGFUcmFuc3BvcnRDb25uZWN0ZWQoa2luZCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5wdWJsaXNoZXJDb25uZWN0aW9uUHJvbWlzZTtcbiAgICB9KTtcbiAgfVxuICAvKiBAaW50ZXJuYWwgKi9cbiAgdmVyaWZ5VHJhbnNwb3J0KCkge1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcHJpbWFyeSBjb25uZWN0aW9uXG4gICAgaWYgKHRoaXMucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSAhPT0gUENUcmFuc3BvcnRTdGF0ZS5DT05ORUNURUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gZW5zdXJlIHNpZ25hbCBpcyBjb25uZWN0ZWRcbiAgICBpZiAoIXRoaXMuY2xpZW50LndzIHx8IHRoaXMuY2xpZW50LndzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBuZWdvdGlhdGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIC8vIG9ic2VydmUgc2lnbmFsIHN0YXRlXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBpZiAoIXRoaXMucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBOZWdvdGlhdGlvbkVycm9yKCdQQyBtYW5hZ2VyIGlzIGNsb3NlZCcpKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wY01hbmFnZXIucmVxdWlyZVB1Ymxpc2hlcigpO1xuICAgICAgICAvLyBkb24ndCBuZWdvdGlhdGUgd2l0aG91dCBhbnkgdHJhbnNjZWl2ZXJzIG9yIGRhdGEgY2hhbm5lbCwgaXQgd2lsbCBnZW5lcmF0ZSBzZHAgd2l0aG91dCBpY2UgZnJhZyB0aGVuIG5lZ290aWF0ZSBmYWlsZWRcbiAgICAgICAgaWYgKHRoaXMucGNNYW5hZ2VyLnB1Ymxpc2hlci5nZXRUcmFuc2NlaXZlcnMoKS5sZW5ndGggPT0gMCAmJiAhdGhpcy5sb3NzeURDICYmICF0aGlzLnJlbGlhYmxlREMpIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZURhdGFDaGFubmVscygpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgICAgY29uc3QgaGFuZGxlQ2xvc2VkID0gKCkgPT4ge1xuICAgICAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdlbmdpbmUgZGlzY29ubmVjdGVkIHdoaWxlIG5lZ290aWF0aW9uIHdhcyBvbmdvaW5nJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgICAgIHJlamVjdCgnY2Fubm90IG5lZ290aWF0ZSBvbiBjbG9zZWQgZW5naW5lJyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuICAgICAgICB0aGlzLnBjTWFuYWdlci5wdWJsaXNoZXIub25jZShQQ0V2ZW50cy5SVFBWaWRlb1BheWxvYWRUeXBlcywgcnRwVHlwZXMgPT4ge1xuICAgICAgICAgIGNvbnN0IHJ0cE1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICBydHBUeXBlcy5mb3JFYWNoKHJ0cCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb2RlYyA9IHJ0cC5jb2RlYy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgaWYgKGlzVmlkZW9Db2RlYyhjb2RlYykpIHtcbiAgICAgICAgICAgICAgcnRwTWFwLnNldChydHAucGF5bG9hZCwgY29kZWMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZW1pdChFbmdpbmVFdmVudC5SVFBWaWRlb01hcFVwZGF0ZSwgcnRwTWFwKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgeWllbGQgdGhpcy5wY01hbmFnZXIubmVnb3RpYXRlKGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBOZWdvdGlhdGlvbkVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLmZ1bGxSZWNvbm5lY3RPbk5leHQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QoJ25lZ290aWF0aW9uJywgUmVjb25uZWN0UmVhc29uLlJSX1VOS05PV04pO1xuICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICB0aGlzLm9mZihFbmdpbmVFdmVudC5DbG9zaW5nLCBoYW5kbGVDbG9zZWQpO1xuICAgICAgICB9XG4gICAgICB9KSk7XG4gICAgfSk7XG4gIH1cbiAgZGF0YUNoYW5uZWxGb3JLaW5kKGtpbmQsIHN1Yikge1xuICAgIGlmICghc3ViKSB7XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLkxPU1NZKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxvc3N5REM7XG4gICAgICB9XG4gICAgICBpZiAoa2luZCA9PT0gRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbGlhYmxlREM7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuTE9TU1kpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9zc3lEQ1N1YjtcbiAgICAgIH1cbiAgICAgIGlmIChraW5kID09PSBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVsaWFibGVEQ1N1YjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZW5kU3luY1N0YXRlKHJlbW90ZVRyYWNrcywgbG9jYWxUcmFja3MpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghdGhpcy5wY01hbmFnZXIpIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N5bmMgc3RhdGUgY2Fubm90IGJlIHNlbnQgd2l0aG91dCBwZWVyIGNvbm5lY3Rpb24gc2V0dXAnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwcmV2aW91c0Fuc3dlciA9IHRoaXMucGNNYW5hZ2VyLnN1YnNjcmliZXIuZ2V0TG9jYWxEZXNjcmlwdGlvbigpO1xuICAgIGNvbnN0IHByZXZpb3VzT2ZmZXIgPSB0aGlzLnBjTWFuYWdlci5zdWJzY3JpYmVyLmdldFJlbW90ZURlc2NyaXB0aW9uKCk7XG4gICAgLyogMS4gYXV0b3N1YnNjcmliZSBvbiwgc28gc3Vic2NyaWJlZCB0cmFja3MgPSBhbGwgdHJhY2tzIC0gdW5zdWIgdHJhY2tzLFxuICAgICAgICAgIGluIHRoaXMgY2FzZSwgd2Ugc2VuZCB1bnN1YiB0cmFja3MsIHNvIHNlcnZlciBhZGQgYWxsIHRyYWNrcyB0byB0aGlzXG4gICAgICAgICAgc3Vic2NyaWJlIHBjIGFuZCB1bnN1YiBzcGVjaWFsIHRyYWNrcyBmcm9tIGl0LlxuICAgICAgIDIuIGF1dG9zdWJzY3JpYmUgb2ZmLCB3ZSBzZW5kIHN1YnNjcmliZWQgdHJhY2tzLlxuICAgICovXG4gICAgY29uc3QgYXV0b1N1YnNjcmliZSA9IChfYiA9IChfYSA9IHRoaXMuc2lnbmFsT3B0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9TdWJzY3JpYmUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWU7XG4gICAgY29uc3QgdHJhY2tTaWRzID0gbmV3IEFycmF5KCk7XG4gICAgY29uc3QgdHJhY2tTaWRzRGlzYWJsZWQgPSBuZXcgQXJyYXkoKTtcbiAgICByZW1vdGVUcmFja3MuZm9yRWFjaCh0cmFjayA9PiB7XG4gICAgICBpZiAodHJhY2suaXNEZXNpcmVkICE9PSBhdXRvU3Vic2NyaWJlKSB7XG4gICAgICAgIHRyYWNrU2lkcy5wdXNoKHRyYWNrLnRyYWNrU2lkKTtcbiAgICAgIH1cbiAgICAgIGlmICghdHJhY2suaXNFbmFibGVkKSB7XG4gICAgICAgIHRyYWNrU2lkc0Rpc2FibGVkLnB1c2godHJhY2sudHJhY2tTaWQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuY2xpZW50LnNlbmRTeW5jU3RhdGUobmV3IFN5bmNTdGF0ZSh7XG4gICAgICBhbnN3ZXI6IHByZXZpb3VzQW5zd2VyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHNkcDogcHJldmlvdXNBbnN3ZXIuc2RwLFxuICAgICAgICB0eXBlOiBwcmV2aW91c0Fuc3dlci50eXBlXG4gICAgICB9KSA6IHVuZGVmaW5lZCxcbiAgICAgIG9mZmVyOiBwcmV2aW91c09mZmVyID8gdG9Qcm90b1Nlc3Npb25EZXNjcmlwdGlvbih7XG4gICAgICAgIHNkcDogcHJldmlvdXNPZmZlci5zZHAsXG4gICAgICAgIHR5cGU6IHByZXZpb3VzT2ZmZXIudHlwZVxuICAgICAgfSkgOiB1bmRlZmluZWQsXG4gICAgICBzdWJzY3JpcHRpb246IG5ldyBVcGRhdGVTdWJzY3JpcHRpb24oe1xuICAgICAgICB0cmFja1NpZHMsXG4gICAgICAgIHN1YnNjcmliZTogIWF1dG9TdWJzY3JpYmUsXG4gICAgICAgIHBhcnRpY2lwYW50VHJhY2tzOiBbXVxuICAgICAgfSksXG4gICAgICBwdWJsaXNoVHJhY2tzOiBnZXRUcmFja1B1YmxpY2F0aW9uSW5mbyhsb2NhbFRyYWNrcyksXG4gICAgICBkYXRhQ2hhbm5lbHM6IHRoaXMuZGF0YUNoYW5uZWxzSW5mbygpLFxuICAgICAgdHJhY2tTaWRzRGlzYWJsZWRcbiAgICB9KSk7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIGZhaWxOZXh0KCkge1xuICAgIC8vIGRlYnVnZ2luZyBtZXRob2QgdG8gZmFpbCB0aGUgbmV4dCByZWNvbm5lY3QvcmVzdW1lIGF0dGVtcHRcbiAgICB0aGlzLnNob3VsZEZhaWxOZXh0ID0gdHJ1ZTtcbiAgfVxuICBkYXRhQ2hhbm5lbHNJbmZvKCkge1xuICAgIGNvbnN0IGluZm9zID0gW107XG4gICAgY29uc3QgZ2V0SW5mbyA9IChkYywgdGFyZ2V0KSA9PiB7XG4gICAgICBpZiAoKGRjID09PSBudWxsIHx8IGRjID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYy5pZCkgIT09IHVuZGVmaW5lZCAmJiBkYy5pZCAhPT0gbnVsbCkge1xuICAgICAgICBpbmZvcy5wdXNoKG5ldyBEYXRhQ2hhbm5lbEluZm8oe1xuICAgICAgICAgIGxhYmVsOiBkYy5sYWJlbCxcbiAgICAgICAgICBpZDogZGMuaWQsXG4gICAgICAgICAgdGFyZ2V0XG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGdldEluZm8odGhpcy5kYXRhQ2hhbm5lbEZvcktpbmQoRGF0YVBhY2tldF9LaW5kLkxPU1NZKSwgU2lnbmFsVGFyZ2V0LlBVQkxJU0hFUik7XG4gICAgZ2V0SW5mbyh0aGlzLmRhdGFDaGFubmVsRm9yS2luZChEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpLCBTaWduYWxUYXJnZXQuUFVCTElTSEVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5MT1NTWSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICBnZXRJbmZvKHRoaXMuZGF0YUNoYW5uZWxGb3JLaW5kKERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSwgdHJ1ZSksIFNpZ25hbFRhcmdldC5TVUJTQ1JJQkVSKTtcbiAgICByZXR1cm4gaW5mb3M7XG4gIH1cbiAgY2xlYXJSZWNvbm5lY3RUaW1lb3V0KCkge1xuICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgIENyaXRpY2FsVGltZXJzLmNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBjbGVhclBlbmRpbmdSZWNvbm5lY3QoKSB7XG4gICAgdGhpcy5jbGVhclJlY29ubmVjdFRpbWVvdXQoKTtcbiAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgfVxuICByZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cbiAgZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyKCkge1xuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignb25saW5lJywgdGhpcy5oYW5kbGVCcm93c2VyT25MaW5lKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIFNpZ25hbFJlY29ubmVjdEVycm9yIGV4dGVuZHMgRXJyb3Ige31cbmZ1bmN0aW9uIHN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsKHByb3RvY29sKSB7XG4gIHJldHVybiBwcm90b2NvbCAhPT0gdW5kZWZpbmVkICYmIHByb3RvY29sID4gMTM7XG59XG5mdW5jdGlvbiBhcHBseVVzZXJEYXRhQ29tcGF0KG5ld09iaiwgb2xkT2JqKSB7XG4gIGNvbnN0IHBhcnRpY2lwYW50SWRlbnRpdHkgPSBuZXdPYmoucGFydGljaXBhbnRJZGVudGl0eSA/IG5ld09iai5wYXJ0aWNpcGFudElkZW50aXR5IDogb2xkT2JqLnBhcnRpY2lwYW50SWRlbnRpdHk7XG4gIG5ld09iai5wYXJ0aWNpcGFudElkZW50aXR5ID0gcGFydGljaXBhbnRJZGVudGl0eTtcbiAgb2xkT2JqLnBhcnRpY2lwYW50SWRlbnRpdHkgPSBwYXJ0aWNpcGFudElkZW50aXR5O1xuICBjb25zdCBkZXN0aW5hdGlvbklkZW50aXRpZXMgPSBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzLmxlbmd0aCAhPT0gMCA/IG5ld09iai5kZXN0aW5hdGlvbklkZW50aXRpZXMgOiBvbGRPYmouZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICBuZXdPYmouZGVzdGluYXRpb25JZGVudGl0aWVzID0gZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICBvbGRPYmouZGVzdGluYXRpb25JZGVudGl0aWVzID0gZGVzdGluYXRpb25JZGVudGl0aWVzO1xufVxuXG5jbGFzcyBSZWdpb25VcmxQcm92aWRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcbiAgICB0aGlzLmxhc3RVcGRhdGVBdCA9IDA7XG4gICAgdGhpcy5zZXR0aW5nc0NhY2hlVGltZSA9IDMwMDA7XG4gICAgdGhpcy5hdHRlbXB0ZWRSZWdpb25zID0gW107XG4gICAgdGhpcy5zZXJ2ZXJVcmwgPSBuZXcgVVJMKHVybCk7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIHVwZGF0ZVRva2VuKHRva2VuKSB7XG4gICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICB9XG4gIGlzQ2xvdWQoKSB7XG4gICAgcmV0dXJuIGlzQ2xvdWQodGhpcy5zZXJ2ZXJVcmwpO1xuICB9XG4gIGdldFNlcnZlclVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5zZXJ2ZXJVcmw7XG4gIH1cbiAgZ2V0TmV4dEJlc3RSZWdpb25VcmwoYWJvcnRTaWduYWwpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKCF0aGlzLmlzQ2xvdWQoKSkge1xuICAgICAgICB0aHJvdyBFcnJvcigncmVnaW9uIGF2YWlsYWJpbGl0eSBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgTGl2ZUtpdCBDbG91ZCBkb21haW5zJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVnaW9uU2V0dGluZ3MgfHwgRGF0ZS5ub3coKSAtIHRoaXMubGFzdFVwZGF0ZUF0ID4gdGhpcy5zZXR0aW5nc0NhY2hlVGltZSkge1xuICAgICAgICB0aGlzLnJlZ2lvblNldHRpbmdzID0geWllbGQgdGhpcy5mZXRjaFJlZ2lvblNldHRpbmdzKGFib3J0U2lnbmFsKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2lvbnNMZWZ0ID0gdGhpcy5yZWdpb25TZXR0aW5ncy5yZWdpb25zLmZpbHRlcihyZWdpb24gPT4gIXRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5maW5kKGF0dGVtcHRlZCA9PiBhdHRlbXB0ZWQudXJsID09PSByZWdpb24udXJsKSk7XG4gICAgICBpZiAocmVnaW9uc0xlZnQubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCBuZXh0UmVnaW9uID0gcmVnaW9uc0xlZnRbMF07XG4gICAgICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucy5wdXNoKG5leHRSZWdpb24pO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmRlYnVnKFwibmV4dCByZWdpb246IFwiLmNvbmNhdChuZXh0UmVnaW9uLnJlZ2lvbikpO1xuICAgICAgICByZXR1cm4gbmV4dFJlZ2lvbi51cmw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICByZXNldEF0dGVtcHRzKCkge1xuICAgIHRoaXMuYXR0ZW1wdGVkUmVnaW9ucyA9IFtdO1xuICB9XG4gIC8qIEBpbnRlcm5hbCAqL1xuICBmZXRjaFJlZ2lvblNldHRpbmdzKHNpZ25hbCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlID0geWllbGQgZmV0Y2goXCJcIi5jb25jYXQoZ2V0Q2xvdWRDb25maWdVcmwodGhpcy5zZXJ2ZXJVcmwpLCBcIi9yZWdpb25zXCIpLCB7XG4gICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICBhdXRob3JpemF0aW9uOiBcIkJlYXJlciBcIi5jb25jYXQodGhpcy50b2tlbilcbiAgICAgICAgfSxcbiAgICAgICAgc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlmIChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHJlZ2lvblNldHRpbmdzID0geWllbGQgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5qc29uKCk7XG4gICAgICAgIHRoaXMubGFzdFVwZGF0ZUF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgcmV0dXJuIHJlZ2lvblNldHRpbmdzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIkNvdWxkIG5vdCBmZXRjaCByZWdpb24gc2V0dGluZ3M6IFwiLmNvbmNhdChyZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1c1RleHQpLCByZWdpb25TZXR0aW5nc1Jlc3BvbnNlLnN0YXR1cyA9PT0gNDAxID8gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQgOiBDb25uZWN0aW9uRXJyb3JSZWFzb24uSW50ZXJuYWxFcnJvciwgcmVnaW9uU2V0dGluZ3NSZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyhyZWdpb25zKSB7XG4gICAgdGhpcy5yZWdpb25TZXR0aW5ncyA9IHJlZ2lvbnM7XG4gICAgdGhpcy5sYXN0VXBkYXRlQXQgPSBEYXRlLm5vdygpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRDbG91ZENvbmZpZ1VybChzZXJ2ZXJVcmwpIHtcbiAgcmV0dXJuIFwiXCIuY29uY2F0KHNlcnZlclVybC5wcm90b2NvbC5yZXBsYWNlKCd3cycsICdodHRwJyksIFwiLy9cIikuY29uY2F0KHNlcnZlclVybC5ob3N0LCBcIi9zZXR0aW5nc1wiKTtcbn1cblxuY2xhc3MgQmFzZVN0cmVhbVJlYWRlciB7XG4gIGdldCBpbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl9pbmZvO1xuICB9XG4gIGNvbnN0cnVjdG9yKGluZm8sIHN0cmVhbSwgdG90YWxCeXRlU2l6ZSkge1xuICAgIHRoaXMucmVhZGVyID0gc3RyZWFtO1xuICAgIHRoaXMudG90YWxCeXRlU2l6ZSA9IHRvdGFsQnl0ZVNpemU7XG4gICAgdGhpcy5faW5mbyA9IGluZm87XG4gICAgdGhpcy5ieXRlc1JlY2VpdmVkID0gMDtcbiAgfVxufVxuY2xhc3MgQnl0ZVN0cmVhbVJlYWRlciBleHRlbmRzIEJhc2VTdHJlYW1SZWFkZXIge1xuICBoYW5kbGVDaHVua1JlY2VpdmVkKGNodW5rKSB7XG4gICAgdmFyIF9hO1xuICAgIHRoaXMuYnl0ZXNSZWNlaXZlZCArPSBjaHVuay5jb250ZW50LmJ5dGVMZW5ndGg7XG4gICAgY29uc3QgY3VycmVudFByb2dyZXNzID0gdGhpcy50b3RhbEJ5dGVTaXplID8gdGhpcy5ieXRlc1JlY2VpdmVkIC8gdGhpcy50b3RhbEJ5dGVTaXplIDogdW5kZWZpbmVkO1xuICAgIChfYSA9IHRoaXMub25Qcm9ncmVzcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcywgY3VycmVudFByb2dyZXNzKTtcbiAgfVxuICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgIGNvbnN0IHJlYWRlciA9IHRoaXMucmVhZGVyLmdldFJlYWRlcigpO1xuICAgIHJldHVybiB7XG4gICAgICBuZXh0OiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgZG9uZSxcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IHlpZWxkIHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2h1bmtSZWNlaXZlZCh2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICBkb25lOiBmYWxzZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLmNvbnRlbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yc1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVhZEFsbCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzEsIF9iLCBfYztcbiAgICAgIGxldCBjaHVua3MgPSBuZXcgU2V0KCk7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgKHZhciBfZCA9IHRydWUsIF9lID0gX19hc3luY1ZhbHVlcyh0aGlzKSwgX2Y7IF9mID0geWllbGQgX2UubmV4dCgpLCBfYSA9IF9mLmRvbmUsICFfYTsgX2QgPSB0cnVlKSB7XG4gICAgICAgICAgX2MgPSBfZi52YWx1ZTtcbiAgICAgICAgICBfZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IGNodW5rID0gX2M7XG4gICAgICAgICAgY2h1bmtzLmFkZChjaHVuayk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVfMV8xKSB7XG4gICAgICAgIGVfMSA9IHtcbiAgICAgICAgICBlcnJvcjogZV8xXzFcbiAgICAgICAgfTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgaWYgKCFfZCAmJiAhX2EgJiYgKF9iID0gX2UucmV0dXJuKSkgeWllbGQgX2IuY2FsbChfZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgaWYgKGVfMSkgdGhyb3cgZV8xLmVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gQXJyYXkuZnJvbShjaHVua3MpO1xuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEEgY2xhc3MgdG8gcmVhZCBjaHVua3MgZnJvbSBhIFJlYWRhYmxlU3RyZWFtIGFuZCBwcm92aWRlIHRoZW0gaW4gYSBzdHJ1Y3R1cmVkIGZvcm1hdC5cbiAqL1xuY2xhc3MgVGV4dFN0cmVhbVJlYWRlciBleHRlbmRzIEJhc2VTdHJlYW1SZWFkZXIge1xuICAvKipcbiAgICogQSBUZXh0U3RyZWFtUmVhZGVyIGluc3RhbmNlIGNhbiBiZSB1c2VkIGFzIGFuIEFzeW5jSXRlcmF0b3IgdGhhdCByZXR1cm5zIHRoZSBlbnRpcmUgc3RyaW5nXG4gICAqIHRoYXQgaGFzIGJlZW4gcmVjZWl2ZWQgdXAgdG8gdGhlIGN1cnJlbnQgcG9pbnQgaW4gdGltZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGluZm8sIHN0cmVhbSwgdG90YWxDaHVua0NvdW50KSB7XG4gICAgc3VwZXIoaW5mbywgc3RyZWFtLCB0b3RhbENodW5rQ291bnQpO1xuICAgIHRoaXMucmVjZWl2ZWRDaHVua3MgPSBuZXcgTWFwKCk7XG4gIH1cbiAgaGFuZGxlQ2h1bmtSZWNlaXZlZChjaHVuaykge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBpbmRleCA9IGJpZ0ludFRvTnVtYmVyKGNodW5rLmNodW5rSW5kZXgpO1xuICAgIGNvbnN0IHByZXZpb3VzQ2h1bmtBdEluZGV4ID0gdGhpcy5yZWNlaXZlZENodW5rcy5nZXQoaW5kZXgpO1xuICAgIGlmIChwcmV2aW91c0NodW5rQXRJbmRleCAmJiBwcmV2aW91c0NodW5rQXRJbmRleC52ZXJzaW9uID4gY2h1bmsudmVyc2lvbikge1xuICAgICAgLy8gd2UgaGF2ZSBhIG5ld2VyIHZlcnNpb24gYWxyZWFkeSwgZHJvcHBpbmcgdGhlIG9sZCBvbmVcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWNlaXZlZENodW5rcy5zZXQoaW5kZXgsIGNodW5rKTtcbiAgICB0aGlzLmJ5dGVzUmVjZWl2ZWQgKz0gY2h1bmsuY29udGVudC5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGN1cnJlbnRQcm9ncmVzcyA9IHRoaXMudG90YWxCeXRlU2l6ZSA/IHRoaXMuYnl0ZXNSZWNlaXZlZCAvIHRoaXMudG90YWxCeXRlU2l6ZSA6IHVuZGVmaW5lZDtcbiAgICAoX2EgPSB0aGlzLm9uUHJvZ3Jlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMsIGN1cnJlbnRQcm9ncmVzcyk7XG4gIH1cbiAgLyoqXG4gICAqIEFzeW5jIGl0ZXJhdG9yIGltcGxlbWVudGF0aW9uIHRvIGFsbG93IHVzYWdlIG9mIGBmb3IgYXdhaXQuLi5vZmAgc3ludGF4LlxuICAgKiBZaWVsZHMgc3RydWN0dXJlZCBjaHVua3MgZnJvbSB0aGUgc3RyZWFtLlxuICAgKlxuICAgKi9cbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCByZWFkZXIgPSB0aGlzLnJlYWRlci5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQ6ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICBkb25lLFxuICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICB9ID0geWllbGQgcmVhZGVyLnJlYWQoKTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgZG9uZTogdHJ1ZSxcbiAgICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDaHVua1JlY2VpdmVkKHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICAgICAgICB2YWx1ZTogZGVjb2Rlci5kZWNvZGUodmFsdWUuY29udGVudClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yc1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pLFxuICAgICAgcmV0dXJuKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkb25lOiB0cnVlLFxuICAgICAgICAgICAgdmFsdWU6IHVuZGVmaW5lZFxuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgcmVhZEFsbCgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBlXzIsIF9iLCBfYztcbiAgICAgIGxldCBmaW5hbFN0cmluZyA9ICcnO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm9yICh2YXIgX2QgPSB0cnVlLCBfZSA9IF9fYXN5bmNWYWx1ZXModGhpcyksIF9mOyBfZiA9IHlpZWxkIF9lLm5leHQoKSwgX2EgPSBfZi5kb25lLCAhX2E7IF9kID0gdHJ1ZSkge1xuICAgICAgICAgIF9jID0gX2YudmFsdWU7XG4gICAgICAgICAgX2QgPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCBjaHVuayA9IF9jO1xuICAgICAgICAgIGZpbmFsU3RyaW5nICs9IGNodW5rO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlXzJfMSkge1xuICAgICAgICBlXzIgPSB7XG4gICAgICAgICAgZXJyb3I6IGVfMl8xXG4gICAgICAgIH07XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmICghX2QgJiYgIV9hICYmIChfYiA9IF9lLnJldHVybikpIHlpZWxkIF9iLmNhbGwoX2UpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIGlmIChlXzIpIHRocm93IGVfMi5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZpbmFsU3RyaW5nO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIEJhc2VTdHJlYW1Xcml0ZXIge1xuICBjb25zdHJ1Y3Rvcih3cml0YWJsZVN0cmVhbSwgaW5mbywgb25DbG9zZSkge1xuICAgIHRoaXMud3JpdGFibGVTdHJlYW0gPSB3cml0YWJsZVN0cmVhbTtcbiAgICB0aGlzLmRlZmF1bHRXcml0ZXIgPSB3cml0YWJsZVN0cmVhbS5nZXRXcml0ZXIoKTtcbiAgICB0aGlzLm9uQ2xvc2UgPSBvbkNsb3NlO1xuICAgIHRoaXMuaW5mbyA9IGluZm87XG4gIH1cbiAgd3JpdGUoY2h1bmspIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0V3JpdGVyLndyaXRlKGNodW5rKTtcbiAgfVxuICBjbG9zZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgeWllbGQgdGhpcy5kZWZhdWx0V3JpdGVyLmNsb3NlKCk7XG4gICAgICB0aGlzLmRlZmF1bHRXcml0ZXIucmVsZWFzZUxvY2soKTtcbiAgICAgIChfYSA9IHRoaXMub25DbG9zZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFRleHRTdHJlYW1Xcml0ZXIgZXh0ZW5kcyBCYXNlU3RyZWFtV3JpdGVyIHt9XG5jbGFzcyBCeXRlU3RyZWFtV3JpdGVyIGV4dGVuZHMgQmFzZVN0cmVhbVdyaXRlciB7fVxuXG5jbGFzcyBSZW1vdGVUcmFjayBleHRlbmRzIFRyYWNrIHtcbiAgY29uc3RydWN0b3IobWVkaWFUcmFjaywgc2lkLCBraW5kLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKG1lZGlhVHJhY2ssIGtpbmQsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMuc2lkID0gc2lkO1xuICAgIHRoaXMucmVjZWl2ZXIgPSByZWNlaXZlcjtcbiAgfVxuICBnZXQgaXNMb2NhbCgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRNdXRlZChtdXRlZCkge1xuICAgIGlmICh0aGlzLmlzTXV0ZWQgIT09IG11dGVkKSB7XG4gICAgICB0aGlzLmlzTXV0ZWQgPSBtdXRlZDtcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suZW5hYmxlZCA9ICFtdXRlZDtcbiAgICAgIHRoaXMuZW1pdChtdXRlZCA/IFRyYWNrRXZlbnQuTXV0ZWQgOiBUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldE1lZGlhU3RyZWFtKHN0cmVhbSkge1xuICAgIC8vIHRoaXMgaXMgbmVlZGVkIHRvIGRldGVybWluZSB3aGVuIHRoZSB0cmFjayBpcyBmaW5pc2hlZFxuICAgIHRoaXMubWVkaWFTdHJlYW0gPSBzdHJlYW07XG4gICAgY29uc3Qgb25SZW1vdmVUcmFjayA9IGV2ZW50ID0+IHtcbiAgICAgIGlmIChldmVudC50cmFjayA9PT0gdGhpcy5fbWVkaWFTdHJlYW1UcmFjaykge1xuICAgICAgICBzdHJlYW0ucmVtb3ZlRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgICAgICAgaWYgKHRoaXMucmVjZWl2ZXIgJiYgJ3BsYXlvdXREZWxheUhpbnQnIGluIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgICB0aGlzLnJlY2VpdmVyLnBsYXlvdXREZWxheUhpbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWNlaXZlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5FbmRlZCwgdGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBzdHJlYW0uYWRkRXZlbnRMaXN0ZW5lcigncmVtb3ZldHJhY2snLCBvblJlbW92ZVRyYWNrKTtcbiAgfVxuICBzdGFydCgpIHtcbiAgICB0aGlzLnN0YXJ0TW9uaXRvcigpO1xuICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxuICAgIHN1cGVyLmVuYWJsZSgpO1xuICB9XG4gIHN0b3AoKSB7XG4gICAgdGhpcy5zdG9wTW9uaXRvcigpO1xuICAgIC8vIHVzZSBgZW5hYmxlZGAgb2YgdHJhY2sgdG8gZW5hYmxlIHJlLXVzZSBvZiB0cmFuc2NlaXZlclxuICAgIHN1cGVyLmRpc2FibGUoKTtcbiAgfVxuICAvKipcbiAgICogR2V0cyB0aGUgUlRDU3RhdHNSZXBvcnQgZm9yIHRoZSBSZW1vdGVUcmFjaydzIHVuZGVybHlpbmcgUlRDUnRwUmVjZWl2ZXJcbiAgICogU2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9SVENTdGF0c1JlcG9ydFxuICAgKlxuICAgKiBAcmV0dXJucyBQcm9taXNlPFJUQ1N0YXRzUmVwb3J0PiB8IHVuZGVmaW5lZFxuICAgKi9cbiAgZ2V0UlRDU3RhdHNSZXBvcnQoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghKChfYSA9IHRoaXMucmVjZWl2ZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTdGF0cykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhdHNSZXBvcnQgPSB5aWVsZCB0aGlzLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgICByZXR1cm4gc3RhdHNSZXBvcnQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEFsbG93cyB0byBzZXQgYSBwbGF5b3V0IGRlbGF5IChpbiBzZWNvbmRzKSBmb3IgdGhpcyB0cmFjay5cbiAgICogQSBoaWdoZXIgdmFsdWUgYWxsb3dzIGZvciBtb3JlIGJ1ZmZlcmluZyBvZiB0aGUgdHJhY2sgaW4gdGhlIGJyb3dzZXJcbiAgICogYW5kIHdpbGwgcmVzdWx0IGluIGEgZGVsYXkgb2YgbWVkaWEgYmVpbmcgcGxheWVkIGJhY2sgb2YgYGRlbGF5SW5TZWNvbmRzYFxuICAgKi9cbiAgc2V0UGxheW91dERlbGF5KGRlbGF5SW5TZWNvbmRzKSB7XG4gICAgaWYgKHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIGlmICgncGxheW91dERlbGF5SGludCcgaW4gdGhpcy5yZWNlaXZlcikge1xuICAgICAgICB0aGlzLnJlY2VpdmVyLnBsYXlvdXREZWxheUhpbnQgPSBkZWxheUluU2Vjb25kcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ1BsYXlvdXQgZGVsYXkgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGJyb3dzZXInKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cud2FybignQ2Fubm90IHNldCBwbGF5b3V0IGRlbGF5LCB0cmFjayBhbHJlYWR5IGVuZGVkJyk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHBsYXlvdXQgZGVsYXkgKGluIHNlY29uZHMpIG9mIHRoaXMgdHJhY2suXG4gICAqL1xuICBnZXRQbGF5b3V0RGVsYXkoKSB7XG4gICAgaWYgKHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgIGlmICgncGxheW91dERlbGF5SGludCcgaW4gdGhpcy5yZWNlaXZlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZWNlaXZlci5wbGF5b3V0RGVsYXlIaW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5sb2cud2FybignUGxheW91dCBkZWxheSBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlcicpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdDYW5ub3QgZ2V0IHBsYXlvdXQgZGVsYXksIHRyYWNrIGFscmVhZHkgZW5kZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIHN0YXJ0TW9uaXRvcigpIHtcbiAgICBpZiAoIXRoaXMubW9uaXRvckludGVydmFsKSB7XG4gICAgICB0aGlzLm1vbml0b3JJbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubW9uaXRvclJlY2VpdmVyKCksIG1vbml0b3JGcmVxdWVuY3kpO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNTeW5jaHJvbml6YXRpb25Tb3VyY2VzKCkpIHtcbiAgICAgIHRoaXMucmVnaXN0ZXJUaW1lU3luY1VwZGF0ZSgpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlclRpbWVTeW5jVXBkYXRlKCkge1xuICAgIGNvbnN0IGxvb3AgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICB0aGlzLnRpbWVTeW5jSGFuZGxlID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IGxvb3AoKSk7XG4gICAgICBjb25zdCBzb3VyY2VzID0gKF9hID0gdGhpcy5yZWNlaXZlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN5bmNocm9uaXphdGlvblNvdXJjZXMoKVswXTtcbiAgICAgIGlmIChzb3VyY2VzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgcnRwVGltZXN0YW1wXG4gICAgICAgIH0gPSBzb3VyY2VzO1xuICAgICAgICBpZiAocnRwVGltZXN0YW1wICYmIHRoaXMucnRwVGltZXN0YW1wICE9PSBydHBUaW1lc3RhbXApIHtcbiAgICAgICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5UaW1lU3luY1VwZGF0ZSwge1xuICAgICAgICAgICAgdGltZXN0YW1wLFxuICAgICAgICAgICAgcnRwVGltZXN0YW1wXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5ydHBUaW1lc3RhbXAgPSBydHBUaW1lc3RhbXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIGxvb3AoKTtcbiAgfVxufVxuXG5jbGFzcyBSZW1vdGVBdWRpb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhdWRpb0NvbnRleHQsIGF1ZGlvT3V0cHV0LCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLkF1ZGlvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5tb25pdG9yUmVjZWl2ZXIgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAoIXRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSAwO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuZ2V0UmVjZWl2ZXJTdGF0cygpO1xuICAgICAgaWYgKHN0YXRzICYmIHRoaXMucHJldlN0YXRzICYmIHRoaXMucmVjZWl2ZXIpIHtcbiAgICAgICAgdGhpcy5fY3VycmVudEJpdHJhdGUgPSBjb21wdXRlQml0cmF0ZShzdGF0cywgdGhpcy5wcmV2U3RhdHMpO1xuICAgICAgfVxuICAgICAgdGhpcy5wcmV2U3RhdHMgPSBzdGF0cztcbiAgICB9KTtcbiAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IGF1ZGlvQ29udGV4dDtcbiAgICB0aGlzLndlYkF1ZGlvUGx1Z2luTm9kZXMgPSBbXTtcbiAgICBpZiAoYXVkaW9PdXRwdXQpIHtcbiAgICAgIHRoaXMuc2lua0lkID0gYXVkaW9PdXRwdXQuZGV2aWNlSWQ7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBzZXRzIHRoZSB2b2x1bWUgZm9yIGFsbCBhdHRhY2hlZCBhdWRpbyBlbGVtZW50c1xuICAgKi9cbiAgc2V0Vm9sdW1lKHZvbHVtZSkge1xuICAgIHZhciBfYTtcbiAgICBmb3IgKGNvbnN0IGVsIG9mIHRoaXMuYXR0YWNoZWRFbGVtZW50cykge1xuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nYWluLnNldFRhcmdldEF0VGltZSh2b2x1bWUsIDAsIDAuMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbC52b2x1bWUgPSB2b2x1bWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1JlYWN0TmF0aXZlKCkpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMuX21lZGlhU3RyZWFtVHJhY2suX3NldFZvbHVtZSh2b2x1bWUpO1xuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRWb2x1bWUgPSB2b2x1bWU7XG4gIH1cbiAgLyoqXG4gICAqIGdldHMgdGhlIHZvbHVtZSBvZiBhdHRhY2hlZCBhdWRpbyBlbGVtZW50cyAobG91ZGVzdClcbiAgICovXG4gIGdldFZvbHVtZSgpIHtcbiAgICBpZiAodGhpcy5lbGVtZW50Vm9sdW1lKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50Vm9sdW1lO1xuICAgIH1cbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XG4gICAgICAvLyBSTiB2b2x1bWUgdmFsdWUgZGVmYXVsdHMgdG8gMS4wIGlmIGhhc24ndCBiZWVuIGNoYW5nZWQuXG4gICAgICByZXR1cm4gMS4wO1xuICAgIH1cbiAgICBsZXQgaGlnaGVzdFZvbHVtZSA9IDA7XG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICBpZiAoZWxlbWVudC52b2x1bWUgPiBoaWdoZXN0Vm9sdW1lKSB7XG4gICAgICAgIGhpZ2hlc3RWb2x1bWUgPSBlbGVtZW50LnZvbHVtZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gaGlnaGVzdFZvbHVtZTtcbiAgfVxuICAvKipcbiAgICogY2FsbHMgc2V0U2lua0lkIG9uIGFsbCBhdHRhY2hlZCBlbGVtZW50cywgaWYgc3VwcG9ydGVkXG4gICAqIEBwYXJhbSBkZXZpY2VJZCBhdWRpbyBvdXRwdXQgZGV2aWNlXG4gICAqL1xuICBzZXRTaW5rSWQoZGV2aWNlSWQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5zaW5rSWQgPSBkZXZpY2VJZDtcbiAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5tYXAoZWxtID0+IHtcbiAgICAgICAgaWYgKCFzdXBwb3J0c1NldFNpbmtJZChlbG0pKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgcmV0dXJuIGVsbS5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgfSkpO1xuICAgIH0pO1xuICB9XG4gIGF0dGFjaChlbGVtZW50KSB7XG4gICAgY29uc3QgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24gPSB0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID09PSAwO1xuICAgIGlmICghZWxlbWVudCkge1xuICAgICAgZWxlbWVudCA9IHN1cGVyLmF0dGFjaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXBlci5hdHRhY2goZWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnNpbmtJZCAmJiBzdXBwb3J0c1NldFNpbmtJZChlbGVtZW50KSkge1xuICAgICAgLyogQHRzLWlnbm9yZSAqL1xuICAgICAgZWxlbWVudC5zZXRTaW5rSWQodGhpcy5zaW5rSWQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5hdWRpb0NvbnRleHQgJiYgbmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24pIHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1c2luZyBhdWRpbyBjb250ZXh0IG1hcHBpbmcnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy5jb25uZWN0V2ViQXVkaW8odGhpcy5hdWRpb0NvbnRleHQsIGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC52b2x1bWUgPSAwO1xuICAgICAgZWxlbWVudC5tdXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLmVsZW1lbnRWb2x1bWUpIHtcbiAgICAgIC8vIG1ha2Ugc3VyZSB2b2x1bWUgc2V0dGluZyBpcyBiZWluZyBhcHBsaWVkIHRvIHRoZSBuZXdseSBhdHRhY2hlZCBlbGVtZW50XG4gICAgICB0aGlzLnNldFZvbHVtZSh0aGlzLmVsZW1lbnRWb2x1bWUpO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxuICBkZXRhY2goZWxlbWVudCkge1xuICAgIGxldCBkZXRhY2hlZDtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGRldGFjaGVkID0gc3VwZXIuZGV0YWNoKCk7XG4gICAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZXRhY2hlZCA9IHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICAgIC8vIGlmIHRoZXJlIGFyZSBzdGlsbCBhbnkgYXR0YWNoZWQgZWxlbWVudHMgYWZ0ZXIgZGV0YWNoaW5nLCBjb25uZWN0IHdlYmF1ZGlvIHRvIHRoZSBmaXJzdCBlbGVtZW50IHRoYXQncyBsZWZ0XG4gICAgICAvLyBkaXNjb25uZWN0IHdlYmF1ZGlvIG90aGVyd2lzZVxuICAgICAgaWYgKHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLmF0dGFjaGVkRWxlbWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKHRoaXMuYXVkaW9Db250ZXh0LCB0aGlzLmF0dGFjaGVkRWxlbWVudHNbMF0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRldGFjaGVkO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKi9cbiAgc2V0QXVkaW9Db250ZXh0KGF1ZGlvQ29udGV4dCkge1xuICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gYXVkaW9Db250ZXh0O1xuICAgIGlmIChhdWRpb0NvbnRleHQgJiYgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuY29ubmVjdFdlYkF1ZGlvKGF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKCFhdWRpb0NvbnRleHQpIHtcbiAgICAgIHRoaXMuZGlzY29ubmVjdFdlYkF1ZGlvKCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbFxuICAgKiBAcGFyYW0ge0F1ZGlvTm9kZVtdfSBub2RlcyAtIEFuIGFycmF5IG9mIFdlYkF1ZGlvIG5vZGVzLiBUaGVzZSBub2RlcyBzaG91bGQgbm90IGJlIGNvbm5lY3RlZCB0byBlYWNoIG90aGVyIHdoZW4gcGFzc2VkLCBhcyB0aGUgc2RrIHdpbGwgdGFrZSBjYXJlIG9mIGNvbm5lY3RpbmcgdGhlbSBpbiB0aGUgb3JkZXIgb2YgdGhlIGFycmF5LlxuICAgKi9cbiAgc2V0V2ViQXVkaW9QbHVnaW5zKG5vZGVzKSB7XG4gICAgdGhpcy53ZWJBdWRpb1BsdWdpbk5vZGVzID0gbm9kZXM7XG4gICAgaWYgKHRoaXMuYXR0YWNoZWRFbGVtZW50cy5sZW5ndGggPiAwICYmIHRoaXMuYXVkaW9Db250ZXh0KSB7XG4gICAgICB0aGlzLmNvbm5lY3RXZWJBdWRpbyh0aGlzLmF1ZGlvQ29udGV4dCwgdGhpcy5hdHRhY2hlZEVsZW1lbnRzWzBdKTtcbiAgICB9XG4gIH1cbiAgY29ubmVjdFdlYkF1ZGlvKGNvbnRleHQsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRpc2Nvbm5lY3RXZWJBdWRpbygpO1xuICAgIC8vIEB0cy1pZ25vcmUgYXR0YWNoZWQgZWxlbWVudHMgYWx3YXlzIGhhdmUgYSBzcmNPYmplY3Qgc2V0XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gY29udGV4dC5jcmVhdGVNZWRpYVN0cmVhbVNvdXJjZShlbGVtZW50LnNyY09iamVjdCk7XG4gICAgbGV0IGxhc3ROb2RlID0gdGhpcy5zb3VyY2VOb2RlO1xuICAgIHRoaXMud2ViQXVkaW9QbHVnaW5Ob2Rlcy5mb3JFYWNoKG5vZGUgPT4ge1xuICAgICAgbGFzdE5vZGUuY29ubmVjdChub2RlKTtcbiAgICAgIGxhc3ROb2RlID0gbm9kZTtcbiAgICB9KTtcbiAgICB0aGlzLmdhaW5Ob2RlID0gY29udGV4dC5jcmVhdGVHYWluKCk7XG4gICAgbGFzdE5vZGUuY29ubmVjdCh0aGlzLmdhaW5Ob2RlKTtcbiAgICB0aGlzLmdhaW5Ob2RlLmNvbm5lY3QoY29udGV4dC5kZXN0aW5hdGlvbik7XG4gICAgaWYgKHRoaXMuZWxlbWVudFZvbHVtZSkge1xuICAgICAgdGhpcy5nYWluTm9kZS5nYWluLnNldFRhcmdldEF0VGltZSh0aGlzLmVsZW1lbnRWb2x1bWUsIDAsIDAuMSk7XG4gICAgfVxuICAgIC8vIHRyeSB0byByZXN1bWUgdGhlIGNvbnRleHQgaWYgaXQgaXNuJ3QgcnVubmluZyBhbHJlYWR5XG4gICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgY29udGV4dC5yZXN1bWUoKS50aGVuKCgpID0+IHtcbiAgICAgICAgaWYgKGNvbnRleHQuc3RhdGUgIT09ICdydW5uaW5nJykge1xuICAgICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIG5ldyBFcnJvcihcIkF1ZGlvIENvbnRleHQgY291bGRuJ3QgYmUgc3RhcnRlZCBhdXRvbWF0aWNhbGx5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkF1ZGlvUGxheWJhY2tGYWlsZWQsIGUpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGRpc2Nvbm5lY3RXZWJBdWRpbygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIChfYSA9IHRoaXMuZ2Fpbk5vZGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kaXNjb25uZWN0KCk7XG4gICAgKF9iID0gdGhpcy5zb3VyY2VOb2RlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuZ2Fpbk5vZGUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5zb3VyY2VOb2RlID0gdW5kZWZpbmVkO1xuICB9XG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xuICAgICAgc3RhdHMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgaWYgKHYudHlwZSA9PT0gJ2luYm91bmQtcnRwJykge1xuICAgICAgICAgIHJlY2VpdmVyU3RhdHMgPSB7XG4gICAgICAgICAgICB0eXBlOiAnYXVkaW8nLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHYuaWQsXG4gICAgICAgICAgICB0aW1lc3RhbXA6IHYudGltZXN0YW1wLFxuICAgICAgICAgICAgaml0dGVyOiB2LmppdHRlcixcbiAgICAgICAgICAgIGJ5dGVzUmVjZWl2ZWQ6IHYuYnl0ZXNSZWNlaXZlZCxcbiAgICAgICAgICAgIGNvbmNlYWxlZFNhbXBsZXM6IHYuY29uY2VhbGVkU2FtcGxlcyxcbiAgICAgICAgICAgIGNvbmNlYWxtZW50RXZlbnRzOiB2LmNvbmNlYWxtZW50RXZlbnRzLFxuICAgICAgICAgICAgc2lsZW50Q29uY2VhbGVkU2FtcGxlczogdi5zaWxlbnRDb25jZWFsZWRTYW1wbGVzLFxuICAgICAgICAgICAgc2lsZW50Q29uY2VhbG1lbnRFdmVudHM6IHYuc2lsZW50Q29uY2VhbG1lbnRFdmVudHMsXG4gICAgICAgICAgICB0b3RhbEF1ZGlvRW5lcmd5OiB2LnRvdGFsQXVkaW9FbmVyZ3ksXG4gICAgICAgICAgICB0b3RhbFNhbXBsZXNEdXJhdGlvbjogdi50b3RhbFNhbXBsZXNEdXJhdGlvblxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlY2VpdmVyU3RhdHM7XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgUkVBQ1RJT05fREVMQVkgPSAxMDA7XG5jbGFzcyBSZW1vdGVWaWRlb1RyYWNrIGV4dGVuZHMgUmVtb3RlVHJhY2sge1xuICBjb25zdHJ1Y3RvcihtZWRpYVRyYWNrLCBzaWQsIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgc3VwZXIobWVkaWFUcmFjaywgc2lkLCBUcmFjay5LaW5kLlZpZGVvLCByZWNlaXZlciwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy5lbGVtZW50SW5mb3MgPSBbXTtcbiAgICB0aGlzLm1vbml0b3JSZWNlaXZlciA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IDA7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0geWllbGQgdGhpcy5nZXRSZWNlaXZlclN0YXRzKCk7XG4gICAgICBpZiAoc3RhdHMgJiYgdGhpcy5wcmV2U3RhdHMgJiYgdGhpcy5yZWNlaXZlcikge1xuICAgICAgICB0aGlzLl9jdXJyZW50Qml0cmF0ZSA9IGNvbXB1dGVCaXRyYXRlKHN0YXRzLCB0aGlzLnByZXZTdGF0cyk7XG4gICAgICB9XG4gICAgICB0aGlzLnByZXZTdGF0cyA9IHN0YXRzO1xuICAgIH0pO1xuICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplID0gcigoKSA9PiB7XG4gICAgICB0aGlzLnVwZGF0ZURpbWVuc2lvbnMoKTtcbiAgICB9LCBSRUFDVElPTl9ERUxBWSk7XG4gICAgdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0gYWRhcHRpdmVTdHJlYW1TZXR0aW5ncztcbiAgfVxuICBnZXQgaXNBZGFwdGl2ZVN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgLyoqXG4gICAqIE5vdGU6IFdoZW4gdXNpbmcgYWRhcHRpdmVTdHJlYW0sIHlvdSBuZWVkIHRvIHVzZSByZW1vdGVWaWRlb1RyYWNrLmF0dGFjaCgpIHRvIGFkZCB0aGUgdHJhY2sgdG8gYSBIVE1MVmlkZW9FbGVtZW50LCBvdGhlcndpc2UgeW91ciB2aWRlbyB0cmFja3MgbWlnaHQgbmV2ZXIgc3RhcnRcbiAgICovXG4gIGdldCBtZWRpYVN0cmVhbVRyYWNrKCkge1xuICAgIHJldHVybiB0aGlzLl9tZWRpYVN0cmVhbVRyYWNrO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0TXV0ZWQobXV0ZWQpIHtcbiAgICBzdXBlci5zZXRNdXRlZChtdXRlZCk7XG4gICAgdGhpcy5hdHRhY2hlZEVsZW1lbnRzLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAvLyBkZXRhY2ggb3IgYXR0YWNoXG4gICAgICBpZiAobXV0ZWQpIHtcbiAgICAgICAgZGV0YWNoVHJhY2sodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRhY2hUb0VsZW1lbnQodGhpcy5fbWVkaWFTdHJlYW1UcmFjaywgZWxlbWVudCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgYXR0YWNoKGVsZW1lbnQpIHtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBzdXBlci5hdHRhY2goKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VwZXIuYXR0YWNoKGVsZW1lbnQpO1xuICAgIH1cbiAgICAvLyBJdCdzIHBvc3NpYmxlIGF0dGFjaCBpcyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgb24gYW4gZWxlbWVudC4gV2hlbiB0aGF0J3NcbiAgICAvLyB0aGUgY2FzZSwgd2UnZCB3YW50IHRvIGF2b2lkIGFkZGluZyBkdXBsaWNhdGUgZWxlbWVudEluZm9zXG4gICAgaWYgKHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyAmJiB0aGlzLmVsZW1lbnRJbmZvcy5maW5kKGluZm8gPT4gaW5mby5lbGVtZW50ID09PSBlbGVtZW50KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBlbGVtZW50SW5mbyA9IG5ldyBIVE1MRWxlbWVudEluZm8oZWxlbWVudCk7XG4gICAgICB0aGlzLm9ic2VydmVFbGVtZW50SW5mbyhlbGVtZW50SW5mbyk7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIC8qKlxuICAgKiBPYnNlcnZlIGFuIEVsZW1lbnRJbmZvIGZvciBjaGFuZ2VzIHdoZW4gYWRhcHRpdmUgc3RyZWFtaW5nLlxuICAgKiBAcGFyYW0gZWxlbWVudEluZm9cbiAgICogQGludGVybmFsXG4gICAqL1xuICBvYnNlcnZlRWxlbWVudEluZm8oZWxlbWVudEluZm8pIHtcbiAgICBpZiAodGhpcy5hZGFwdGl2ZVN0cmVhbVNldHRpbmdzICYmIHRoaXMuZWxlbWVudEluZm9zLmZpbmQoaW5mbyA9PiBpbmZvID09PSBlbGVtZW50SW5mbykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgZWxlbWVudEluZm8uaGFuZGxlUmVzaXplID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmRlYm91bmNlZEhhbmRsZVJlc2l6ZSgpO1xuICAgICAgfTtcbiAgICAgIGVsZW1lbnRJbmZvLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLmVsZW1lbnRJbmZvcy5wdXNoKGVsZW1lbnRJbmZvKTtcbiAgICAgIGVsZW1lbnRJbmZvLm9ic2VydmUoKTtcbiAgICAgIC8vIHRyaWdnZXIgdGhlIGZpcnN0IHJlc2l6ZSB1cGRhdGUgY3ljbGVcbiAgICAgIC8vIGlmIHRoZSB0YWIgaXMgYmFja2dyb3VuZGVkLCB0aGUgaW5pdGlhbCByZXNpemUgZXZlbnQgZG9lcyBub3QgZmlyZSB1bnRpbFxuICAgICAgLy8gdGhlIHRhYiBjb21lcyBpbnRvIGZvY3VzIGZvciB0aGUgZmlyc3QgdGltZS5cbiAgICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XG4gICAgICB0aGlzLnVwZGF0ZVZpc2liaWxpdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2cud2FybigndmlzaWJpbGl0eSByZXNpemUgb2JzZXJ2ZXIgbm90IHRyaWdnZXJlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTdG9wIG9ic2VydmluZyBhbiBFbGVtZW50SW5mbyBmb3IgY2hhbmdlcy5cbiAgICogQHBhcmFtIGVsZW1lbnRJbmZvXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGVsZW1lbnRJbmZvKSB7XG4gICAgaWYgKCF0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ3N0b3BPYnNlcnZpbmdFbGVtZW50SW5mbyBpZ25vcmVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8gPT09IGVsZW1lbnRJbmZvKTtcbiAgICBmb3IgKGNvbnN0IGluZm8gb2Ygc3RvcEVsZW1lbnRJbmZvcykge1xuICAgICAgaW5mby5zdG9wT2JzZXJ2aW5nKCk7XG4gICAgfVxuICAgIHRoaXMuZWxlbWVudEluZm9zID0gdGhpcy5lbGVtZW50SW5mb3MuZmlsdGVyKGluZm8gPT4gaW5mbyAhPT0gZWxlbWVudEluZm8pO1xuICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgIHRoaXMuZGVib3VuY2VkSGFuZGxlUmVzaXplKCk7XG4gIH1cbiAgZGV0YWNoKGVsZW1lbnQpIHtcbiAgICBsZXQgZGV0YWNoZWRFbGVtZW50cyA9IFtdO1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHN1cGVyLmRldGFjaChlbGVtZW50KTtcbiAgICB9XG4gICAgZGV0YWNoZWRFbGVtZW50cyA9IHN1cGVyLmRldGFjaCgpO1xuICAgIGZvciAoY29uc3QgZSBvZiBkZXRhY2hlZEVsZW1lbnRzKSB7XG4gICAgICB0aGlzLnN0b3BPYnNlcnZpbmdFbGVtZW50KGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGV0YWNoZWRFbGVtZW50cztcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIGdldERlY29kZXJJbXBsZW1lbnRhdGlvbigpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuIChfYSA9IHRoaXMucHJldlN0YXRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGVjb2RlckltcGxlbWVudGF0aW9uO1xuICB9XG4gIGdldFJlY2VpdmVyU3RhdHMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICghdGhpcy5yZWNlaXZlciB8fCAhdGhpcy5yZWNlaXZlci5nZXRTdGF0cykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICAgIGxldCByZWNlaXZlclN0YXRzO1xuICAgICAgbGV0IGNvZGVjSUQgPSAnJztcbiAgICAgIGxldCBjb2RlY3MgPSBuZXcgTWFwKCk7XG4gICAgICBzdGF0cy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICBpZiAodi50eXBlID09PSAnaW5ib3VuZC1ydHAnKSB7XG4gICAgICAgICAgY29kZWNJRCA9IHYuY29kZWNJZDtcbiAgICAgICAgICByZWNlaXZlclN0YXRzID0ge1xuICAgICAgICAgICAgdHlwZTogJ3ZpZGVvJyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiB2LmlkLFxuICAgICAgICAgICAgZnJhbWVzRGVjb2RlZDogdi5mcmFtZXNEZWNvZGVkLFxuICAgICAgICAgICAgZnJhbWVzRHJvcHBlZDogdi5mcmFtZXNEcm9wcGVkLFxuICAgICAgICAgICAgZnJhbWVzUmVjZWl2ZWQ6IHYuZnJhbWVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBwYWNrZXRzUmVjZWl2ZWQ6IHYucGFja2V0c1JlY2VpdmVkLFxuICAgICAgICAgICAgcGFja2V0c0xvc3Q6IHYucGFja2V0c0xvc3QsXG4gICAgICAgICAgICBmcmFtZVdpZHRoOiB2LmZyYW1lV2lkdGgsXG4gICAgICAgICAgICBmcmFtZUhlaWdodDogdi5mcmFtZUhlaWdodCxcbiAgICAgICAgICAgIHBsaUNvdW50OiB2LnBsaUNvdW50LFxuICAgICAgICAgICAgZmlyQ291bnQ6IHYuZmlyQ291bnQsXG4gICAgICAgICAgICBuYWNrQ291bnQ6IHYubmFja0NvdW50LFxuICAgICAgICAgICAgaml0dGVyOiB2LmppdHRlcixcbiAgICAgICAgICAgIHRpbWVzdGFtcDogdi50aW1lc3RhbXAsXG4gICAgICAgICAgICBieXRlc1JlY2VpdmVkOiB2LmJ5dGVzUmVjZWl2ZWQsXG4gICAgICAgICAgICBkZWNvZGVySW1wbGVtZW50YXRpb246IHYuZGVjb2RlckltcGxlbWVudGF0aW9uXG4gICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIGlmICh2LnR5cGUgPT09ICdjb2RlYycpIHtcbiAgICAgICAgICBjb2RlY3Muc2V0KHYuaWQsIHYpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChyZWNlaXZlclN0YXRzICYmIGNvZGVjSUQgIT09ICcnICYmIGNvZGVjcy5nZXQoY29kZWNJRCkpIHtcbiAgICAgICAgcmVjZWl2ZXJTdGF0cy5taW1lVHlwZSA9IGNvZGVjcy5nZXQoY29kZWNJRCkubWltZVR5cGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVjZWl2ZXJTdGF0cztcbiAgICB9KTtcbiAgfVxuICBzdG9wT2JzZXJ2aW5nRWxlbWVudChlbGVtZW50KSB7XG4gICAgY29uc3Qgc3RvcEVsZW1lbnRJbmZvcyA9IHRoaXMuZWxlbWVudEluZm9zLmZpbHRlcihpbmZvID0+IGluZm8uZWxlbWVudCA9PT0gZWxlbWVudCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHN0b3BFbGVtZW50SW5mb3MpIHtcbiAgICAgIHRoaXMuc3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvKGluZm8pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVBcHBWaXNpYmlsaXR5Q2hhbmdlZCgpIHtcbiAgICBjb25zdCBfc3VwZXIgPSBPYmplY3QuY3JlYXRlKG51bGwsIHtcbiAgICAgIGhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkOiB7XG4gICAgICAgIGdldDogKCkgPT4gc3VwZXIuaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWRcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgX3N1cGVyLmhhbmRsZUFwcFZpc2liaWxpdHlDaGFuZ2VkLmNhbGwodGhpcyk7XG4gICAgICBpZiAoIXRoaXMuaXNBZGFwdGl2ZVN0cmVhbSkgcmV0dXJuO1xuICAgICAgdGhpcy51cGRhdGVWaXNpYmlsaXR5KCk7XG4gICAgfSk7XG4gIH1cbiAgdXBkYXRlVmlzaWJpbGl0eSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IGxhc3RWaXNpYmlsaXR5Q2hhbmdlID0gdGhpcy5lbGVtZW50SW5mb3MucmVkdWNlKChwcmV2LCBpbmZvKSA9PiBNYXRoLm1heChwcmV2LCBpbmZvLnZpc2liaWxpdHlDaGFuZ2VkQXQgfHwgMCksIDApO1xuICAgIGNvbnN0IGJhY2tncm91bmRQYXVzZSA9ICgoX2IgPSAoX2EgPSB0aGlzLmFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZVZpZGVvSW5CYWNrZ3JvdW5kKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlIC8vIGRlZmF1bHQgdG8gdHJ1ZVxuICAgICkgPyB0aGlzLmlzSW5CYWNrZ3JvdW5kIDogZmFsc2U7XG4gICAgY29uc3QgaXNQaVBNb2RlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZShpbmZvID0+IGluZm8ucGljdHVyZUluUGljdHVyZSk7XG4gICAgY29uc3QgaXNWaXNpYmxlID0gdGhpcy5lbGVtZW50SW5mb3Muc29tZShpbmZvID0+IGluZm8udmlzaWJsZSkgJiYgIWJhY2tncm91bmRQYXVzZSB8fCBpc1BpUE1vZGU7XG4gICAgaWYgKHRoaXMubGFzdFZpc2libGUgPT09IGlzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWlzVmlzaWJsZSAmJiBEYXRlLm5vdygpIC0gbGFzdFZpc2liaWxpdHlDaGFuZ2UgPCBSRUFDVElPTl9ERUxBWSkge1xuICAgICAgLy8gZGVsYXkgaGlkZGVuIGV2ZW50c1xuICAgICAgQ3JpdGljYWxUaW1lcnMuc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMudXBkYXRlVmlzaWJpbGl0eSgpO1xuICAgICAgfSwgUkVBQ1RJT05fREVMQVkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmxhc3RWaXNpYmxlID0gaXNWaXNpYmxlO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCBpc1Zpc2libGUsIHRoaXMpO1xuICB9XG4gIHVwZGF0ZURpbWVuc2lvbnMoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBsZXQgbWF4V2lkdGggPSAwO1xuICAgIGxldCBtYXhIZWlnaHQgPSAwO1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IHRoaXMuZ2V0UGl4ZWxEZW5zaXR5KCk7XG4gICAgZm9yIChjb25zdCBpbmZvIG9mIHRoaXMuZWxlbWVudEluZm9zKSB7XG4gICAgICBjb25zdCBjdXJyZW50RWxlbWVudFdpZHRoID0gaW5mby53aWR0aCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgY29uc3QgY3VycmVudEVsZW1lbnRIZWlnaHQgPSBpbmZvLmhlaWdodCgpICogcGl4ZWxEZW5zaXR5O1xuICAgICAgaWYgKGN1cnJlbnRFbGVtZW50V2lkdGggKyBjdXJyZW50RWxlbWVudEhlaWdodCA+IG1heFdpZHRoICsgbWF4SGVpZ2h0KSB7XG4gICAgICAgIG1heFdpZHRoID0gY3VycmVudEVsZW1lbnRXaWR0aDtcbiAgICAgICAgbWF4SGVpZ2h0ID0gY3VycmVudEVsZW1lbnRIZWlnaHQ7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICgoKF9hID0gdGhpcy5sYXN0RGltZW5zaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndpZHRoKSA9PT0gbWF4V2lkdGggJiYgKChfYiA9IHRoaXMubGFzdERpbWVuc2lvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5oZWlnaHQpID09PSBtYXhIZWlnaHQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sYXN0RGltZW5zaW9ucyA9IHtcbiAgICAgIHdpZHRoOiBtYXhXaWR0aCxcbiAgICAgIGhlaWdodDogbWF4SGVpZ2h0XG4gICAgfTtcbiAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmxhc3REaW1lbnNpb25zLCB0aGlzKTtcbiAgfVxuICBnZXRQaXhlbERlbnNpdHkoKSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHBpeGVsRGVuc2l0eSA9IChfYSA9IHRoaXMuYWRhcHRpdmVTdHJlYW1TZXR0aW5ncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBpeGVsRGVuc2l0eTtcbiAgICBpZiAocGl4ZWxEZW5zaXR5ID09PSAnc2NyZWVuJykge1xuICAgICAgcmV0dXJuIGdldERldmljZVBpeGVsUmF0aW8oKTtcbiAgICB9IGVsc2UgaWYgKCFwaXhlbERlbnNpdHkpIHtcbiAgICAgIC8vIHdoZW4gdW5zZXQsIHdlJ2xsIHBpY2sgYSBzYW5lIGRlZmF1bHQgaGVyZS5cbiAgICAgIC8vIGZvciBoaWdoZXIgcGl4ZWwgZGVuc2l0eSBkZXZpY2VzIChtb2JpbGUgcGhvbmVzLCBldGMpLCB3ZSdsbCB1c2UgMlxuICAgICAgLy8gb3RoZXJ3aXNlIGl0IGRlZmF1bHRzIHRvIDFcbiAgICAgIGNvbnN0IGRldmljZVBpeGVsUmF0aW8gPSBnZXREZXZpY2VQaXhlbFJhdGlvKCk7XG4gICAgICBpZiAoZGV2aWNlUGl4ZWxSYXRpbyA+IDIpIHtcbiAgICAgICAgcmV0dXJuIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBpeGVsRGVuc2l0eTtcbiAgfVxufVxuY2xhc3MgSFRNTEVsZW1lbnRJbmZvIHtcbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNQaVAgfHwgdGhpcy5pc0ludGVyc2VjdGluZztcbiAgfVxuICBnZXQgcGljdHVyZUluUGljdHVyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5pc1BpUDtcbiAgfVxuICBjb25zdHJ1Y3RvcihlbGVtZW50LCB2aXNpYmxlKSB7XG4gICAgdGhpcy5vblZpc2liaWxpdHlDaGFuZ2VkID0gZW50cnkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGlzSW50ZXJzZWN0aW5nXG4gICAgICB9ID0gZW50cnk7XG4gICAgICBpZiAodGFyZ2V0ID09PSB0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IGlzSW50ZXJzZWN0aW5nO1xuICAgICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICAgICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gRGF0ZS5ub3coKTtcbiAgICAgICAgKF9hID0gdGhpcy5oYW5kbGVWaXNpYmlsaXR5Q2hhbmdlZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLm9uRW50ZXJQaVAgPSAoKSA9PiB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIChfYiA9IChfYSA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53aW5kb3cpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5hZGRFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gICAgICB0aGlzLmlzUGlQID0gaXNFbGVtZW50SW5QaVAodGhpcy5lbGVtZW50KTtcbiAgICAgIChfYyA9IHRoaXMuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5jYWxsKHRoaXMpO1xuICAgIH07XG4gICAgdGhpcy5vbkxlYXZlUGlQID0gKCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgdGhpcy5pc1BpUCA9IGlzRWxlbWVudEluUGlQKHRoaXMuZWxlbWVudCk7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5pc0ludGVyc2VjdGluZyA9IHZpc2libGUgIT09IG51bGwgJiYgdmlzaWJsZSAhPT0gdm9pZCAwID8gdmlzaWJsZSA6IGlzRWxlbWVudEluVmlld3BvcnQoZWxlbWVudCk7XG4gICAgdGhpcy5pc1BpUCA9IGlzV2ViKCkgJiYgaXNFbGVtZW50SW5QaVAoZWxlbWVudCk7XG4gICAgdGhpcy52aXNpYmlsaXR5Q2hhbmdlZEF0ID0gMDtcbiAgfVxuICB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsaWVudFdpZHRoO1xuICB9XG4gIGhlaWdodCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50LmNsaWVudEhlaWdodDtcbiAgfVxuICBvYnNlcnZlKCkge1xuICAgIHZhciBfYSwgX2IsIF9jO1xuICAgIC8vIG1ha2Ugc3VyZSB3ZSB1cGRhdGUgdGhlIGN1cnJlbnQgdmlzaWJsZSBzdGF0ZSBvbmNlIHdlIHN0YXJ0IHRvIG9ic2VydmVcbiAgICB0aGlzLmlzSW50ZXJzZWN0aW5nID0gaXNFbGVtZW50SW5WaWV3cG9ydCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuaXNQaVAgPSBpc0VsZW1lbnRJblBpUCh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuZWxlbWVudC5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICAoX2EgPSB0aGlzLmhhbmRsZVJlc2l6ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwodGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnQuaGFuZGxlVmlzaWJpbGl0eUNoYW5nZWQgPSB0aGlzLm9uVmlzaWJpbGl0eUNoYW5nZWQ7XG4gICAgZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIoKS5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgZ2V0UmVzaXplT2JzZXJ2ZXIoKS5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVycGljdHVyZWlucGljdHVyZScsIHRoaXMub25FbnRlclBpUCk7XG4gICAgdGhpcy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2xlYXZlcGljdHVyZWlucGljdHVyZScsIHRoaXMub25MZWF2ZVBpUCk7XG4gICAgKF9hID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFkZEV2ZW50TGlzdGVuZXIoJ2VudGVyJywgdGhpcy5vbkVudGVyUGlQKTtcbiAgICAoX2MgPSAoX2IgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iud2luZG93KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcigncGFnZWhpZGUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICB9XG4gIHN0b3BPYnNlcnZpbmcoKSB7XG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAoX2EgPSBnZXRJbnRlcnNlY3Rpb25PYnNlcnZlcigpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5vYnNlcnZlKHRoaXMuZWxlbWVudCk7XG4gICAgKF9iID0gZ2V0UmVzaXplT2JzZXJ2ZXIoKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnVub2JzZXJ2ZSh0aGlzLmVsZW1lbnQpO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcnBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uRW50ZXJQaVApO1xuICAgIHRoaXMuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdsZWF2ZXBpY3R1cmVpbnBpY3R1cmUnLCB0aGlzLm9uTGVhdmVQaVApO1xuICAgIChfYyA9IHdpbmRvdy5kb2N1bWVudFBpY3R1cmVJblBpY3R1cmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5yZW1vdmVFdmVudExpc3RlbmVyKCdlbnRlcicsIHRoaXMub25FbnRlclBpUCk7XG4gICAgKF9lID0gKF9kID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLndpbmRvdykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vbkxlYXZlUGlQKTtcbiAgfVxufVxuZnVuY3Rpb24gaXNFbGVtZW50SW5QaVAoZWwpIHtcbiAgdmFyIF9hLCBfYjtcbiAgLy8gU2ltcGxlIHZpZGVvIFBpUFxuICBpZiAoZG9jdW1lbnQucGljdHVyZUluUGljdHVyZUVsZW1lbnQgPT09IGVsKSByZXR1cm4gdHJ1ZTtcbiAgLy8gRG9jdW1lbnQgUGlQXG4gIGlmICgoX2EgPSB3aW5kb3cuZG9jdW1lbnRQaWN0dXJlSW5QaWN0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2luZG93KSByZXR1cm4gaXNFbGVtZW50SW5WaWV3cG9ydChlbCwgKF9iID0gd2luZG93LmRvY3VtZW50UGljdHVyZUluUGljdHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLndpbmRvdyk7XG4gIHJldHVybiBmYWxzZTtcbn1cbi8vIGRvZXMgbm90IGFjY291bnQgZm9yIG9jY2x1c2lvbiBieSBvdGhlciBlbGVtZW50cyBvciBvcGFjaXR5IHByb3BlcnR5XG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXdwb3J0KGVsLCB3aW4pIHtcbiAgY29uc3Qgdmlld3BvcnRXaW5kb3cgPSB3aW4gfHwgd2luZG93O1xuICBsZXQgdG9wID0gZWwub2Zmc2V0VG9wO1xuICBsZXQgbGVmdCA9IGVsLm9mZnNldExlZnQ7XG4gIGNvbnN0IHdpZHRoID0gZWwub2Zmc2V0V2lkdGg7XG4gIGNvbnN0IGhlaWdodCA9IGVsLm9mZnNldEhlaWdodDtcbiAgY29uc3Qge1xuICAgIGhpZGRlblxuICB9ID0gZWw7XG4gIGNvbnN0IHtcbiAgICBkaXNwbGF5XG4gIH0gPSBnZXRDb21wdXRlZFN0eWxlKGVsKTtcbiAgd2hpbGUgKGVsLm9mZnNldFBhcmVudCkge1xuICAgIGVsID0gZWwub2Zmc2V0UGFyZW50O1xuICAgIHRvcCArPSBlbC5vZmZzZXRUb3A7XG4gICAgbGVmdCArPSBlbC5vZmZzZXRMZWZ0O1xuICB9XG4gIHJldHVybiB0b3AgPCB2aWV3cG9ydFdpbmRvdy5wYWdlWU9mZnNldCArIHZpZXdwb3J0V2luZG93LmlubmVySGVpZ2h0ICYmIGxlZnQgPCB2aWV3cG9ydFdpbmRvdy5wYWdlWE9mZnNldCArIHZpZXdwb3J0V2luZG93LmlubmVyV2lkdGggJiYgdG9wICsgaGVpZ2h0ID4gdmlld3BvcnRXaW5kb3cucGFnZVlPZmZzZXQgJiYgbGVmdCArIHdpZHRoID4gdmlld3BvcnRXaW5kb3cucGFnZVhPZmZzZXQgJiYgIWhpZGRlbiAmJiBkaXNwbGF5ICE9PSAnbm9uZSc7XG59XG5cbmNsYXNzIFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKGtpbmQsIGlkLCBuYW1lLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5tZXRhZGF0YU11dGVkID0gZmFsc2U7XG4gICAgdGhpcy5lbmNyeXB0aW9uID0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gICAgdGhpcy5sb2cgPSBsaXZla2l0TG9nZ2VyO1xuICAgIHRoaXMuaGFuZGxlTXV0ZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5NdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVVubXV0ZWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5Vbm11dGVkKTtcbiAgICB9O1xuICAgIHRoaXMubG9nID0gZ2V0TG9nZ2VyKChfYSA9IGxvZ2dlck9wdGlvbnMgPT09IG51bGwgfHwgbG9nZ2VyT3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogbG9nZ2VyT3B0aW9ucy5sb2dnZXJOYW1lKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBMb2dnZXJOYW1lcy5QdWJsaWNhdGlvbik7XG4gICAgdGhpcy5sb2dnZXJDb250ZXh0Q2IgPSB0aGlzLmxvZ2dlckNvbnRleHRDYjtcbiAgICB0aGlzLnNldE1heExpc3RlbmVycygxMDApO1xuICAgIHRoaXMua2luZCA9IGtpbmQ7XG4gICAgdGhpcy50cmFja1NpZCA9IGlkO1xuICAgIHRoaXMudHJhY2tOYW1lID0gbmFtZTtcbiAgICB0aGlzLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5Vbmtub3duO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0VHJhY2sodHJhY2spIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgdGhpcy50cmFjay5vZmYoVHJhY2tFdmVudC5NdXRlZCwgdGhpcy5oYW5kbGVNdXRlZCk7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMuaGFuZGxlVW5tdXRlZCk7XG4gICAgfVxuICAgIHRoaXMudHJhY2sgPSB0cmFjaztcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIC8vIGZvcndhcmQgZXZlbnRzXG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50Lk11dGVkLCB0aGlzLmhhbmRsZU11dGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5oYW5kbGVVbm11dGVkKTtcbiAgICB9XG4gIH1cbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh0aGlzKSksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodGhpcykpO1xuICB9XG4gIGdldCBpc011dGVkKCkge1xuICAgIHJldHVybiB0aGlzLm1ldGFkYXRhTXV0ZWQ7XG4gIH1cbiAgZ2V0IGlzRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBnZXQgaXNTdWJzY3JpYmVkKCkge1xuICAgIHJldHVybiB0aGlzLnRyYWNrICE9PSB1bmRlZmluZWQ7XG4gIH1cbiAgZ2V0IGlzRW5jcnlwdGVkKCkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHRpb24gIT09IEVuY3J5cHRpb25fVHlwZS5OT05FO1xuICB9XG4gIC8qKlxuICAgKiBhbiBbQXVkaW9UcmFja10gaWYgdGhpcyBwdWJsaWNhdGlvbiBob2xkcyBhbiBhdWRpbyB0cmFja1xuICAgKi9cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgaWYgKGlzQXVkaW9UcmFjayh0aGlzLnRyYWNrKSkge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2s7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBhbiBbVmlkZW9UcmFja10gaWYgdGhpcyBwdWJsaWNhdGlvbiBob2xkcyBhIHZpZGVvIHRyYWNrXG4gICAqL1xuICBnZXQgdmlkZW9UcmFjaygpIHtcbiAgICBpZiAoaXNWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICByZXR1cm4gdGhpcy50cmFjaztcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICB0aGlzLnRyYWNrU2lkID0gaW5mby5zaWQ7XG4gICAgdGhpcy50cmFja05hbWUgPSBpbmZvLm5hbWU7XG4gICAgdGhpcy5zb3VyY2UgPSBUcmFjay5zb3VyY2VGcm9tUHJvdG8oaW5mby5zb3VyY2UpO1xuICAgIHRoaXMubWltZVR5cGUgPSBpbmZvLm1pbWVUeXBlO1xuICAgIGlmICh0aGlzLmtpbmQgPT09IFRyYWNrLktpbmQuVmlkZW8gJiYgaW5mby53aWR0aCA+IDApIHtcbiAgICAgIHRoaXMuZGltZW5zaW9ucyA9IHtcbiAgICAgICAgd2lkdGg6IGluZm8ud2lkdGgsXG4gICAgICAgIGhlaWdodDogaW5mby5oZWlnaHRcbiAgICAgIH07XG4gICAgICB0aGlzLnNpbXVsY2FzdGVkID0gaW5mby5zaW11bGNhc3Q7XG4gICAgfVxuICAgIHRoaXMuZW5jcnlwdGlvbiA9IGluZm8uZW5jcnlwdGlvbjtcbiAgICB0aGlzLnRyYWNrSW5mbyA9IGluZm87XG4gICAgdGhpcy5sb2cuZGVidWcoJ3VwZGF0ZSBwdWJsaWNhdGlvbiBpbmZvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICBpbmZvXG4gICAgfSkpO1xuICB9XG59XG4oZnVuY3Rpb24gKFRyYWNrUHVibGljYXRpb24pIHtcbiAgKGZ1bmN0aW9uIChTdWJzY3JpcHRpb25TdGF0dXMpIHtcbiAgICBTdWJzY3JpcHRpb25TdGF0dXNbXCJEZXNpcmVkXCJdID0gXCJkZXNpcmVkXCI7XG4gICAgU3Vic2NyaXB0aW9uU3RhdHVzW1wiU3Vic2NyaWJlZFwiXSA9IFwic3Vic2NyaWJlZFwiO1xuICAgIFN1YnNjcmlwdGlvblN0YXR1c1tcIlVuc3Vic2NyaWJlZFwiXSA9IFwidW5zdWJzY3JpYmVkXCI7XG4gIH0pKFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzIHx8IChUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cyA9IHt9KSk7XG4gIChmdW5jdGlvbiAoUGVybWlzc2lvblN0YXR1cykge1xuICAgIFBlcm1pc3Npb25TdGF0dXNbXCJBbGxvd2VkXCJdID0gXCJhbGxvd2VkXCI7XG4gICAgUGVybWlzc2lvblN0YXR1c1tcIk5vdEFsbG93ZWRcIl0gPSBcIm5vdF9hbGxvd2VkXCI7XG4gIH0pKFRyYWNrUHVibGljYXRpb24uUGVybWlzc2lvblN0YXR1cyB8fCAoVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzID0ge30pKTtcbn0pKFRyYWNrUHVibGljYXRpb24gfHwgKFRyYWNrUHVibGljYXRpb24gPSB7fSkpO1xuXG5jbGFzcyBMb2NhbFRyYWNrUHVibGljYXRpb24gZXh0ZW5kcyBUcmFja1B1YmxpY2F0aW9uIHtcbiAgZ2V0IGlzVXBzdHJlYW1QYXVzZWQoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaXNVcHN0cmVhbVBhdXNlZDtcbiAgfVxuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgdHJhY2ssIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBzdXBlcihraW5kLCB0aS5zaWQsIHRpLm5hbWUsIGxvZ2dlck9wdGlvbnMpO1xuICAgIHRoaXMudHJhY2sgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gKCkgPT4ge1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuRW5kZWQpO1xuICAgIH07XG4gICAgdGhpcy51cGRhdGVJbmZvKHRpKTtcbiAgICB0aGlzLnNldFRyYWNrKHRyYWNrKTtcbiAgfVxuICBzZXRUcmFjayh0cmFjaykge1xuICAgIGlmICh0aGlzLnRyYWNrKSB7XG4gICAgICB0aGlzLnRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cbiAgICBzdXBlci5zZXRUcmFjayh0cmFjayk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgIH1cbiAgfVxuICBnZXQgaXNNdXRlZCgpIHtcbiAgICBpZiAodGhpcy50cmFjaykge1xuICAgICAgcmV0dXJuIHRoaXMudHJhY2suaXNNdXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzTXV0ZWQ7XG4gIH1cbiAgZ2V0IGF1ZGlvVHJhY2soKSB7XG4gICAgcmV0dXJuIHN1cGVyLmF1ZGlvVHJhY2s7XG4gIH1cbiAgZ2V0IHZpZGVvVHJhY2soKSB7XG4gICAgcmV0dXJuIHN1cGVyLnZpZGVvVHJhY2s7XG4gIH1cbiAgZ2V0IGlzTG9jYWwoKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIE11dGUgdGhlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICBtdXRlKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICByZXR1cm4gKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm11dGUoKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogVW5tdXRlIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uXG4gICAqL1xuICB1bm11dGUoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHJldHVybiAoX2EgPSB0aGlzLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EudW5tdXRlKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFBhdXNlcyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIGZyb20gYmVpbmcgc2VudCB0byB0aGUgc2VydmVyXG4gICAqIGFuZCBzaWduYWxzIFwibXV0ZWRcIiBldmVudCB0byBvdGhlciBwYXJ0aWNpcGFudHNcbiAgICogVXNlZnVsIGlmIHlvdSB3YW50IHRvIHBhdXNlIHRoZSBzdHJlYW0gd2l0aG91dCBwYXVzaW5nIHRoZSBsb2NhbCBtZWRpYSBzdHJlYW0gdHJhY2tcbiAgICovXG4gIHBhdXNlVXBzdHJlYW0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIHlpZWxkIChfYSA9IHRoaXMudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wYXVzZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFJlc3VtZXMgc2VuZGluZyB0aGUgbWVkaWEgc3RyZWFtIHRyYWNrIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHB1YmxpY2F0aW9uIHRvIHRoZSBzZXJ2ZXIgYWZ0ZXIgYSBjYWxsIHRvIFtbcGF1c2VVcHN0cmVhbSgpXV1cbiAgICogYW5kIHNpZ25hbHMgXCJ1bm11dGVkXCIgZXZlbnQgdG8gb3RoZXIgcGFydGljaXBhbnRzICh1bmxlc3MgdGhlIHRyYWNrIGlzIGV4cGxpY2l0bHkgbXV0ZWQpXG4gICAqL1xuICByZXN1bWVVcHN0cmVhbSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgeWllbGQgKF9hID0gdGhpcy50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlc3VtZVVwc3RyZWFtKCk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhY2tGZWF0dXJlcygpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGlzQXVkaW9UcmFjayh0aGlzLnRyYWNrKSkge1xuICAgICAgY29uc3Qgc2V0dGluZ3MgPSB0aGlzLnRyYWNrLmdldFNvdXJjZVRyYWNrU2V0dGluZ3MoKTtcbiAgICAgIGNvbnN0IGZlYXR1cmVzID0gbmV3IFNldCgpO1xuICAgICAgaWYgKHNldHRpbmdzLmF1dG9HYWluQ29udHJvbCkge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfQVVUT19HQUlOX0NPTlRST0wpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRpbmdzLmVjaG9DYW5jZWxsYXRpb24pIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX0VDSE9fQ0FOQ0VMTEFUSU9OKTtcbiAgICAgIH1cbiAgICAgIGlmIChzZXR0aW5ncy5ub2lzZVN1cHByZXNzaW9uKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9OT0lTRV9TVVBQUkVTU0lPTik7XG4gICAgICB9XG4gICAgICBpZiAoc2V0dGluZ3MuY2hhbm5lbENvdW50ICYmIHNldHRpbmdzLmNoYW5uZWxDb3VudCA+IDEpIHtcbiAgICAgICAgZmVhdHVyZXMuYWRkKEF1ZGlvVHJhY2tGZWF0dXJlLlRGX1NURVJFTyk7XG4gICAgICB9XG4gICAgICBpZiAoISgoX2EgPSB0aGlzLm9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kdHgpKSB7XG4gICAgICAgIGZlYXR1cmVzLmFkZChBdWRpb1RyYWNrRmVhdHVyZS5URl9OT19EVFgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudHJhY2suZW5oYW5jZWROb2lzZUNhbmNlbGxhdGlvbikge1xuICAgICAgICBmZWF0dXJlcy5hZGQoQXVkaW9UcmFja0ZlYXR1cmUuVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBBcnJheS5mcm9tKGZlYXR1cmVzLnZhbHVlcygpKTtcbiAgICB9IGVsc2UgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGxvY2FsIHZpZGVvIGFuZCBhdWRpbyB0cmFjayBhdCB0aGUgc2FtZSB0aW1lLiBXaGVuIGFjcXVpcmluZyBib3RoXG4gKiBhdWRpbyBhbmQgdmlkZW8gdHJhY2tzIHRvZ2V0aGVyLCBpdCdsbCBkaXNwbGF5IGEgc2luZ2xlIHBlcm1pc3Npb24gcHJvbXB0IHRvXG4gKiB0aGUgdXNlciBpbnN0ZWFkIG9mIHR3byBzZXBhcmF0ZSBvbmVzLlxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxUcmFja3Mob3B0aW9ucywgbG9nZ2VyT3B0aW9ucykge1xuICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IG9wdGlvbnMgPSB7fTtcbiAgICBsZXQgYXR0ZW1wdEV4YWN0TWF0Y2ggPSBmYWxzZTtcbiAgICBjb25zdCB7XG4gICAgICBhdWRpb1Byb2Nlc3NvcixcbiAgICAgIHZpZGVvUHJvY2Vzc29yLFxuICAgICAgb3B0aW9uc1dpdGhvdXRQcm9jZXNzb3I6IGludGVybmFsT3B0aW9uc1xuICAgIH0gPSBleHRyYWN0UHJvY2Vzc29yc0Zyb21PcHRpb25zKG9wdGlvbnMpO1xuICAgIGxldCByZXRyeUF1ZGlvT3B0aW9ucyA9IGludGVybmFsT3B0aW9ucy5hdWRpbztcbiAgICBsZXQgcmV0cnlWaWRlb09wdGlvbnMgPSBpbnRlcm5hbE9wdGlvbnMudmlkZW87XG4gICAgaWYgKGF1ZGlvUHJvY2Vzc29yICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8ucHJvY2Vzc29yID0gYXVkaW9Qcm9jZXNzb3I7XG4gICAgfVxuICAgIGlmICh2aWRlb1Byb2Nlc3NvciAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0Jykge1xuICAgICAgaW50ZXJuYWxPcHRpb25zLnZpZGVvLnByb2Nlc3NvciA9IHZpZGVvUHJvY2Vzc29yO1xuICAgIH1cbiAgICAvLyBpZiB0aGUgdXNlciBwYXNzZXMgYSBkZXZpY2UgaWQgYXMgYSBzdHJpbmcsIHdlIGRlZmF1bHQgdG8gZXhhY3QgbWF0Y2hcbiAgICBpZiAob3B0aW9ucy5hdWRpbyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLmF1ZGlvLmRldmljZUlkID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgZGV2aWNlSWQgPSBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQ7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQgPSB7XG4gICAgICAgIGV4YWN0OiBkZXZpY2VJZFxuICAgICAgfTtcbiAgICAgIGF0dGVtcHRFeGFjdE1hdGNoID0gdHJ1ZTtcbiAgICAgIHJldHJ5QXVkaW9PcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnRlcm5hbE9wdGlvbnMuYXVkaW8pLCB7XG4gICAgICAgIGRldmljZUlkOiB7XG4gICAgICAgICAgaWRlYWw6IGRldmljZUlkXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLnZpZGVvICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPT09ICdvYmplY3QnICYmIHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMudmlkZW8uZGV2aWNlSWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBkZXZpY2VJZCA9IGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZDtcbiAgICAgIGludGVybmFsT3B0aW9ucy52aWRlby5kZXZpY2VJZCA9IHtcbiAgICAgICAgZXhhY3Q6IGRldmljZUlkXG4gICAgICB9O1xuICAgICAgYXR0ZW1wdEV4YWN0TWF0Y2ggPSB0cnVlO1xuICAgICAgcmV0cnlWaWRlb09wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGludGVybmFsT3B0aW9ucy52aWRlbyksIHtcbiAgICAgICAgZGV2aWNlSWQ6IHtcbiAgICAgICAgICBpZGVhbDogZGV2aWNlSWRcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRPRE8gaWYgaW50ZXJuYWwgb3B0aW9ucyBkb24ndCBoYXZlIGRldmljZSBJZCBzcGVjaWZpZWQsIHNldCBpdCB0byAnZGVmYXVsdCdcbiAgICBpZiAoaW50ZXJuYWxPcHRpb25zLmF1ZGlvID09PSB0cnVlIHx8IHR5cGVvZiBpbnRlcm5hbE9wdGlvbnMuYXVkaW8gPT09ICdvYmplY3QnICYmICFpbnRlcm5hbE9wdGlvbnMuYXVkaW8uZGV2aWNlSWQpIHtcbiAgICAgIGludGVybmFsT3B0aW9ucy5hdWRpbyA9IHtcbiAgICAgICAgZGV2aWNlSWQ6ICdkZWZhdWx0J1xuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGludGVybmFsT3B0aW9ucy52aWRlbyA9PT0gdHJ1ZSB8fCB0eXBlb2YgaW50ZXJuYWxPcHRpb25zLnZpZGVvID09PSAnb2JqZWN0JyAmJiAhaW50ZXJuYWxPcHRpb25zLnZpZGVvLmRldmljZUlkKSB7XG4gICAgICBpbnRlcm5hbE9wdGlvbnMudmlkZW8gPSB7XG4gICAgICAgIGRldmljZUlkOiAnZGVmYXVsdCdcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9wdHMgPSBtZXJnZURlZmF1bHRPcHRpb25zKGludGVybmFsT3B0aW9ucywgYXVkaW9EZWZhdWx0cywgdmlkZW9EZWZhdWx0cyk7XG4gICAgY29uc3QgY29uc3RyYWludHMgPSBjb25zdHJhaW50c0Zvck9wdGlvbnMob3B0cyk7XG4gICAgLy8gS2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgcHJvbWlzZSBvbiBEZXZpY2VNYW5hZ2VyIGFuZCBhd2FpdCBpdCBpbiBnZXRMb2NhbERldmljZXMoKVxuICAgIC8vIHdvcmtzIGFyb3VuZCBpT1MgU2FmYXJpIEJ1ZyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTc5MzYzXG4gICAgY29uc3QgbWVkaWFQcm9taXNlID0gbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMuYXVkaW8pIHtcbiAgICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ2F1ZGlvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ2F1ZGlvaW5wdXQnKSk7XG4gICAgfVxuICAgIGlmIChpbnRlcm5hbE9wdGlvbnMudmlkZW8pIHtcbiAgICAgIERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCBtZWRpYVByb21pc2UpO1xuICAgICAgbWVkaWFQcm9taXNlLmNhdGNoKCgpID0+IERldmljZU1hbmFnZXIudXNlck1lZGlhUHJvbWlzZU1hcC5kZWxldGUoJ3ZpZGVvaW5wdXQnKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBtZWRpYVByb21pc2U7XG4gICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwoc3RyZWFtLmdldFRyYWNrcygpLm1hcChtZWRpYVN0cmVhbVRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgaXNBdWRpbyA9IG1lZGlhU3RyZWFtVHJhY2sua2luZCA9PT0gJ2F1ZGlvJztcbiAgICAgICAgbGV0IHRyYWNrT3B0aW9ucyA9IGlzQXVkaW8gPyBvcHRzLmF1ZGlvIDogb3B0cy52aWRlbztcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFja09wdGlvbnMgPT09ICdib29sZWFuJyB8fCAhdHJhY2tPcHRpb25zKSB7XG4gICAgICAgICAgdHJhY2tPcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRyYWNrQ29uc3RyYWludHM7XG4gICAgICAgIGNvbnN0IGNvbk9yQm9vbCA9IGlzQXVkaW8gPyBjb25zdHJhaW50cy5hdWRpbyA6IGNvbnN0cmFpbnRzLnZpZGVvO1xuICAgICAgICBpZiAodHlwZW9mIGNvbk9yQm9vbCAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgdHJhY2tDb25zdHJhaW50cyA9IGNvbk9yQm9vbDtcbiAgICAgICAgfVxuICAgICAgICAvLyB1cGRhdGUgdGhlIGNvbnN0cmFpbnRzIHdpdGggdGhlIGRldmljZSBpZCB0aGUgdXNlciBnYXZlIHBlcm1pc3Npb25zIHRvIGluIHRoZSBwZXJtaXNzaW9uIHByb21wdFxuICAgICAgICAvLyBvdGhlcndpc2UgZWFjaCB0cmFjayByZXN0YXJ0IChlLmcuIG11dGUgLSB1bm11dGUpIHdpbGwgdHJ5IHRvIGluaXRpYWxpemUgdGhlIGRldmljZSBhZ2FpbiAtPiBjYXVzaW5nIGFkZGl0aW9uYWwgcGVybWlzc2lvbiBwcm9tcHRzXG4gICAgICAgIGNvbnN0IG5ld0RldmljZUlkID0gbWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmRldmljZUlkO1xuICAgICAgICBpZiAoKHRyYWNrQ29uc3RyYWludHMgPT09IG51bGwgfHwgdHJhY2tDb25zdHJhaW50cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2tDb25zdHJhaW50cy5kZXZpY2VJZCkgJiYgdW53cmFwQ29uc3RyYWludCh0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkKSAhPT0gbmV3RGV2aWNlSWQpIHtcbiAgICAgICAgICB0cmFja0NvbnN0cmFpbnRzLmRldmljZUlkID0gbmV3RGV2aWNlSWQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIXRyYWNrQ29uc3RyYWludHMpIHtcbiAgICAgICAgICB0cmFja0NvbnN0cmFpbnRzID0ge1xuICAgICAgICAgICAgZGV2aWNlSWQ6IG5ld0RldmljZUlkXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFjayA9IG1lZGlhVHJhY2tUb0xvY2FsVHJhY2sobWVkaWFTdHJlYW1UcmFjaywgdHJhY2tDb25zdHJhaW50cywgbG9nZ2VyT3B0aW9ucyk7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLkNhbWVyYTtcbiAgICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgICAgdHJhY2suc291cmNlID0gVHJhY2suU291cmNlLk1pY3JvcGhvbmU7XG4gICAgICAgIH1cbiAgICAgICAgdHJhY2subWVkaWFTdHJlYW0gPSBzdHJlYW07XG4gICAgICAgIGlmIChpc0F1ZGlvVHJhY2sodHJhY2spICYmIGF1ZGlvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdHJhY2suc2V0UHJvY2Vzc29yKGF1ZGlvUHJvY2Vzc29yKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc1ZpZGVvVHJhY2sodHJhY2spICYmIHZpZGVvUHJvY2Vzc29yKSB7XG4gICAgICAgICAgeWllbGQgdHJhY2suc2V0UHJvY2Vzc29yKHZpZGVvUHJvY2Vzc29yKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJhY2s7XG4gICAgICB9KSkpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmICghYXR0ZW1wdEV4YWN0TWF0Y2gpIHtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVMb2NhbFRyYWNrcyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7XG4gICAgICAgIGF1ZGlvOiByZXRyeUF1ZGlvT3B0aW9ucyxcbiAgICAgICAgdmlkZW86IHJldHJ5VmlkZW9PcHRpb25zXG4gICAgICB9KSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgfVxuICB9KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIFtbTG9jYWxWaWRlb1RyYWNrXV0gd2l0aCBnZXRVc2VyTWVkaWEoKVxuICogQHBhcmFtIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlTG9jYWxWaWRlb1RyYWNrKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgICBhdWRpbzogZmFsc2UsXG4gICAgICB2aWRlbzogb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cmFja3NbMF07XG4gIH0pO1xufVxuZnVuY3Rpb24gY3JlYXRlTG9jYWxBdWRpb1RyYWNrKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBjb25zdCB0cmFja3MgPSB5aWVsZCBjcmVhdGVMb2NhbFRyYWNrcyh7XG4gICAgICBhdWRpbzogb3B0aW9ucyAhPT0gbnVsbCAmJiBvcHRpb25zICE9PSB2b2lkIDAgPyBvcHRpb25zIDogdHJ1ZSxcbiAgICAgIHZpZGVvOiBmYWxzZVxuICAgIH0pO1xuICAgIHJldHVybiB0cmFja3NbMF07XG4gIH0pO1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgc2NyZWVuIGNhcHR1cmUgdHJhY2tzIHdpdGggZ2V0RGlzcGxheU1lZGlhKCkuXG4gKiBBIExvY2FsVmlkZW9UcmFjayBpcyBhbHdheXMgY3JlYXRlZCBhbmQgcmV0dXJuZWQuXG4gKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUxvY2FsU2NyZWVuVHJhY2tzKG9wdGlvbnMpIHtcbiAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnJlc29sdXRpb24gPT09IHVuZGVmaW5lZCAmJiAhaXNTYWZhcmkxNygpKSB7XG4gICAgICBvcHRpb25zLnJlc29sdXRpb24gPSBTY3JlZW5TaGFyZVByZXNldHMuaDEwODBmcHMzMC5yZXNvbHV0aW9uO1xuICAgIH1cbiAgICBpZiAobmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXREaXNwbGF5TWVkaWEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IERldmljZVVuc3VwcG9ydGVkRXJyb3IoJ2dldERpc3BsYXlNZWRpYSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gc2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyhvcHRpb25zKTtcbiAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgY29uc3QgdHJhY2tzID0gc3RyZWFtLmdldFZpZGVvVHJhY2tzKCk7XG4gICAgaWYgKHRyYWNrcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3Qgc2NyZWVuVmlkZW8gPSBuZXcgTG9jYWxWaWRlb1RyYWNrKHRyYWNrc1swXSwgdW5kZWZpbmVkLCBmYWxzZSk7XG4gICAgc2NyZWVuVmlkZW8uc291cmNlID0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlO1xuICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcbiAgICBpZiAoc3RyZWFtLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NyZWVuQXVkaW8gPSBuZXcgTG9jYWxBdWRpb1RyYWNrKHN0cmVhbS5nZXRBdWRpb1RyYWNrcygpWzBdLCB1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIHNjcmVlbkF1ZGlvLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZUF1ZGlvO1xuICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgfVxuICAgIHJldHVybiBsb2NhbFRyYWNrcztcbiAgfSk7XG59XG5cbnZhciBDb25uZWN0aW9uUXVhbGl0eTtcbihmdW5jdGlvbiAoQ29ubmVjdGlvblF1YWxpdHkpIHtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJFeGNlbGxlbnRcIl0gPSBcImV4Y2VsbGVudFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIkdvb2RcIl0gPSBcImdvb2RcIjtcbiAgQ29ubmVjdGlvblF1YWxpdHlbXCJQb29yXCJdID0gXCJwb29yXCI7XG4gIC8qKlxuICAgKiBJbmRpY2F0ZXMgdGhhdCBhIHBhcnRpY2lwYW50IGhhcyB0ZW1wb3JhcmlseSAob3IgcGVybWFuZW50bHkpIGxvc3QgY29ubmVjdGlvbiB0byBMaXZlS2l0LlxuICAgKiBGb3IgcGVybWFuZW50IGRpc2Nvbm5lY3Rpb24gYSBgUGFydGljaXBhbnREaXNjb25uZWN0ZWRgIGV2ZW50IHdpbGwgYmUgZW1pdHRlZCBhZnRlciBhIHRpbWVvdXRcbiAgICovXG4gIENvbm5lY3Rpb25RdWFsaXR5W1wiTG9zdFwiXSA9IFwibG9zdFwiO1xuICBDb25uZWN0aW9uUXVhbGl0eVtcIlVua25vd25cIl0gPSBcInVua25vd25cIjtcbn0pKENvbm5lY3Rpb25RdWFsaXR5IHx8IChDb25uZWN0aW9uUXVhbGl0eSA9IHt9KSk7XG5mdW5jdGlvbiBxdWFsaXR5RnJvbVByb3RvKHEpIHtcbiAgc3dpdGNoIChxKSB7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkVYQ0VMTEVOVDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5FeGNlbGxlbnQ7XG4gICAgY2FzZSBDb25uZWN0aW9uUXVhbGl0eSQxLkdPT0Q6XG4gICAgICByZXR1cm4gQ29ubmVjdGlvblF1YWxpdHkuR29vZDtcbiAgICBjYXNlIENvbm5lY3Rpb25RdWFsaXR5JDEuUE9PUjpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Qb29yO1xuICAgIGNhc2UgQ29ubmVjdGlvblF1YWxpdHkkMS5MT1NUOlxuICAgICAgcmV0dXJuIENvbm5lY3Rpb25RdWFsaXR5Lkxvc3Q7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICB9XG59XG5jbGFzcyBQYXJ0aWNpcGFudCBleHRlbmRzIGV2ZW50c0V4cG9ydHMuRXZlbnRFbWl0dGVyIHtcbiAgZ2V0IGxvZ0NvbnRleHQoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgKF9iID0gKF9hID0gdGhpcy5sb2dnZXJPcHRpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubG9nZ2VyQ29udGV4dENiKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpO1xuICB9XG4gIGdldCBpc0VuY3J5cHRlZCgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5zaXplID4gMCAmJiBBcnJheS5mcm9tKHRoaXMudHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmV2ZXJ5KHRyID0+IHRyLmlzRW5jcnlwdGVkKTtcbiAgfVxuICBnZXQgaXNBZ2VudCgpIHtcbiAgICB2YXIgX2E7XG4gICAgcmV0dXJuICgoX2EgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuYWdlbnQpIHx8IHRoaXMua2luZCA9PT0gUGFydGljaXBhbnRJbmZvX0tpbmQuQUdFTlQ7XG4gIH1cbiAgZ2V0IGtpbmQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2tpbmQ7XG4gIH1cbiAgLyoqIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMsIHNpbWlsYXIgdG8gbWV0YWRhdGEsIGJ1dCBhcyBhIGtleS92YWx1ZSBtYXAgKi9cbiAgZ2V0IGF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5fYXR0cmlidXRlcykpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3Ioc2lkLCBpZGVudGl0eSwgbmFtZSwgbWV0YWRhdGEsIGF0dHJpYnV0ZXMsIGxvZ2dlck9wdGlvbnMpIHtcbiAgICBsZXQga2luZCA9IGFyZ3VtZW50cy5sZW5ndGggPiA2ICYmIGFyZ3VtZW50c1s2XSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzZdIDogUGFydGljaXBhbnRJbmZvX0tpbmQuU1RBTkRBUkQ7XG4gICAgdmFyIF9hO1xuICAgIHN1cGVyKCk7XG4gICAgLyoqIGF1ZGlvIGxldmVsIGJldHdlZW4gMC0xLjAsIDEgYmVpbmcgbG91ZGVzdCwgMCBiZWluZyBzb2Z0ZXN0ICovXG4gICAgdGhpcy5hdWRpb0xldmVsID0gMDtcbiAgICAvKiogaWYgcGFydGljaXBhbnQgaXMgY3VycmVudGx5IHNwZWFraW5nICovXG4gICAgdGhpcy5pc1NwZWFraW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBDb25uZWN0aW9uUXVhbGl0eS5Vbmtub3duO1xuICAgIHRoaXMubG9nID0gbGl2ZWtpdExvZ2dlcjtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSBsb2dnZXJPcHRpb25zID09PSBudWxsIHx8IGxvZ2dlck9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvZ2dlck9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUGFydGljaXBhbnQpO1xuICAgIHRoaXMubG9nZ2VyT3B0aW9ucyA9IGxvZ2dlck9wdGlvbnM7XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnNpZCA9IHNpZDtcbiAgICB0aGlzLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuX2tpbmQgPSBraW5kO1xuICAgIHRoaXMuX2F0dHJpYnV0ZXMgPSBhdHRyaWJ1dGVzICE9PSBudWxsICYmIGF0dHJpYnV0ZXMgIT09IHZvaWQgMCA/IGF0dHJpYnV0ZXMgOiB7fTtcbiAgfVxuICBnZXRUcmFja1B1YmxpY2F0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgc291cmNlIGZpbHRlciwgZm9yIGV4YW1wbGUsIGdldHRpbmdcbiAgICogdGhlIHVzZXIncyBjYW1lcmEgdHJhY2sgd2l0aCBnZXRUcmFja0J5U291cmNlKFRyYWNrLlNvdXJjZS5DYW1lcmEpLlxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcbiAgICBmb3IgKGNvbnN0IFssIHB1Yl0gb2YgdGhpcy50cmFja1B1YmxpY2F0aW9ucykge1xuICAgICAgaWYgKHB1Yi5zb3VyY2UgPT09IHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gcHViO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICAvKipcbiAgICogRmluZHMgdGhlIGZpcnN0IHRyYWNrIHRoYXQgbWF0Y2hlcyB0aGUgdHJhY2sncyBuYW1lLlxuICAgKi9cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgZm9yIChjb25zdCBbLCBwdWJdIG9mIHRoaXMudHJhY2tQdWJsaWNhdGlvbnMpIHtcbiAgICAgIGlmIChwdWIudHJhY2tOYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBwdWI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBjb25uZWN0aW9uUXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gIH1cbiAgZ2V0IGlzQ2FtZXJhRW5hYmxlZCgpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgcmV0dXJuICEoKF9hID0gdHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLmlzTXV0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpO1xuICB9XG4gIGdldCBpc01pY3JvcGhvbmVFbmFibGVkKCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgcmV0dXJuICEoKF9hID0gdHJhY2sgPT09IG51bGwgfHwgdHJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRyYWNrLmlzTXV0ZWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpO1xuICB9XG4gIGdldCBpc1NjcmVlblNoYXJlRW5hYmxlZCgpIHtcbiAgICBjb25zdCB0cmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUpO1xuICAgIHJldHVybiAhIXRyYWNrO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKiogd2hlbiBwYXJ0aWNpcGFudCBqb2luZWQgdGhlIHJvb20gKi9cbiAgZ2V0IGpvaW5lZEF0KCkge1xuICAgIGlmICh0aGlzLnBhcnRpY2lwYW50SW5mbykge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlci5wYXJzZUludCh0aGlzLnBhcnRpY2lwYW50SW5mby5qb2luZWRBdC50b1N0cmluZygpKSAqIDEwMDApO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IERhdGUoKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIC8vIGl0J3MgcG9zc2libGUgdGhlIHVwZGF0ZSBjb3VsZCBiZSBhcHBsaWVkIG91dCBvZiBvcmRlciBkdWUgdG8gYXdhaXRcbiAgICAvLyBkdXJpbmcgcmVjb25uZWN0IHNlcXVlbmNlcy4gd2hlbiB0aGF0IGhhcHBlbnMsIGl0J3MgcG9zc2libGUgZm9yIHNlcnZlclxuICAgIC8vIHRvIGhhdmUgc2VudCBtb3JlIHJlY2VudCB2ZXJzaW9uIG9mIHBhcnRpY2lwYW50IGluZm8gd2hpbGUgSlMgaXMgd2FpdGluZ1xuICAgIC8vIHRvIHByb2Nlc3MgdGhlIGV4aXN0aW5nIHBheWxvYWQuXG4gICAgLy8gd2hlbiB0aGUgcGFydGljaXBhbnQgc2lkIHJlbWFpbnMgdGhlIHNhbWUsIGFuZCB3ZSBhbHJlYWR5IGhhdmUgYSBsYXRlciB2ZXJzaW9uXG4gICAgLy8gb2YgdGhlIHBheWxvYWQsIHRoZXkgY2FuIGJlIHNhZmVseSBza2lwcGVkXG4gICAgaWYgKHRoaXMucGFydGljaXBhbnRJbmZvICYmIHRoaXMucGFydGljaXBhbnRJbmZvLnNpZCA9PT0gaW5mby5zaWQgJiYgdGhpcy5wYXJ0aWNpcGFudEluZm8udmVyc2lvbiA+IGluZm8udmVyc2lvbikge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmlkZW50aXR5ID0gaW5mby5pZGVudGl0eTtcbiAgICB0aGlzLnNpZCA9IGluZm8uc2lkO1xuICAgIHRoaXMuX3NldE5hbWUoaW5mby5uYW1lKTtcbiAgICB0aGlzLl9zZXRNZXRhZGF0YShpbmZvLm1ldGFkYXRhKTtcbiAgICB0aGlzLl9zZXRBdHRyaWJ1dGVzKGluZm8uYXR0cmlidXRlcyk7XG4gICAgaWYgKGluZm8ucGVybWlzc2lvbikge1xuICAgICAgdGhpcy5zZXRQZXJtaXNzaW9ucyhpbmZvLnBlcm1pc3Npb24pO1xuICAgIH1cbiAgICAvLyBzZXQgdGhpcyBsYXN0IHNvIHNldE1ldGFkYXRhIGNhbiBkZXRlY3QgY2hhbmdlc1xuICAgIHRoaXMucGFydGljaXBhbnRJbmZvID0gaW5mbztcbiAgICB0aGlzLmxvZy50cmFjZSgndXBkYXRlIHBhcnRpY2lwYW50IGluZm8nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgIGluZm9cbiAgICB9KSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcbiAgICoqL1xuICBfc2V0TWV0YWRhdGEobWQpIHtcbiAgICBjb25zdCBjaGFuZ2VkID0gdGhpcy5tZXRhZGF0YSAhPT0gbWQ7XG4gICAgY29uc3QgcHJldk1ldGFkYXRhID0gdGhpcy5tZXRhZGF0YTtcbiAgICB0aGlzLm1ldGFkYXRhID0gbWQ7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBwcmV2TWV0YWRhdGEpO1xuICAgIH1cbiAgfVxuICBfc2V0TmFtZShuYW1lKSB7XG4gICAgY29uc3QgY2hhbmdlZCA9IHRoaXMubmFtZSAhPT0gbmFtZTtcbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIGlmIChjaGFuZ2VkKSB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCBuYW1lKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIFVwZGF0ZXMgbWV0YWRhdGEgZnJvbSBzZXJ2ZXJcbiAgICoqL1xuICBfc2V0QXR0cmlidXRlcyhhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgZGlmZiA9IGRpZmZBdHRyaWJ1dGVzKHRoaXMuYXR0cmlidXRlcywgYXR0cmlidXRlcyk7XG4gICAgdGhpcy5fYXR0cmlidXRlcyA9IGF0dHJpYnV0ZXM7XG4gICAgaWYgKE9iamVjdC5rZXlzKGRpZmYpLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCBkaWZmKTtcbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRQZXJtaXNzaW9ucyhwZXJtaXNzaW9ucykge1xuICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9ucyA9IHRoaXMucGVybWlzc2lvbnM7XG4gICAgY29uc3QgY2hhbmdlZCA9IHBlcm1pc3Npb25zLmNhblB1Ymxpc2ggIT09ICgoX2EgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FuUHVibGlzaCkgfHwgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlICE9PSAoKF9iID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhblN1YnNjcmliZSkgfHwgcGVybWlzc2lvbnMuY2FuUHVibGlzaERhdGEgIT09ICgoX2MgPSB0aGlzLnBlcm1pc3Npb25zKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuY2FuUHVibGlzaERhdGEpIHx8IHBlcm1pc3Npb25zLmhpZGRlbiAhPT0gKChfZCA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5oaWRkZW4pIHx8IHBlcm1pc3Npb25zLnJlY29yZGVyICE9PSAoKF9lID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLnJlY29yZGVyKSB8fCBwZXJtaXNzaW9ucy5jYW5QdWJsaXNoU291cmNlcy5sZW5ndGggIT09IHRoaXMucGVybWlzc2lvbnMuY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoIHx8IHBlcm1pc3Npb25zLmNhblB1Ymxpc2hTb3VyY2VzLnNvbWUoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIHZhbHVlICE9PSAoKF9hID0gdGhpcy5wZXJtaXNzaW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhblB1Ymxpc2hTb3VyY2VzW2luZGV4XSk7XG4gICAgfSkgfHwgcGVybWlzc2lvbnMuY2FuU3Vic2NyaWJlTWV0cmljcyAhPT0gKChfZiA9IHRoaXMucGVybWlzc2lvbnMpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5jYW5TdWJzY3JpYmVNZXRyaWNzKTtcbiAgICB0aGlzLnBlcm1pc3Npb25zID0gcGVybWlzc2lvbnM7XG4gICAgaWYgKGNoYW5nZWQpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gY2hhbmdlZDtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldElzU3BlYWtpbmcoc3BlYWtpbmcpIHtcbiAgICBpZiAoc3BlYWtpbmcgPT09IHRoaXMuaXNTcGVha2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmlzU3BlYWtpbmcgPSBzcGVha2luZztcbiAgICBpZiAoc3BlYWtpbmcpIHtcbiAgICAgIHRoaXMubGFzdFNwb2tlQXQgPSBuZXcgRGF0ZSgpO1xuICAgIH1cbiAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5Jc1NwZWFraW5nQ2hhbmdlZCwgc3BlYWtpbmcpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0Q29ubmVjdGlvblF1YWxpdHkocSkge1xuICAgIGNvbnN0IHByZXZRdWFsaXR5ID0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHk7XG4gICAgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkgPSBxdWFsaXR5RnJvbVByb3RvKHEpO1xuICAgIGlmIChwcmV2UXVhbGl0eSAhPT0gdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpIHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgdGhpcy5fY29ubmVjdGlvblF1YWxpdHkpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBdWRpb0NvbnRleHQoY3R4KSB7XG4gICAgdGhpcy5hdWRpb0NvbnRleHQgPSBjdHg7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2godHJhY2sgPT4gaXNBdWRpb1RyYWNrKHRyYWNrLnRyYWNrKSAmJiB0cmFjay50cmFjay5zZXRBdWRpb0NvbnRleHQoY3R4KSk7XG4gIH1cbiAgYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbikge1xuICAgIC8vIGZvcndhcmQgcHVibGljYXRpb24gZHJpdmVuIGV2ZW50c1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuTXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlVubXV0ZWQsICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgcHVibGljYXRpb24pO1xuICAgIH0pO1xuICAgIGNvbnN0IHB1YiA9IHB1YmxpY2F0aW9uO1xuICAgIGlmIChwdWIudHJhY2spIHtcbiAgICAgIHB1Yi50cmFjay5zaWQgPSBwdWJsaWNhdGlvbi50cmFja1NpZDtcbiAgICB9XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5zZXQocHVibGljYXRpb24udHJhY2tTaWQsIHB1YmxpY2F0aW9uKTtcbiAgICBzd2l0Y2ggKHB1YmxpY2F0aW9uLmtpbmQpIHtcbiAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVHJhY2suS2luZC5WaWRlbzpcbiAgICAgICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLnNldChwdWJsaWNhdGlvbi50cmFja1NpZCwgcHVibGljYXRpb24pO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJhY2tQZXJtaXNzaW9uVG9Qcm90byhwZXJtcykge1xuICB2YXIgX2EsIF9iLCBfYztcbiAgaWYgKCFwZXJtcy5wYXJ0aWNpcGFudFNpZCAmJiAhcGVybXMucGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB0cmFjayBwZXJtaXNzaW9uLCBtdXN0IHByb3ZpZGUgYXQgbGVhc3Qgb25lIG9mIHBhcnRpY2lwYW50SWRlbnRpdHkgYW5kIHBhcnRpY2lwYW50U2lkJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBUcmFja1Blcm1pc3Npb24oe1xuICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IChfYSA9IHBlcm1zLnBhcnRpY2lwYW50SWRlbnRpdHkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgIHBhcnRpY2lwYW50U2lkOiAoX2IgPSBwZXJtcy5wYXJ0aWNpcGFudFNpZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgYWxsVHJhY2tzOiAoX2MgPSBwZXJtcy5hbGxvd0FsbCkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogZmFsc2UsXG4gICAgdHJhY2tTaWRzOiBwZXJtcy5hbGxvd2VkVHJhY2tTaWRzIHx8IFtdXG4gIH0pO1xufVxuXG5jb25zdCBTVFJFQU1fQ0hVTktfU0laRSA9IDE1MDAwO1xuY2xhc3MgTG9jYWxQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBjb25zdHJ1Y3RvcihzaWQsIGlkZW50aXR5LCBlbmdpbmUsIG9wdGlvbnMsIHJvb21ScGNIYW5kbGVycykge1xuICAgIHN1cGVyKHNpZCwgaWRlbnRpdHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgIGxvZ2dlck5hbWU6IG9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5lbmdpbmUubG9nQ29udGV4dFxuICAgIH0pO1xuICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5wZW5kaW5nUHVibGlzaFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zID0gW107XG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSB0cnVlO1xuICAgIHRoaXMuZW5jcnlwdGlvblR5cGUgPSBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICB0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdBY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmhhbmRsZVJlY29ubmVjdGluZyA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5yZWNvbm5lY3RGdXR1cmUpIHtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSBuZXcgRnV0dXJlKCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVJlY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIChfYiA9IChfYSA9IHRoaXMucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVzb2x2ZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EpO1xuICAgICAgdGhpcy5yZWNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdGVkID0gKCkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICh0aGlzLnJlY29ubmVjdEZ1dHVyZSkge1xuICAgICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZS5wcm9taXNlLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihlLm1lc3NhZ2UsIHRoaXMubG9nQ29udGV4dCkpO1xuICAgICAgICAoX2IgPSAoX2EgPSB0aGlzLnJlY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlamVjdCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsICdHb3QgZGlzY29ubmVjdGVkIGR1cmluZyByZWNvbm5lY3Rpb24gYXR0ZW1wdCcpO1xuICAgICAgICB0aGlzLnJlY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlU2lnbmFsUmVxdWVzdFJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3Qge1xuICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgIHJlYXNvbixcbiAgICAgICAgbWVzc2FnZVxuICAgICAgfSA9IHJlc3BvbnNlO1xuICAgICAgY29uc3QgdGFyZ2V0UmVxdWVzdCA9IHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLmdldChyZXF1ZXN0SWQpO1xuICAgICAgaWYgKHRhcmdldFJlcXVlc3QpIHtcbiAgICAgICAgaWYgKHJlYXNvbiAhPT0gUmVxdWVzdFJlc3BvbnNlX1JlYXNvbi5PSykge1xuICAgICAgICAgIHRhcmdldFJlcXVlc3QucmVqZWN0KG5ldyBTaWduYWxSZXF1ZXN0RXJyb3IobWVzc2FnZSwgcmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuZGVsZXRlKHJlcXVlc3RJZCk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZURhdGFQYWNrZXQgPSBwYWNrZXQgPT4ge1xuICAgICAgc3dpdGNoIChwYWNrZXQudmFsdWUuY2FzZSkge1xuICAgICAgICBjYXNlICdycGNSZXNwb25zZSc6XG4gICAgICAgICAgbGV0IHJwY1Jlc3BvbnNlID0gcGFja2V0LnZhbHVlLnZhbHVlO1xuICAgICAgICAgIGxldCBwYXlsb2FkID0gbnVsbDtcbiAgICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICAgIGlmIChycGNSZXNwb25zZS52YWx1ZS5jYXNlID09PSAncGF5bG9hZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBycGNSZXNwb25zZS52YWx1ZS52YWx1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHJwY1Jlc3BvbnNlLnZhbHVlLmNhc2UgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICAgIGVycm9yID0gUnBjRXJyb3IuZnJvbVByb3RvKHJwY1Jlc3BvbnNlLnZhbHVlLnZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1JwY1Jlc3BvbnNlKHJwY1Jlc3BvbnNlLnJlcXVlc3RJZCwgcGF5bG9hZCwgZXJyb3IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdycGNBY2snOlxuICAgICAgICAgIGxldCBycGNBY2sgPSBwYWNrZXQudmFsdWUudmFsdWU7XG4gICAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ1JwY0FjayhycGNBY2sucmVxdWVzdElkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMudXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyA9ICgpID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyB0cmFjayBzdWJzY3JpcHRpb24gcGVybWlzc2lvbnMnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgYWxsUGFydGljaXBhbnRzQWxsb3dlZDogdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUsXG4gICAgICAgIHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9uczogdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnNcbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuZW5naW5lLmNsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uUGVybWlzc2lvbnModGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUsIHRoaXMucGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zLm1hcChwID0+IHRyYWNrUGVybWlzc2lvblRvUHJvdG8ocCkpKTtcbiAgICB9O1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICB0aGlzLm9uVHJhY2tVbm11dGVkID0gdHJhY2sgPT4ge1xuICAgICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRyYWNrLmlzVXBzdHJlYW1QYXVzZWQpO1xuICAgIH07XG4gICAgLy8gd2hlbiB0aGUgbG9jYWwgdHJhY2sgY2hhbmdlcyBpbiBtdXRlIHN0YXR1cywgd2UnbGwgbm90aWZ5IHNlcnZlciBhcyBzdWNoXG4gICAgLyoqIEBpbnRlcm5hbCAqL1xuICAgIHRoaXMub25UcmFja011dGVkID0gKHRyYWNrLCBtdXRlZCkgPT4ge1xuICAgICAgaWYgKG11dGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbXV0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFjay5zaWQpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCB1cGRhdGUgbXV0ZSBzdGF0dXMgZm9yIHVucHVibGlzaGVkIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVuZ2luZS51cGRhdGVNdXRlU3RhdHVzKHRyYWNrLnNpZCwgbXV0ZWQpO1xuICAgIH07XG4gICAgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQgPSB0cmFjayA9PiB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndXBzdHJlYW0gcGF1c2VkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgdGhpcy5vblRyYWNrTXV0ZWQodHJhY2ssIHRydWUpO1xuICAgIH07XG4gICAgdGhpcy5vblRyYWNrVXBzdHJlYW1SZXN1bWVkID0gdHJhY2sgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3Vwc3RyZWFtIHJlc3VtZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICB0aGlzLm9uVHJhY2tNdXRlZCh0cmFjaywgdHJhY2suaXNNdXRlZCk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tGZWF0dXJlVXBkYXRlID0gdHJhY2sgPT4ge1xuICAgICAgY29uc3QgcHViID0gdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zLmdldCh0cmFjay5zaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybihcIkNvdWxkIG5vdCB1cGRhdGUgbG9jYWwgYXVkaW8gdHJhY2sgc2V0dGluZ3MsIG1pc3NpbmcgcHVibGljYXRpb24gZm9yIHRyYWNrIFwiLmNvbmNhdCh0cmFjay5zaWQpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFVwZGF0ZUxvY2FsQXVkaW9UcmFjayhwdWIudHJhY2tTaWQsIHB1Yi5nZXRUcmFja0ZlYXR1cmVzKCkpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSA9IHVwZGF0ZSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIGVfMSwgX2IsIF9jO1xuICAgICAgdmFyIF9kLCBfZTtcbiAgICAgIGlmICghKChfZCA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5keW5hY2FzdCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zLmdldCh1cGRhdGUudHJhY2tTaWQpO1xuICAgICAgaWYgKCFwdWIpIHtcbiAgICAgICAgdGhpcy5sb2cud2FybigncmVjZWl2ZWQgc3Vic2NyaWJlZCBxdWFsaXR5IHVwZGF0ZSBmb3IgdW5rbm93biB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHRyYWNrU2lkOiB1cGRhdGUudHJhY2tTaWRcbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodXBkYXRlLnN1YnNjcmliZWRDb2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoIXB1Yi52aWRlb1RyYWNrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld0NvZGVjcyA9IHlpZWxkIHB1Yi52aWRlb1RyYWNrLnNldFB1Ymxpc2hpbmdDb2RlY3ModXBkYXRlLnN1YnNjcmliZWRDb2RlY3MpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGZvciAodmFyIF9mID0gdHJ1ZSwgbmV3Q29kZWNzXzEgPSBfX2FzeW5jVmFsdWVzKG5ld0NvZGVjcyksIG5ld0NvZGVjc18xXzE7IG5ld0NvZGVjc18xXzEgPSB5aWVsZCBuZXdDb2RlY3NfMS5uZXh0KCksIF9hID0gbmV3Q29kZWNzXzFfMS5kb25lLCAhX2E7IF9mID0gdHJ1ZSkge1xuICAgICAgICAgICAgX2MgPSBuZXdDb2RlY3NfMV8xLnZhbHVlO1xuICAgICAgICAgICAgX2YgPSBmYWxzZTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gX2M7XG4gICAgICAgICAgICBpZiAoaXNCYWNrdXBDb2RlYyhjb2RlYykpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwdWJsaXNoIFwiLmNvbmNhdChjb2RlYywgXCIgZm9yIFwiKS5jb25jYXQocHViLnZpZGVvVHJhY2suc2lkKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YikpKTtcbiAgICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2socHViLnZpZGVvVHJhY2ssIGNvZGVjLCBwdWIub3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlXzFfMSkge1xuICAgICAgICAgIGVfMSA9IHtcbiAgICAgICAgICAgIGVycm9yOiBlXzFfMVxuICAgICAgICAgIH07XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICghX2YgJiYgIV9hICYmIChfYiA9IG5ld0NvZGVjc18xLnJldHVybikpIHlpZWxkIF9iLmNhbGwobmV3Q29kZWNzXzEpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICBpZiAoZV8xKSB0aHJvdyBlXzEuZXJyb3I7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHVwZGF0ZS5zdWJzY3JpYmVkUXVhbGl0aWVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgeWllbGQgKF9lID0gcHViLnZpZGVvVHJhY2spID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5zZXRQdWJsaXNoaW5nTGF5ZXJzKHVwZGF0ZS5zdWJzY3JpYmVkUXVhbGl0aWVzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLmhhbmRsZUxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHVucHVibGlzaGVkID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQodW5wdWJsaXNoZWQudHJhY2tTaWQpO1xuICAgICAgaWYgKCF0cmFjaykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdyZWNlaXZlZCB1bnB1Ymxpc2hlZCBldmVudCBmb3IgdW5rbm93biB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHRyYWNrU2lkOiB1bnB1Ymxpc2hlZC50cmFja1NpZFxuICAgICAgICB9KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2sudHJhY2spO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVUcmFja0VuZGVkID0gdHJhY2sgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlIHx8IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8pIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3VucHVibGlzaGluZyBsb2NhbCB0cmFjayBkdWUgdG8gVHJhY2tFbmRlZCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICB9IGVsc2UgaWYgKHRyYWNrLmlzVXNlclByb3ZpZGVkKSB7XG4gICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChpc1dlYigpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb25zdCBjdXJyZW50UGVybWlzc2lvbnMgPSB5aWVsZCBuYXZpZ2F0b3IgPT09IG51bGwgfHwgbmF2aWdhdG9yID09PSB2b2lkIDAgPyB2b2lkIDAgOiBuYXZpZ2F0b3IucGVybWlzc2lvbnMucXVlcnkoe1xuICAgICAgICAgICAgICAgIC8vIHRoZSBwZXJtaXNzaW9uIHF1ZXJ5IGZvciBjYW1lcmEgYW5kIG1pY3JvcGhvbmUgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQgaW4gU2FmYXJpIGFuZCBGaXJlZm94XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIG5hbWU6IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSA/ICdjYW1lcmEnIDogJ21pY3JvcGhvbmUnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFBlcm1pc3Npb25zICYmIGN1cnJlbnRQZXJtaXNzaW9ucy5zdGF0ZSA9PT0gJ2RlbmllZCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZy53YXJuKFwidXNlciBoYXMgcmV2b2tlZCBhY2Nlc3MgdG8gXCIuY29uY2F0KHRyYWNrLnNvdXJjZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICAgICAgICAgICAgICAvLyBkZXRlY3QgZ3JhbnRlZCBjaGFuZ2UgYWZ0ZXIgcGVybWlzc2lvbnMgd2VyZSBkZW5pZWQgdG8gdHJ5IGFuZCByZXN1bWUgdGhlblxuICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UGVybWlzc2lvbnMuc3RhdGUgIT09ICdkZW5pZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2suaXNNdXRlZCkge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYWNrLnJlc3RhcnRUcmFjaygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRQZXJtaXNzaW9ucy5vbmNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0dldFVzZXJNZWRpYSBQZXJtaXNzaW9uIGRlbmllZCcpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIC8vIHBlcm1pc3Npb25zIHF1ZXJ5IGZhaWxzIGZvciBmaXJlZm94LCB3ZSBjb250aW51ZSBhbmQgdHJ5IHRvIHJlc3RhcnQgdGhlIHRyYWNrXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghdHJhY2suaXNNdXRlZCkge1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3RyYWNrIGVuZGVkLCBhdHRlbXB0aW5nIHRvIHVzZSBhIGRpZmZlcmVudCBkZXZpY2UnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgICAgIC8vIGZhbGwgYmFjayB0byBkZWZhdWx0IGRldmljZSBpZiBhdmFpbGFibGVcbiAgICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKHtcbiAgICAgICAgICAgICAgICBkZXZpY2VJZDogJ2RlZmF1bHQnXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybihcImNvdWxkIG5vdCByZXN0YXJ0IHRyYWNrLCBtdXRpbmcgaW5zdGVhZFwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgeWllbGQgdHJhY2subXV0ZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5hdWRpb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgIHRoaXMucm9vbU9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMuc2V0dXBFbmdpbmUoZW5naW5lKTtcbiAgICB0aGlzLmFjdGl2ZURldmljZU1hcCA9IG5ldyBNYXAoW1snYXVkaW9pbnB1dCcsICdkZWZhdWx0J10sIFsndmlkZW9pbnB1dCcsICdkZWZhdWx0J10sIFsnYXVkaW9vdXRwdXQnLCAnZGVmYXVsdCddXSk7XG4gICAgdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5ycGNIYW5kbGVycyA9IHJvb21ScGNIYW5kbGVycztcbiAgfVxuICBnZXQgbGFzdENhbWVyYUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLmNhbWVyYUVycm9yO1xuICB9XG4gIGdldCBsYXN0TWljcm9waG9uZUVycm9yKCkge1xuICAgIHJldHVybiB0aGlzLm1pY3JvcGhvbmVFcnJvcjtcbiAgfVxuICBnZXQgaXNFMkVFRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbmNyeXB0aW9uVHlwZSAhPT0gRW5jcnlwdGlvbl9UeXBlLk5PTkU7XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXR1cEVuZ2luZShlbmdpbmUpIHtcbiAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICB0aGlzLmVuZ2luZS5vbihFbmdpbmVFdmVudC5SZW1vdGVNdXRlLCAodHJhY2tTaWQsIG11dGVkKSA9PiB7XG4gICAgICBjb25zdCBwdWIgPSB0aGlzLnRyYWNrUHVibGljYXRpb25zLmdldCh0cmFja1NpZCk7XG4gICAgICBpZiAoIXB1YiB8fCAhcHViLnRyYWNrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChtdXRlZCkge1xuICAgICAgICBwdWIubXV0ZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHViLnVubXV0ZSgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LkNvbm5lY3RlZCwgdGhpcy5oYW5kbGVSZWNvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVzdGFydGVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkLCB0aGlzLmhhbmRsZVJlY29ubmVjdGVkKS5vbihFbmdpbmVFdmVudC5SZXN0YXJ0aW5nLCB0aGlzLmhhbmRsZVJlY29ubmVjdGluZykub24oRW5naW5lRXZlbnQuUmVzdW1pbmcsIHRoaXMuaGFuZGxlUmVjb25uZWN0aW5nKS5vbihFbmdpbmVFdmVudC5Mb2NhbFRyYWNrVW5wdWJsaXNoZWQsIHRoaXMuaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSwgdGhpcy5oYW5kbGVTdWJzY3JpYmVkUXVhbGl0eVVwZGF0ZSkub24oRW5naW5lRXZlbnQuRGlzY29ubmVjdGVkLCB0aGlzLmhhbmRsZURpc2Nvbm5lY3RlZCkub24oRW5naW5lRXZlbnQuU2lnbmFsUmVxdWVzdFJlc3BvbnNlLCB0aGlzLmhhbmRsZVNpZ25hbFJlcXVlc3RSZXNwb25zZSkub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpO1xuICB9XG4gIC8qKlxuICAgKiBTZXRzIGFuZCB1cGRhdGVzIHRoZSBtZXRhZGF0YSBvZiB0aGUgbG9jYWwgcGFydGljaXBhbnQuXG4gICAqIE5vdGU6IHRoaXMgcmVxdWlyZXMgYGNhblVwZGF0ZU93bk1ldGFkYXRhYCBwZXJtaXNzaW9uLlxuICAgKiBtZXRob2Qgd2lsbCB0aHJvdyBpZiB0aGUgdXNlciBkb2Vzbid0IGhhdmUgdGhlIHJlcXVpcmVkIHBlcm1pc3Npb25zXG4gICAqIEBwYXJhbSBtZXRhZGF0YVxuICAgKi9cbiAgc2V0TWV0YWRhdGEobWV0YWRhdGEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xuICAgICAgICBtZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFNldHMgYW5kIHVwZGF0ZXMgdGhlIG5hbWUgb2YgdGhlIGxvY2FsIHBhcnRpY2lwYW50LlxuICAgKiBOb3RlOiB0aGlzIHJlcXVpcmVzIGBjYW5VcGRhdGVPd25NZXRhZGF0YWAgcGVybWlzc2lvbi5cbiAgICogbWV0aG9kIHdpbGwgdGhyb3cgaWYgdGhlIHVzZXIgZG9lc24ndCBoYXZlIHRoZSByZXF1aXJlZCBwZXJtaXNzaW9uc1xuICAgKiBAcGFyYW0gbWV0YWRhdGFcbiAgICovXG4gIHNldE5hbWUobmFtZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLnJlcXVlc3RNZXRhZGF0YVVwZGF0ZSh7XG4gICAgICAgIG5hbWVcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZXQgb3IgdXBkYXRlIHBhcnRpY2lwYW50IGF0dHJpYnV0ZXMuIEl0IHdpbGwgbWFrZSB1cGRhdGVzIG9ubHkgdG8ga2V5cyB0aGF0XG4gICAqIGFyZSBwcmVzZW50IGluIGBhdHRyaWJ1dGVzYCwgYW5kIHdpbGwgbm90IG92ZXJyaWRlIG90aGVycy5cbiAgICogTm90ZTogdGhpcyByZXF1aXJlcyBgY2FuVXBkYXRlT3duTWV0YWRhdGFgIHBlcm1pc3Npb24uXG4gICAqIEBwYXJhbSBhdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgdG8gdXBkYXRlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGVzKGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgeWllbGQgdGhpcy5yZXF1ZXN0TWV0YWRhdGFVcGRhdGUoe1xuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICByZXF1ZXN0TWV0YWRhdGFVcGRhdGUoX2EpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoX3JlZikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgIGxldCB7XG4gICAgICAgIG1ldGFkYXRhLFxuICAgICAgICBuYW1lLFxuICAgICAgICBhdHRyaWJ1dGVzXG4gICAgICB9ID0gX3JlZjtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gX19hd2FpdGVyKF90aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsZXQgaXNSZWplY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdElkID0geWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LnNlbmRVcGRhdGVMb2NhbE1ldGFkYXRhKChfYSA9IG1ldGFkYXRhICE9PSBudWxsICYmIG1ldGFkYXRhICE9PSB2b2lkIDAgPyBtZXRhZGF0YSA6IHRoaXMubWV0YWRhdGEpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLCAoX2IgPSBuYW1lICE9PSBudWxsICYmIG5hbWUgIT09IHZvaWQgMCA/IG5hbWUgOiB0aGlzLm5hbWUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICcnLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nU2lnbmFsUmVxdWVzdHMuc2V0KHJlcXVlc3RJZCwge1xuICAgICAgICAgICAgICByZXNvbHZlLFxuICAgICAgICAgICAgICByZWplY3Q6IGVycm9yID0+IHtcbiAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIGlzUmVqZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICB2YWx1ZXM6IHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB3aGlsZSAocGVyZm9ybWFuY2Uubm93KCkgLSBzdGFydFRpbWUgPCA1MDAwICYmICFpc1JlamVjdGVkKSB7XG4gICAgICAgICAgICAgIGlmICgoIW5hbWUgfHwgdGhpcy5uYW1lID09PSBuYW1lKSAmJiAoIW1ldGFkYXRhIHx8IHRoaXMubWV0YWRhdGEgPT09IG1ldGFkYXRhKSAmJiAoIWF0dHJpYnV0ZXMgfHwgT2JqZWN0LmVudHJpZXMoYXR0cmlidXRlcykuZXZlcnkoX3JlZjIgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmMjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5hdHRyaWJ1dGVzW2tleV0gPT09IHZhbHVlIHx8IHZhbHVlID09PSAnJyAmJiAhdGhpcy5hdHRyaWJ1dGVzW2tleV07XG4gICAgICAgICAgICAgIH0pKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1NpZ25hbFJlcXVlc3RzLmRlbGV0ZShyZXF1ZXN0SWQpO1xuICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQgc2xlZXAoNTApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVqZWN0KG5ldyBTaWduYWxSZXF1ZXN0RXJyb3IoJ1JlcXVlc3QgdG8gdXBkYXRlIGxvY2FsIG1ldGFkYXRhIHRpbWVkIG91dCcsICdUaW1lb3V0RXJyb3InKSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvcikgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBFbmFibGUgb3IgZGlzYWJsZSBhIHBhcnRpY2lwYW50J3MgY2FtZXJhIHRyYWNrLlxuICAgKlxuICAgKiBJZiBhIHRyYWNrIGhhcyBhbHJlYWR5IHB1Ymxpc2hlZCwgaXQnbGwgbXV0ZSBvciB1bm11dGUgdGhlIHRyYWNrLlxuICAgKiBSZXNvbHZlcyB3aXRoIGEgYExvY2FsVHJhY2tQdWJsaWNhdGlvbmAgaW5zdGFuY2UgaWYgc3VjY2Vzc2Z1bCBhbmQgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlXG4gICAqL1xuICBzZXRDYW1lcmFFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5DYW1lcmEsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuICAvKipcbiAgICogRW5hYmxlIG9yIGRpc2FibGUgYSBwYXJ0aWNpcGFudCdzIG1pY3JvcGhvbmUgdHJhY2suXG4gICAqXG4gICAqIElmIGEgdHJhY2sgaGFzIGFscmVhZHkgcHVibGlzaGVkLCBpdCdsbCBtdXRlIG9yIHVubXV0ZSB0aGUgdHJhY2suXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcbiAgICovXG4gIHNldE1pY3JvcGhvbmVFbmFibGVkKGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0VHJhY2tFbmFibGVkKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lLCBlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIFN0YXJ0IG9yIHN0b3Agc2hhcmluZyBhIHBhcnRpY2lwYW50J3Mgc2NyZWVuXG4gICAqIFJlc29sdmVzIHdpdGggYSBgTG9jYWxUcmFja1B1YmxpY2F0aW9uYCBpbnN0YW5jZSBpZiBzdWNjZXNzZnVsIGFuZCBgdW5kZWZpbmVkYCBvdGhlcndpc2VcbiAgICovXG4gIHNldFNjcmVlblNoYXJlRW5hYmxlZChlbmFibGVkLCBvcHRpb25zLCBwdWJsaXNoT3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnNldFRyYWNrRW5hYmxlZChUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFBlcm1pc3Npb25zKHBlcm1pc3Npb25zKSB7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb25zID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICBjb25zdCBjaGFuZ2VkID0gc3VwZXIuc2V0UGVybWlzc2lvbnMocGVybWlzc2lvbnMpO1xuICAgIGlmIChjaGFuZ2VkICYmIHByZXZQZXJtaXNzaW9ucykge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQsIHByZXZQZXJtaXNzaW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBjaGFuZ2VkO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmVuY3J5cHRpb25UeXBlID0gZW5hYmxlZCA/IEVuY3J5cHRpb25fVHlwZS5HQ00gOiBFbmNyeXB0aW9uX1R5cGUuTk9ORTtcbiAgICAgIHlpZWxkIHRoaXMucmVwdWJsaXNoQWxsVHJhY2tzKHVuZGVmaW5lZCwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG4gIHNldFRyYWNrRW5hYmxlZChzb3VyY2UsIGVuYWJsZWQsIG9wdGlvbnMsIHB1Ymxpc2hPcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICB0aGlzLmxvZy5kZWJ1Zygnc2V0VHJhY2tFbmFibGVkJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZW5hYmxlZFxuICAgICAgfSkpO1xuICAgICAgaWYgKHRoaXMucmVwdWJsaXNoUHJvbWlzZSkge1xuICAgICAgICB5aWVsZCB0aGlzLnJlcHVibGlzaFByb21pc2U7XG4gICAgICB9XG4gICAgICBsZXQgdHJhY2sgPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICAgIGlmIChlbmFibGVkKSB7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgIHlpZWxkIHRyYWNrLnVubXV0ZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxldCBsb2NhbFRyYWNrcztcbiAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nUHVibGlzaGluZy5oYXMoc291cmNlKSkge1xuICAgICAgICAgICAgY29uc3QgcGVuZGluZ1RyYWNrID0geWllbGQgdGhpcy53YWl0Rm9yUGVuZGluZ1B1YmxpY2F0aW9uT2ZTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICAgIGlmICghcGVuZGluZ1RyYWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ3dhaXRpbmcgZm9yIHBlbmRpbmcgcHVibGljYXRpb24gcHJvbWlzZSB0aW1lZCBvdXQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICBzb3VyY2VcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgcGVuZGluZ1RyYWNrID09PSBudWxsIHx8IHBlbmRpbmdUcmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGVuZGluZ1RyYWNrLnVubXV0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHBlbmRpbmdUcmFjaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoc291cmNlKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3dpdGNoIChzb3VyY2UpIHtcbiAgICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuQ2FtZXJhOlxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVUcmFja3Moe1xuICAgICAgICAgICAgICAgICAgdmlkZW86IChfYSA9IG9wdGlvbnMpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgICAgICAgICBsb2NhbFRyYWNrcyA9IHlpZWxkIHRoaXMuY3JlYXRlVHJhY2tzKHtcbiAgICAgICAgICAgICAgICAgIGF1ZGlvOiAoX2IgPSBvcHRpb25zKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgVHJhY2suU291cmNlLlNjcmVlblNoYXJlOlxuICAgICAgICAgICAgICAgIGxvY2FsVHJhY2tzID0geWllbGQgdGhpcy5jcmVhdGVTY3JlZW5UcmFja3MoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucykpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcihzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvY2FsVHJhY2tzID09PSBudWxsIHx8IGxvY2FsVHJhY2tzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsb2NhbFRyYWNrcy5mb3JFYWNoKHRyID0+IHtcbiAgICAgICAgICAgICAgdHIuc3RvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50Lk1lZGlhRGV2aWNlc0Vycm9yLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKHNvdXJjZSk7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcHVibGlzaFByb21pc2VzID0gW107XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxvY2FsVHJhY2sgb2YgbG9jYWxUcmFja3MpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbygncHVibGlzaGluZyB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhsb2NhbFRyYWNrKSkpO1xuICAgICAgICAgICAgICBwdWJsaXNoUHJvbWlzZXMucHVzaCh0aGlzLnB1Ymxpc2hUcmFjayhsb2NhbFRyYWNrLCBwdWJsaXNoT3B0aW9ucykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHVibGlzaGVkVHJhY2tzID0geWllbGQgUHJvbWlzZS5hbGwocHVibGlzaFByb21pc2VzKTtcbiAgICAgICAgICAgIC8vIGZvciBzY3JlZW4gc2hhcmUgcHVibGljYXRpb25zIGluY2x1ZGluZyBhdWRpbywgdGhpcyB3aWxsIG9ubHkgcmV0dXJuIHRoZSBzY3JlZW4gc2hhcmUgcHVibGljYXRpb24sIG5vdCB0aGUgc2NyZWVuIHNoYXJlIGF1ZGlvIG9uZVxuICAgICAgICAgICAgLy8gcmV2aXNpdCBpZiB3ZSB3YW50IHRvIHJldHVybiBhbiBhcnJheSBvZiB0cmFja3MgaW5zdGVhZCBmb3IgdjJcbiAgICAgICAgICAgIFt0cmFja10gPSBwdWJsaXNoZWRUcmFja3M7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9jYWxUcmFja3MgPT09IG51bGwgfHwgbG9jYWxUcmFja3MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxvY2FsVHJhY2tzLmZvckVhY2godHIgPT4ge1xuICAgICAgICAgICAgICB0ci5zdG9wKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuZGVsZXRlKHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoISh0cmFjayA9PT0gbnVsbCB8fCB0cmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogdHJhY2sudHJhY2spICYmIHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKHNvdXJjZSkpIHtcbiAgICAgICAgICAvLyBpZiB0aGVyZSdzIG5vIHRyYWNrIGF2YWlsYWJsZSB5ZXQgZmlyc3Qgd2FpdCBmb3IgcGVuZGluZyBwdWJsaXNoaW5nIHByb21pc2VzIG9mIHRoYXQgc291cmNlIHRvIHNlZSBpZiBpdCBiZWNvbWVzIGF2YWlsYWJsZVxuICAgICAgICAgIHRyYWNrID0geWllbGQgdGhpcy53YWl0Rm9yUGVuZGluZ1B1YmxpY2F0aW9uT2ZTb3VyY2Uoc291cmNlKTtcbiAgICAgICAgICBpZiAoIXRyYWNrKSB7XG4gICAgICAgICAgICB0aGlzLmxvZy5pbmZvKCd3YWl0aW5nIGZvciBwZW5kaW5nIHB1YmxpY2F0aW9uIHByb21pc2UgdGltZWQgb3V0JywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgICAgIHNvdXJjZVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHJhY2sgJiYgdHJhY2sudHJhY2spIHtcbiAgICAgICAgICAvLyBzY3JlZW5zaGFyZSBjYW5ub3QgYmUgbXV0ZWQsIHVucHVibGlzaCBpbnN0ZWFkXG4gICAgICAgICAgaWYgKHNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgICB0cmFjayA9IHlpZWxkIHRoaXMudW5wdWJsaXNoVHJhY2sodHJhY2sudHJhY2spO1xuICAgICAgICAgICAgY29uc3Qgc2NyZWVuQXVkaW9UcmFjayA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbyk7XG4gICAgICAgICAgICBpZiAoc2NyZWVuQXVkaW9UcmFjayAmJiBzY3JlZW5BdWRpb1RyYWNrLnRyYWNrKSB7XG4gICAgICAgICAgICAgIHRoaXMudW5wdWJsaXNoVHJhY2soc2NyZWVuQXVkaW9UcmFjay50cmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHlpZWxkIHRyYWNrLm11dGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaCBib3RoIGNhbWVyYSBhbmQgbWljcm9waG9uZSBhdCB0aGUgc2FtZSB0aW1lLiBUaGlzIGlzIHVzZWZ1bCBmb3JcbiAgICogZGlzcGxheWluZyBhIHNpbmdsZSBQZXJtaXNzaW9uIERpYWxvZyBib3ggdG8gdGhlIGVuZCB1c2VyLlxuICAgKi9cbiAgZW5hYmxlQ2FtZXJhQW5kTWljcm9waG9uZSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKFRyYWNrLlNvdXJjZS5DYW1lcmEpIHx8IHRoaXMucGVuZGluZ1B1Ymxpc2hpbmcuaGFzKFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKSkge1xuICAgICAgICAvLyBuby1vcCBpdCdzIGFscmVhZHkgYmVlbiByZXF1ZXN0ZWRcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5hZGQoVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmFkZChUcmFjay5Tb3VyY2UuTWljcm9waG9uZSk7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB0cmFja3MgPSB5aWVsZCB0aGlzLmNyZWF0ZVRyYWNrcyh7XG4gICAgICAgICAgYXVkaW86IHRydWUsXG4gICAgICAgICAgdmlkZW86IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodHJhY2sgPT4gdGhpcy5wdWJsaXNoVHJhY2sodHJhY2spKSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB0aGlzLnBlbmRpbmdQdWJsaXNoaW5nLmRlbGV0ZShUcmFjay5Tb3VyY2UuQ2FtZXJhKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nUHVibGlzaGluZy5kZWxldGUoVHJhY2suU291cmNlLk1pY3JvcGhvbmUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgbG9jYWwgY2FtZXJhIGFuZC9vciBtaWNyb3Bob25lIHRyYWNrc1xuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKiBAcmV0dXJuc1xuICAgKi9cbiAgY3JlYXRlVHJhY2tzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IG9wdGlvbnMgPSB7fTtcbiAgICAgIGNvbnN0IG1lcmdlZE9wdGlvbnNXaXRoUHJvY2Vzc29ycyA9IG1lcmdlRGVmYXVsdE9wdGlvbnMob3B0aW9ucywgKF9hID0gdGhpcy5yb29tT3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLCAoX2IgPSB0aGlzLnJvb21PcHRpb25zKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmlkZW9DYXB0dXJlRGVmYXVsdHMpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdHJhY2tzID0geWllbGQgY3JlYXRlTG9jYWxUcmFja3MobWVyZ2VkT3B0aW9uc1dpdGhQcm9jZXNzb3JzLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBsb2NhbFRyYWNrcyA9IHRyYWNrcy5tYXAodHJhY2sgPT4ge1xuICAgICAgICAgIGlmIChpc0F1ZGlvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgICB0aGlzLm1pY3JvcGhvbmVFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dCh0aGlzLmF1ZGlvQ29udGV4dCk7XG4gICAgICAgICAgICB0cmFjay5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNWaWRlb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgICAgdGhpcy5jYW1lcmFFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRyYWNrLnNvdXJjZSA9IFRyYWNrLlNvdXJjZS5DYW1lcmE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiB0cmFjaztcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBsb2NhbFRyYWNrcztcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBpZiAob3B0aW9ucy5hdWRpbykge1xuICAgICAgICAgICAgdGhpcy5taWNyb3Bob25lRXJyb3IgPSBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnZpZGVvKSB7XG4gICAgICAgICAgICB0aGlzLmNhbWVyYUVycm9yID0gZXJyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzY3JlZW4gY2FwdHVyZSB0cmFja3Mgd2l0aCBnZXREaXNwbGF5TWVkaWEoKS5cbiAgICogQSBMb2NhbFZpZGVvVHJhY2sgaXMgYWx3YXlzIGNyZWF0ZWQgYW5kIHJldHVybmVkLlxuICAgKiBJZiB7IGF1ZGlvOiB0cnVlIH0sIGFuZCB0aGUgYnJvd3NlciBzdXBwb3J0cyBhdWRpbyBjYXB0dXJlLCBhIExvY2FsQXVkaW9UcmFjayBpcyBhbHNvIGNyZWF0ZWQuXG4gICAqL1xuICBjcmVhdGVTY3JlZW5UcmFja3Mob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAob3B0aW9ucyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgIH1cbiAgICAgIGlmIChuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBEZXZpY2VVbnN1cHBvcnRlZEVycm9yKCdnZXREaXNwbGF5TWVkaWEgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMucmVzb2x1dGlvbiA9PT0gdW5kZWZpbmVkICYmICFpc1NhZmFyaTE3KCkpIHtcbiAgICAgICAgLy8gd2UgbmVlZCB0byBjb25zdHJhaW4gdGhlIGRpbWVuc2lvbnMsIG90aGVyd2lzZSBpdCBjb3VsZCBsZWFkIHRvIGxvdyBiaXRyYXRlXG4gICAgICAgIC8vIGR1ZSB0byBlbmNvZGluZyBhIGh1Z2UgdmlkZW8uIEVuY29kaW5nIHN1Y2ggbGFyZ2Ugc3VyZmFjZXMgaXMgcmVhbGx5IGV4cGVuc2l2ZVxuICAgICAgICAvLyB1bmZvcnR1bmF0ZWx5IFNhZmFyaSAxNyBoYXMgYSBidXQgYW5kIGNhbm5vdCBiZSBjb25zdHJhaW5lZCBieSBkZWZhdWx0XG4gICAgICAgIG9wdGlvbnMucmVzb2x1dGlvbiA9IFNjcmVlblNoYXJlUHJlc2V0cy5oMTA4MGZwczMwLnJlc29sdXRpb247XG4gICAgICB9XG4gICAgICBjb25zdCBjb25zdHJhaW50cyA9IHNjcmVlbkNhcHR1cmVUb0Rpc3BsYXlNZWRpYVN0cmVhbU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICBjb25zdCBzdHJlYW0gPSB5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldERpc3BsYXlNZWRpYShjb25zdHJhaW50cyk7XG4gICAgICBjb25zdCB0cmFja3MgPSBzdHJlYW0uZ2V0VmlkZW9UcmFja3MoKTtcbiAgICAgIGlmICh0cmFja3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcignbm8gdmlkZW8gdHJhY2sgZm91bmQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNjcmVlblZpZGVvID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFja3NbMF0sIHVuZGVmaW5lZCwgZmFsc2UsIHtcbiAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgfSk7XG4gICAgICBzY3JlZW5WaWRlby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmU7XG4gICAgICBpZiAob3B0aW9ucy5jb250ZW50SGludCkge1xuICAgICAgICBzY3JlZW5WaWRlby5tZWRpYVN0cmVhbVRyYWNrLmNvbnRlbnRIaW50ID0gb3B0aW9ucy5jb250ZW50SGludDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxvY2FsVHJhY2tzID0gW3NjcmVlblZpZGVvXTtcbiAgICAgIGlmIChzdHJlYW0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQpO1xuICAgICAgICBjb25zdCBzY3JlZW5BdWRpbyA9IG5ldyBMb2NhbEF1ZGlvVHJhY2soc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF0sIHVuZGVmaW5lZCwgZmFsc2UsIHRoaXMuYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5yb29tT3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICBzY3JlZW5BdWRpby5zb3VyY2UgPSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmVBdWRpbztcbiAgICAgICAgbG9jYWxUcmFja3MucHVzaChzY3JlZW5BdWRpbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbG9jYWxUcmFja3M7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBuZXcgdHJhY2sgdG8gdGhlIHJvb21cbiAgICogQHBhcmFtIHRyYWNrXG4gICAqIEBwYXJhbSBvcHRpb25zXG4gICAqL1xuICBwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMucHVibGlzaE9yUmVwdWJsaXNoVHJhY2sodHJhY2ssIG9wdGlvbnMpO1xuICAgIH0pO1xuICB9XG4gIHB1Ymxpc2hPclJlcHVibGlzaFRyYWNrKHRyYWNrXzEsIG9wdGlvbnNfMSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgYXJndW1lbnRzLCB2b2lkIDAsIGZ1bmN0aW9uICh0cmFjaywgb3B0aW9ucykge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG4gICAgICBsZXQgaXNSZXB1Ymxpc2ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICAgIHRyYWNrLnNldEF1ZGlvQ29udGV4dChfdGhpczIuYXVkaW9Db250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCAoX2EgPSBfdGhpczIucmVjb25uZWN0RnV0dXJlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucHJvbWlzZTtcbiAgICAgICAgaWYgKF90aGlzMi5yZXB1Ymxpc2hQcm9taXNlICYmICFpc1JlcHVibGlzaCkge1xuICAgICAgICAgIHlpZWxkIF90aGlzMi5yZXB1Ymxpc2hQcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0xvY2FsVHJhY2sodHJhY2spICYmIF90aGlzMi5wZW5kaW5nUHVibGlzaFByb21pc2VzLmhhcyh0cmFjaykpIHtcbiAgICAgICAgICB5aWVsZCBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5nZXQodHJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGxldCBkZWZhdWx0Q29uc3RyYWludHM7XG4gICAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5nZXRDb25zdHJhaW50cygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIHdlIHdhbnQgdG8gYWNjZXNzIGNvbnN0cmFpbnRzIGRpcmVjdGx5IGFzIGB0cmFjay5tZWRpYVN0cmVhbVRyYWNrYFxuICAgICAgICAgIC8vIG1pZ2h0IGJlIHBvaW50aW5nIHRvIGEgbm9uLWRldmljZSB0cmFjayAoZS5nLiBwcm9jZXNzZWQgdHJhY2spIGFscmVhZHlcbiAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSB0cmFjay5jb25zdHJhaW50cztcbiAgICAgICAgICBsZXQgZGV2aWNlS2luZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBzd2l0Y2ggKHRyYWNrLnNvdXJjZSkge1xuICAgICAgICAgICAgY2FzZSBUcmFjay5Tb3VyY2UuTWljcm9waG9uZTpcbiAgICAgICAgICAgICAgZGV2aWNlS2luZCA9ICdhdWRpb2lucHV0JztcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFRyYWNrLlNvdXJjZS5DYW1lcmE6XG4gICAgICAgICAgICAgIGRldmljZUtpbmQgPSAndmlkZW9pbnB1dCc7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkZXZpY2VLaW5kICYmIF90aGlzMi5hY3RpdmVEZXZpY2VNYXAuaGFzKGRldmljZUtpbmQpKSB7XG4gICAgICAgICAgICBkZWZhdWx0Q29uc3RyYWludHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25zdHJhaW50cyksIHtcbiAgICAgICAgICAgICAgZGV2aWNlSWQ6IF90aGlzMi5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gY29udmVydCByYXcgbWVkaWEgdHJhY2sgaW50byBhdWRpbyBvciB2aWRlbyB0cmFja1xuICAgICAgICBpZiAodHJhY2sgaW5zdGFuY2VvZiBNZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgc3dpdGNoICh0cmFjay5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgICAgICAgIHRyYWNrID0gbmV3IExvY2FsQXVkaW9UcmFjayh0cmFjaywgZGVmYXVsdENvbnN0cmFpbnRzLCB0cnVlLCBfdGhpczIuYXVkaW9Db250ZXh0LCB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiBfdGhpczIubG9nQ29udGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICd2aWRlbyc6XG4gICAgICAgICAgICAgIHRyYWNrID0gbmV3IExvY2FsVmlkZW9UcmFjayh0cmFjaywgZGVmYXVsdENvbnN0cmFpbnRzLCB0cnVlLCB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyTmFtZTogX3RoaXMyLnJvb21PcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiBfdGhpczIubG9nQ29udGV4dFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoXCJ1bnN1cHBvcnRlZCBNZWRpYVN0cmVhbVRyYWNrIGtpbmQgXCIuY29uY2F0KHRyYWNrLmtpbmQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJhY2sudXBkYXRlTG9nZ2VyT3B0aW9ucyh7XG4gICAgICAgICAgICBsb2dnZXJOYW1lOiBfdGhpczIucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gX3RoaXMyLmxvZ0NvbnRleHRcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpcyBpdCBhbHJlYWR5IHB1Ymxpc2hlZD8gaWYgc28gc2tpcFxuICAgICAgICBsZXQgZXhpc3RpbmdQdWJsaWNhdGlvbjtcbiAgICAgICAgX3RoaXMyLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgICAgIGlmICghcHVibGljYXRpb24udHJhY2spIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHB1YmxpY2F0aW9uLnRyYWNrID09PSB0cmFjaykge1xuICAgICAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IHB1YmxpY2F0aW9uO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChleGlzdGluZ1B1YmxpY2F0aW9uKSB7XG4gICAgICAgICAgX3RoaXMyLmxvZy53YXJuKCd0cmFjayBoYXMgYWxyZWFkeSBiZWVuIHB1Ymxpc2hlZCwgc2tpcHBpbmcnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhleGlzdGluZ1B1YmxpY2F0aW9uKSkpO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGlzU3RlcmVvSW5wdXQgPSAnY2hhbm5lbENvdW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldFNldHRpbmdzKCkgJiZcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBgY2hhbm5lbENvdW50YCBvbiBnZXRTZXR0aW5ncygpIGlzIGN1cnJlbnRseSBvbmx5IGF2YWlsYWJsZSBmb3IgU2FmYXJpLCBidXQgaXMgZ2VuZXJhbGx5IHRoZSBiZXN0IHdheSB0byBkZXRlcm1pbmUgYSBzdGVyZW8gdHJhY2sgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL01lZGlhVHJhY2tTZXR0aW5ncy9jaGFubmVsQ291bnRcbiAgICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5nZXRTZXR0aW5ncygpLmNoYW5uZWxDb3VudCA9PT0gMiB8fCB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmdldENvbnN0cmFpbnRzKCkuY2hhbm5lbENvdW50ID09PSAyO1xuICAgICAgICBjb25zdCBpc1N0ZXJlbyA9IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mb3JjZVN0ZXJlbykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogaXNTdGVyZW9JbnB1dDtcbiAgICAgICAgLy8gZGlzYWJsZSBkdHggZm9yIHN0ZXJlbyB0cmFjayBpZiBub3QgZW5hYmxlZCBleHBsaWNpdGx5XG4gICAgICAgIGlmIChpc1N0ZXJlbykge1xuICAgICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAob3B0aW9ucy5kdHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgX3RoaXMyLmxvZy5pbmZvKFwiT3B1cyBEVFggd2lsbCBiZSBkaXNhYmxlZCBmb3Igc3RlcmVvIHRyYWNrcyBieSBkZWZhdWx0LiBFbmFibGUgdGhlbSBleHBsaWNpdGx5IHRvIG1ha2UgaXQgd29yay5cIiwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChvcHRpb25zLnJlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBfdGhpczIubG9nLmluZm8oXCJPcHVzIFJFRCB3aWxsIGJlIGRpc2FibGVkIGZvciBzdGVyZW8gdHJhY2tzIGJ5IGRlZmF1bHQuIEVuYWJsZSB0aGVtIGV4cGxpY2l0bHkgdG8gbWFrZSBpdCB3b3JrLlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9jID0gb3B0aW9ucy5kdHgpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IG9wdGlvbnMuZHR4ID0gZmFsc2U7XG4gICAgICAgICAgKF9kID0gb3B0aW9ucy5yZWQpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IG9wdGlvbnMucmVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgX3RoaXMyLnJvb21PcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgICAgICBpZiAoIWlzRTJFRVNpbXVsY2FzdFN1cHBvcnRlZCgpICYmIF90aGlzMi5yb29tT3B0aW9ucy5lMmVlKSB7XG4gICAgICAgICAgX3RoaXMyLmxvZy5pbmZvKFwiRW5kLXRvLWVuZCBlbmNyeXB0aW9uIGlzIHNldCB1cCwgc2ltdWxjYXN0IHB1Ymxpc2hpbmcgd2lsbCBiZSBkaXNhYmxlZCBvbiBTYWZhcmkgdmVyc2lvbnMgYW5kIGlPUyBicm93c2VycyBydW5uaW5nIGlPUyA8IHYxNy4yXCIsIE9iamVjdC5hc3NpZ24oe30sIF90aGlzMi5sb2dDb250ZXh0KSk7XG4gICAgICAgICAgb3B0cy5zaW11bGNhc3QgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0cy5zb3VyY2UpIHtcbiAgICAgICAgICB0cmFjay5zb3VyY2UgPSBvcHRzLnNvdXJjZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpczIsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodGhpcy5lbmdpbmUuY2xpZW50LmN1cnJlbnRTdGF0ZSAhPT0gU2lnbmFsQ29ubmVjdGlvblN0YXRlLkNPTk5FQ1RFRCkge1xuICAgICAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnZGVmZXJyaW5nIHRyYWNrIHB1YmxpY2F0aW9uIHVudGlsIHNpZ25hbCBpcyBjb25uZWN0ZWQnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICB0cmFjazogZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaylcbiAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICBjb25zdCBvblNpZ25hbENvbm5lY3RlZCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgcHVibGljYXRpb24gPSB5aWVsZCB0aGlzLnB1Ymxpc2godHJhY2ssIG9wdHMsIGlzU3RlcmVvKTtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmUocHVibGljYXRpb24pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5vZmYoRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCBvblNpZ25hbENvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQdWJsaXNoVHJhY2tFcnJvcigncHVibGlzaGluZyByZWplY3RlZCBhcyBlbmdpbmUgbm90IGNvbm5lY3RlZCB3aXRoaW4gdGltZW91dCcsIDQwOCkpO1xuICAgICAgICAgICAgICB9LCAxNTAwMCk7XG4gICAgICAgICAgICAgIHRoaXMuZW5naW5lLm9uY2UoRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCBvblNpZ25hbENvbm5lY3RlZCk7XG4gICAgICAgICAgICAgIHRoaXMuZW5naW5lLm9uKEVuZ2luZUV2ZW50LkNsb3NpbmcsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmVuZ2luZS5vZmYoRW5naW5lRXZlbnQuU2lnbmFsQ29ubmVjdGVkLCBvblNpZ25hbENvbm5lY3RlZCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBQdWJsaXNoVHJhY2tFcnJvcigncHVibGlzaGluZyByZWplY3RlZCBhcyBlbmdpbmUgY2xvc2VkJywgNDk5KSk7XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHRoaXMucHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pO1xuICAgICAgICAgICAgICAgIHJlc29sdmUocHVibGljYXRpb24pO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICBfdGhpczIucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5zZXQodHJhY2ssIHB1Ymxpc2hQcm9taXNlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHlpZWxkIHB1Ymxpc2hQcm9taXNlO1xuICAgICAgICAgIHJldHVybiBwdWJsaWNhdGlvbjtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgX3RoaXMyLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZGVsZXRlKHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIGhhc1Blcm1pc3Npb25zVG9QdWJsaXNoKHRyYWNrKSB7XG4gICAgaWYgKCF0aGlzLnBlcm1pc3Npb25zKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdubyBwZXJtaXNzaW9ucyBwcmVzZW50IGZvciBwdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYW5QdWJsaXNoLFxuICAgICAgY2FuUHVibGlzaFNvdXJjZXNcbiAgICB9ID0gdGhpcy5wZXJtaXNzaW9ucztcbiAgICBpZiAoY2FuUHVibGlzaCAmJiAoY2FuUHVibGlzaFNvdXJjZXMubGVuZ3RoID09PSAwIHx8IGNhblB1Ymxpc2hTb3VyY2VzLm1hcChzb3VyY2UgPT4gZ2V0VHJhY2tTb3VyY2VGcm9tUHJvdG8oc291cmNlKSkuaW5jbHVkZXModHJhY2suc291cmNlKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aGlzLmxvZy53YXJuKCdpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMgdG8gcHVibGlzaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayh0cmFjaykpKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcHVibGlzaCh0cmFjaywgb3B0cywgaXNTdGVyZW8pIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaCwgX2osIF9rO1xuICAgICAgaWYgKCF0aGlzLmhhc1Blcm1pc3Npb25zVG9QdWJsaXNoKHRyYWNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgUHVibGlzaFRyYWNrRXJyb3IoJ2ZhaWxlZCB0byBwdWJsaXNoIHRyYWNrLCBpbnN1ZmZpY2llbnQgcGVybWlzc2lvbnMnLCA0MDMpO1xuICAgICAgfVxuICAgICAgY29uc3QgZXhpc3RpbmdUcmFja09mU291cmNlID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5maW5kKHB1Ymxpc2hlZFRyYWNrID0+IGlzTG9jYWxUcmFjayh0cmFjaykgJiYgcHVibGlzaGVkVHJhY2suc291cmNlID09PSB0cmFjay5zb3VyY2UpO1xuICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiB0cmFjay5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgIHRoaXMubG9nLmluZm8oXCJwdWJsaXNoaW5nIGEgc2Vjb25kIHRyYWNrIHdpdGggdGhlIHNhbWUgc291cmNlOiBcIi5jb25jYXQodHJhY2suc291cmNlKSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgfVxuICAgICAgaWYgKG9wdHMuc3RvcE1pY1RyYWNrT25NdXRlICYmIGlzQXVkaW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJhY2suc3RvcE9uTXV0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodHJhY2suc291cmNlID09PSBUcmFjay5Tb3VyY2UuU2NyZWVuU2hhcmUgJiYgaXNGaXJlRm94KCkpIHtcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCB3b3JrIHdlbGwgd2l0aCBzaW11bGNhc3RlZCBzY3JlZW4gc2hhcmVcbiAgICAgICAgLy8gd2UgZnJlcXVlbnRseSBnZXQgbm8gZGF0YSBvbiBsYXllciAwIHdoZW4gZW5hYmxlZFxuICAgICAgICBvcHRzLnNpbXVsY2FzdCA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gcmVxdWlyZSBmdWxsIEFWMS9WUDkgU1ZDIHN1cHBvcnQgcHJpb3IgdG8gdXNpbmcgaXRcbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICdhdjEnICYmICFzdXBwb3J0c0FWMSgpKSB7XG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09ICd2cDknICYmICFzdXBwb3J0c1ZQOSgpKSB7XG4gICAgICAgIG9wdHMudmlkZW9Db2RlYyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRzLnZpZGVvQ29kZWMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSBkZWZhdWx0VmlkZW9Db2RlYztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAvLyBmYWxsYmFjayB0byBhIHN1cHBvcnRlZCBjb2RlYyBpZiBpdCBpcyBub3Qgc3VwcG9ydGVkXG4gICAgICAgIGlmICghdGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzLnNvbWUoYyA9PiBvcHRzLnZpZGVvQ29kZWMgPT09IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKGMubWltZSkpKSB7XG4gICAgICAgICAgb3B0cy52aWRlb0NvZGVjID0gbWltZVR5cGVUb1ZpZGVvQ29kZWNTdHJpbmcodGhpcy5lbmFibGVkUHVibGlzaFZpZGVvQ29kZWNzWzBdLm1pbWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCB2aWRlb0NvZGVjID0gb3B0cy52aWRlb0NvZGVjO1xuICAgICAgLy8gaGFuZGxlIHRyYWNrIGFjdGlvbnNcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVW5tdXRlZCwgdGhpcy5vblRyYWNrVW5tdXRlZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZVRyYWNrRW5kZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5VcHN0cmVhbVJlc3VtZWQsIHRoaXMub25UcmFja1Vwc3RyZWFtUmVzdW1lZCk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlLCB0aGlzLm9uVHJhY2tGZWF0dXJlVXBkYXRlKTtcbiAgICAgIC8vIGNyZWF0ZSB0cmFjayBwdWJsaWNhdGlvbiBmcm9tIHRyYWNrXG4gICAgICBjb25zdCByZXEgPSBuZXcgQWRkVHJhY2tSZXF1ZXN0KHtcbiAgICAgICAgLy8gZ2V0IGxvY2FsIHRyYWNrIGlkIGZvciB1c2UgZHVyaW5nIHB1Ymxpc2hpbmdcbiAgICAgICAgY2lkOiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrLmlkLFxuICAgICAgICBuYW1lOiBvcHRzLm5hbWUsXG4gICAgICAgIHR5cGU6IFRyYWNrLmtpbmRUb1Byb3RvKHRyYWNrLmtpbmQpLFxuICAgICAgICBtdXRlZDogdHJhY2suaXNNdXRlZCxcbiAgICAgICAgc291cmNlOiBUcmFjay5zb3VyY2VUb1Byb3RvKHRyYWNrLnNvdXJjZSksXG4gICAgICAgIGRpc2FibGVEdHg6ICEoKF9hID0gb3B0cy5kdHgpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRydWUpLFxuICAgICAgICBlbmNyeXB0aW9uOiB0aGlzLmVuY3J5cHRpb25UeXBlLFxuICAgICAgICBzdGVyZW86IGlzU3RlcmVvLFxuICAgICAgICBkaXNhYmxlUmVkOiB0aGlzLmlzRTJFRUVuYWJsZWQgfHwgISgoX2IgPSBvcHRzLnJlZCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogdHJ1ZSksXG4gICAgICAgIHN0cmVhbTogb3B0cyA9PT0gbnVsbCB8fCBvcHRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRzLnN0cmVhbSxcbiAgICAgICAgYmFja3VwQ29kZWNQb2xpY3k6IG9wdHMgPT09IG51bGwgfHwgb3B0cyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0cy5iYWNrdXBDb2RlY1BvbGljeVxuICAgICAgfSk7XG4gICAgICAvLyBjb21wdXRlIGVuY29kaW5ncyBhbmQgbGF5ZXJzIGZvciB2aWRlb1xuICAgICAgbGV0IGVuY29kaW5ncztcbiAgICAgIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLlZpZGVvKSB7XG4gICAgICAgIGxldCBkaW1zID0ge1xuICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgIGhlaWdodDogMFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGRpbXMgPSB5aWVsZCB0cmFjay53YWl0Rm9yRGltZW5zaW9ucygpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgLy8gdXNlIGRlZmF1bHRzLCBpdCdzIHF1aXRlIHBhaW5mdWwgZm9yIGNvbmdlc3Rpb24gY29udHJvbCB3aXRob3V0IHNpbXVsY2FzdFxuICAgICAgICAgIC8vIHNvIHVzaW5nIGRlZmF1bHQgZGltcyBhY2NvcmRpbmcgdG8gcHVibGlzaCBzZXR0aW5nc1xuICAgICAgICAgIGNvbnN0IGRlZmF1bHRSZXMgPSAoX2QgPSAoX2MgPSB0aGlzLnJvb21PcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVzb2x1dGlvbikgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogVmlkZW9QcmVzZXRzLmg3MjAucmVzb2x1dGlvbjtcbiAgICAgICAgICBkaW1zID0ge1xuICAgICAgICAgICAgd2lkdGg6IGRlZmF1bHRSZXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGRlZmF1bHRSZXMuaGVpZ2h0XG4gICAgICAgICAgfTtcbiAgICAgICAgICAvLyBsb2cgZmFpbHVyZVxuICAgICAgICAgIHRoaXMubG9nLmVycm9yKCdjb3VsZCBub3QgZGV0ZXJtaW5lIHRyYWNrIGRpbWVuc2lvbnMsIHVzaW5nIGRlZmF1bHRzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSwge1xuICAgICAgICAgICAgZGltc1xuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IHNob3VsZCBiZSBkZWZpbmVkIGZvciB2aWRlb1xuICAgICAgICByZXEud2lkdGggPSBkaW1zLndpZHRoO1xuICAgICAgICByZXEuaGVpZ2h0ID0gZGltcy5oZWlnaHQ7XG4gICAgICAgIC8vIGZvciBzdmMgY29kZWNzLCBkaXNhYmxlIHNpbXVsY2FzdCBhbmQgdXNlIHZwOCBmb3IgYmFja3VwIGNvZGVjXG4gICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICBpZiAoaXNTVkNDb2RlYyh2aWRlb0NvZGVjKSkge1xuICAgICAgICAgICAgaWYgKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlKSB7XG4gICAgICAgICAgICAgIC8vIHZwOSBzdmMgd2l0aCBzY3JlZW5zaGFyZSBjYW5ub3QgZW5jb2RlIG11bHRpcGxlIHNwYXRpYWwgbGF5ZXJzXG4gICAgICAgICAgICAgIC8vIGRvaW5nIHNvIHJlZHVjZXMgcHVibGlzaCByZXNvbHV0aW9uIHRvIG1pbmltYWwgcmVzb2x1dGlvblxuICAgICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9ICdMMVQzJztcbiAgICAgICAgICAgICAgLy8gQ2hyb21lIGRvZXMgbm90IGFsbG93IG1vcmUgdGhhbiA1IGZwcyB3aXRoIEwxVDMsIGFuZCBpdCBoYXMgZW5jb2RpbmcgYnVncyB3aXRoIEwzVDNcbiAgICAgICAgICAgICAgLy8gSXQgaGFzIGEgZGlmZmVyZW50IHBhdGggZm9yIHNjcmVlbnNoYXJlIGhhbmRsaW5nIGFuZCBpdCBzZWVtcyB0byBiZSB1bnRlc3RlZC9idWdneVxuICAgICAgICAgICAgICAvLyBBcyBhIHdvcmthcm91bmQsIHdlIGFyZSBzZXR0aW5nIGNvbnRlbnRIaW50IHRvIGZvcmNlIGl0IHRvIGdvIHRocm91Z2ggdGhlIHNhbWVcbiAgICAgICAgICAgICAgLy8gcGF0aCBhcyByZWd1bGFyIGNhbWVyYSB2aWRlby4gV2hpbGUgdGhpcyBpcyBub3Qgb3B0aW1hbCwgaXQgZGVsaXZlcnMgdGhlIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAgIC8vIHRoYXQgd2UgbmVlZFxuICAgICAgICAgICAgICBpZiAoJ2NvbnRlbnRIaW50JyBpbiB0cmFjay5tZWRpYVN0cmVhbVRyYWNrKSB7XG4gICAgICAgICAgICAgICAgdHJhY2subWVkaWFTdHJlYW1UcmFjay5jb250ZW50SGludCA9ICdtb3Rpb24nO1xuICAgICAgICAgICAgICAgIHRoaXMubG9nLmluZm8oJ2ZvcmNpbmcgY29udGVudEhpbnQgdG8gbW90aW9uIGZvciBzY3JlZW5zaGFyZSB3aXRoIFNWQyBjb2RlY3MnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHNldCBzY2FsYWJpbGl0eU1vZGUgdG8gJ0wzVDNfS0VZJyBieSBkZWZhdWx0XG4gICAgICAgICAgICBvcHRzLnNjYWxhYmlsaXR5TW9kZSA9IChfZSA9IG9wdHMuc2NhbGFiaWxpdHlNb2RlKSAhPT0gbnVsbCAmJiBfZSAhPT0gdm9pZCAwID8gX2UgOiAnTDNUM19LRVknO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzID0gW25ldyBTaW11bGNhc3RDb2RlYyh7XG4gICAgICAgICAgICBjb2RlYzogdmlkZW9Db2RlYyxcbiAgICAgICAgICAgIGNpZDogdHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxuICAgICAgICAgIH0pXTtcbiAgICAgICAgICAvLyBzZXQgdXAgYmFja3VwXG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgPT09IHRydWUpIHtcbiAgICAgICAgICAgIG9wdHMuYmFja3VwQ29kZWMgPSB7XG4gICAgICAgICAgICAgIGNvZGVjOiBkZWZhdWx0VmlkZW9Db2RlY1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG9wdHMuYmFja3VwQ29kZWMgJiYgdmlkZW9Db2RlYyAhPT0gb3B0cy5iYWNrdXBDb2RlYy5jb2RlYyAmJlxuICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIGNvZGVjc1xuICAgICAgICAgIHJlcS5lbmNyeXB0aW9uID09PSBFbmNyeXB0aW9uX1R5cGUuTk9ORSkge1xuICAgICAgICAgICAgLy8gbXVsdGktY29kZWMgc2ltdWxjYXN0IHJlcXVpcmVzIGR5bmFjYXN0XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbU9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgICAgICAgdGhpcy5yb29tT3B0aW9ucy5keW5hY2FzdCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEuc2ltdWxjYXN0Q29kZWNzLnB1c2gobmV3IFNpbXVsY2FzdENvZGVjKHtcbiAgICAgICAgICAgICAgY29kZWM6IG9wdHMuYmFja3VwQ29kZWMuY29kZWMsXG4gICAgICAgICAgICAgIGNpZDogJydcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmdzID0gY29tcHV0ZVZpZGVvRW5jb2RpbmdzKHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlLCByZXEud2lkdGgsIHJlcS5oZWlnaHQsIG9wdHMpO1xuICAgICAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHJlcS53aWR0aCwgcmVxLmhlaWdodCwgZW5jb2RpbmdzLCBpc1NWQ0NvZGVjKG9wdHMudmlkZW9Db2RlYykpO1xuICAgICAgfSBlbHNlIGlmICh0cmFjay5raW5kID09PSBUcmFjay5LaW5kLkF1ZGlvKSB7XG4gICAgICAgIGVuY29kaW5ncyA9IFt7XG4gICAgICAgICAgbWF4Qml0cmF0ZTogKF9mID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2YgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9mLm1heEJpdHJhdGUsXG4gICAgICAgICAgcHJpb3JpdHk6IChfaCA9IChfZyA9IG9wdHMuYXVkaW9QcmVzZXQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5wcmlvcml0eSkgIT09IG51bGwgJiYgX2ggIT09IHZvaWQgMCA/IF9oIDogJ2hpZ2gnLFxuICAgICAgICAgIG5ldHdvcmtQcmlvcml0eTogKF9rID0gKF9qID0gb3B0cy5hdWRpb1ByZXNldCkgPT09IG51bGwgfHwgX2ogPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9qLnByaW9yaXR5KSAhPT0gbnVsbCAmJiBfayAhPT0gdm9pZCAwID8gX2sgOiAnaGlnaCdcbiAgICAgICAgfV07XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZW5naW5lIHx8IHRoaXMuZW5naW5lLmlzQ2xvc2VkKSB7XG4gICAgICAgIHRocm93IG5ldyBVbmV4cGVjdGVkQ29ubmVjdGlvblN0YXRlKCdjYW5ub3QgcHVibGlzaCB0cmFjayB3aGVuIG5vdCBjb25uZWN0ZWQnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5lZ290aWF0ZSA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIGlmICghdGhpcy5lbmdpbmUucGNNYW5hZ2VyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ3BjTWFuYWdlciBpcyBub3QgcmVhZHknKTtcbiAgICAgICAgfVxuICAgICAgICB0cmFjay5zZW5kZXIgPSB5aWVsZCB0aGlzLmVuZ2luZS5jcmVhdGVTZW5kZXIodHJhY2ssIG9wdHMsIGVuY29kaW5ncyk7XG4gICAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgICAoX2EgPSBvcHRzLmRlZ3JhZGF0aW9uUHJlZmVyZW5jZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogb3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UgPSBnZXREZWZhdWx0RGVncmFkYXRpb25QcmVmZXJlbmNlKHRyYWNrKTtcbiAgICAgICAgICB0cmFjay5zZXREZWdyYWRhdGlvblByZWZlcmVuY2Uob3B0cy5kZWdyYWRhdGlvblByZWZlcmVuY2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICBpZiAoaXNGaXJlRm94KCkgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5BdWRpbykge1xuICAgICAgICAgICAgLyogUmVmZXIgdG8gUkZDIGh0dHBzOi8vZGF0YXRyYWNrZXIuaWV0Zi5vcmcvZG9jL2h0bWwvcmZjNzU4NyNzZWN0aW9uLTYuMSxcbiAgICAgICAgICAgICAgIGxpdmVraXQtc2VydmVyIHVzZXMgbWF4YXZlcmFnZWJpdHJhdGU9NTEwMDAwIGluIHRoZSBhbnN3ZXIgc2RwIHRvIHBlcm1pdCBjbGllbnQgdG9cbiAgICAgICAgICAgICAgIHB1Ymxpc2ggaGlnaCBxdWFsaXR5IGF1ZGlvIHRyYWNrLiBCdXQgZmlyZWZveCBhbHdheXMgdXNlcyB0aGlzIHZhbHVlIGFzIHRoZSBhY3R1YWxcbiAgICAgICAgICAgICAgIGJpdHJhdGVzLCBjYXVzaW5nIHRoZSBhdWRpbyBiaXRyYXRlcyB0byByaXNlIHRvIDUxMEticHMgaW4gYW55IHN0ZXJlbyBjYXNlIHVuZXhwZWN0ZWRseS5cbiAgICAgICAgICAgICAgIFNvIHRoZSBjbGllbnQgbmVlZCB0byBtb2RpZnkgbWF4YXZlcnJhZ2ViaXRyYXRlcyBpbiBhbnN3ZXIgc2RwIHRvIHVzZXIgcHJvdmlkZWQgdmFsdWUgdG9cbiAgICAgICAgICAgICAgIGZpeCB0aGUgaXNzdWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCB0cmFja1RyYW5zY2VpdmVyID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrLnNlbmRlcikge1xuICAgICAgICAgICAgICAgIHRyYWNrVHJhbnNjZWl2ZXIgPSB0cmFuc2NlaXZlcjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYWNrVHJhbnNjZWl2ZXIpIHtcbiAgICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XG4gICAgICAgICAgICAgICAgdHJhbnNjZWl2ZXI6IHRyYWNrVHJhbnNjZWl2ZXIsXG4gICAgICAgICAgICAgICAgY29kZWM6ICdvcHVzJyxcbiAgICAgICAgICAgICAgICBtYXhicjogKChfYiA9IGVuY29kaW5nc1swXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm1heEJpdHJhdGUpID8gZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwIDogMFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKHRyYWNrLmNvZGVjICYmIGlzU1ZDQ29kZWModHJhY2suY29kZWMpICYmICgoX2MgPSBlbmNvZGluZ3NbMF0pID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5tYXhCaXRyYXRlKSkge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLnB1Ymxpc2hlci5zZXRUcmFja0NvZGVjQml0cmF0ZSh7XG4gICAgICAgICAgICAgIGNpZDogcmVxLmNpZCxcbiAgICAgICAgICAgICAgY29kZWM6IHRyYWNrLmNvZGVjLFxuICAgICAgICAgICAgICBtYXhicjogZW5jb2RpbmdzWzBdLm1heEJpdHJhdGUgLyAxMDAwXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUubmVnb3RpYXRlKCk7XG4gICAgICB9KTtcbiAgICAgIGxldCB0aTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zdCByZXRzID0geWllbGQgUHJvbWlzZS5hbGwoW3RoaXMuZW5naW5lLmFkZFRyYWNrKHJlcSksIG5lZ290aWF0ZSgpXSk7XG4gICAgICAgIHRpID0gcmV0c1swXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpID0geWllbGQgdGhpcy5lbmdpbmUuYWRkVHJhY2socmVxKTtcbiAgICAgICAgLy8gc2VydmVyIG1pZ2h0IG5vdCBzdXBwb3J0IHRoZSBjb2RlYyB0aGUgY2xpZW50IGhhcyByZXF1ZXN0ZWQsIGluIHRoYXQgY2FzZSwgZmFsbGJhY2tcbiAgICAgICAgLy8gdG8gYSBzdXBwb3J0ZWQgY29kZWNcbiAgICAgICAgbGV0IHByaW1hcnlDb2RlY01pbWU7XG4gICAgICAgIHRpLmNvZGVjcy5mb3JFYWNoKGNvZGVjID0+IHtcbiAgICAgICAgICBpZiAocHJpbWFyeUNvZGVjTWltZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwcmltYXJ5Q29kZWNNaW1lID0gY29kZWMubWltZVR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHByaW1hcnlDb2RlY01pbWUgJiYgdHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRDb2RlYyA9IG1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nKHByaW1hcnlDb2RlY01pbWUpO1xuICAgICAgICAgIGlmICh1cGRhdGVkQ29kZWMgIT09IHZpZGVvQ29kZWMpIHtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdmYWxsaW5nIGJhY2sgdG8gc2VydmVyIHNlbGVjdGVkIGNvZGVjJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSwge1xuICAgICAgICAgICAgICBjb2RlYzogdXBkYXRlZENvZGVjXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBvcHRzLnZpZGVvQ29kZWMgPSB1cGRhdGVkQ29kZWM7XG4gICAgICAgICAgICAvLyByZWNvbXB1dGUgZW5jb2RpbmdzIHNpbmNlIGJpdHJhdGVzL2V0YyBjb3VsZCBoYXZlIGNoYW5nZWRcbiAgICAgICAgICAgIGVuY29kaW5ncyA9IGNvbXB1dGVWaWRlb0VuY29kaW5ncyh0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5TY3JlZW5TaGFyZSwgcmVxLndpZHRoLCByZXEuaGVpZ2h0LCBvcHRzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgbmVnb3RpYXRlKCk7XG4gICAgICB9XG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IG5ldyBMb2NhbFRyYWNrUHVibGljYXRpb24odHJhY2sua2luZCwgdGksIHRyYWNrLCB7XG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMucm9vbU9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgIH0pO1xuICAgICAgLy8gc2F2ZSBvcHRpb25zIGZvciB3aGVuIGl0IG5lZWRzIHRvIGJlIHJlcHVibGlzaGVkIGFnYWluXG4gICAgICBwdWJsaWNhdGlvbi5vcHRpb25zID0gb3B0cztcbiAgICAgIHRyYWNrLnNpZCA9IHRpLnNpZDtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwicHVibGlzaGluZyBcIi5jb25jYXQodHJhY2sua2luZCwgXCIgd2l0aCBlbmNvZGluZ3NcIiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgIHRyYWNrSW5mbzogdGlcbiAgICAgIH0pKTtcbiAgICAgIGlmIChpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpIHtcbiAgICAgICAgdHJhY2suc3RhcnRNb25pdG9yKHRoaXMuZW5naW5lLmNsaWVudCk7XG4gICAgICB9IGVsc2UgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgICB0cmFjay5zdGFydE1vbml0b3IoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkVHJhY2tQdWJsaWNhdGlvbihwdWJsaWNhdGlvbik7XG4gICAgICAvLyBzZW5kIGV2ZW50IGZvciBwdWJsaWNhdGlvblxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1B1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH0pO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIC8qKiBAaW50ZXJuYWxcbiAgICogcHVibGlzaCBhZGRpdGlvbmFsIGNvZGVjIHRvIGV4aXN0aW5nIHRyYWNrXG4gICAqL1xuICBwdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2sodHJhY2ssIHZpZGVvQ29kZWMsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hO1xuICAgICAgLy8gVE9ETyByZW1vdmUgb25jZSBlMmVlIGlzIHN1cHBvcnRlZCBmb3IgYmFja3VwIHRyYWNrc1xuICAgICAgaWYgKHRoaXMuZW5jcnlwdGlvblR5cGUgIT09IEVuY3J5cHRpb25fVHlwZS5OT05FKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlzIGl0IG5vdCBwdWJsaXNoZWQ/IGlmIHNvIHNraXBcbiAgICAgIGxldCBleGlzdGluZ1B1YmxpY2F0aW9uO1xuICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgICAgaWYgKCFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHVibGljYXRpb24udHJhY2sgPT09IHRyYWNrKSB7XG4gICAgICAgICAgZXhpc3RpbmdQdWJsaWNhdGlvbiA9IHB1YmxpY2F0aW9uO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmICghZXhpc3RpbmdQdWJsaWNhdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgVHJhY2tJbnZhbGlkRXJyb3IoJ3RyYWNrIGlzIG5vdCBwdWJsaXNoZWQnKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBUcmFja0ludmFsaWRFcnJvcigndHJhY2sgaXMgbm90IGEgdmlkZW8gdHJhY2snKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wdWJsaXNoRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICAgIGNvbnN0IGVuY29kaW5ncyA9IGNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyh0cmFjaywgdmlkZW9Db2RlYywgb3B0cyk7XG4gICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKFwiYmFja3VwIGNvZGVjIGhhcyBiZWVuIGRpc2FibGVkLCBpZ25vcmluZyByZXF1ZXN0IHRvIGFkZCBhZGRpdGlvbmFsIGNvZGVjIGZvciB0cmFja1wiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2sodHJhY2spKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNpbXVsY2FzdFRyYWNrID0gdHJhY2suYWRkU2ltdWxjYXN0VHJhY2sodmlkZW9Db2RlYywgZW5jb2RpbmdzKTtcbiAgICAgIGlmICghc2ltdWxjYXN0VHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVxID0gbmV3IEFkZFRyYWNrUmVxdWVzdCh7XG4gICAgICAgIGNpZDogc2ltdWxjYXN0VHJhY2subWVkaWFTdHJlYW1UcmFjay5pZCxcbiAgICAgICAgdHlwZTogVHJhY2sua2luZFRvUHJvdG8odHJhY2sua2luZCksXG4gICAgICAgIG11dGVkOiB0cmFjay5pc011dGVkLFxuICAgICAgICBzb3VyY2U6IFRyYWNrLnNvdXJjZVRvUHJvdG8odHJhY2suc291cmNlKSxcbiAgICAgICAgc2lkOiB0cmFjay5zaWQsXG4gICAgICAgIHNpbXVsY2FzdENvZGVjczogW3tcbiAgICAgICAgICBjb2RlYzogb3B0cy52aWRlb0NvZGVjLFxuICAgICAgICAgIGNpZDogc2ltdWxjYXN0VHJhY2subWVkaWFTdHJlYW1UcmFjay5pZFxuICAgICAgICB9XVxuICAgICAgfSk7XG4gICAgICByZXEubGF5ZXJzID0gdmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzKHJlcS53aWR0aCwgcmVxLmhlaWdodCwgZW5jb2RpbmdzKTtcbiAgICAgIGlmICghdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUoJ2Nhbm5vdCBwdWJsaXNoIHRyYWNrIHdoZW4gbm90IGNvbm5lY3RlZCcpO1xuICAgICAgfVxuICAgICAgY29uc3QgbmVnb3RpYXRlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jcmVhdGVTaW11bGNhc3RTZW5kZXIodHJhY2ssIHNpbXVsY2FzdFRyYWNrLCBvcHRzLCBlbmNvZGluZ3MpO1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5uZWdvdGlhdGUoKTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmV0cyA9IHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmVuZ2luZS5hZGRUcmFjayhyZXEpLCBuZWdvdGlhdGUoKV0pO1xuICAgICAgY29uc3QgdGkgPSByZXRzWzBdO1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJwdWJsaXNoZWQgXCIuY29uY2F0KHZpZGVvQ29kZWMsIFwiIGZvciB0cmFjayBcIikuY29uY2F0KHRyYWNrLnNpZCksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICBlbmNvZGluZ3MsXG4gICAgICAgIHRyYWNrSW5mbzogdGlcbiAgICAgIH0pKTtcbiAgICB9KTtcbiAgfVxuICB1bnB1Ymxpc2hUcmFjayh0cmFjaywgc3RvcE9uVW5wdWJsaXNoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBpZiAoaXNMb2NhbFRyYWNrKHRyYWNrKSkge1xuICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZSA9IHRoaXMucGVuZGluZ1B1Ymxpc2hQcm9taXNlcy5nZXQodHJhY2spO1xuICAgICAgICBpZiAocHVibGlzaFByb21pc2UpIHtcbiAgICAgICAgICB0aGlzLmxvZy5pbmZvKCdhd2FpdGluZyBwdWJsaXNoIHByb21pc2UgYmVmb3JlIGF0dGVtcHRpbmcgdG8gdW5wdWJsaXNoJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHRyYWNrKSkpO1xuICAgICAgICAgIHlpZWxkIHB1Ymxpc2hQcm9taXNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBsb29rIHRocm91Z2ggYWxsIHB1Ymxpc2hlZCB0cmFja3MgdG8gZmluZCB0aGUgcmlnaHQgb25lc1xuICAgICAgY29uc3QgcHVibGljYXRpb24gPSB0aGlzLmdldFB1YmxpY2F0aW9uRm9yVHJhY2sodHJhY2spO1xuICAgICAgY29uc3QgcHViTG9nQ29udGV4dCA9IHB1YmxpY2F0aW9uID8gZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikgOiB1bmRlZmluZWQ7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZygndW5wdWJsaXNoaW5nIHRyYWNrJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSk7XG4gICAgICBpZiAoIXB1YmxpY2F0aW9uIHx8ICFwdWJsaWNhdGlvbi50cmFjaykge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCd0cmFjayB3YXMgbm90IHVucHVibGlzaGVkIGJlY2F1c2Ugbm8gcHVibGljYXRpb24gd2FzIGZvdW5kJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBwdWJMb2dDb250ZXh0KSk7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB0cmFjayA9IHB1YmxpY2F0aW9uLnRyYWNrO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuTXV0ZWQsIHRoaXMub25UcmFja011dGVkKTtcbiAgICAgIHRyYWNrLm9mZihUcmFja0V2ZW50LlVubXV0ZWQsIHRoaXMub25UcmFja1VubXV0ZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuRW5kZWQsIHRoaXMuaGFuZGxlVHJhY2tFbmRlZCk7XG4gICAgICB0cmFjay5vZmYoVHJhY2tFdmVudC5VcHN0cmVhbVBhdXNlZCwgdGhpcy5vblRyYWNrVXBzdHJlYW1QYXVzZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuVXBzdHJlYW1SZXN1bWVkLCB0aGlzLm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQpO1xuICAgICAgdHJhY2sub2ZmKFRyYWNrRXZlbnQuQXVkaW9UcmFja0ZlYXR1cmVVcGRhdGUsIHRoaXMub25UcmFja0ZlYXR1cmVVcGRhdGUpO1xuICAgICAgaWYgKHN0b3BPblVucHVibGlzaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHN0b3BPblVucHVibGlzaCA9IChfYiA9IChfYSA9IHRoaXMucm9vbU9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKHN0b3BPblVucHVibGlzaCkge1xuICAgICAgICB0cmFjay5zdG9wKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFjay5zdG9wTW9uaXRvcigpO1xuICAgICAgfVxuICAgICAgbGV0IG5lZ290aWF0aW9uTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCB0cmFja1NlbmRlciA9IHRyYWNrLnNlbmRlcjtcbiAgICAgIHRyYWNrLnNlbmRlciA9IHVuZGVmaW5lZDtcbiAgICAgIGlmICh0aGlzLmVuZ2luZS5wY01hbmFnZXIgJiYgdGhpcy5lbmdpbmUucGNNYW5hZ2VyLmN1cnJlbnRTdGF0ZSA8IFBDVHJhbnNwb3J0U3RhdGUuRkFJTEVEICYmIHRyYWNrU2VuZGVyKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgZm9yIChjb25zdCB0cmFuc2NlaXZlciBvZiB0aGlzLmVuZ2luZS5wY01hbmFnZXIucHVibGlzaGVyLmdldFRyYW5zY2VpdmVycygpKSB7XG4gICAgICAgICAgICAvLyBpZiBzZW5kZXIgaXMgbm90IGN1cnJlbnRseSBzZW5kaW5nIChhZnRlciByZXBsYWNlVHJhY2sobnVsbCkpXG4gICAgICAgICAgICAvLyByZW1vdmVUcmFjayB3b3VsZCBoYXZlIG5vIGVmZmVjdC5cbiAgICAgICAgICAgIC8vIHRvIGVuc3VyZSB3ZSBlbmQgdXAgc3VjY2Vzc2Z1bGx5IHJlbW92aW5nIHRoZSB0cmFjaywgbWFudWFsbHkgc2V0XG4gICAgICAgICAgICAvLyB0aGUgdHJhbnNjZWl2ZXIgdG8gaW5hY3RpdmVcbiAgICAgICAgICAgIGlmICh0cmFuc2NlaXZlci5zZW5kZXIgPT09IHRyYWNrU2VuZGVyKSB7XG4gICAgICAgICAgICAgIHRyYW5zY2VpdmVyLmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICAgIG5lZ290aWF0aW9uTmVlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrU2VuZGVyKSkge1xuICAgICAgICAgICAgbmVnb3RpYXRpb25OZWVkZWQgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNMb2NhbFZpZGVvVHJhY2sodHJhY2spKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHRyYWNrSW5mb10gb2YgdHJhY2suc2ltdWxjYXN0Q29kZWNzKSB7XG4gICAgICAgICAgICAgIGlmICh0cmFja0luZm8uc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZW5naW5lLnJlbW92ZVRyYWNrKHRyYWNrSW5mby5zZW5kZXIpKSB7XG4gICAgICAgICAgICAgICAgICBuZWdvdGlhdGlvbk5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYWNrSW5mby5zZW5kZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYWNrLnNpbXVsY2FzdENvZGVjcy5jbGVhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ2ZhaWxlZCB0byB1bnB1Ymxpc2ggdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgcHViTG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyByZW1vdmUgZnJvbSBvdXIgbWFwc1xuICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgc3dpdGNoIChwdWJsaWNhdGlvbi5raW5kKSB7XG4gICAgICAgIGNhc2UgVHJhY2suS2luZC5BdWRpbzpcbiAgICAgICAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHB1YmxpY2F0aW9uLnRyYWNrU2lkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICAgIHRoaXMudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5kZWxldGUocHVibGljYXRpb24udHJhY2tTaWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgICBwdWJsaWNhdGlvbi5zZXRUcmFjayh1bmRlZmluZWQpO1xuICAgICAgaWYgKG5lZ290aWF0aW9uTmVlZGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLm5lZ290aWF0ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICAgIH0pO1xuICB9XG4gIHVucHVibGlzaFRyYWNrcyh0cmFja3MpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIFByb21pc2UuYWxsKHRyYWNrcy5tYXAodHJhY2sgPT4gdGhpcy51bnB1Ymxpc2hUcmFjayh0cmFjaykpKTtcbiAgICAgIHJldHVybiByZXN1bHRzLmZpbHRlcih0cmFjayA9PiAhIXRyYWNrKTtcbiAgICB9KTtcbiAgfVxuICByZXB1Ymxpc2hBbGxUcmFja3Mob3B0aW9uc18xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuICAgICAgbGV0IHJlc3RhcnRUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKF90aGlzMy5yZXB1Ymxpc2hQcm9taXNlKSB7XG4gICAgICAgICAgeWllbGQgX3RoaXMzLnJlcHVibGlzaFByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMzLnJlcHVibGlzaFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBfX2F3YWl0ZXIoX3RoaXMzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxQdWJzID0gW107XG4gICAgICAgICAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgICAgICAgICAgaWYgKHB1Yi50cmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgICBwdWIub3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHViLm9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxQdWJzLnB1c2gocHViKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChsb2NhbFB1YnMubWFwKHB1YiA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHRyYWNrID0gcHViLnRyYWNrO1xuICAgICAgICAgICAgICB5aWVsZCB0aGlzLnVucHVibGlzaFRyYWNrKHRyYWNrLCBmYWxzZSk7XG4gICAgICAgICAgICAgIGlmIChyZXN0YXJ0VHJhY2tzICYmICF0cmFjay5pc011dGVkICYmIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlICYmIHRyYWNrLnNvdXJjZSAhPT0gVHJhY2suU291cmNlLlNjcmVlblNoYXJlQXVkaW8gJiYgKGlzTG9jYWxBdWRpb1RyYWNrKHRyYWNrKSB8fCBpc0xvY2FsVmlkZW9UcmFjayh0cmFjaykpICYmICF0cmFjay5pc1VzZXJQcm92aWRlZCkge1xuICAgICAgICAgICAgICAgIC8vIGdlbmVyYWxseSB3ZSBuZWVkIHRvIHJlc3RhcnQgdGhlIHRyYWNrIGJlZm9yZSBwdWJsaXNoaW5nLCBvZnRlbiBhIGZ1bGwgcmVjb25uZWN0XG4gICAgICAgICAgICAgICAgLy8gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgY29tcHV0ZXIgaGFkIGdvbmUgdG8gc2xlZXAuXG4gICAgICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoJ3Jlc3RhcnRpbmcgZXhpc3RpbmcgdHJhY2snLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICAgICAgICAgIHRyYWNrOiBwdWIudHJhY2tTaWRcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgeWllbGQgdHJhY2sucmVzdGFydFRyYWNrKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgeWllbGQgdGhpcy5wdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayh0cmFjaywgcHViLm9wdGlvbnMsIHRydWUpO1xuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgdGhpcy5yZXB1Ymxpc2hQcm9taXNlID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICB5aWVsZCBfdGhpczMucmVwdWJsaXNoUHJvbWlzZTtcbiAgICAgIH0oKTtcbiAgICB9KTtcbiAgfVxuICAvKipcbiAgICogUHVibGlzaCBhIG5ldyBkYXRhIHBheWxvYWQgdG8gdGhlIHJvb20uIERhdGEgd2lsbCBiZSBmb3J3YXJkZWQgdG8gZWFjaFxuICAgKiBwYXJ0aWNpcGFudCBpbiB0aGUgcm9vbSBpZiB0aGUgZGVzdGluYXRpb24gZmllbGQgaW4gcHVibGlzaE9wdGlvbnMgaXMgZW1wdHlcbiAgICpcbiAgICogQHBhcmFtIGRhdGEgVWludDhBcnJheSBvZiB0aGUgcGF5bG9hZC4gVG8gc2VuZCBzdHJpbmcgZGF0YSwgdXNlIFRleHRFbmNvZGVyLmVuY29kZVxuICAgKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25hbGx5IHNwZWNpZnkgYSBgcmVsaWFibGVgLCBgdG9waWNgIGFuZCBgZGVzdGluYXRpb25gXG4gICAqL1xuICBwdWJsaXNoRGF0YShkYXRhXzEpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIGFyZ3VtZW50cywgdm9pZCAwLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XG4gICAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgICByZXR1cm4gZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3Qga2luZCA9IG9wdGlvbnMucmVsaWFibGUgPyBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUgOiBEYXRhUGFja2V0X0tpbmQuTE9TU1k7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdGlvbnMudG9waWM7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICBraW5kOiBraW5kLFxuICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICBjYXNlOiAndXNlcicsXG4gICAgICAgICAgICB2YWx1ZTogbmV3IFVzZXJQYWNrZXQoe1xuICAgICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBfdGhpczQuaWRlbnRpdHksXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICAgICAgdG9waWNcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgeWllbGQgX3RoaXM0LmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIGtpbmQpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBQdWJsaXNoIFNJUCBEVE1GIG1lc3NhZ2UgdG8gdGhlIHJvb20uXG4gICAqXG4gICAqIEBwYXJhbSBjb2RlIERUTUYgY29kZVxuICAgKiBAcGFyYW0gZGlnaXQgRFRNRiBkaWdpdFxuICAgKi9cbiAgcHVibGlzaER0bWYoY29kZSwgZGlnaXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBraW5kOiBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3NpcER0bWYnLFxuICAgICAgICAgIHZhbHVlOiBuZXcgU2lwRFRNRih7XG4gICAgICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICAgICAgZGlnaXQ6IGRpZ2l0XG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgfSk7XG4gIH1cbiAgc2VuZENoYXRNZXNzYWdlKHRleHQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgbXNnID0ge1xuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcbiAgICAgICAgbWVzc2FnZTogdGV4dCxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhdHRhY2hlZEZpbGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNobWVudHNcbiAgICAgIH07XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ2NoYXRNZXNzYWdlJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IENoYXRNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXNnKSwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKG1zZy50aW1lc3RhbXApXG4gICAgICAgICAgfSkpXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuQ2hhdE1lc3NhZ2UsIG1zZyk7XG4gICAgICByZXR1cm4gbXNnO1xuICAgIH0pO1xuICB9XG4gIGVkaXRDaGF0TWVzc2FnZShlZGl0VGV4dCwgb3JpZ2luYWxNZXNzYWdlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IG1zZyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3JpZ2luYWxNZXNzYWdlKSwge1xuICAgICAgICBtZXNzYWdlOiBlZGl0VGV4dCxcbiAgICAgICAgZWRpdFRpbWVzdGFtcDogRGF0ZS5ub3coKVxuICAgICAgfSk7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ2NoYXRNZXNzYWdlJyxcbiAgICAgICAgICB2YWx1ZTogbmV3IENoYXRNZXNzYWdlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbXNnKSwge1xuICAgICAgICAgICAgdGltZXN0YW1wOiBwcm90b0ludDY0LnBhcnNlKG1zZy50aW1lc3RhbXApLFxuICAgICAgICAgICAgZWRpdFRpbWVzdGFtcDogcHJvdG9JbnQ2NC5wYXJzZShtc2cuZWRpdFRpbWVzdGFtcClcbiAgICAgICAgICB9KSlcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5zZW5kRGF0YVBhY2tldChwYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgbXNnKTtcbiAgICAgIHJldHVybiBtc2c7XG4gICAgfSk7XG4gIH1cbiAgc2VuZFRleHQodGV4dCwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBzdHJlYW1JZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICBjb25zdCB0ZXh0SW5CeXRlcyA9IG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZSh0ZXh0KTtcbiAgICAgIGNvbnN0IHRvdGFsVGV4dExlbmd0aCA9IHRleHRJbkJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICBjb25zdCBmaWxlSWRzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dGFjaG1lbnRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFwKCgpID0+IGNyeXB0by5yYW5kb21VVUlEKCkpO1xuICAgICAgY29uc3QgcHJvZ3Jlc3NlcyA9IG5ldyBBcnJheShmaWxlSWRzID8gZmlsZUlkcy5sZW5ndGggKyAxIDogMSkuZmlsbCgwKTtcbiAgICAgIGNvbnN0IGhhbmRsZVByb2dyZXNzID0gKHByb2dyZXNzLCBpZHgpID0+IHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBwcm9ncmVzc2VzW2lkeF0gPSBwcm9ncmVzcztcbiAgICAgICAgY29uc3QgdG90YWxQcm9ncmVzcyA9IHByb2dyZXNzZXMucmVkdWNlKChhY2MsIHZhbCkgPT4gYWNjICsgdmFsLCAwKTtcbiAgICAgICAgKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm9uUHJvZ3Jlc3MpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKG9wdGlvbnMsIHRvdGFsUHJvZ3Jlc3MpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IHlpZWxkIHRoaXMuc3RyZWFtVGV4dCh7XG4gICAgICAgIHN0cmVhbUlkLFxuICAgICAgICB0b3RhbFNpemU6IHRvdGFsVGV4dExlbmd0aCxcbiAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICB0b3BpYzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljLFxuICAgICAgICBhdHRhY2hlZFN0cmVhbUlkczogZmlsZUlkcyxcbiAgICAgICAgYXR0cmlidXRlczogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmF0dHJpYnV0ZXNcbiAgICAgIH0pO1xuICAgICAgeWllbGQgd3JpdGVyLndyaXRlKHRleHQpO1xuICAgICAgLy8gc2V0IHRleHQgcGFydCBvZiBwcm9ncmVzcyB0byAxXG4gICAgICBoYW5kbGVQcm9ncmVzcygxLCAwKTtcbiAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xuICAgICAgaWYgKChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0YWNobWVudHMpICYmIGZpbGVJZHMpIHtcbiAgICAgICAgeWllbGQgUHJvbWlzZS5hbGwob3B0aW9ucy5hdHRhY2htZW50cy5tYXAoKGZpbGUsIGlkeCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHJldHVybiB0aGlzLl9zZW5kRmlsZShmaWxlSWRzW2lkeF0sIGZpbGUsIHtcbiAgICAgICAgICAgIHRvcGljOiBvcHRpb25zLnRvcGljLFxuICAgICAgICAgICAgbWltZVR5cGU6IGZpbGUudHlwZSxcbiAgICAgICAgICAgIG9uUHJvZ3Jlc3M6IHByb2dyZXNzID0+IHtcbiAgICAgICAgICAgICAgaGFuZGxlUHJvZ3Jlc3MocHJvZ3Jlc3MsIGlkeCArIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdyaXRlci5pbmZvO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQGV4cGVyaW1lbnRhbCBDQVVUSU9OLCBtaWdodCBnZXQgcmVtb3ZlZCBpbiBhIG1pbm9yIHJlbGVhc2VcbiAgICovXG4gIHN0cmVhbVRleHQob3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3Qgc3RyZWFtSWQgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc3RyZWFtSWQpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgIG1pbWVUeXBlOiAndGV4dC9wbGFpbicsXG4gICAgICAgIHRpbWVzdGFtcDogRGF0ZS5ub3coKSxcbiAgICAgICAgdG9waWM6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3BpYykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycsXG4gICAgICAgIHNpemU6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy50b3RhbFNpemUsXG4gICAgICAgIGF0dHJpYnV0ZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzXG4gICAgICB9O1xuICAgICAgY29uc3QgaGVhZGVyID0gbmV3IERhdGFTdHJlYW1fSGVhZGVyKHtcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIG1pbWVUeXBlOiBpbmZvLm1pbWVUeXBlLFxuICAgICAgICB0b3BpYzogaW5mby50b3BpYyxcbiAgICAgICAgdGltZXN0YW1wOiBudW1iZXJUb0JpZ0ludChpbmZvLnRpbWVzdGFtcCksXG4gICAgICAgIHRvdGFsTGVuZ3RoOiBudW1iZXJUb0JpZ0ludChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudG90YWxTaXplKSxcbiAgICAgICAgYXR0cmlidXRlczogaW5mby5hdHRyaWJ1dGVzLFxuICAgICAgICBjb250ZW50SGVhZGVyOiB7XG4gICAgICAgICAgY2FzZTogJ3RleHRIZWFkZXInLFxuICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YVN0cmVhbV9UZXh0SGVhZGVyKHtcbiAgICAgICAgICAgIHZlcnNpb246IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52ZXJzaW9uLFxuICAgICAgICAgICAgYXR0YWNoZWRTdHJlYW1JZHM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRhY2hlZFN0cmVhbUlkcyxcbiAgICAgICAgICAgIHJlcGx5VG9TdHJlYW1JZDogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnJlcGx5VG9TdHJlYW1JZCxcbiAgICAgICAgICAgIG9wZXJhdGlvblR5cGU6IChvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudHlwZSkgPT09ICd1cGRhdGUnID8gRGF0YVN0cmVhbV9PcGVyYXRpb25UeXBlLlVQREFURSA6IERhdGFTdHJlYW1fT3BlcmF0aW9uVHlwZS5DUkVBVEVcbiAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXM7XG4gICAgICBjb25zdCBwYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBjYXNlOiAnc3RyZWFtSGVhZGVyJyxcbiAgICAgICAgICB2YWx1ZTogaGVhZGVyXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgICAgbGV0IGNodW5rSWQgPSAwO1xuICAgICAgY29uc3QgbG9jYWxQID0gdGhpcztcbiAgICAgIGNvbnN0IHdyaXRhYmxlU3RyZWFtID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgLy8gSW1wbGVtZW50IHRoZSBzaW5rXG4gICAgICAgIHdyaXRlKHRleHQpIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0ZXh0Qnl0ZUNodW5rIG9mIHNwbGl0VXRmOCh0ZXh0LCBTVFJFQU1fQ0hVTktfU0laRSkpIHtcbiAgICAgICAgICAgICAgeWllbGQgbG9jYWxQLmVuZ2luZS53YWl0Rm9yQnVmZmVyU3RhdHVzTG93KERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gbmV3IERhdGFTdHJlYW1fQ2h1bmsoe1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IHRleHRCeXRlQ2h1bmssXG4gICAgICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICAgICAgY2h1bmtJbmRleDogbnVtYmVyVG9CaWdJbnQoY2h1bmtJZClcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNodW5rUGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgICAgY2FzZTogJ3N0cmVhbUNodW5rJyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBjaHVua1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHlpZWxkIGxvY2FsUC5lbmdpbmUuc2VuZERhdGFQYWNrZXQoY2h1bmtQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgICAgIGNodW5rSWQgKz0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXIgPSBuZXcgRGF0YVN0cmVhbV9UcmFpbGVyKHtcbiAgICAgICAgICAgICAgc3RyZWFtSWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgdHJhaWxlclBhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgICAgZGVzdGluYXRpb25JZGVudGl0aWVzLFxuICAgICAgICAgICAgICB2YWx1ZToge1xuICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1UcmFpbGVyJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdHJhaWxlclxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHlpZWxkIGxvY2FsUC5lbmdpbmUuc2VuZERhdGFQYWNrZXQodHJhaWxlclBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWJvcnQoZXJyKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ1NpbmsgZXJyb3I6JywgZXJyKTtcbiAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBhYm9ydHMgdG8gc2lnbmFsIHNvbWV0aGluZyB0byByZWNlaXZlciBzaWRlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgbGV0IG9uRW5naW5lQ2xvc2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkIHdyaXRlci5jbG9zZSgpO1xuICAgICAgfSk7XG4gICAgICBsb2NhbFAuZW5naW5lLm9uY2UoRW5naW5lRXZlbnQuQ2xvc2luZywgb25FbmdpbmVDbG9zZSk7XG4gICAgICBjb25zdCB3cml0ZXIgPSBuZXcgVGV4dFN0cmVhbVdyaXRlcih3cml0YWJsZVN0cmVhbSwgaW5mbywgKCkgPT4gdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LkNsb3NpbmcsIG9uRW5naW5lQ2xvc2UpKTtcbiAgICAgIHJldHVybiB3cml0ZXI7XG4gICAgfSk7XG4gIH1cbiAgc2VuZEZpbGUoZmlsZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBzdHJlYW1JZCA9IGNyeXB0by5yYW5kb21VVUlEKCk7XG4gICAgICB5aWVsZCB0aGlzLl9zZW5kRmlsZShzdHJlYW1JZCwgZmlsZSwgb3B0aW9ucyk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZDogc3RyZWFtSWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgX3NlbmRGaWxlKHN0cmVhbUlkLCBmaWxlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHdyaXRlciA9IHlpZWxkIHRoaXMuc3RyZWFtQnl0ZXMoe1xuICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgdG90YWxTaXplOiBmaWxlLnNpemUsXG4gICAgICAgIG5hbWU6IGZpbGUubmFtZSxcbiAgICAgICAgbWltZVR5cGU6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5taW1lVHlwZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZmlsZS50eXBlLFxuICAgICAgICB0b3BpYzogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljLFxuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXNcbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVhZGVyID0gZmlsZS5zdHJlYW0oKS5nZXRSZWFkZXIoKTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBkb25lLFxuICAgICAgICAgIHZhbHVlXG4gICAgICAgIH0gPSB5aWVsZCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHlpZWxkIHdyaXRlci53cml0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIHJldHVybiB3cml0ZXIuaW5mbztcbiAgICB9KTtcbiAgfVxuICBzdHJlYW1CeXRlcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICBjb25zdCBzdHJlYW1JZCA9IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zdHJlYW1JZCkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgIGNvbnN0IGRlc3RpbmF0aW9uSWRlbnRpdGllcyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5kZXN0aW5hdGlvbklkZW50aXRpZXM7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgIG1pbWVUeXBlOiAoX2IgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMubWltZVR5cGUpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nLFxuICAgICAgICB0b3BpYzogKF9jID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvcGljKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJyxcbiAgICAgICAgdGltZXN0YW1wOiBEYXRlLm5vdygpLFxuICAgICAgICBhdHRyaWJ1dGVzOiBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlcyxcbiAgICAgICAgc2l6ZTogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnRvdGFsU2l6ZSxcbiAgICAgICAgbmFtZTogKF9kID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLm5hbWUpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6ICd1bmtub3duJ1xuICAgICAgfTtcbiAgICAgIGNvbnN0IGhlYWRlciA9IG5ldyBEYXRhU3RyZWFtX0hlYWRlcih7XG4gICAgICAgIHRvdGFsTGVuZ3RoOiBudW1iZXJUb0JpZ0ludCgoX2UgPSBpbmZvLnNpemUpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IDApLFxuICAgICAgICBtaW1lVHlwZTogaW5mby5taW1lVHlwZSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHRvcGljOiBpbmZvLnRvcGljLFxuICAgICAgICB0aW1lc3RhbXA6IG51bWJlclRvQmlnSW50KERhdGUubm93KCkpLFxuICAgICAgICBjb250ZW50SGVhZGVyOiB7XG4gICAgICAgICAgY2FzZTogJ2J5dGVIZWFkZXInLFxuICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YVN0cmVhbV9CeXRlSGVhZGVyKHtcbiAgICAgICAgICAgIG5hbWU6IGluZm8ubmFtZVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXMsXG4gICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgY2FzZTogJ3N0cmVhbUhlYWRlcicsXG4gICAgICAgICAgdmFsdWU6IGhlYWRlclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnNlbmREYXRhUGFja2V0KHBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgIGxldCBjaHVua0lkID0gMDtcbiAgICAgIGNvbnN0IHdyaXRlTXV0ZXggPSBuZXcgXygpO1xuICAgICAgY29uc3QgZW5naW5lID0gdGhpcy5lbmdpbmU7XG4gICAgICBjb25zdCBsb2cgPSB0aGlzLmxvZztcbiAgICAgIGNvbnN0IHdyaXRhYmxlU3RyZWFtID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdW5sb2NrID0geWllbGQgd3JpdGVNdXRleC5sb2NrKCk7XG4gICAgICAgICAgICBsZXQgYnl0ZU9mZnNldCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB3aGlsZSAoYnl0ZU9mZnNldCA8IGNodW5rLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJDaHVuayA9IGNodW5rLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBTVFJFQU1fQ0hVTktfU0laRSk7XG4gICAgICAgICAgICAgICAgeWllbGQgZW5naW5lLndhaXRGb3JCdWZmZXJTdGF0dXNMb3coRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaHVua1BhY2tldCA9IG5ldyBEYXRhUGFja2V0KHtcbiAgICAgICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2U6ICdzdHJlYW1DaHVuaycsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXcgRGF0YVN0cmVhbV9DaHVuayh7XG4gICAgICAgICAgICAgICAgICAgICAgY29udGVudDogc3ViQ2h1bmssXG4gICAgICAgICAgICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICAgICAgICAgICAgY2h1bmtJbmRleDogbnVtYmVyVG9CaWdJbnQoY2h1bmtJZClcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB5aWVsZCBlbmdpbmUuc2VuZERhdGFQYWNrZXQoY2h1bmtQYWNrZXQsIERhdGFQYWNrZXRfS2luZC5SRUxJQUJMRSk7XG4gICAgICAgICAgICAgICAgY2h1bmtJZCArPSAxO1xuICAgICAgICAgICAgICAgIGJ5dGVPZmZzZXQgKz0gc3ViQ2h1bmsuYnl0ZUxlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgdW5sb2NrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsb3NlKCkge1xuICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0cmFpbGVyID0gbmV3IERhdGFTdHJlYW1fVHJhaWxlcih7XG4gICAgICAgICAgICAgIHN0cmVhbUlkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHRyYWlsZXJQYWNrZXQgPSBuZXcgRGF0YVBhY2tldCh7XG4gICAgICAgICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdGllcyxcbiAgICAgICAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICAgICAgICBjYXNlOiAnc3RyZWFtVHJhaWxlcicsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHRyYWlsZXJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB5aWVsZCBlbmdpbmUuc2VuZERhdGFQYWNrZXQodHJhaWxlclBhY2tldCwgRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgYWJvcnQoZXJyKSB7XG4gICAgICAgICAgbG9nLmVycm9yKCdTaW5rIGVycm9yOicsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYnl0ZVdyaXRlciA9IG5ldyBCeXRlU3RyZWFtV3JpdGVyKHdyaXRhYmxlU3RyZWFtLCBpbmZvKTtcbiAgICAgIHJldHVybiBieXRlV3JpdGVyO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZSBhbiBSUEMgY2FsbCB0byBhIHJlbW90ZSBwYXJ0aWNpcGFudFxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgaW5pdGlhdGluZyB0aGUgUlBDIGNhbGwsIHNlZSB7QGxpbmsgUGVyZm9ybVJwY1BhcmFtc31cbiAgICogQHJldHVybnMgQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgd2l0aCB0aGUgcmVzcG9uc2UgcGF5bG9hZCBvciByZWplY3RzIHdpdGggYW4gZXJyb3IuXG4gICAqIEB0aHJvd3MgRXJyb3Igb24gZmFpbHVyZS4gRGV0YWlscyBpbiBgbWVzc2FnZWAuXG4gICAqL1xuICBwZXJmb3JtUnBjKF9hKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKF9yZWYzKSB7XG4gICAgICB2YXIgX3RoaXM1ID0gdGhpcztcbiAgICAgIGxldCB7XG4gICAgICAgIGRlc3RpbmF0aW9uSWRlbnRpdHksXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgcmVzcG9uc2VUaW1lb3V0ID0gMTAwMDBcbiAgICAgIH0gPSBfcmVmMztcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBtYXhSb3VuZFRyaXBMYXRlbmN5ID0gMjAwMDtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IF9fYXdhaXRlcihfdGhpczUsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgICBpZiAoYnl0ZUxlbmd0aChwYXlsb2FkKSA+IE1BWF9QQVlMT0FEX0JZVEVTKSB7XG4gICAgICAgICAgICByZWplY3QoUnBjRXJyb3IuYnVpbHRJbignUkVRVUVTVF9QQVlMT0FEX1RPT19MQVJHRScpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCgoX2IgPSAoX2EgPSB0aGlzLmVuZ2luZS5sYXRlc3RKb2luUmVzcG9uc2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IudmVyc2lvbikgJiYgY29tcGFyZVZlcnNpb25zKChfZCA9IChfYyA9IHRoaXMuZW5naW5lLmxhdGVzdEpvaW5SZXNwb25zZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlcnZlckluZm8pID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC52ZXJzaW9uLCAnMS44LjAnKSA8IDApIHtcbiAgICAgICAgICAgIHJlamVjdChScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9TRVJWRVInKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGlkID0gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICAgICAgICB5aWVsZCB0aGlzLnB1Ymxpc2hScGNSZXF1ZXN0KGRlc3RpbmF0aW9uSWRlbnRpdHksIGlkLCBtZXRob2QsIHBheWxvYWQsIHJlc3BvbnNlVGltZW91dCAtIG1heFJvdW5kVHJpcExhdGVuY3kpO1xuICAgICAgICAgIGNvbnN0IGFja1RpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ0NPTk5FQ1RJT05fVElNRU9VVCcpKTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJlc3BvbnNlVGltZW91dElkKTtcbiAgICAgICAgICB9LCBtYXhSb3VuZFRyaXBMYXRlbmN5KTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdBY2tzLnNldChpZCwge1xuICAgICAgICAgICAgcmVzb2x2ZTogKCkgPT4ge1xuICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZW91dElkKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBkZXN0aW5hdGlvbklkZW50aXR5XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgcmVzcG9uc2VUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcmVqZWN0KFJwY0Vycm9yLmJ1aWx0SW4oJ1JFU1BPTlNFX1RJTUVPVVQnKSk7XG4gICAgICAgICAgfSwgcmVzcG9uc2VUaW1lb3V0KTtcbiAgICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuc2V0KGlkLCB7XG4gICAgICAgICAgICByZXNvbHZlOiAocmVzcG9uc2VQYXlsb2FkLCByZXNwb25zZUVycm9yKSA9PiB7XG4gICAgICAgICAgICAgIGNsZWFyVGltZW91dChyZXNwb25zZVRpbWVvdXRJZCk7XG4gICAgICAgICAgICAgIGlmICh0aGlzLnBlbmRpbmdBY2tzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1JQQyByZXNwb25zZSByZWNlaXZlZCBiZWZvcmUgYWNrJywgaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKGlkKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoYWNrVGltZW91dElkKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocmVzcG9uc2VFcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChyZXNwb25zZUVycm9yKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlUGF5bG9hZCAhPT0gbnVsbCAmJiByZXNwb25zZVBheWxvYWQgIT09IHZvaWQgMCA/IHJlc3BvbnNlUGF5bG9hZCA6ICcnKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IGRlc3RpbmF0aW9uSWRlbnRpdHlcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSkpO1xuICAgICAgfSgpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYHJvb20ucmVnaXN0ZXJScGNNZXRob2RgIGluc3RlYWRcbiAgICovXG4gIHJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKFwieW91J3JlIG92ZXJyaWRpbmcgdGhlIFJQQyBoYW5kbGVyIGZvciBtZXRob2QgXCIuY29uY2F0KG1ldGhvZCwgXCIsIGluIHRoZSBmdXR1cmUgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yXCIpKTtcbiAgICB9XG4gICAgdGhpcy5ycGNIYW5kbGVycy5zZXQobWV0aG9kLCBoYW5kbGVyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGByb29tLnVucmVnaXN0ZXJScGNNZXRob2RgIGluc3RlYWRcbiAgICovXG4gIHVucmVnaXN0ZXJScGNNZXRob2QobWV0aG9kKSB7XG4gICAgdGhpcy5ycGNIYW5kbGVycy5kZWxldGUobWV0aG9kKTtcbiAgfVxuICAvKipcbiAgICogQ29udHJvbCB3aG8gY2FuIHN1YnNjcmliZSB0byBMb2NhbFBhcnRpY2lwYW50J3MgcHVibGlzaGVkIHRyYWNrcy5cbiAgICpcbiAgICogQnkgZGVmYXVsdCwgYWxsIHBhcnRpY2lwYW50cyBjYW4gc3Vic2NyaWJlLiBUaGlzIGFsbG93cyBmaW5lLWdyYWluZWQgY29udHJvbCBvdmVyXG4gICAqIHdobyBpcyBhYmxlIHRvIHN1YnNjcmliZSBhdCBhIHBhcnRpY2lwYW50IGFuZCB0cmFjayBsZXZlbC5cbiAgICpcbiAgICogTm90ZTogaWYgYWNjZXNzIGlzIGdpdmVuIGF0IGEgdHJhY2stbGV2ZWwgKGkuZS4gYm90aCBbYWxsUGFydGljaXBhbnRzQWxsb3dlZF0gYW5kXG4gICAqIFtQYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbi5hbGxUcmFja3NBbGxvd2VkXSBhcmUgZmFsc2UpLCBhbnkgbmV3ZXIgcHVibGlzaGVkIHRyYWNrc1xuICAgKiB3aWxsIG5vdCBncmFudCBwZXJtaXNzaW9ucyB0byBhbnkgcGFydGljaXBhbnRzIGFuZCB3aWxsIHJlcXVpcmUgYSBzdWJzZXF1ZW50XG4gICAqIHBlcm1pc3Npb25zIHVwZGF0ZSB0byBhbGxvdyBzdWJzY3JpcHRpb24uXG4gICAqXG4gICAqIEBwYXJhbSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkIEFsbG93cyBhbGwgcGFydGljaXBhbnRzIHRvIHN1YnNjcmliZSBhbGwgdHJhY2tzLlxuICAgKiAgVGFrZXMgcHJlY2VkZW5jZSBvdmVyIFtbcGFydGljaXBhbnRUcmFja1Blcm1pc3Npb25zXV0gaWYgc2V0IHRvIHRydWUuXG4gICAqICBCeSBkZWZhdWx0IHRoaXMgaXMgc2V0IHRvIHRydWUuXG4gICAqIEBwYXJhbSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgRnVsbCBsaXN0IG9mIGluZGl2aWR1YWwgcGVybWlzc2lvbnMgcGVyXG4gICAqICBwYXJ0aWNpcGFudC90cmFjay4gQW55IG9taXR0ZWQgcGFydGljaXBhbnRzIHdpbGwgbm90IHJlY2VpdmUgYW55IHBlcm1pc3Npb25zLlxuICAgKi9cbiAgc2V0VHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyhhbGxQYXJ0aWNpcGFudHNBbGxvd2VkKSB7XG4gICAgbGV0IHBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogW107XG4gICAgdGhpcy5wYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnMgPSBwYXJ0aWNpcGFudFRyYWNrUGVybWlzc2lvbnM7XG4gICAgdGhpcy5hbGxQYXJ0aWNpcGFudHNBbGxvd2VkVG9TdWJzY3JpYmUgPSBhbGxQYXJ0aWNpcGFudHNBbGxvd2VkO1xuICAgIGlmICghdGhpcy5lbmdpbmUuY2xpZW50LmlzRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLnVwZGF0ZVRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMoKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlSW5jb21pbmdScGNBY2socmVxdWVzdElkKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ0Fja3MuZ2V0KHJlcXVlc3RJZCk7XG4gICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgIGhhbmRsZXIucmVzb2x2ZSgpO1xuICAgICAgdGhpcy5wZW5kaW5nQWNrcy5kZWxldGUocmVxdWVzdElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignQWNrIHJlY2VpdmVkIGZvciB1bmV4cGVjdGVkIFJQQyByZXF1ZXN0JywgcmVxdWVzdElkKTtcbiAgICB9XG4gIH1cbiAgaGFuZGxlSW5jb21pbmdScGNSZXNwb25zZShyZXF1ZXN0SWQsIHBheWxvYWQsIGVycm9yKSB7XG4gICAgY29uc3QgaGFuZGxlciA9IHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5nZXQocmVxdWVzdElkKTtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgaGFuZGxlci5yZXNvbHZlKHBheWxvYWQsIGVycm9yKTtcbiAgICAgIHRoaXMucGVuZGluZ1Jlc3BvbnNlcy5kZWxldGUocmVxdWVzdElkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignUmVzcG9uc2UgcmVjZWl2ZWQgZm9yIHVuZXhwZWN0ZWQgUlBDIHJlcXVlc3QnLCByZXF1ZXN0SWQpO1xuICAgIH1cbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHB1Ymxpc2hScGNSZXF1ZXN0KGRlc3RpbmF0aW9uSWRlbnRpdHksIHJlcXVlc3RJZCwgbWV0aG9kLCBwYXlsb2FkLCByZXNwb25zZVRpbWVvdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgcGFja2V0ID0gbmV3IERhdGFQYWNrZXQoe1xuICAgICAgICBkZXN0aW5hdGlvbklkZW50aXRpZXM6IFtkZXN0aW5hdGlvbklkZW50aXR5XSxcbiAgICAgICAga2luZDogRGF0YVBhY2tldF9LaW5kLlJFTElBQkxFLFxuICAgICAgICB2YWx1ZToge1xuICAgICAgICAgIGNhc2U6ICdycGNSZXF1ZXN0JyxcbiAgICAgICAgICB2YWx1ZTogbmV3IFJwY1JlcXVlc3Qoe1xuICAgICAgICAgICAgaWQ6IHJlcXVlc3RJZCxcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIHBheWxvYWQsXG4gICAgICAgICAgICByZXNwb25zZVRpbWVvdXRNczogcmVzcG9uc2VUaW1lb3V0LFxuICAgICAgICAgICAgdmVyc2lvbjogMVxuICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5lbmdpbmUuc2VuZERhdGFQYWNrZXQocGFja2V0LCBEYXRhUGFja2V0X0tpbmQuUkVMSUFCTEUpO1xuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgaGFuZGxlUGFydGljaXBhbnREaXNjb25uZWN0ZWQocGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIGZvciAoY29uc3QgW2lkLCB7XG4gICAgICBwYXJ0aWNpcGFudElkZW50aXR5OiBwZW5kaW5nSWRlbnRpdHlcbiAgICB9XSBvZiB0aGlzLnBlbmRpbmdBY2tzKSB7XG4gICAgICBpZiAocGVuZGluZ0lkZW50aXR5ID09PSBwYXJ0aWNpcGFudElkZW50aXR5KSB7XG4gICAgICAgIHRoaXMucGVuZGluZ0Fja3MuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBbaWQsIHtcbiAgICAgIHBhcnRpY2lwYW50SWRlbnRpdHk6IHBlbmRpbmdJZGVudGl0eSxcbiAgICAgIHJlc29sdmVcbiAgICB9XSBvZiB0aGlzLnBlbmRpbmdSZXNwb25zZXMpIHtcbiAgICAgIGlmIChwZW5kaW5nSWRlbnRpdHkgPT09IHBhcnRpY2lwYW50SWRlbnRpdHkpIHtcbiAgICAgICAgcmVzb2x2ZShudWxsLCBScGNFcnJvci5idWlsdEluKCdSRUNJUElFTlRfRElTQ09OTkVDVEVEJykpO1xuICAgICAgICB0aGlzLnBlbmRpbmdSZXNwb25zZXMuZGVsZXRlKGlkKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzZXRFbmFibGVkUHVibGlzaENvZGVjcyhjb2RlY3MpIHtcbiAgICB0aGlzLmVuYWJsZWRQdWJsaXNoVmlkZW9Db2RlY3MgPSBjb2RlY3MuZmlsdGVyKGMgPT4gYy5taW1lLnNwbGl0KCcvJylbMF0udG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvJyk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICBpZiAoaW5mby5zaWQgIT09IHRoaXMuc2lkKSB7XG4gICAgICAvLyBkcm9wIHVwZGF0ZXMgdGhhdCBzcGVjaWZ5IGEgd3Jvbmcgc2lkLlxuICAgICAgLy8gdGhlIHNpZCBmb3IgbG9jYWwgcGFydGljaXBhbnQgaXMgb25seSBleHBsaWNpdGx5IHNldCBvbiBqb2luIGFuZCBmdWxsIHJlY29ubmVjdFxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXN1cGVyLnVwZGF0ZUluZm8oaW5mbykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gcmVjb25jaWxlIHRyYWNrIG11dGUgc3RhdHVzLlxuICAgIC8vIGlmIHNlcnZlcidzIHRyYWNrIG11dGUgc3RhdHVzIGRvZXNuJ3QgbWF0Y2ggYWN0dWFsLCB3ZSdsbCBoYXZlIHRvIHVwZGF0ZVxuICAgIC8vIHRoZSBzZXJ2ZXIncyBjb3B5XG4gICAgaW5mby50cmFja3MuZm9yRWFjaCh0aSA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgcHViID0gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQodGkuc2lkKTtcbiAgICAgIGlmIChwdWIpIHtcbiAgICAgICAgY29uc3QgbXV0ZWRPblNlcnZlciA9IHB1Yi5pc011dGVkIHx8ICgoX2IgPSAoX2EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Vwc3RyZWFtUGF1c2VkKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBmYWxzZSk7XG4gICAgICAgIGlmIChtdXRlZE9uU2VydmVyICE9PSB0aS5tdXRlZCkge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCd1cGRhdGluZyBzZXJ2ZXIgbXV0ZSBzdGF0ZSBhZnRlciByZWNvbmNpbGUnLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWIpKSwge1xuICAgICAgICAgICAgbXV0ZWRPblNlcnZlclxuICAgICAgICAgIH0pKTtcbiAgICAgICAgICB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZE11dGVUcmFjayh0aS5zaWQsIG11dGVkT25TZXJ2ZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0UHVibGljYXRpb25Gb3JUcmFjayh0cmFjaykge1xuICAgIGxldCBwdWJsaWNhdGlvbjtcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHViID0+IHtcbiAgICAgIGNvbnN0IGxvY2FsVHJhY2sgPSBwdWIudHJhY2s7XG4gICAgICBpZiAoIWxvY2FsVHJhY2spIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gdGhpcyBsb29rcyBvdmVybHkgY29tcGxpY2F0ZWQgZHVlIHRvIHRoaXMgb2JqZWN0IHRyZWVcbiAgICAgIGlmICh0cmFjayBpbnN0YW5jZW9mIE1lZGlhU3RyZWFtVHJhY2spIHtcbiAgICAgICAgaWYgKGlzTG9jYWxBdWRpb1RyYWNrKGxvY2FsVHJhY2spIHx8IGlzTG9jYWxWaWRlb1RyYWNrKGxvY2FsVHJhY2spKSB7XG4gICAgICAgICAgaWYgKGxvY2FsVHJhY2subWVkaWFTdHJlYW1UcmFjayA9PT0gdHJhY2spIHtcbiAgICAgICAgICAgIHB1YmxpY2F0aW9uID0gcHViO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0cmFjayA9PT0gbG9jYWxUcmFjaykge1xuICAgICAgICBwdWJsaWNhdGlvbiA9IHB1YjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcHVibGljYXRpb247XG4gIH1cbiAgd2FpdEZvclBlbmRpbmdQdWJsaWNhdGlvbk9mU291cmNlKHNvdXJjZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCB3YWl0Rm9yUGVuZGluZ1RpbWVvdXQgPSAxMDAwMDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICB3aGlsZSAoRGF0ZS5ub3coKSA8IHN0YXJ0VGltZSArIHdhaXRGb3JQZW5kaW5nVGltZW91dCkge1xuICAgICAgICBjb25zdCBwdWJsaXNoUHJvbWlzZUVudHJ5ID0gQXJyYXkuZnJvbSh0aGlzLnBlbmRpbmdQdWJsaXNoUHJvbWlzZXMuZW50cmllcygpKS5maW5kKF9yZWY0ID0+IHtcbiAgICAgICAgICBsZXQgW3BlbmRpbmdUcmFja10gPSBfcmVmNDtcbiAgICAgICAgICByZXR1cm4gcGVuZGluZ1RyYWNrLnNvdXJjZSA9PT0gc291cmNlO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHB1Ymxpc2hQcm9taXNlRW50cnkpIHtcbiAgICAgICAgICByZXR1cm4gcHVibGlzaFByb21pc2VFbnRyeVsxXTtcbiAgICAgICAgfVxuICAgICAgICB5aWVsZCBzbGVlcCgyMCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiBleHRlbmRzIFRyYWNrUHVibGljYXRpb24ge1xuICBjb25zdHJ1Y3RvcihraW5kLCB0aSwgYXV0b1N1YnNjcmliZSwgbG9nZ2VyT3B0aW9ucykge1xuICAgIHN1cGVyKGtpbmQsIHRpLnNpZCwgdGkubmFtZSwgbG9nZ2VyT3B0aW9ucyk7XG4gICAgdGhpcy50cmFjayA9IHVuZGVmaW5lZDtcbiAgICAvKiogQGludGVybmFsICovXG4gICAgdGhpcy5hbGxvd2VkID0gdHJ1ZTtcbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gVmlkZW9RdWFsaXR5LkhJR0g7XG4gICAgdGhpcy5oYW5kbGVFbmRlZCA9IHRyYWNrID0+IHtcbiAgICAgIHRoaXMuc2V0VHJhY2sodW5kZWZpbmVkKTtcbiAgICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LkVuZGVkLCB0cmFjayk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UgPSB2aXNpYmxlID0+IHtcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiYWRhcHRpdmVzdHJlYW0gdmlkZW8gdmlzaWJpbGl0eSBcIi5jb25jYXQodGhpcy50cmFja1NpZCwgXCIsIHZpc2libGU9XCIpLmNvbmNhdCh2aXNpYmxlKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMuZGlzYWJsZWQgPSAhdmlzaWJsZTtcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSA9IGRpbWVuc2lvbnMgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoXCJhZGFwdGl2ZXN0cmVhbSB2aWRlbyBkaW1lbnNpb25zIFwiLmNvbmNhdChkaW1lbnNpb25zLndpZHRoLCBcInhcIikuY29uY2F0KGRpbWVuc2lvbnMuaGVpZ2h0KSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgfTtcbiAgICB0aGlzLnN1YnNjcmliZWQgPSBhdXRvU3Vic2NyaWJlO1xuICAgIHRoaXMudXBkYXRlSW5mbyh0aSk7XG4gIH1cbiAgLyoqXG4gICAqIFN1YnNjcmliZSBvciB1bnN1YnNjcmliZSB0byB0aGlzIHJlbW90ZSB0cmFja1xuICAgKiBAcGFyYW0gc3Vic2NyaWJlZCB0cnVlIHRvIHN1YnNjcmliZSB0byBhIHRyYWNrLCBmYWxzZSB0byB1bnN1YnNjcmliZVxuICAgKi9cbiAgc2V0U3Vic2NyaWJlZChzdWJzY3JpYmVkKSB7XG4gICAgY29uc3QgcHJldlN0YXR1cyA9IHRoaXMuc3Vic2NyaXB0aW9uU3RhdHVzO1xuICAgIGNvbnN0IHByZXZQZXJtaXNzaW9uID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIHRoaXMuc3Vic2NyaWJlZCA9IHN1YnNjcmliZWQ7XG4gICAgLy8gcmVzZXQgYWxsb3dlZCBzdGF0dXMgd2hlbiBkZXNpcmVkIHN1YnNjcmlwdGlvbiBzdGF0ZSBjaGFuZ2VzXG4gICAgLy8gc2VydmVyIHdpbGwgbm90aWZ5IGNsaWVudCB2aWEgc2lnbmFsIG1lc3NhZ2UgaWYgaXQncyBub3QgYWxsb3dlZFxuICAgIGlmIChzdWJzY3JpYmVkKSB7XG4gICAgICB0aGlzLmFsbG93ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBzdWIgPSBuZXcgVXBkYXRlU3Vic2NyaXB0aW9uKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgc3Vic2NyaWJlOiB0aGlzLnN1YnNjcmliZWQsXG4gICAgICBwYXJ0aWNpcGFudFRyYWNrczogW25ldyBQYXJ0aWNpcGFudFRyYWNrcyh7XG4gICAgICAgIC8vIHNlbmRpbmcgYW4gZW1wdHkgcGFydGljaXBhbnQgaWQgc2luY2UgVHJhY2tQdWJsaWNhdGlvbiBkb2Vzbid0IGtlZXAgaXRcbiAgICAgICAgLy8gdGhpcyBpcyBmaWxsZWQgaW4gYnkgdGhlIHBhcnRpY2lwYW50IHRoYXQgcmVjZWl2ZXMgdGhpcyBtZXNzYWdlXG4gICAgICAgIHBhcnRpY2lwYW50U2lkOiAnJyxcbiAgICAgICAgdHJhY2tTaWRzOiBbdGhpcy50cmFja1NpZF1cbiAgICAgIH0pXVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdChUcmFja0V2ZW50LlVwZGF0ZVN1YnNjcmlwdGlvbiwgc3ViKTtcbiAgICB0aGlzLmVtaXRTdWJzY3JpcHRpb25VcGRhdGVJZkNoYW5nZWQocHJldlN0YXR1cyk7XG4gICAgdGhpcy5lbWl0UGVybWlzc2lvblVwZGF0ZUlmQ2hhbmdlZChwcmV2UGVybWlzc2lvbik7XG4gIH1cbiAgZ2V0IHN1YnNjcmlwdGlvblN0YXR1cygpIHtcbiAgICBpZiAodGhpcy5zdWJzY3JpYmVkID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIFRyYWNrUHVibGljYXRpb24uU3Vic2NyaXB0aW9uU3RhdHVzLlVuc3Vic2NyaWJlZDtcbiAgICB9XG4gICAgaWYgKCFzdXBlci5pc1N1YnNjcmliZWQpIHtcbiAgICAgIHJldHVybiBUcmFja1B1YmxpY2F0aW9uLlN1YnNjcmlwdGlvblN0YXR1cy5EZXNpcmVkO1xuICAgIH1cbiAgICByZXR1cm4gVHJhY2tQdWJsaWNhdGlvbi5TdWJzY3JpcHRpb25TdGF0dXMuU3Vic2NyaWJlZDtcbiAgfVxuICBnZXQgcGVybWlzc2lvblN0YXR1cygpIHtcbiAgICByZXR1cm4gdGhpcy5hbGxvd2VkID8gVHJhY2tQdWJsaWNhdGlvbi5QZXJtaXNzaW9uU3RhdHVzLkFsbG93ZWQgOiBUcmFja1B1YmxpY2F0aW9uLlBlcm1pc3Npb25TdGF0dXMuTm90QWxsb3dlZDtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIHRyYWNrIGlzIHN1YnNjcmliZWQsIGFuZCByZWFkeSBmb3IgcGxheWJhY2tcbiAgICovXG4gIGdldCBpc1N1YnNjcmliZWQoKSB7XG4gICAgaWYgKHRoaXMuc3Vic2NyaWJlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmlzU3Vic2NyaWJlZDtcbiAgfVxuICAvLyByZXR1cm5zIGNsaWVudCdzIGRlc2lyZSB0byBzdWJzY3JpYmUgdG8gYSB0cmFjaywgYWxzbyB0cnVlIGlmIGF1dG9TdWJzY3JpYmUgaXMgZW5hYmxlZFxuICBnZXQgaXNEZXNpcmVkKCkge1xuICAgIHJldHVybiB0aGlzLnN1YnNjcmliZWQgIT09IGZhbHNlO1xuICB9XG4gIGdldCBpc0VuYWJsZWQoKSB7XG4gICAgcmV0dXJuICF0aGlzLmRpc2FibGVkO1xuICB9XG4gIGdldCBpc0xvY2FsKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogZGlzYWJsZSBzZXJ2ZXIgZnJvbSBzZW5kaW5nIGRvd24gZGF0YSBmb3IgdGhpcyB0cmFjay4gdGhpcyBpcyB1c2VmdWwgd2hlblxuICAgKiB0aGUgcGFydGljaXBhbnQgaXMgb2ZmIHNjcmVlbiwgeW91IG1heSBkaXNhYmxlIHN0cmVhbWluZyBkb3duIHRoZWlyIHZpZGVvXG4gICAqIHRvIHJlZHVjZSBiYW5kd2lkdGggcmVxdWlyZW1lbnRzXG4gICAqIEBwYXJhbSBlbmFibGVkXG4gICAqL1xuICBzZXRFbmFibGVkKGVuYWJsZWQpIHtcbiAgICBpZiAoIXRoaXMuaXNNYW51YWxPcGVyYXRpb25BbGxvd2VkKCkgfHwgdGhpcy5kaXNhYmxlZCA9PT0gIWVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5kaXNhYmxlZCA9ICFlbmFibGVkO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cbiAgLyoqXG4gICAqIGZvciB0cmFja3MgdGhhdCBzdXBwb3J0IHNpbXVsY2FzdGluZywgYWRqdXN0IHN1YnNjcmliZWQgcXVhbGl0eVxuICAgKlxuICAgKiBUaGlzIGluZGljYXRlcyB0aGUgaGlnaGVzdCBxdWFsaXR5IHRoZSBjbGllbnQgY2FuIGFjY2VwdC4gaWYgbmV0d29ya1xuICAgKiBiYW5kd2lkdGggZG9lcyBub3QgYWxsb3csIHNlcnZlciB3aWxsIGF1dG9tYXRpY2FsbHkgcmVkdWNlIHF1YWxpdHkgdG9cbiAgICogb3B0aW1pemUgZm9yIHVuaW50ZXJydXB0ZWQgdmlkZW9cbiAgICovXG4gIHNldFZpZGVvUXVhbGl0eShxdWFsaXR5KSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpIHx8IHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSA9PT0gcXVhbGl0eSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnRWaWRlb1F1YWxpdHkgPSBxdWFsaXR5O1xuICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cbiAgc2V0VmlkZW9EaW1lbnNpb25zKGRpbWVuc2lvbnMpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmICghdGhpcy5pc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoKChfYSA9IHRoaXMudmlkZW9EaW1lbnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2lkdGgpID09PSBkaW1lbnNpb25zLndpZHRoICYmICgoX2IgPSB0aGlzLnZpZGVvRGltZW5zaW9ucykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmhlaWdodCkgPT09IGRpbWVuc2lvbnMuaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChpc1JlbW90ZVZpZGVvVHJhY2sodGhpcy50cmFjaykpIHtcbiAgICAgIHRoaXMudmlkZW9EaW1lbnNpb25zID0gZGltZW5zaW9ucztcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5ID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cbiAgc2V0VmlkZW9GUFMoZnBzKSB7XG4gICAgaWYgKCF0aGlzLmlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNSZW1vdGVWaWRlb1RyYWNrKHRoaXMudHJhY2spKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmZwcyA9PT0gZnBzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZnBzID0gZnBzO1xuICAgIHRoaXMuZW1pdFRyYWNrVXBkYXRlKCk7XG4gIH1cbiAgZ2V0IHZpZGVvUXVhbGl0eSgpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5O1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgc2V0VHJhY2sodHJhY2spIHtcbiAgICBjb25zdCBwcmV2U3RhdHVzID0gdGhpcy5zdWJzY3JpcHRpb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlBlcm1pc3Npb24gPSB0aGlzLnBlcm1pc3Npb25TdGF0dXM7XG4gICAgY29uc3QgcHJldlRyYWNrID0gdGhpcy50cmFjaztcbiAgICBpZiAocHJldlRyYWNrID09PSB0cmFjaykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJldlRyYWNrKSB7XG4gICAgICAvLyB1bnJlZ2lzdGVyIGxpc3RlbmVyXG4gICAgICBwcmV2VHJhY2sub2ZmKFRyYWNrRXZlbnQuVmlkZW9EaW1lbnNpb25zQ2hhbmdlZCwgdGhpcy5oYW5kbGVWaWRlb0RpbWVuc2lvbnNDaGFuZ2UpO1xuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgcHJldlRyYWNrLm9mZihUcmFja0V2ZW50LkVuZGVkLCB0aGlzLmhhbmRsZUVuZGVkKTtcbiAgICAgIHByZXZUcmFjay5kZXRhY2goKTtcbiAgICAgIHByZXZUcmFjay5zdG9wTW9uaXRvcigpO1xuICAgICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVW5zdWJzY3JpYmVkLCBwcmV2VHJhY2spO1xuICAgIH1cbiAgICBzdXBlci5zZXRUcmFjayh0cmFjayk7XG4gICAgaWYgKHRyYWNrKSB7XG4gICAgICB0cmFjay5zaWQgPSB0aGlzLnRyYWNrU2lkO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5WaWRlb0RpbWVuc2lvbnNDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpZGVvRGltZW5zaW9uc0NoYW5nZSk7XG4gICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpc2liaWxpdHlDaGFuZ2VkLCB0aGlzLmhhbmRsZVZpc2liaWxpdHlDaGFuZ2UpO1xuICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5FbmRlZCwgdGhpcy5oYW5kbGVFbmRlZCk7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpYmVkLCB0cmFjayk7XG4gICAgfVxuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldEFsbG93ZWQoYWxsb3dlZCkge1xuICAgIGNvbnN0IHByZXZTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBjb25zdCBwcmV2UGVybWlzc2lvbiA9IHRoaXMucGVybWlzc2lvblN0YXR1cztcbiAgICB0aGlzLmFsbG93ZWQgPSBhbGxvd2VkO1xuICAgIHRoaXMuZW1pdFBlcm1pc3Npb25VcGRhdGVJZkNoYW5nZWQocHJldlBlcm1pc3Npb24pO1xuICAgIHRoaXMuZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2U3RhdHVzKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHNldFN1YnNjcmlwdGlvbkVycm9yKGVycm9yKSB7XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uRmFpbGVkLCBlcnJvcik7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1cGRhdGVJbmZvKGluZm8pIHtcbiAgICBzdXBlci51cGRhdGVJbmZvKGluZm8pO1xuICAgIGNvbnN0IHByZXZNZXRhZGF0YU11dGVkID0gdGhpcy5tZXRhZGF0YU11dGVkO1xuICAgIHRoaXMubWV0YWRhdGFNdXRlZCA9IGluZm8ubXV0ZWQ7XG4gICAgaWYgKHRoaXMudHJhY2spIHtcbiAgICAgIHRoaXMudHJhY2suc2V0TXV0ZWQoaW5mby5tdXRlZCk7XG4gICAgfSBlbHNlIGlmIChwcmV2TWV0YWRhdGFNdXRlZCAhPT0gaW5mby5tdXRlZCkge1xuICAgICAgdGhpcy5lbWl0KGluZm8ubXV0ZWQgPyBUcmFja0V2ZW50Lk11dGVkIDogVHJhY2tFdmVudC5Vbm11dGVkKTtcbiAgICB9XG4gIH1cbiAgZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZChwcmV2aW91c1N0YXR1cykge1xuICAgIGNvbnN0IGN1cnJlbnRTdGF0dXMgPSB0aGlzLnN1YnNjcmlwdGlvblN0YXR1cztcbiAgICBpZiAocHJldmlvdXNTdGF0dXMgPT09IGN1cnJlbnRTdGF0dXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgY3VycmVudFN0YXR1cywgcHJldmlvdXNTdGF0dXMpO1xuICB9XG4gIGVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkKHByZXZpb3VzUGVybWlzc2lvblN0YXR1cykge1xuICAgIGNvbnN0IGN1cnJlbnRQZXJtaXNzaW9uU3RhdHVzID0gdGhpcy5wZXJtaXNzaW9uU3RhdHVzO1xuICAgIGlmIChjdXJyZW50UGVybWlzc2lvblN0YXR1cyAhPT0gcHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzKSB7XG4gICAgICB0aGlzLmVtaXQoVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgdGhpcy5wZXJtaXNzaW9uU3RhdHVzLCBwcmV2aW91c1Blcm1pc3Npb25TdGF0dXMpO1xuICAgIH1cbiAgfVxuICBpc01hbnVhbE9wZXJhdGlvbkFsbG93ZWQoKSB7XG4gICAgaWYgKHRoaXMua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbyAmJiB0aGlzLmlzQWRhcHRpdmVTdHJlYW0pIHtcbiAgICAgIHRoaXMubG9nLndhcm4oJ2FkYXB0aXZlIHN0cmVhbSBpcyBlbmFibGVkLCBjYW5ub3QgY2hhbmdlIHZpZGVvIHRyYWNrIHNldHRpbmdzJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzRGVzaXJlZCkge1xuICAgICAgdGhpcy5sb2cud2FybignY2Fubm90IHVwZGF0ZSB0cmFjayBzZXR0aW5ncyB3aGVuIG5vdCBzdWJzY3JpYmVkJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgZ2V0IGlzQWRhcHRpdmVTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGlzUmVtb3RlVmlkZW9UcmFjayh0aGlzLnRyYWNrKSAmJiB0aGlzLnRyYWNrLmlzQWRhcHRpdmVTdHJlYW07XG4gIH1cbiAgLyogQGludGVybmFsICovXG4gIGVtaXRUcmFja1VwZGF0ZSgpIHtcbiAgICBjb25zdCBzZXR0aW5ncyA9IG5ldyBVcGRhdGVUcmFja1NldHRpbmdzKHtcbiAgICAgIHRyYWNrU2lkczogW3RoaXMudHJhY2tTaWRdLFxuICAgICAgZGlzYWJsZWQ6IHRoaXMuZGlzYWJsZWQsXG4gICAgICBmcHM6IHRoaXMuZnBzXG4gICAgfSk7XG4gICAgaWYgKHRoaXMudmlkZW9EaW1lbnNpb25zKSB7XG4gICAgICBzZXR0aW5ncy53aWR0aCA9IE1hdGguY2VpbCh0aGlzLnZpZGVvRGltZW5zaW9ucy53aWR0aCk7XG4gICAgICBzZXR0aW5ncy5oZWlnaHQgPSBNYXRoLmNlaWwodGhpcy52aWRlb0RpbWVuc2lvbnMuaGVpZ2h0KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY3VycmVudFZpZGVvUXVhbGl0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBzZXR0aW5ncy5xdWFsaXR5ID0gdGhpcy5jdXJyZW50VmlkZW9RdWFsaXR5O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBkZWZhdWx0cyB0byBoaWdoIHF1YWxpdHlcbiAgICAgIHNldHRpbmdzLnF1YWxpdHkgPSBWaWRlb1F1YWxpdHkuSElHSDtcbiAgICB9XG4gICAgdGhpcy5lbWl0KFRyYWNrRXZlbnQuVXBkYXRlU2V0dGluZ3MsIHNldHRpbmdzKTtcbiAgfVxufVxuXG5jbGFzcyBSZW1vdGVQYXJ0aWNpcGFudCBleHRlbmRzIFBhcnRpY2lwYW50IHtcbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBzdGF0aWMgZnJvbVBhcnRpY2lwYW50SW5mbyhzaWduYWxDbGllbnQsIHBpLCBsb2dnZXJPcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBSZW1vdGVQYXJ0aWNpcGFudChzaWduYWxDbGllbnQsIHBpLnNpZCwgcGkuaWRlbnRpdHksIHBpLm5hbWUsIHBpLm1ldGFkYXRhLCBwaS5hdHRyaWJ1dGVzLCBsb2dnZXJPcHRpb25zLCBwaS5raW5kKTtcbiAgfVxuICBnZXQgbG9nQ29udGV4dCgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBzdXBlci5sb2dDb250ZXh0KSwge1xuICAgICAgcnBJRDogdGhpcy5zaWQsXG4gICAgICByZW1vdGVQYXJ0aWNpcGFudDogdGhpcy5pZGVudGl0eVxuICAgIH0pO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgY29uc3RydWN0b3Ioc2lnbmFsQ2xpZW50LCBzaWQsIGlkZW50aXR5LCBuYW1lLCBtZXRhZGF0YSwgYXR0cmlidXRlcywgbG9nZ2VyT3B0aW9ucykge1xuICAgIGxldCBraW5kID0gYXJndW1lbnRzLmxlbmd0aCA+IDcgJiYgYXJndW1lbnRzWzddICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbN10gOiBQYXJ0aWNpcGFudEluZm9fS2luZC5TVEFOREFSRDtcbiAgICBzdXBlcihzaWQsIGlkZW50aXR5IHx8ICcnLCBuYW1lLCBtZXRhZGF0YSwgYXR0cmlidXRlcywgbG9nZ2VyT3B0aW9ucywga2luZCk7XG4gICAgdGhpcy5zaWduYWxDbGllbnQgPSBzaWduYWxDbGllbnQ7XG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy52aWRlb1RyYWNrUHVibGljYXRpb25zID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudm9sdW1lTWFwID0gbmV3IE1hcCgpO1xuICB9XG4gIGFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pIHtcbiAgICBzdXBlci5hZGRUcmFja1B1YmxpY2F0aW9uKHB1YmxpY2F0aW9uKTtcbiAgICAvLyByZWdpc3RlciBhY3Rpb24gZXZlbnRzXG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VcGRhdGVTZXR0aW5ncywgc2V0dGluZ3MgPT4ge1xuICAgICAgdGhpcy5sb2cuZGVidWcoJ3NlbmQgdXBkYXRlIHNldHRpbmdzJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKSkpO1xuICAgICAgdGhpcy5zaWduYWxDbGllbnQuc2VuZFVwZGF0ZVRyYWNrU2V0dGluZ3Moc2V0dGluZ3MpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuVXBkYXRlU3Vic2NyaXB0aW9uLCBzdWIgPT4ge1xuICAgICAgc3ViLnBhcnRpY2lwYW50VHJhY2tzLmZvckVhY2gocHQgPT4ge1xuICAgICAgICBwdC5wYXJ0aWNpcGFudFNpZCA9IHRoaXMuc2lkO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnNpZ25hbENsaWVudC5zZW5kVXBkYXRlU3Vic2NyaXB0aW9uKHN1Yik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCwgc3RhdHVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1YmxpY2F0aW9uLCBzdGF0dXMpO1xuICAgIH0pO1xuICAgIHB1YmxpY2F0aW9uLm9uKFRyYWNrRXZlbnQuU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgc3RhdHVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgcHVibGljYXRpb24sIHN0YXR1cyk7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5TdWJzY3JpYmVkLCB0cmFjayA9PiB7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcHVibGljYXRpb24ub24oVHJhY2tFdmVudC5VbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2sgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHByZXZpb3VzVHJhY2ssIHB1YmxpY2F0aW9uKTtcbiAgICB9KTtcbiAgICBwdWJsaWNhdGlvbi5vbihUcmFja0V2ZW50LlN1YnNjcmlwdGlvbkZhaWxlZCwgZXJyb3IgPT4ge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpcHRpb25GYWlsZWQsIHB1YmxpY2F0aW9uLnRyYWNrU2lkLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpIHtcbiAgICBjb25zdCB0cmFjayA9IHN1cGVyLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHJldHVybiB0cmFjaztcbiAgICB9XG4gIH1cbiAgZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZShuYW1lKSB7XG4gICAgY29uc3QgdHJhY2sgPSBzdXBlci5nZXRUcmFja1B1YmxpY2F0aW9uQnlOYW1lKG5hbWUpO1xuICAgIGlmICh0cmFjaykge1xuICAgICAgcmV0dXJuIHRyYWNrO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogc2V0cyB0aGUgdm9sdW1lIG9uIHRoZSBwYXJ0aWNpcGFudCdzIGF1ZGlvIHRyYWNrXG4gICAqIGJ5IGRlZmF1bHQsIHRoaXMgYWZmZWN0cyB0aGUgbWljcm9waG9uZSBwdWJsaWNhdGlvblxuICAgKiBhIGRpZmZlcmVudCBzb3VyY2UgY2FuIGJlIHBhc3NlZCBpbiBhcyBhIHNlY29uZCBhcmd1bWVudFxuICAgKiBpZiBubyB0cmFjayBleGlzdHMgdGhlIHZvbHVtZSB3aWxsIGJlIGFwcGxpZWQgd2hlbiB0aGUgbWljcm9waG9uZSB0cmFjayBpcyBhZGRlZFxuICAgKi9cbiAgc2V0Vm9sdW1lKHZvbHVtZSkge1xuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgIHRoaXMudm9sdW1lTWFwLnNldChzb3VyY2UsIHZvbHVtZSk7XG4gICAgY29uc3QgYXVkaW9QdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbihzb3VyY2UpO1xuICAgIGlmIChhdWRpb1B1YmxpY2F0aW9uICYmIGF1ZGlvUHVibGljYXRpb24udHJhY2spIHtcbiAgICAgIGF1ZGlvUHVibGljYXRpb24udHJhY2suc2V0Vm9sdW1lKHZvbHVtZSk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBnZXRzIHRoZSB2b2x1bWUgb24gdGhlIHBhcnRpY2lwYW50J3MgbWljcm9waG9uZSB0cmFja1xuICAgKi9cbiAgZ2V0Vm9sdW1lKCkge1xuICAgIGxldCBzb3VyY2UgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lO1xuICAgIGNvbnN0IGF1ZGlvUHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb24oc291cmNlKTtcbiAgICBpZiAoYXVkaW9QdWJsaWNhdGlvbiAmJiBhdWRpb1B1YmxpY2F0aW9uLnRyYWNrKSB7XG4gICAgICByZXR1cm4gYXVkaW9QdWJsaWNhdGlvbi50cmFjay5nZXRWb2x1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudm9sdW1lTWFwLmdldChzb3VyY2UpO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgYWRkU3Vic2NyaWJlZE1lZGlhVHJhY2sobWVkaWFUcmFjaywgc2lkLCBtZWRpYVN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MsIHRyaWVzTGVmdCkge1xuICAgIC8vIGZpbmQgdGhlIHRyYWNrIHB1YmxpY2F0aW9uXG4gICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgdGhlIG1lZGlhIHRyYWNrIHRvIGFycml2ZSBiZWZvcmUgcGFydGljaXBhbnQgaW5mb1xuICAgIGxldCBwdWJsaWNhdGlvbiA9IHRoaXMuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHNpZCk7XG4gICAgLy8gaXQncyBhbHNvIHBvc3NpYmxlIHRoYXQgdGhlIGJyb3dzZXIgZGlkbid0IGhvbm9yIG91ciBvcmlnaW5hbCB0cmFjayBpZFxuICAgIC8vIEZpcmVGb3ggd291bGQgdXNlIGl0cyBvd24gbG9jYWwgdXVpZCBpbnN0ZWFkIG9mIHNlcnZlciB0cmFjayBpZFxuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIGlmICghc2lkLnN0YXJ0c1dpdGgoJ1RSJykpIHtcbiAgICAgICAgLy8gZmluZCB0aGUgZmlyc3QgdHJhY2sgdGhhdCBtYXRjaGVzIHR5cGVcbiAgICAgICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICAgIGlmICghcHVibGljYXRpb24gJiYgbWVkaWFUcmFjay5raW5kID09PSBwLmtpbmQudG9TdHJpbmcoKSkge1xuICAgICAgICAgICAgcHVibGljYXRpb24gPSBwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIHdoZW4gd2UgY291bGRuJ3QgbG9jYXRlIHRoZSB0cmFjaywgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBtZXRhZGF0YSBoYXNuJ3RcbiAgICAvLyB5ZXQgYXJyaXZlZC4gV2FpdCBhIGJpdCBsb25nZXIgZm9yIGl0IHRvIGFycml2ZSwgb3IgZmlyZSBhbiBlcnJvclxuICAgIGlmICghcHVibGljYXRpb24pIHtcbiAgICAgIGlmICh0cmllc0xlZnQgPT09IDApIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2NvdWxkIG5vdCBmaW5kIHB1Ymxpc2hlZCB0cmFjaycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHRyYWNrU2lkOiBzaWRcbiAgICAgICAgfSkpO1xuICAgICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRyaWVzTGVmdCA9PT0gdW5kZWZpbmVkKSB0cmllc0xlZnQgPSAyMDtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHNpZCwgbWVkaWFTdHJlYW0sIHJlY2VpdmVyLCBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzLCB0cmllc0xlZnQgLSAxKTtcbiAgICAgIH0sIDE1MCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtZWRpYVRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHtcbiAgICAgIHRoaXMubG9nLmVycm9yKCd1bmFibGUgdG8gc3Vic2NyaWJlIGJlY2F1c2UgTWVkaWFTdHJlYW1UcmFjayBpcyBlbmRlZC4gRG8gbm90IGNhbGwgTWVkaWFTdHJlYW1UcmFjay5zdG9wKCknLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIGdldExvZ0NvbnRleHRGcm9tVHJhY2socHVibGljYXRpb24pKSk7XG4gICAgICB0aGlzLmVtaXQoUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgc2lkKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaXNWaWRlbyA9IG1lZGlhVHJhY2sua2luZCA9PT0gJ3ZpZGVvJztcbiAgICBsZXQgdHJhY2s7XG4gICAgaWYgKGlzVmlkZW8pIHtcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZVZpZGVvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgYWRhcHRpdmVTdHJlYW1TZXR0aW5ncyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYWNrID0gbmV3IFJlbW90ZUF1ZGlvVHJhY2sobWVkaWFUcmFjaywgc2lkLCByZWNlaXZlciwgdGhpcy5hdWRpb0NvbnRleHQsIHRoaXMuYXVkaW9PdXRwdXQpO1xuICAgIH1cbiAgICAvLyBzZXQgdHJhY2sgaW5mb1xuICAgIHRyYWNrLnNvdXJjZSA9IHB1YmxpY2F0aW9uLnNvdXJjZTtcbiAgICAvLyBrZWVwIHB1YmxpY2F0aW9uJ3MgbXV0ZWQgc3RhdHVzXG4gICAgdHJhY2suaXNNdXRlZCA9IHB1YmxpY2F0aW9uLmlzTXV0ZWQ7XG4gICAgdHJhY2suc2V0TWVkaWFTdHJlYW0obWVkaWFTdHJlYW0pO1xuICAgIHRyYWNrLnN0YXJ0KCk7XG4gICAgcHVibGljYXRpb24uc2V0VHJhY2sodHJhY2spO1xuICAgIC8vIHNldCBwYXJ0aWNpcGFudCB2b2x1bWVzIG9uIG5ldyBhdWRpbyB0cmFja3NcbiAgICBpZiAodGhpcy52b2x1bWVNYXAuaGFzKHB1YmxpY2F0aW9uLnNvdXJjZSkgJiYgaXNSZW1vdGVUcmFjayh0cmFjaykgJiYgaXNBdWRpb1RyYWNrKHRyYWNrKSkge1xuICAgICAgdHJhY2suc2V0Vm9sdW1lKHRoaXMudm9sdW1lTWFwLmdldChwdWJsaWNhdGlvbi5zb3VyY2UpKTtcbiAgICB9XG4gICAgcmV0dXJuIHB1YmxpY2F0aW9uO1xuICB9XG4gIC8qKiBAaW50ZXJuYWwgKi9cbiAgZ2V0IGhhc01ldGFkYXRhKCkge1xuICAgIHJldHVybiAhIXRoaXMucGFydGljaXBhbnRJbmZvO1xuICB9XG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFRyYWNrUHVibGljYXRpb25CeVNpZChzaWQpIHtcbiAgICByZXR1cm4gdGhpcy50cmFja1B1YmxpY2F0aW9ucy5nZXQoc2lkKTtcbiAgfVxuICAvKiogQGludGVybmFsICovXG4gIHVwZGF0ZUluZm8oaW5mbykge1xuICAgIGlmICghc3VwZXIudXBkYXRlSW5mbyhpbmZvKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyB3ZSBhcmUgZ2V0dGluZyBhIGxpc3Qgb2YgYWxsIGF2YWlsYWJsZSB0cmFja3MsIHJlY29uY2lsZSBpbiBoZXJlXG4gICAgLy8gYW5kIHNlbmQgb3V0IGV2ZW50cyBmb3IgY2hhbmdlc1xuICAgIC8vIHJlY29uY2lsZSB0cmFjayBwdWJsaWNhdGlvbnMsIHB1Ymxpc2ggZXZlbnRzIG9ubHkgaWYgbWV0YWRhdGEgaXMgYWxyZWFkeSB0aGVyZVxuICAgIC8vIGkuZS4gY2hhbmdlcyBzaW5jZSB0aGUgbG9jYWwgcGFydGljaXBhbnQgaGFzIGpvaW5lZFxuICAgIGNvbnN0IHZhbGlkVHJhY2tzID0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IG5ld1RyYWNrcyA9IG5ldyBNYXAoKTtcbiAgICBpbmZvLnRyYWNrcy5mb3JFYWNoKHRpID0+IHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBsZXQgcHVibGljYXRpb24gPSB0aGlzLmdldFRyYWNrUHVibGljYXRpb25CeVNpZCh0aS5zaWQpO1xuICAgICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgICAvLyBuZXcgcHVibGljYXRpb25cbiAgICAgICAgY29uc3Qga2luZCA9IFRyYWNrLmtpbmRGcm9tUHJvdG8odGkudHlwZSk7XG4gICAgICAgIGlmICgha2luZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBwdWJsaWNhdGlvbiA9IG5ldyBSZW1vdGVUcmFja1B1YmxpY2F0aW9uKGtpbmQsIHRpLCAoX2EgPSB0aGlzLnNpZ25hbENsaWVudC5jb25uZWN0T3B0aW9ucykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF1dG9TdWJzY3JpYmUsIHtcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dCxcbiAgICAgICAgICBsb2dnZXJOYW1lOiAoX2IgPSB0aGlzLmxvZ2dlck9wdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sb2dnZXJOYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBwdWJsaWNhdGlvbi51cGRhdGVJbmZvKHRpKTtcbiAgICAgICAgbmV3VHJhY2tzLnNldCh0aS5zaWQsIHB1YmxpY2F0aW9uKTtcbiAgICAgICAgY29uc3QgZXhpc3RpbmdUcmFja09mU291cmNlID0gQXJyYXkuZnJvbSh0aGlzLnRyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKS5maW5kKHB1Ymxpc2hlZFRyYWNrID0+IHB1Ymxpc2hlZFRyYWNrLnNvdXJjZSA9PT0gKHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5zb3VyY2UpKTtcbiAgICAgICAgaWYgKGV4aXN0aW5nVHJhY2tPZlNvdXJjZSAmJiBwdWJsaWNhdGlvbi5zb3VyY2UgIT09IFRyYWNrLlNvdXJjZS5Vbmtub3duKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJyZWNlaXZlZCBhIHNlY29uZCB0cmFjayBwdWJsaWNhdGlvbiBmb3IgXCIuY29uY2F0KHRoaXMuaWRlbnRpdHksIFwiIHdpdGggdGhlIHNhbWUgc291cmNlOiBcIikuY29uY2F0KHB1YmxpY2F0aW9uLnNvdXJjZSksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgb2xkVHJhY2s6IGdldExvZ0NvbnRleHRGcm9tVHJhY2soZXhpc3RpbmdUcmFja09mU291cmNlKSxcbiAgICAgICAgICAgIG5ld1RyYWNrOiBnZXRMb2dDb250ZXh0RnJvbVRyYWNrKHB1YmxpY2F0aW9uKVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZFRyYWNrUHVibGljYXRpb24ocHVibGljYXRpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVibGljYXRpb24udXBkYXRlSW5mbyh0aSk7XG4gICAgICB9XG4gICAgICB2YWxpZFRyYWNrcy5zZXQodGkuc2lkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgLy8gZGV0ZWN0IHJlbW92ZWQgdHJhY2tzXG4gICAgdGhpcy50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIGlmICghdmFsaWRUcmFja3MuaGFzKHB1YmxpY2F0aW9uLnRyYWNrU2lkKSkge1xuICAgICAgICB0aGlzLmxvZy50cmFjZSgnZGV0ZWN0ZWQgcmVtb3ZlZCB0cmFjayBvbiByZW1vdGUgcGFydGljaXBhbnQsIHVucHVibGlzaGluZycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwgZ2V0TG9nQ29udGV4dEZyb21UcmFjayhwdWJsaWNhdGlvbikpKTtcbiAgICAgICAgdGhpcy51bnB1Ymxpc2hUcmFjayhwdWJsaWNhdGlvbi50cmFja1NpZCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgLy8gYWx3YXlzIGVtaXQgZXZlbnRzIGZvciBuZXcgcHVibGljYXRpb25zLCBSb29tIHdpbGwgbm90IGZvcndhcmQgdGhlbSB1bmxlc3MgaXQncyByZWFkeVxuICAgIG5ld1RyYWNrcy5mb3JFYWNoKHB1YmxpY2F0aW9uID0+IHtcbiAgICAgIHRoaXMuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYWNrUHVibGlzaGVkLCBwdWJsaWNhdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICB1bnB1Ymxpc2hUcmFjayhzaWQsIHNlbmRVbnB1Ymxpc2gpIHtcbiAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHRoaXMudHJhY2tQdWJsaWNhdGlvbnMuZ2V0KHNpZCk7XG4gICAgaWYgKCFwdWJsaWNhdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBhbHNvIHNlbmQgdW5zdWJzY3JpYmUsIGlmIHRyYWNrIGlzIGFjdGl2ZWx5IHN1YnNjcmliZWRcbiAgICBjb25zdCB7XG4gICAgICB0cmFja1xuICAgIH0gPSBwdWJsaWNhdGlvbjtcbiAgICBpZiAodHJhY2spIHtcbiAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgIHB1YmxpY2F0aW9uLnNldFRyYWNrKHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIC8vIHJlbW92ZSB0cmFjayBmcm9tIG1hcHMgb25seSBhZnRlciB1bnN1YnNjcmliZWQgaGFzIGJlZW4gZmlyZWRcbiAgICB0aGlzLnRyYWNrUHVibGljYXRpb25zLmRlbGV0ZShzaWQpO1xuICAgIC8vIHJlbW92ZSBmcm9tIHRoZSByaWdodCB0eXBlIG1hcFxuICAgIHN3aXRjaCAocHVibGljYXRpb24ua2luZCkge1xuICAgICAgY2FzZSBUcmFjay5LaW5kLkF1ZGlvOlxuICAgICAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUcmFjay5LaW5kLlZpZGVvOlxuICAgICAgICB0aGlzLnZpZGVvVHJhY2tQdWJsaWNhdGlvbnMuZGVsZXRlKHNpZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoc2VuZFVucHVibGlzaCkge1xuICAgICAgdGhpcy5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24pO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXRBdWRpb091dHB1dChvdXRwdXQpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5hdWRpb091dHB1dCA9IG91dHB1dDtcbiAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICB0aGlzLmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChpc0F1ZGlvVHJhY2socHViLnRyYWNrKSAmJiBpc1JlbW90ZVRyYWNrKHB1Yi50cmFjaykpIHtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHB1Yi50cmFjay5zZXRTaW5rSWQoKF9hID0gb3V0cHV0LmRldmljZUlkKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnZGVmYXVsdCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqIEBpbnRlcm5hbCAqL1xuICBlbWl0KGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuICAgIHRoaXMubG9nLnRyYWNlKCdwYXJ0aWNpcGFudCBldmVudCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgZXZlbnQsXG4gICAgICBhcmdzXG4gICAgfSkpO1xuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuXG52YXIgQ29ubmVjdGlvblN0YXRlO1xuKGZ1bmN0aW9uIChDb25uZWN0aW9uU3RhdGUpIHtcbiAgQ29ubmVjdGlvblN0YXRlW1wiRGlzY29ubmVjdGVkXCJdID0gXCJkaXNjb25uZWN0ZWRcIjtcbiAgQ29ubmVjdGlvblN0YXRlW1wiQ29ubmVjdGluZ1wiXSA9IFwiY29ubmVjdGluZ1wiO1xuICBDb25uZWN0aW9uU3RhdGVbXCJDb25uZWN0ZWRcIl0gPSBcImNvbm5lY3RlZFwiO1xuICBDb25uZWN0aW9uU3RhdGVbXCJSZWNvbm5lY3RpbmdcIl0gPSBcInJlY29ubmVjdGluZ1wiO1xuICBDb25uZWN0aW9uU3RhdGVbXCJTaWduYWxSZWNvbm5lY3RpbmdcIl0gPSBcInNpZ25hbFJlY29ubmVjdGluZ1wiO1xufSkoQ29ubmVjdGlvblN0YXRlIHx8IChDb25uZWN0aW9uU3RhdGUgPSB7fSkpO1xuY29uc3QgY29ubmVjdGlvblJlY29uY2lsZUZyZXF1ZW5jeSA9IDQgKiAxMDAwO1xuLyoqXG4gKiBJbiBMaXZlS2l0LCBhIHJvb20gaXMgdGhlIGxvZ2ljYWwgZ3JvdXBpbmcgZm9yIGEgbGlzdCBvZiBwYXJ0aWNpcGFudHMuXG4gKiBQYXJ0aWNpcGFudHMgaW4gYSByb29tIGNhbiBwdWJsaXNoIHRyYWNrcywgYW5kIHN1YnNjcmliZSB0byBvdGhlcnMnIHRyYWNrcy5cbiAqXG4gKiBhIFJvb20gZmlyZXMgW1tSb29tRXZlbnQgfCBSb29tRXZlbnRzXV0uXG4gKlxuICogQG5vSW5oZXJpdERvY1xuICovXG5jbGFzcyBSb29tIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBSb29tLCB0aGUgcHJpbWFyeSBjb25zdHJ1Y3QgZm9yIGEgTGl2ZUtpdCBzZXNzaW9uLlxuICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHZhciBfdGhpcztcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBzdXBlcigpO1xuICAgIF90aGlzID0gdGhpcztcbiAgICB0aGlzLnN0YXRlID0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZDtcbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIHBhcnRpY2lwYW50cyB0aGF0IGFyZSBhY3RpdmVseSBzcGVha2luZy4gd2hlbiB0aGlzIGNoYW5nZXNcbiAgICAgKiBhIFtbUm9vbUV2ZW50LkFjdGl2ZVNwZWFrZXJzQ2hhbmdlZF1dIGV2ZW50IGlzIGZpcmVkXG4gICAgICovXG4gICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IFtdO1xuICAgIC8qKiByZWZsZWN0cyB0aGUgc2VuZGVyIGVuY3J5cHRpb24gc3RhdHVzIG9mIHRoZSBsb2NhbCBwYXJ0aWNpcGFudCAqL1xuICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGZhbHNlO1xuICAgIHRoaXMuYXVkaW9FbmFibGVkID0gdHJ1ZTtcbiAgICB0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQgPSBmYWxzZTtcbiAgICB0aGlzLmxvZyA9IGxpdmVraXRMb2dnZXI7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xuICAgIHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMudGV4dFN0cmVhbUhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMucnBjSGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5jb25uZWN0ID0gKHVybCwgdG9rZW4sIG9wdHMpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGlmICghaXNCcm93c2VyU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgaWYgKGlzUmVhY3ROYXRpdmUoKSkge1xuICAgICAgICAgIHRocm93IEVycm9yKFwiV2ViUlRDIGlzbid0IGRldGVjdGVkLCBoYXZlIHlvdSBjYWxsZWQgcmVnaXN0ZXJHbG9iYWxzP1wiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBFcnJvcihcIkxpdmVLaXQgZG9lc24ndCBzZWVtIHRvIGJlIHN1cHBvcnRlZCBvbiB0aGlzIGJyb3dzZXIuIFRyeSB0byB1cGRhdGUgeW91ciBicm93c2VyIGFuZCBtYWtlIHN1cmUgbm8gYnJvd3NlciBleHRlbnNpb25zIGFyZSBkaXNhYmxpbmcgd2ViUlRDLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gSW4gY2FzZSBhIGRpc2Nvbm5lY3QgY2FsbGVkIGhhcHBlbmVkIHJpZ2h0IGJlZm9yZSB0aGUgY29ubmVjdCBjYWxsLCBtYWtlIHN1cmUgdGhlIGRpc2Nvbm5lY3QgaXMgY29tcGxldGVkIGZpcnN0IGJ5IGF3YWl0aW5nIGl0cyBsb2NrXG4gICAgICBjb25zdCB1bmxvY2tEaXNjb25uZWN0ID0geWllbGQgdGhpcy5kaXNjb25uZWN0TG9jay5sb2NrKCk7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgICAvLyB3aGVuIHRoZSBzdGF0ZSBpcyByZWNvbm5lY3Rpbmcgb3IgY29ubmVjdGVkLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgaW1tZWRpYXRlbHlcbiAgICAgICAgdGhpcy5sb2cuaW5mbyhcImFscmVhZHkgY29ubmVjdGVkIHRvIHJvb20gXCIuY29uY2F0KHRoaXMubmFtZSksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHVubG9ja0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuY29ubmVjdEZ1dHVyZSkge1xuICAgICAgICB1bmxvY2tEaXNjb25uZWN0KCk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm5lY3RGdXR1cmUucHJvbWlzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyk7XG4gICAgICBpZiAoKChfYSA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTZXJ2ZXJVcmwoKS50b1N0cmluZygpKSAhPT0gdXJsKSB7XG4gICAgICAgIHRoaXMucmVnaW9uVXJsID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSkge1xuICAgICAgICBpZiAodGhpcy5yZWdpb25VcmxQcm92aWRlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdGhpcy5yZWdpb25VcmxQcm92aWRlciA9IG5ldyBSZWdpb25VcmxQcm92aWRlcih1cmwsIHRva2VuKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLnVwZGF0ZVRva2VuKHRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB0cmlnZ2VyIHRoZSBmaXJzdCBmZXRjaCB3aXRob3V0IHdhaXRpbmcgZm9yIGEgcmVzcG9uc2VcbiAgICAgICAgLy8gaWYgaW5pdGlhbCBjb25uZWN0aW9uIGZhaWxzLCB0aGlzIHdpbGwgc3BlZWQgdXAgcGlja2luZyByZWdpb25hbCB1cmxcbiAgICAgICAgLy8gb24gc3Vic2VxdWVudCBydW5zXG4gICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIuZmV0Y2hSZWdpb25TZXR0aW5ncygpLnRoZW4oc2V0dGluZ3MgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSB0aGlzLnJlZ2lvblVybFByb3ZpZGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U2VydmVyUmVwb3J0ZWRSZWdpb25zKHNldHRpbmdzKTtcbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IGZldGNoIHJlZ2lvbiBzZXR0aW5ncycsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgY29uc3QgY29ubmVjdEZuID0gKHJlc29sdmUsIHJlamVjdCwgcmVnaW9uVXJsKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLmFib3J0Q29udHJvbGxlcikge1xuICAgICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwbGljaXQgY3JlYXRpb24gYXMgbG9jYWwgdmFyIG5lZWRlZCB0byBzYXRpc2Z5IFRTIGNvbXBpbGVyIHdoZW4gcGFzc2luZyBpdCB0byBgYXR0ZW1wdENvbm5lY3Rpb25gIGZ1cnRoZXIgZG93blxuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIHRoaXMuYWJvcnRDb250cm9sbGVyID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBpbnRlbnRpb24gdG8gY29ubmVjdCBoYXMgYmVlbiBzaWduYWxsZWQgc28gd2UgY2FuIGFsbG93IGNhbmNlbGxpbmcgb2YgdGhlIGNvbm5lY3Rpb24gdmlhIGRpc2Nvbm5lY3QoKSBhZ2FpblxuICAgICAgICB1bmxvY2tEaXNjb25uZWN0ID09PSBudWxsIHx8IHVubG9ja0Rpc2Nvbm5lY3QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHVubG9ja0Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB5aWVsZCB0aGlzLmF0dGVtcHRDb25uZWN0aW9uKHJlZ2lvblVybCAhPT0gbnVsbCAmJiByZWdpb25VcmwgIT09IHZvaWQgMCA/IHJlZ2lvblVybCA6IHVybCwgdG9rZW4sIG9wdHMsIGFib3J0Q29udHJvbGxlcik7XG4gICAgICAgICAgdGhpcy5hYm9ydENvbnRyb2xsZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgJiYgZSBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiBlLnJlYXNvbiAhPT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLkNhbmNlbGxlZCAmJiBlLnJlYXNvbiAhPT0gQ29ubmVjdGlvbkVycm9yUmVhc29uLk5vdEFsbG93ZWQpIHtcbiAgICAgICAgICAgIGxldCBuZXh0VXJsID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIG5leHRVcmwgPSB5aWVsZCB0aGlzLnJlZ2lvblVybFByb3ZpZGVyLmdldE5leHRCZXN0UmVnaW9uVXJsKChfYSA9IHRoaXMuYWJvcnRDb250cm9sbGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lnbmFsKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENvbm5lY3Rpb25FcnJvciAmJiAoZXJyb3Iuc3RhdHVzID09PSA0MDEgfHwgZXJyb3IucmVhc29uID09PSBDb25uZWN0aW9uRXJyb3JSZWFzb24uQ2FuY2VsbGVkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCk7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChuZXh0VXJsICYmICEoKF9iID0gdGhpcy5hYm9ydENvbnRyb2xsZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zaWduYWwuYWJvcnRlZCkpIHtcbiAgICAgICAgICAgICAgdGhpcy5sb2cuaW5mbyhcIkluaXRpYWwgY29ubmVjdGlvbiBmYWlsZWQgd2l0aCBDb25uZWN0aW9uRXJyb3I6IFwiLmNvbmNhdChlLm1lc3NhZ2UsIFwiLiBSZXRyeWluZyB3aXRoIGFub3RoZXIgcmVnaW9uOiBcIikuY29uY2F0KG5leHRVcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgICAgICAgIHlpZWxkIGNvbm5lY3RGbihyZXNvbHZlLCByZWplY3QsIG5leHRVcmwpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvcihlKSk7XG4gICAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGV0IGRpc2Nvbm5lY3RSZWFzb24gPSBEaXNjb25uZWN0UmVhc29uLlVOS05PV05fUkVBU09OO1xuICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBDb25uZWN0aW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgZGlzY29ubmVjdFJlYXNvbiA9IGdldERpc2Nvbm5lY3RSZWFzb25Gcm9tQ29ubmVjdGlvbkVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVEaXNjb25uZWN0KHRoaXMub3B0aW9ucy5zdG9wTG9jYWxUcmFja09uVW5wdWJsaXNoLCBkaXNjb25uZWN0UmVhc29uKTtcbiAgICAgICAgICAgIHJlamVjdChlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgcmVnaW9uVXJsID0gdGhpcy5yZWdpb25Vcmw7XG4gICAgICB0aGlzLnJlZ2lvblVybCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IG5ldyBGdXR1cmUoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0Rm4ocmVzb2x2ZSwgcmVqZWN0LCByZWdpb25VcmwpO1xuICAgICAgfSwgKCkgPT4ge1xuICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbkZ1dHVyZXMoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHRoaXMuY29ubmVjdEZ1dHVyZS5wcm9taXNlO1xuICAgIH0pO1xuICAgIHRoaXMuY29ubmVjdFNpZ25hbCA9ICh1cmwsIHRva2VuLCBlbmdpbmUsIGNvbm5lY3RPcHRpb25zLCByb29tT3B0aW9ucywgYWJvcnRDb250cm9sbGVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIGVuZ2luZS5qb2luKHVybCwgdG9rZW4sIHtcbiAgICAgICAgYXV0b1N1YnNjcmliZTogY29ubmVjdE9wdGlvbnMuYXV0b1N1YnNjcmliZSxcbiAgICAgICAgYWRhcHRpdmVTdHJlYW06IHR5cGVvZiByb29tT3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSA9PT0gJ29iamVjdCcgPyB0cnVlIDogcm9vbU9wdGlvbnMuYWRhcHRpdmVTdHJlYW0sXG4gICAgICAgIG1heFJldHJpZXM6IGNvbm5lY3RPcHRpb25zLm1heFJldHJpZXMsXG4gICAgICAgIGUyZWVFbmFibGVkOiAhIXRoaXMuZTJlZU1hbmFnZXIsXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IGNvbm5lY3RPcHRpb25zLndlYnNvY2tldFRpbWVvdXRcbiAgICAgIH0sIGFib3J0Q29udHJvbGxlci5zaWduYWwpO1xuICAgICAgbGV0IHNlcnZlckluZm8gPSBqb2luUmVzcG9uc2Uuc2VydmVySW5mbztcbiAgICAgIGlmICghc2VydmVySW5mbykge1xuICAgICAgICBzZXJ2ZXJJbmZvID0ge1xuICAgICAgICAgIHZlcnNpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJWZXJzaW9uLFxuICAgICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5zZXJ2ZXJJbmZvID0gc2VydmVySW5mbztcbiAgICAgIHRoaXMubG9nLmRlYnVnKFwiY29ubmVjdGVkIHRvIExpdmVraXQgU2VydmVyIFwiLmNvbmNhdChPYmplY3QuZW50cmllcyhzZXJ2ZXJJbmZvKS5tYXAoX3JlZiA9PiB7XG4gICAgICAgIGxldCBba2V5LCB2YWx1ZV0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gXCJcIi5jb25jYXQoa2V5LCBcIjogXCIpLmNvbmNhdCh2YWx1ZSk7XG4gICAgICB9KS5qb2luKCcsICcpKSwge1xuICAgICAgICByb29tOiAoX2EgPSBqb2luUmVzcG9uc2Uucm9vbSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm5hbWUsXG4gICAgICAgIHJvb21TaWQ6IChfYiA9IGpvaW5SZXNwb25zZS5yb29tKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2lkLFxuICAgICAgICBpZGVudGl0eTogKF9jID0gam9pblJlc3BvbnNlLnBhcnRpY2lwYW50KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuaWRlbnRpdHlcbiAgICAgIH0pO1xuICAgICAgaWYgKCFzZXJ2ZXJJbmZvLnZlcnNpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkU2VydmVyKCd1bmtub3duIHNlcnZlciB2ZXJzaW9uJyk7XG4gICAgICB9XG4gICAgICBpZiAoc2VydmVySW5mby52ZXJzaW9uID09PSAnMC4xNS4xJyAmJiB0aGlzLm9wdGlvbnMuZHluYWNhc3QpIHtcbiAgICAgICAgdGhpcy5sb2cuZGVidWcoJ2Rpc2FibGluZyBkeW5hY2FzdCBkdWUgdG8gc2VydmVyIHZlcnNpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAvLyBkeW5hY2FzdCBoYXMgYSBidWcgaW4gMC4xNS4xLCBzbyB3ZSBjYW5ub3QgdXNlIGl0IHRoZW5cbiAgICAgICAgcm9vbU9wdGlvbnMuZHluYWNhc3QgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBqb2luUmVzcG9uc2U7XG4gICAgfSk7XG4gICAgdGhpcy5hcHBseUpvaW5SZXNwb25zZSA9IGpvaW5SZXNwb25zZSA9PiB7XG4gICAgICBjb25zdCBwaSA9IGpvaW5SZXNwb25zZS5wYXJ0aWNpcGFudDtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWQgPSBwaS5zaWQ7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPSBwaS5pZGVudGl0eTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5zZXRFbmFibGVkUHVibGlzaENvZGVjcyhqb2luUmVzcG9uc2UuZW5hYmxlZFB1Ymxpc2hDb2RlY3MpO1xuICAgICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlICYmIHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFNpZlRyYWlsZXIoam9pblJlc3BvbnNlLnNpZlRyYWlsZXIpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgdGhpcy5sb2cuZXJyb3IoZSBpbnN0YW5jZW9mIEVycm9yID8gZS5tZXNzYWdlIDogJ0NvdWxkIG5vdCBzZXQgU2lmVHJhaWxlcicsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIHBvcHVsYXRlIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHRoZXNlIHNob3VsZCBub3QgdHJpZ2dlciBuZXcgZXZlbnRzXG4gICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyhbcGksIC4uLmpvaW5SZXNwb25zZS5vdGhlclBhcnRpY2lwYW50c10pO1xuICAgICAgaWYgKGpvaW5SZXNwb25zZS5yb29tKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZShqb2luUmVzcG9uc2Uucm9vbSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmF0dGVtcHRDb25uZWN0aW9uID0gKHVybCwgdG9rZW4sIG9wdHMsIGFib3J0Q29udHJvbGxlcikgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZyB8fCAoKF9hID0gdGhpcy5lbmdpbmUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZW5kaW5nUmVjb25uZWN0KSkge1xuICAgICAgICB0aGlzLmxvZy5pbmZvKCdSZWNvbm5lY3Rpb24gYXR0ZW1wdCByZXBsYWNlZCBieSBuZXcgY29ubmVjdGlvbiBhdHRlbXB0JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGNsb3NlIGFuZCByZWNyZWF0ZSB0aGUgZXhpc3RpbmcgZW5naW5lIGluIG9yZGVyIHRvIGdldCByaWQgb2YgYW55IHBvdGVudGlhbGx5IG9uZ29pbmcgcmVjb25uZWN0aW9uIGF0dGVtcHRzXG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNyZWF0ZSBlbmdpbmUgaWYgcHJldmlvdXNseSBkaXNjb25uZWN0ZWRcbiAgICAgICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICAgICAgfVxuICAgICAgaWYgKChfYiA9IHRoaXMucmVnaW9uVXJsUHJvdmlkZXIpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pc0Nsb3VkKCkpIHtcbiAgICAgICAgdGhpcy5lbmdpbmUuc2V0UmVnaW9uVXJsUHJvdmlkZXIodGhpcy5yZWdpb25VcmxQcm92aWRlcik7XG4gICAgICB9XG4gICAgICB0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKTtcbiAgICAgIHRoaXMuY29ubk9wdGlvbnMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMpLCBvcHRzKTtcbiAgICAgIGlmICh0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZykge1xuICAgICAgICB0aGlzLmVuZ2luZS5ydGNDb25maWcgPSB0aGlzLmNvbm5PcHRpb25zLnJ0Y0NvbmZpZztcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dCkge1xuICAgICAgICB0aGlzLmVuZ2luZS5wZWVyQ29ubmVjdGlvblRpbWVvdXQgPSB0aGlzLmNvbm5PcHRpb25zLnBlZXJDb25uZWN0aW9uVGltZW91dDtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpvaW5SZXNwb25zZSA9IHlpZWxkIHRoaXMuY29ubmVjdFNpZ25hbCh1cmwsIHRva2VuLCB0aGlzLmVuZ2luZSwgdGhpcy5jb25uT3B0aW9ucywgdGhpcy5vcHRpb25zLCBhYm9ydENvbnRyb2xsZXIpO1xuICAgICAgICB0aGlzLmFwcGx5Sm9pblJlc3BvbnNlKGpvaW5SZXNwb25zZSk7XG4gICAgICAgIC8vIGZvcndhcmQgbWV0YWRhdGEgY2hhbmdlZCBmb3IgdGhlIGxvY2FsIHBhcnRpY2lwYW50XG4gICAgICAgIHRoaXMuc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCk7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLnJlY3JlYXRlRW5naW5lKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdGluZ0Vycm9yID0gbmV3IENvbm5lY3Rpb25FcnJvcihcImNvdWxkIG5vdCBlc3RhYmxpc2ggc2lnbmFsIGNvbm5lY3Rpb25cIiwgQ29ubmVjdGlvbkVycm9yUmVhc29uLlNlcnZlclVucmVhY2hhYmxlKTtcbiAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3IubWVzc2FnZSA9IFwiXCIuY29uY2F0KHJlc3VsdGluZ0Vycm9yLm1lc3NhZ2UsIFwiOiBcIikuY29uY2F0KGVyci5tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRXJyb3IucmVhc29uID0gZXJyLnJlYXNvbjtcbiAgICAgICAgICByZXN1bHRpbmdFcnJvci5zdGF0dXMgPSBlcnIuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiZXJyb3IgdHJ5aW5nIHRvIGVzdGFibGlzaCBzaWduYWwgY29ubmVjdGlvblwiLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvcjogZXJyXG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhyb3cgcmVzdWx0aW5nRXJyb3I7XG4gICAgICB9XG4gICAgICBpZiAoYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgdGhyb3cgbmV3IENvbm5lY3Rpb25FcnJvcihcIkNvbm5lY3Rpb24gYXR0ZW1wdCBhYm9ydGVkXCIsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUud2FpdEZvclBDSW5pdGlhbENvbm5lY3Rpb24odGhpcy5jb25uT3B0aW9ucy5wZWVyQ29ubmVjdGlvblRpbWVvdXQsIGFib3J0Q29udHJvbGxlcik7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsb3NlKCk7XG4gICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgdGhyb3cgZTtcbiAgICAgIH1cbiAgICAgIC8vIGFsc28gaG9vayB1bmxvYWQgZXZlbnRcbiAgICAgIGlmIChpc1dlYigpICYmIHRoaXMub3B0aW9ucy5kaXNjb25uZWN0T25QYWdlTGVhdmUpIHtcbiAgICAgICAgLy8gY2FwdHVyaW5nIGJvdGggJ3BhZ2VoaWRlJyBhbmQgJ2JlZm9yZXVubG9hZCcgdG8gY2FwdHVyZSBicm9hZGVzdCBzZXQgb2YgYnJvd3NlciBiZWhhdmlvcnNcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3BhZ2VoaWRlJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLm9uUGFnZUxlYXZlKTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1dlYigpKSB7XG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2ZyZWV6ZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Db25uZWN0ZWQpO1xuICAgICAgdGhpcy5yZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBkaXNjb25uZWN0cyB0aGUgcm9vbSwgZW1pdHMgW1tSb29tRXZlbnQuRGlzY29ubmVjdGVkXV1cbiAgICAgKi9cbiAgICB0aGlzLmRpc2Nvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJnc18xID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzXzFbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gX19hd2FpdGVyKF90aGlzLCBbLi4uYXJnc18xXSwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuICAgICAgICBsZXQgc3RvcFRyYWNrcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogdHJ1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgIGNvbnN0IHVubG9jayA9IHlpZWxkIF90aGlzMi5kaXNjb25uZWN0TG9jay5sb2NrKCk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfdGhpczIuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgX3RoaXMyLmxvZy5kZWJ1ZygnYWxyZWFkeSBkaXNjb25uZWN0ZWQnLCBfdGhpczIubG9nQ29udGV4dCk7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzMi5sb2cuaW5mbygnZGlzY29ubmVjdCBmcm9tIHJvb20nLCBPYmplY3QuYXNzaWduKHt9LCBfdGhpczIubG9nQ29udGV4dCkpO1xuICAgICAgICAgICAgaWYgKF90aGlzMi5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RpbmcgfHwgX3RoaXMyLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IF90aGlzMi5pc1Jlc3VtaW5nKSB7XG4gICAgICAgICAgICAgIC8vIHRyeSBhYm9ydGluZyBwZW5kaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdFxuICAgICAgICAgICAgICBfdGhpczIubG9nLndhcm4oJ2Fib3J0IGNvbm5lY3Rpb24gYXR0ZW1wdCcsIF90aGlzMi5sb2dDb250ZXh0KTtcbiAgICAgICAgICAgICAgKF9hID0gX3RoaXMyLmFib3J0Q29udHJvbGxlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgICAgICAgICAgIC8vIGluIGNhc2UgdGhlIGFib3J0IGNvbnRyb2xsZXIgZGlkbid0IG1hbmFnZSB0byBjYW5jZWwgdGhlIGNvbm5lY3Rpb24gYXR0ZW1wdCwgcmVqZWN0IHRoZSBjb25uZWN0IHByb21pc2UgZXhwbGljaXRseVxuICAgICAgICAgICAgICAoX2MgPSAoX2IgPSBfdGhpczIuY29ubmVjdEZ1dHVyZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlamVjdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmNhbGwoX2IsIG5ldyBDb25uZWN0aW9uRXJyb3IoJ0NsaWVudCBpbml0aWF0ZWQgZGlzY29ubmVjdCcsIENvbm5lY3Rpb25FcnJvclJlYXNvbi5DYW5jZWxsZWQpKTtcbiAgICAgICAgICAgICAgX3RoaXMyLmNvbm5lY3RGdXR1cmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZW5kIGxlYXZlXG4gICAgICAgICAgICBpZiAoISgoX2QgPSBfdGhpczIuZW5naW5lKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QuY2xpZW50LmlzRGlzY29ubmVjdGVkKSkge1xuICAgICAgICAgICAgICB5aWVsZCBfdGhpczIuZW5naW5lLmNsaWVudC5zZW5kTGVhdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGNsb3NlIGVuZ2luZSAoYWxzbyBjbG9zZXMgY2xpZW50KVxuICAgICAgICAgICAgaWYgKF90aGlzMi5lbmdpbmUpIHtcbiAgICAgICAgICAgICAgeWllbGQgX3RoaXMyLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMyLmhhbmRsZURpc2Nvbm5lY3Qoc3RvcFRyYWNrcywgRGlzY29ubmVjdFJlYXNvbi5DTElFTlRfSU5JVElBVEVEKTtcbiAgICAgICAgICAgIC8qIEB0cy1pZ25vcmUgKi9cbiAgICAgICAgICAgIF90aGlzMi5lbmdpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHVubG9jaygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSgpO1xuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLm9uUGFnZUxlYXZlID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdGhpcy5sb2cuaW5mbygnUGFnZSBsZWF2ZSBkZXRlY3RlZCwgZGlzY29ubmVjdGluZycsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICB5aWVsZCB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBCcm93c2VycyBoYXZlIGRpZmZlcmVudCBwb2xpY2llcyByZWdhcmRpbmcgYXVkaW8gcGxheWJhY2suIE1vc3QgcmVxdWlyaW5nXG4gICAgICogc29tZSBmb3JtIG9mIHVzZXIgaW50ZXJhY3Rpb24gKGNsaWNrL3RhcC9ldGMpLlxuICAgICAqIEluIHRob3NlIGNhc2VzLCBhdWRpbyB3aWxsIGJlIHNpbGVudCB1bnRpbCBhIGNsaWNrL3RhcCB0cmlnZ2VyaW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nXG4gICAgICogLSBgc3RhcnRBdWRpb2BcbiAgICAgKiAtIGBnZXRVc2VyTWVkaWFgXG4gICAgICovXG4gICAgdGhpcy5zdGFydEF1ZGlvID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgZWxlbWVudHMgPSBbXTtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICBpZiAoYnJvd3NlciAmJiBicm93c2VyLm9zID09PSAnaU9TJykge1xuICAgICAgICAvKipcbiAgICAgICAgICogaU9TIGJsb2NrcyBhdWRpbyBlbGVtZW50IHBsYXliYWNrIGlmXG4gICAgICAgICAqIC0gdXNlciBpcyBub3QgcHVibGlzaGluZyBhdWRpbyB0aGVtc2VsdmVzIGFuZFxuICAgICAgICAgKiAtIG5vIG90aGVyIGF1ZGlvIHNvdXJjZSBpcyBwbGF5aW5nXG4gICAgICAgICAqXG4gICAgICAgICAqIGFzIGEgd29ya2Fyb3VuZCwgd2UgY3JlYXRlIGFuIGF1ZGlvIGVsZW1lbnQgd2l0aCBhbiBlbXB0eSB0cmFjaywgc28gdGhhdFxuICAgICAgICAgKiBzaWxlbnQgYXVkaW8gaXMgYWx3YXlzIHBsYXlpbmdcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGF1ZGlvSWQgPSAnbGl2ZWtpdC1kdW1teS1hdWRpby1lbCc7XG4gICAgICAgIGxldCBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChhdWRpb0lkKTtcbiAgICAgICAgaWYgKCFkdW1teUF1ZGlvRWwpIHtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICAgIGR1bW15QXVkaW9FbC5pZCA9IGF1ZGlvSWQ7XG4gICAgICAgICAgZHVtbXlBdWRpb0VsLmF1dG9wbGF5ID0gdHJ1ZTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCB0cmFjayA9IGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaygpO1xuICAgICAgICAgIHRyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbShbdHJhY2tdKTtcbiAgICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gc3RyZWFtO1xuICAgICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Zpc2liaWxpdHljaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWR1bW15QXVkaW9FbCkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBzZXQgdGhlIHNyY09iamVjdCB0byBudWxsIG9uIHBhZ2UgaGlkZSBpbiBvcmRlciB0byBwcmV2ZW50IGxvY2sgc2NyZWVuIGNvbnRyb2xzIHRvIHNob3cgdXAgZm9yIGl0XG4gICAgICAgICAgICBkdW1teUF1ZGlvRWwuc3JjT2JqZWN0ID0gZG9jdW1lbnQuaGlkZGVuID8gbnVsbCA6IHN0cmVhbTtcbiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuaGlkZGVuKSB7XG4gICAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdwYWdlIHZpc2libGUgYWdhaW4sIHRyaWdnZXJpbmcgc3RhcnRBdWRpbyB0byByZXN1bWUgcGxheWJhY2sgYW5kIHVwZGF0ZSBwbGF5YmFjayBzdGF0dXMnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgICAgICB0aGlzLnN0YXJ0QXVkaW8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZChkdW1teUF1ZGlvRWwpO1xuICAgICAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgICAgICBkdW1teUF1ZGlvRWwgPT09IG51bGwgfHwgZHVtbXlBdWRpb0VsID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkdW1teUF1ZGlvRWwucmVtb3ZlKCk7XG4gICAgICAgICAgICBkdW1teUF1ZGlvRWwgPSBudWxsO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnRzLnB1c2goZHVtbXlBdWRpb0VsKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHQgPT4ge1xuICAgICAgICAgIGlmICh0LnRyYWNrKSB7XG4gICAgICAgICAgICB0LnRyYWNrLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlID0+IHtcbiAgICAgICAgICAgICAgZWxlbWVudHMucHVzaChlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmFjcXVpcmVBdWRpb0NvbnRleHQoKSwgLi4uZWxlbWVudHMubWFwKGUgPT4ge1xuICAgICAgICAgIGUubXV0ZWQgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZS5wbGF5KCk7XG4gICAgICAgIH0pXSk7XG4gICAgICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja1N0YXJ0ZWQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQoZXJyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuc3RhcnRWaWRlbyA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnRzID0gW107XG4gICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpIHtcbiAgICAgICAgcC52aWRlb1RyYWNrUHVibGljYXRpb25zLmZvckVhY2godHIgPT4ge1xuICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAoX2EgPSB0ci50cmFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmF0dGFjaGVkRWxlbWVudHMuZm9yRWFjaChlbCA9PiB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRzLmluY2x1ZGVzKGVsKSkge1xuICAgICAgICAgICAgICBlbGVtZW50cy5wdXNoKGVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB5aWVsZCBQcm9taXNlLmFsbChlbGVtZW50cy5tYXAoZWwgPT4gZWwucGxheSgpKSkudGhlbigoKSA9PiB7XG4gICAgICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQoKTtcbiAgICAgIH0pLmNhdGNoKGUgPT4ge1xuICAgICAgICBpZiAoZS5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgICAgIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ1Jlc3VtaW5nIHZpZGVvIHBsYXliYWNrIGZhaWxlZCwgbWFrZSBzdXJlIHlvdSBjYWxsIGBzdGFydFZpZGVvYCBkaXJlY3RseSBpbiBhIHVzZXIgZ2VzdHVyZSBoYW5kbGVyJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgdGhpcy5oYW5kbGVSZXN0YXJ0aW5nID0gKCkgPT4ge1xuICAgICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICAgIC8vIGluIGNhc2Ugd2Ugd2VudCBmcm9tIHJlc3VtaW5nIHRvIGZ1bGwtcmVjb25uZWN0LCBtYWtlIHN1cmUgdG8gcmVmbGVjdCBpdCBvbiB0aGUgaXNSZXN1bWluZyBmbGFnXG4gICAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICAgIC8vIGFsc28gdW53aW5kIGV4aXN0aW5nIHBhcnRpY2lwYW50cyAmIGV4aXN0aW5nIHN1YnNjcmlwdGlvbnNcbiAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKHAuaWRlbnRpdHksIHApO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVNpZ25hbFJlc3RhcnRlZCA9IGpvaW5SZXNwb25zZSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInNpZ25hbCByZWNvbm5lY3RlZCB0byBzZXJ2ZXIsIHJlZ2lvbiBcIi5jb25jYXQoam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvbiksIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICByZWdpb246IGpvaW5SZXNwb25zZS5zZXJ2ZXJSZWdpb25cbiAgICAgIH0pKTtcbiAgICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICAgIHRoaXMuYXBwbHlKb2luUmVzcG9uc2Uoam9pblJlc3BvbnNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIHVucHVibGlzaCAmIHJlcHVibGlzaCB0cmFja3NcbiAgICAgICAgeWllbGQgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnJlcHVibGlzaEFsbFRyYWNrcyh1bmRlZmluZWQsIHRydWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5sb2cuZXJyb3IoJ2Vycm9yIHRyeWluZyB0byByZS1wdWJsaXNoIHRyYWNrcyBhZnRlciByZWNvbm5lY3Rpb24nLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMubG9nQ29udGV4dCksIHtcbiAgICAgICAgICBlcnJvclxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS53YWl0Rm9yUmVzdGFydGVkKCk7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwiZnVsbHkgcmVjb25uZWN0ZWQgdG8gc2VydmVyXCIsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIHJlZ2lvbjogam9pblJlc3BvbnNlLnNlcnZlclJlZ2lvblxuICAgICAgICB9KSk7XG4gICAgICB9IGNhdGNoIChfYSkge1xuICAgICAgICAvLyByZWNvbm5lY3Rpb24gZmFpbGVkLCBoYW5kbGVEaXNjb25uZWN0IGlzIGJlaW5nIGludm9rZWQgYWxyZWFkeSwganVzdCByZXR1cm4gaGVyZVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCk7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzID0gcGFydGljaXBhbnRJbmZvcyA9PiB7XG4gICAgICAvLyBoYW5kbGUgY2hhbmdlcyB0byBwYXJ0aWNpcGFudCBzdGF0ZSwgYW5kIHNlbmQgZXZlbnRzXG4gICAgICBwYXJ0aWNpcGFudEluZm9zLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKGluZm8uaWRlbnRpdHkgPT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSkge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBMaXZlS2l0IHNlcnZlciBkb2Vzbid0IHNlbmQgaWRlbnRpdHkgaW5mbyBwcmlvciB0byB2ZXJzaW9uIDEuNS4yIGluIGRpc2Nvbm5lY3QgdXBkYXRlc1xuICAgICAgICAvLyBzbyB3ZSB0cnkgdG8gbWFwIGFuIGVtcHR5IGlkZW50aXR5IHRvIGFuIGFscmVhZHkga25vd24gc0lEIG1hbnVhbGx5XG4gICAgICAgIGlmIChpbmZvLmlkZW50aXR5ID09PSAnJykge1xuICAgICAgICAgIGluZm8uaWRlbnRpdHkgPSAoX2EgPSB0aGlzLnNpZFRvSWRlbnRpdHkuZ2V0KGluZm8uc2lkKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGluZm8uaWRlbnRpdHkpO1xuICAgICAgICAvLyB3aGVuIGl0J3MgZGlzY29ubmVjdGVkLCBzZW5kIHVwZGF0ZXNcbiAgICAgICAgaWYgKGluZm8uc3RhdGUgPT09IFBhcnRpY2lwYW50SW5mb19TdGF0ZS5ESVNDT05ORUNURUQpIHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkKGluZm8uaWRlbnRpdHksIHJlbW90ZVBhcnRpY2lwYW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBjcmVhdGUgcGFydGljaXBhbnQgaWYgZG9lc24ndCBleGlzdFxuICAgICAgICAgIHJlbW90ZVBhcnRpY2lwYW50ID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uaWRlbnRpdHksIGluZm8pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIC8vIHVwZGF0ZXMgYXJlIHNlbnQgb25seSB3aGVuIHRoZXJlJ3MgYSBjaGFuZ2UgdG8gc3BlYWtlciBvcmRlcmluZ1xuICAgIHRoaXMuaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUgPSBzcGVha2VycyA9PiB7XG4gICAgICBjb25zdCBhY3RpdmVTcGVha2VycyA9IFtdO1xuICAgICAgY29uc3Qgc2VlblNpZHMgPSB7fTtcbiAgICAgIHNwZWFrZXJzLmZvckVhY2goc3BlYWtlciA9PiB7XG4gICAgICAgIHNlZW5TaWRzW3NwZWFrZXIuc2lkXSA9IHRydWU7XG4gICAgICAgIGlmIChzcGVha2VyLnNpZCA9PT0gdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZCkge1xuICAgICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0SXNTcGVha2luZyh0cnVlKTtcbiAgICAgICAgICBhY3RpdmVTcGVha2Vycy5wdXNoKHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgcCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzcGVha2VyLnNpZCk7XG4gICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgIHAuYXVkaW9MZXZlbCA9IHNwZWFrZXIubGV2ZWw7XG4gICAgICAgICAgICBwLnNldElzU3BlYWtpbmcodHJ1ZSk7XG4gICAgICAgICAgICBhY3RpdmVTcGVha2Vycy5wdXNoKHApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIXNlZW5TaWRzW3RoaXMubG9jYWxQYXJ0aWNpcGFudC5zaWRdKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hdWRpb0xldmVsID0gMDtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldElzU3BlYWtpbmcoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZm9yRWFjaChwID0+IHtcbiAgICAgICAgaWYgKCFzZWVuU2lkc1twLnNpZF0pIHtcbiAgICAgICAgICBwLmF1ZGlvTGV2ZWwgPSAwO1xuICAgICAgICAgIHAuc2V0SXNTcGVha2luZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XG4gICAgfTtcbiAgICAvLyBwcm9jZXNzIGxpc3Qgb2YgY2hhbmdlZCBzcGVha2Vyc1xuICAgIHRoaXMuaGFuZGxlU3BlYWtlcnNDaGFuZ2VkID0gc3BlYWtlclVwZGF0ZXMgPT4ge1xuICAgICAgY29uc3QgbGFzdFNwZWFrZXJzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2Vycy5mb3JFYWNoKHAgPT4ge1xuICAgICAgICBjb25zdCByZW1vdGVQYXJ0aWNpcGFudCA9IHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmdldChwLmlkZW50aXR5KTtcbiAgICAgICAgaWYgKHJlbW90ZVBhcnRpY2lwYW50ICYmIHJlbW90ZVBhcnRpY2lwYW50LnNpZCAhPT0gcC5zaWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGFzdFNwZWFrZXJzLnNldChwLnNpZCwgcCk7XG4gICAgICB9KTtcbiAgICAgIHNwZWFrZXJVcGRhdGVzLmZvckVhY2goc3BlYWtlciA9PiB7XG4gICAgICAgIGxldCBwID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKHNwZWFrZXIuc2lkKTtcbiAgICAgICAgaWYgKHNwZWFrZXIuc2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgcCA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcC5hdWRpb0xldmVsID0gc3BlYWtlci5sZXZlbDtcbiAgICAgICAgcC5zZXRJc1NwZWFraW5nKHNwZWFrZXIuYWN0aXZlKTtcbiAgICAgICAgaWYgKHNwZWFrZXIuYWN0aXZlKSB7XG4gICAgICAgICAgbGFzdFNwZWFrZXJzLnNldChzcGVha2VyLnNpZCwgcCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGFzdFNwZWFrZXJzLmRlbGV0ZShzcGVha2VyLnNpZCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgY29uc3QgYWN0aXZlU3BlYWtlcnMgPSBBcnJheS5mcm9tKGxhc3RTcGVha2Vycy52YWx1ZXMoKSk7XG4gICAgICBhY3RpdmVTcGVha2Vycy5zb3J0KChhLCBiKSA9PiBiLmF1ZGlvTGV2ZWwgLSBhLmF1ZGlvTGV2ZWwpO1xuICAgICAgdGhpcy5hY3RpdmVTcGVha2VycyA9IGFjdGl2ZVNwZWFrZXJzO1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkLCBhY3RpdmVTcGVha2Vycyk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlID0gc3RyZWFtU3RhdGVVcGRhdGUgPT4ge1xuICAgICAgc3RyZWFtU3RhdGVVcGRhdGUuc3RyZWFtU3RhdGVzLmZvckVhY2goc3RyZWFtU3RhdGUgPT4ge1xuICAgICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRoaXMuZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzdHJlYW1TdGF0ZS5wYXJ0aWNpcGFudFNpZCk7XG4gICAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHN0cmVhbVN0YXRlLnRyYWNrU2lkKTtcbiAgICAgICAgaWYgKCFwdWIgfHwgIXB1Yi50cmFjaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdTdHJlYW1TdGF0ZSA9IFRyYWNrLnN0cmVhbVN0YXRlRnJvbVByb3RvKHN0cmVhbVN0YXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKG5ld1N0cmVhbVN0YXRlICE9PSBwdWIudHJhY2suc3RyZWFtU3RhdGUpIHtcbiAgICAgICAgICBwdWIudHJhY2suc3RyZWFtU3RhdGUgPSBuZXdTdHJlYW1TdGF0ZTtcbiAgICAgICAgICBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdHJlYW1TdGF0ZUNoYW5nZWQsIHB1YiwgcHViLnRyYWNrLnN0cmVhbVN0YXRlKTtcbiAgICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N0cmVhbVN0YXRlQ2hhbmdlZCwgcHViLCBwdWIudHJhY2suc3RyZWFtU3RhdGUsIHBhcnRpY2lwYW50KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUgPSB1cGRhdGUgPT4ge1xuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLmdldFJlbW90ZVBhcnRpY2lwYW50QnlTaWQodXBkYXRlLnBhcnRpY2lwYW50U2lkKTtcbiAgICAgIGlmICghcGFydGljaXBhbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcHViID0gcGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkKHVwZGF0ZS50cmFja1NpZCk7XG4gICAgICBpZiAoIXB1Yikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBwdWIuc2V0QWxsb3dlZCh1cGRhdGUuYWxsb3dlZCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yID0gdXBkYXRlID0+IHtcbiAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gQXJyYXkuZnJvbSh0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkuZmluZChwID0+IHAudHJhY2tQdWJsaWNhdGlvbnMuaGFzKHVwZGF0ZS50cmFja1NpZCkpO1xuICAgICAgaWYgKCFwYXJ0aWNpcGFudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwdWIgPSBwYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9uQnlTaWQodXBkYXRlLnRyYWNrU2lkKTtcbiAgICAgIGlmICghcHViKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHB1Yi5zZXRTdWJzY3JpcHRpb25FcnJvcih1cGRhdGUuZXJyKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlRGF0YVBhY2tldCA9IHBhY2tldCA9PiB7XG4gICAgICAvLyBmaW5kIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgY29uc3QgcGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQocGFja2V0LnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAndXNlcicpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVVc2VyUGFja2V0KHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUsIHBhY2tldC5raW5kKTtcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICd0cmFuc2NyaXB0aW9uJykge1xuICAgICAgICB0aGlzLmhhbmRsZVRyYW5zY3JpcHRpb24ocGFydGljaXBhbnQsIHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnc2lwRHRtZicpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTaXBEdG1mKHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ2NoYXRNZXNzYWdlJykge1xuICAgICAgICB0aGlzLmhhbmRsZUNoYXRNZXNzYWdlKHBhcnRpY2lwYW50LCBwYWNrZXQudmFsdWUudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ21ldHJpY3MnKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlTWV0cmljcyhwYWNrZXQudmFsdWUudmFsdWUsIHBhcnRpY2lwYW50KTtcbiAgICAgIH0gZWxzZSBpZiAocGFja2V0LnZhbHVlLmNhc2UgPT09ICdzdHJlYW1IZWFkZXInKSB7XG4gICAgICAgIHRoaXMuaGFuZGxlU3RyZWFtSGVhZGVyKHBhY2tldC52YWx1ZS52YWx1ZSwgcGFja2V0LnBhcnRpY2lwYW50SWRlbnRpdHkpO1xuICAgICAgfSBlbHNlIGlmIChwYWNrZXQudmFsdWUuY2FzZSA9PT0gJ3N0cmVhbUNodW5rJykge1xuICAgICAgICB0aGlzLmhhbmRsZVN0cmVhbUNodW5rKHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAnc3RyZWFtVHJhaWxlcicpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVTdHJlYW1UcmFpbGVyKHBhY2tldC52YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHBhY2tldC52YWx1ZS5jYXNlID09PSAncnBjUmVxdWVzdCcpIHtcbiAgICAgICAgY29uc3QgcnBjID0gcGFja2V0LnZhbHVlLnZhbHVlO1xuICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nUnBjUmVxdWVzdChwYWNrZXQucGFydGljaXBhbnRJZGVudGl0eSwgcnBjLmlkLCBycGMubWV0aG9kLCBycGMucGF5bG9hZCwgcnBjLnJlc3BvbnNlVGltZW91dE1zLCBycGMudmVyc2lvbik7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZVVzZXJQYWNrZXQgPSAocGFydGljaXBhbnQsIHVzZXJQYWNrZXQsIGtpbmQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIHBhcnRpY2lwYW50LCBraW5kLCB1c2VyUGFja2V0LnRvcGljKTtcbiAgICAgIC8vIGFsc28gZW1pdCBvbiB0aGUgcGFydGljaXBhbnRcbiAgICAgIHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuRGF0YVJlY2VpdmVkLCB1c2VyUGFja2V0LnBheWxvYWQsIGtpbmQpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVTaXBEdG1mID0gKHBhcnRpY2lwYW50LCBkdG1mKSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlNpcERUTUZSZWNlaXZlZCwgZHRtZiwgcGFydGljaXBhbnQpO1xuICAgICAgLy8gYWxzbyBlbWl0IG9uIHRoZSBwYXJ0aWNpcGFudFxuICAgICAgcGFydGljaXBhbnQgPT09IG51bGwgfHwgcGFydGljaXBhbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5TaXBEVE1GUmVjZWl2ZWQsIGR0bWYpO1xuICAgIH07XG4gICAgdGhpcy5idWZmZXJlZFNlZ21lbnRzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuaGFuZGxlVHJhbnNjcmlwdGlvbiA9IChfcmVtb3RlUGFydGljaXBhbnQsIHRyYW5zY3JpcHRpb24pID0+IHtcbiAgICAgIC8vIGZpbmQgdGhlIHBhcnRpY2lwYW50XG4gICAgICBjb25zdCBwYXJ0aWNpcGFudCA9IHRyYW5zY3JpcHRpb24udHJhbnNjcmliZWRQYXJ0aWNpcGFudElkZW50aXR5ID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPyB0aGlzLmxvY2FsUGFydGljaXBhbnQgOiB0aGlzLmdldFBhcnRpY2lwYW50QnlJZGVudGl0eSh0cmFuc2NyaXB0aW9uLnRyYW5zY3JpYmVkUGFydGljaXBhbnRJZGVudGl0eSk7XG4gICAgICBjb25zdCBwdWJsaWNhdGlvbiA9IHBhcnRpY2lwYW50ID09PSBudWxsIHx8IHBhcnRpY2lwYW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5nZXQodHJhbnNjcmlwdGlvbi50cmFja0lkKTtcbiAgICAgIGNvbnN0IHNlZ21lbnRzID0gZXh0cmFjdFRyYW5zY3JpcHRpb25TZWdtZW50cyh0cmFuc2NyaXB0aW9uLCB0aGlzLnRyYW5zY3JpcHRpb25SZWNlaXZlZFRpbWVzKTtcbiAgICAgIHB1YmxpY2F0aW9uID09PSBudWxsIHx8IHB1YmxpY2F0aW9uID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwdWJsaWNhdGlvbi5lbWl0KFRyYWNrRXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkLCBzZWdtZW50cyk7XG4gICAgICBwYXJ0aWNpcGFudCA9PT0gbnVsbCB8fCBwYXJ0aWNpcGFudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGFydGljaXBhbnQuZW1pdChQYXJ0aWNpcGFudEV2ZW50LlRyYW5zY3JpcHRpb25SZWNlaXZlZCwgc2VnbWVudHMsIHB1YmxpY2F0aW9uKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkLCBzZWdtZW50cywgcGFydGljaXBhbnQsIHB1YmxpY2F0aW9uKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQ2hhdE1lc3NhZ2UgPSAocGFydGljaXBhbnQsIGNoYXRNZXNzYWdlKSA9PiB7XG4gICAgICBjb25zdCBtc2cgPSBleHRyYWN0Q2hhdE1lc3NhZ2UoY2hhdE1lc3NhZ2UpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5DaGF0TWVzc2FnZSwgbXNnLCBwYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZU1ldHJpY3MgPSAobWV0cmljcywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTWV0cmljc1JlY2VpdmVkLCBtZXRyaWNzLCBwYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUF1ZGlvUGxheWJhY2tTdGFydGVkID0gKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCB0cnVlKTtcbiAgICB9O1xuICAgIHRoaXMuaGFuZGxlQXVkaW9QbGF5YmFja0ZhaWxlZCA9IGUgPT4ge1xuICAgICAgdGhpcy5sb2cud2FybignY291bGQgbm90IHBsYXliYWNrIGF1ZGlvJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGVycm9yOiBlXG4gICAgICB9KSk7XG4gICAgICBpZiAoIXRoaXMuY2FuUGxheWJhY2tBdWRpbykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmF1ZGlvRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrU3RhcnRlZCA9ICgpID0+IHtcbiAgICAgIGlmICh0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVmlkZW9QbGF5YmFja1N0YXR1c0NoYW5nZWQsIHRydWUpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkID0gKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQpIHtcbiAgICAgICAgdGhpcy5pc1ZpZGVvUGxheWJhY2tCbG9ja2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5WaWRlb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCwgZmFsc2UpO1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgY29uc3QgcHJldmlvdXNEZXZpY2VzID0gRGV2aWNlTWFuYWdlci5nZXRJbnN0YW5jZSgpLnByZXZpb3VzRGV2aWNlcztcbiAgICAgIC8vIGNoZWNrIGZvciBhdmFpbGFibGUgZGV2aWNlcywgYnV0IGRvbid0IHJlcXVlc3QgcGVybWlzc2lvbnMgaW4gb3JkZXIgdG8gYXZvaWQgcHJvbXB0cyBmb3Iga2luZHMgdGhhdCBoYXZlbid0IGJlZW4gdXNlZCBiZWZvcmVcbiAgICAgIGNvbnN0IGF2YWlsYWJsZURldmljZXMgPSB5aWVsZCBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkuZ2V0RGV2aWNlcyh1bmRlZmluZWQsIGZhbHNlKTtcbiAgICAgIGNvbnN0IGJyb3dzZXIgPSBnZXRCcm93c2VyKCk7XG4gICAgICBpZiAoKGJyb3dzZXIgPT09IG51bGwgfHwgYnJvd3NlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogYnJvd3Nlci5uYW1lKSA9PT0gJ0Nocm9tZScgJiYgYnJvd3Nlci5vcyAhPT0gJ2lPUycpIHtcbiAgICAgICAgZm9yIChsZXQgYXZhaWxhYmxlRGV2aWNlIG9mIGF2YWlsYWJsZURldmljZXMpIHtcbiAgICAgICAgICBjb25zdCBwcmV2aW91c0RldmljZSA9IHByZXZpb3VzRGV2aWNlcy5maW5kKGluZm8gPT4gaW5mby5kZXZpY2VJZCA9PT0gYXZhaWxhYmxlRGV2aWNlLmRldmljZUlkKTtcbiAgICAgICAgICBpZiAocHJldmlvdXNEZXZpY2UgJiYgcHJldmlvdXNEZXZpY2UubGFiZWwgIT09ICcnICYmIHByZXZpb3VzRGV2aWNlLmtpbmQgPT09IGF2YWlsYWJsZURldmljZS5raW5kICYmIHByZXZpb3VzRGV2aWNlLmxhYmVsICE9PSBhdmFpbGFibGVEZXZpY2UubGFiZWwpIHtcbiAgICAgICAgICAgIC8vIGxhYmVsIGhhcyBjaGFuZ2VkIG9uIGRldmljZSB0aGUgc2FtZSBkZXZpY2VJZCwgaW5kaWNhdGluZyB0aGF0IHRoZSBkZWZhdWx0IGRldmljZSBoYXMgY2hhbmdlZCBvbiB0aGUgT1MgbGV2ZWxcbiAgICAgICAgICAgIGlmICh0aGlzLmdldEFjdGl2ZURldmljZShhdmFpbGFibGVEZXZpY2Uua2luZCkgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgICAvLyBlbWl0IGFuIGFjdGl2ZSBkZXZpY2UgY2hhbmdlIGV2ZW50IG9ubHkgaWYgdGhlIHNlbGVjdGVkIG91dHB1dCBkZXZpY2UgaXMgYWN0dWFsbHkgb24gYGRlZmF1bHRgXG4gICAgICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQWN0aXZlRGV2aWNlQ2hhbmdlZCwgYXZhaWxhYmxlRGV2aWNlLmtpbmQsIGF2YWlsYWJsZURldmljZS5kZXZpY2VJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBpbnB1dHMgYXJlIGF1dG9tYXRpY2FsbHkgaGFuZGxlZCB2aWEgVHJhY2tFdmVudC5FbmRlZCBjYXVzaW5nIGEgVHJhY2tFdmVudC5SZXN0YXJ0ZWQuIEhlcmUgd2Ugb25seSBuZWVkIHRvIHdvcnJ5IGFib3V0IGF1ZGlvb3V0cHV0cyBjaGFuZ2luZ1xuICAgICAgY29uc3Qga2luZHMgPSBbJ2F1ZGlvb3V0cHV0JywgJ2F1ZGlvaW5wdXQnLCAndmlkZW9pbnB1dCddO1xuICAgICAgZm9yIChsZXQga2luZCBvZiBraW5kcykge1xuICAgICAgICBjb25zdCBkZXZpY2VzT2ZLaW5kID0gYXZhaWxhYmxlRGV2aWNlcy5maWx0ZXIoZCA9PiBkLmtpbmQgPT09IGtpbmQpO1xuICAgICAgICBjb25zdCBhY3RpdmVEZXZpY2UgPSB0aGlzLmdldEFjdGl2ZURldmljZShraW5kKTtcbiAgICAgICAgaWYgKGFjdGl2ZURldmljZSA9PT0gKChfYSA9IHByZXZpb3VzRGV2aWNlcy5maWx0ZXIoaW5mbyA9PiBpbmZvLmtpbmQgPT09IGtpbmQpWzBdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZGV2aWNlSWQpKSB7XG4gICAgICAgICAgLy8gaW4gIFNhZmFyaSB0aGUgZmlyc3QgZGV2aWNlIGlzIGFsd2F5cyB0aGUgZGVmYXVsdCwgc28gd2UgYXNzdW1lIGEgdXNlciBvbiB0aGUgZGVmYXVsdCBkZXZpY2Ugd291bGQgbGlrZSB0byBzd2l0Y2ggdG8gdGhlIGRlZmF1bHQgb25jZSBpdCBjaGFuZ2VzXG4gICAgICAgICAgLy8gRkYgZG9lc24ndCBlbWl0IGFuIGV2ZW50IHdoZW4gdGhlIGRlZmF1bHQgZGV2aWNlIGNoYW5nZXMsIHNvIHdlIHBlcmZvcm0gdGhlIHNhbWUgYmVzdCBlZmZvcnQgYW5kIHN3aXRjaCB0byB0aGUgbmV3IGRldmljZSBvbmNlIGNvbm5lY3RlZCBhbmQgaWYgaXQncyB0aGUgZmlyc3QgaW4gdGhlIGFycmF5XG4gICAgICAgICAgaWYgKGRldmljZXNPZktpbmQubGVuZ3RoID4gMCAmJiAoKF9iID0gZGV2aWNlc09mS2luZFswXSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmRldmljZUlkKSAhPT0gYWN0aXZlRGV2aWNlKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaEFjdGl2ZURldmljZShraW5kLCBkZXZpY2VzT2ZLaW5kWzBdLmRldmljZUlkKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnICYmICFpc1NhZmFyaSgpIHx8IGtpbmQgPT09ICd2aWRlb2lucHV0Jykge1xuICAgICAgICAgIC8vIGFpcnBvZHMgb24gU2FmYXJpIG5lZWQgc3BlY2lhbCBoYW5kbGluZyBmb3IgYXVkaW9pbnB1dCBhcyB0aGUgdHJhY2sgZG9lc24ndCBlbmQgYXMgc29vbiBhcyB5b3UgdGFrZSB0aGVtIG91dFxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN3aXRjaCB0byBmaXJzdCBhdmFpbGFibGUgZGV2aWNlIGlmIHByZXZpb3VzbHkgYWN0aXZlIGRldmljZSBpcyBub3QgYXZhaWxhYmxlIGFueSBtb3JlXG4gICAgICAgIGlmIChkZXZpY2VzT2ZLaW5kLmxlbmd0aCA+IDAgJiYgIWRldmljZXNPZktpbmQuZmluZChkZXZpY2VJbmZvID0+IGRldmljZUluZm8uZGV2aWNlSWQgPT09IHRoaXMuZ2V0QWN0aXZlRGV2aWNlKGtpbmQpKSkge1xuICAgICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoQWN0aXZlRGV2aWNlKGtpbmQsIGRldmljZXNPZktpbmRbMF0uZGV2aWNlSWQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50Lk1lZGlhRGV2aWNlc0NoYW5nZWQpO1xuICAgIH0pO1xuICAgIHRoaXMuaGFuZGxlUm9vbVVwZGF0ZSA9IHJvb20gPT4ge1xuICAgICAgY29uc3Qgb2xkUm9vbSA9IHRoaXMucm9vbUluZm87XG4gICAgICB0aGlzLnJvb21JbmZvID0gcm9vbTtcbiAgICAgIGlmIChvbGRSb29tICYmIG9sZFJvb20ubWV0YWRhdGEgIT09IHJvb20ubWV0YWRhdGEpIHtcbiAgICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUm9vbU1ldGFkYXRhQ2hhbmdlZCwgcm9vbS5tZXRhZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAoKG9sZFJvb20gPT09IG51bGwgfHwgb2xkUm9vbSA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2xkUm9vbS5hY3RpdmVSZWNvcmRpbmcpICE9PSByb29tLmFjdGl2ZVJlY29yZGluZykge1xuICAgICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5SZWNvcmRpbmdTdGF0dXNDaGFuZ2VkLCByb29tLmFjdGl2ZVJlY29yZGluZyk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLmhhbmRsZUNvbm5lY3Rpb25RdWFsaXR5VXBkYXRlID0gdXBkYXRlID0+IHtcbiAgICAgIHVwZGF0ZS51cGRhdGVzLmZvckVhY2goaW5mbyA9PiB7XG4gICAgICAgIGlmIChpbmZvLnBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldENvbm5lY3Rpb25RdWFsaXR5KGluZm8ucXVhbGl0eSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5nZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkKGluZm8ucGFydGljaXBhbnRTaWQpO1xuICAgICAgICBpZiAocGFydGljaXBhbnQpIHtcbiAgICAgICAgICBwYXJ0aWNpcGFudC5zZXRDb25uZWN0aW9uUXVhbGl0eShpbmZvLnF1YWxpdHkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkID0gbWV0YWRhdGEgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkID0gbmFtZSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCA9IGNoYW5nZWRBdHRyaWJ1dGVzID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnRBdHRyaWJ1dGVzQ2hhbmdlZCwgY2hhbmdlZEF0dHJpYnV0ZXMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja011dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tNdXRlZCwgcHViLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkID0gcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uVHJhY2tQcm9jZXNzb3JVcGRhdGUgPSBwcm9jZXNzb3IgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gcHJvY2Vzc29yID09PSBudWxsIHx8IHByb2Nlc3NvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogcHJvY2Vzc29yLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwocHJvY2Vzc29yLCB0aGlzKTtcbiAgICB9O1xuICAgIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkID0gcHViID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub24oVHJhY2tFdmVudC5UcmFja1Byb2Nlc3NvclVwZGF0ZSwgdGhpcy5vblRyYWNrUHJvY2Vzc29yVXBkYXRlKTtcbiAgICAgIChfYiA9IHB1Yi50cmFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLm9uKFRyYWNrRXZlbnQuUmVzdGFydGVkLCB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCk7XG4gICAgICAoX2UgPSAoX2QgPSAoX2MgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5nZXRQcm9jZXNzb3IoKSkgPT09IG51bGwgfHwgX2QgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9kLm9uUHVibGlzaCkgPT09IG51bGwgfHwgX2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9lLmNhbGwoX2QsIHRoaXMpO1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgICBpZiAoaXNMb2NhbEF1ZGlvVHJhY2socHViLnRyYWNrKSkge1xuICAgICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgcHViLnRyYWNrLmNoZWNrRm9yU2lsZW5jZSgpO1xuICAgICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxBdWRpb1NpbGVuY2VEZXRlY3RlZCwgcHViKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgZGV2aWNlSWQgPSB5aWVsZCAoX2YgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5nZXREZXZpY2VJZChmYWxzZSk7XG4gICAgICBjb25zdCBkZXZpY2VLaW5kID0gc291cmNlVG9LaW5kKHB1Yi5zb3VyY2UpO1xuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCA9IHB1YiA9PiB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgKF9hID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eub2ZmKFRyYWNrRXZlbnQuVHJhY2tQcm9jZXNzb3JVcGRhdGUsIHRoaXMub25UcmFja1Byb2Nlc3NvclVwZGF0ZSk7XG4gICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5vZmYoVHJhY2tFdmVudC5SZXN0YXJ0ZWQsIHRoaXMub25Mb2NhbFRyYWNrUmVzdGFydGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCBwdWIsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxUcmFja1Jlc3RhcnRlZCA9IHRyYWNrID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGRldmljZUlkID0geWllbGQgdHJhY2suZ2V0RGV2aWNlSWQoZmFsc2UpO1xuICAgICAgY29uc3QgZGV2aWNlS2luZCA9IHNvdXJjZVRvS2luZCh0cmFjay5zb3VyY2UpO1xuICAgICAgaWYgKGRldmljZUtpbmQgJiYgZGV2aWNlSWQgJiYgZGV2aWNlSWQgIT09IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuZ2V0KGRldmljZUtpbmQpKSB7XG4gICAgICAgIHRoaXMubG9nLmRlYnVnKFwibG9jYWwgdHJhY2sgcmVzdGFydGVkLCBzZXR0aW5nIFwiLmNvbmNhdChkZXZpY2VLaW5kLCBcIiBcIikuY29uY2F0KGRldmljZUlkLCBcIiBhY3RpdmVcIiksIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hY3RpdmVEZXZpY2VNYXAuc2V0KGRldmljZUtpbmQsIGRldmljZUlkKTtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBkZXZpY2VLaW5kLCBkZXZpY2VJZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5vbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkID0gcXVhbGl0eSA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCwgcXVhbGl0eSwgdGhpcy5sb2NhbFBhcnRpY2lwYW50KTtcbiAgICB9O1xuICAgIHRoaXMub25NZWRpYURldmljZXNFcnJvciA9IGUgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5NZWRpYURldmljZXNFcnJvciwgZSk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCA9IHByZXZQZXJtaXNzaW9ucyA9PiB7XG4gICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMsIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfTtcbiAgICB0aGlzLm9uTG9jYWxDaGF0TWVzc2FnZVNlbnQgPSBtc2cgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5DaGF0TWVzc2FnZSwgbXNnLCB0aGlzLmxvY2FsUGFydGljaXBhbnQpO1xuICAgIH07XG4gICAgdGhpcy5zZXRNYXhMaXN0ZW5lcnMoMTAwKTtcbiAgICB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnNpZFRvSWRlbnRpdHkgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByb29tT3B0aW9uRGVmYXVsdHMpLCBvcHRpb25zKTtcbiAgICB0aGlzLmxvZyA9IGdldExvZ2dlcigoX2EgPSB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogTG9nZ2VyTmFtZXMuUm9vbSk7XG4gICAgdGhpcy50cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGF1ZGlvRGVmYXVsdHMpLCBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMpO1xuICAgIHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdmlkZW9EZWZhdWx0cyksIG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cyk7XG4gICAgdGhpcy5vcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHVibGlzaERlZmF1bHRzKSwgb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnB1Ymxpc2hEZWZhdWx0cyk7XG4gICAgdGhpcy5tYXliZUNyZWF0ZUVuZ2luZSgpO1xuICAgIHRoaXMuZGlzY29ubmVjdExvY2sgPSBuZXcgXygpO1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudCA9IG5ldyBMb2NhbFBhcnRpY2lwYW50KCcnLCAnJywgdGhpcy5lbmdpbmUsIHRoaXMub3B0aW9ucywgdGhpcy5ycGNIYW5kbGVycyk7XG4gICAgaWYgKHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoJ3ZpZGVvaW5wdXQnLCB1bndyYXBDb25zdHJhaW50KHRoaXMub3B0aW9ucy52aWRlb0NhcHR1cmVEZWZhdWx0cy5kZXZpY2VJZCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSB7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuYWN0aXZlRGV2aWNlTWFwLnNldCgnYXVkaW9pbnB1dCcsIHVud3JhcENvbnN0cmFpbnQodGhpcy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkKSk7XG4gICAgfVxuICAgIGlmICgoX2IgPSB0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZXZpY2VJZCkge1xuICAgICAgdGhpcy5zd2l0Y2hBY3RpdmVEZXZpY2UoJ2F1ZGlvb3V0cHV0JywgdW53cmFwQ29uc3RyYWludCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQuZGV2aWNlSWQpKS5jYXRjaChlID0+IHRoaXMubG9nLndhcm4oXCJDb3VsZCBub3Qgc2V0IGF1ZGlvIG91dHB1dDogXCIuY29uY2F0KGUubWVzc2FnZSksIHRoaXMubG9nQ29udGV4dCkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5vcHRpb25zLmUyZWUpIHtcbiAgICAgIHRoaXMuc2V0dXBFMkVFKCk7XG4gICAgfVxuICAgIGlmIChpc1dlYigpKSB7XG4gICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAvLyBpbiBvcmRlciB0byBjYXRjaCBkZXZpY2UgY2hhbmdlcyBwcmlvciB0byByb29tIGNvbm5lY3Rpb24gd2UgbmVlZCB0byByZWdpc3RlciB0aGUgZXZlbnQgaW4gdGhlIGNvbnN0cnVjdG9yXG4gICAgICAoX2MgPSBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuYWRkRXZlbnRMaXN0ZW5lcignZGV2aWNlY2hhbmdlJywgdGhpcy5oYW5kbGVEZXZpY2VDaGFuZ2UsIHtcbiAgICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgICB9KTtcbiAgICAgIGlmIChSb29tLmNsZWFudXBSZWdpc3RyeSkge1xuICAgICAgICBSb29tLmNsZWFudXBSZWdpc3RyeS5yZWdpc3Rlcih0aGlzLCAoKSA9PiB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSB0ZXh0IHN0cmVhbSBoYW5kbGVyIGZvciB0b3BpYyBcXFwiXCIuY29uY2F0KHRvcGljLCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuXCIpKTtcbiAgICB9XG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cbiAgdW5yZWdpc3RlclRleHRTdHJlYW1IYW5kbGVyKHRvcGljKSB7XG4gICAgdGhpcy50ZXh0U3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcbiAgfVxuICByZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljLCBjYWxsYmFjaykge1xuICAgIGlmICh0aGlzLmJ5dGVTdHJlYW1IYW5kbGVycy5oYXModG9waWMpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQSBieXRlIHN0cmVhbSBoYW5kbGVyIGZvciB0b3BpYyBcXFwiXCIuY29uY2F0KHRvcGljLCBcIlxcXCIgaGFzIGFscmVhZHkgYmVlbiBzZXQuXCIpKTtcbiAgICB9XG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuc2V0KHRvcGljLCBjYWxsYmFjayk7XG4gIH1cbiAgdW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyKHRvcGljKSB7XG4gICAgdGhpcy5ieXRlU3RyZWFtSGFuZGxlcnMuZGVsZXRlKHRvcGljKTtcbiAgfVxuICAvKipcbiAgICogRXN0YWJsaXNoZXMgdGhlIHBhcnRpY2lwYW50IGFzIGEgcmVjZWl2ZXIgZm9yIGNhbGxzIG9mIHRoZSBzcGVjaWZpZWQgUlBDIG1ldGhvZC5cbiAgICpcbiAgICogQHBhcmFtIG1ldGhvZCAtIFRoZSBuYW1lIG9mIHRoZSBpbmRpY2F0ZWQgUlBDIG1ldGhvZFxuICAgKiBAcGFyYW0gaGFuZGxlciAtIFdpbGwgYmUgaW52b2tlZCB3aGVuIGFuIFJQQyByZXF1ZXN0IGZvciB0aGlzIG1ldGhvZCBpcyByZWNlaXZlZFxuICAgKiBAcmV0dXJucyBBIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIHRoZSBtZXRob2QgaXMgc3VjY2Vzc2Z1bGx5IHJlZ2lzdGVyZWRcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGEgaGFuZGxlciBmb3IgdGhpcyBtZXRob2QgaXMgYWxyZWFkeSByZWdpc3RlcmVkIChtdXN0IGNhbGwgdW5yZWdpc3RlclJwY01ldGhvZCBmaXJzdClcbiAgICpcbiAgICogQGV4YW1wbGVcbiAgICogYGBgdHlwZXNjcmlwdFxuICAgKiByb29tLmxvY2FsUGFydGljaXBhbnQ/LnJlZ2lzdGVyUnBjTWV0aG9kKFxuICAgKiAgICdncmVldCcsXG4gICAqICAgYXN5bmMgKGRhdGE6IFJwY0ludm9jYXRpb25EYXRhKSA9PiB7XG4gICAqICAgICBjb25zb2xlLmxvZyhgUmVjZWl2ZWQgZ3JlZXRpbmcgZnJvbSAke2RhdGEuY2FsbGVySWRlbnRpdHl9OiAke2RhdGEucGF5bG9hZH1gKTtcbiAgICogICAgIHJldHVybiBgSGVsbG8sICR7ZGF0YS5jYWxsZXJJZGVudGl0eX0hYDtcbiAgICogICB9XG4gICAqICk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBUaGUgaGFuZGxlciBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzIHRvIGEgc3RyaW5nLlxuICAgKiBJZiB1bmFibGUgdG8gcmVzcG9uZCB3aXRoaW4gYHJlc3BvbnNlVGltZW91dGAsIHRoZSByZXF1ZXN0IHdpbGwgcmVzdWx0IGluIGFuIGVycm9yIG9uIHRoZSBjYWxsZXIncyBzaWRlLlxuICAgKlxuICAgKiBZb3UgbWF5IHRocm93IGVycm9ycyBvZiB0eXBlIGBScGNFcnJvcmAgd2l0aCBhIHN0cmluZyBgbWVzc2FnZWAgaW4gdGhlIGhhbmRsZXIsXG4gICAqIGFuZCB0aGV5IHdpbGwgYmUgcmVjZWl2ZWQgb24gdGhlIGNhbGxlcidzIHNpZGUgd2l0aCB0aGUgbWVzc2FnZSBpbnRhY3QuXG4gICAqIE90aGVyIGVycm9ycyB0aHJvd24gaW4geW91ciBoYW5kbGVyIHdpbGwgbm90IGJlIHRyYW5zbWl0dGVkIGFzLWlzLCBhbmQgd2lsbCBpbnN0ZWFkIGFycml2ZSB0byB0aGUgY2FsbGVyIGFzIGAxNTAwYCAoXCJBcHBsaWNhdGlvbiBFcnJvclwiKS5cbiAgICovXG4gIHJlZ2lzdGVyUnBjTWV0aG9kKG1ldGhvZCwgaGFuZGxlcikge1xuICAgIGlmICh0aGlzLnJwY0hhbmRsZXJzLmhhcyhtZXRob2QpKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIlJQQyBoYW5kbGVyIGFscmVhZHkgcmVnaXN0ZXJlZCBmb3IgbWV0aG9kIFwiLmNvbmNhdChtZXRob2QsIFwiLCB1bnJlZ2lzdGVyUnBjTWV0aG9kIGJlZm9yZSB0cnlpbmcgdG8gcmVnaXN0ZXIgYWdhaW5cIikpO1xuICAgIH1cbiAgICB0aGlzLnJwY0hhbmRsZXJzLnNldChtZXRob2QsIGhhbmRsZXIpO1xuICB9XG4gIC8qKlxuICAgKiBVbnJlZ2lzdGVycyBhIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBSUEMgbWV0aG9kLlxuICAgKlxuICAgKiBAcGFyYW0gbWV0aG9kIC0gVGhlIG5hbWUgb2YgdGhlIFJQQyBtZXRob2QgdG8gdW5yZWdpc3RlclxuICAgKi9cbiAgdW5yZWdpc3RlclJwY01ldGhvZChtZXRob2QpIHtcbiAgICB0aGlzLnJwY0hhbmRsZXJzLmRlbGV0ZShtZXRob2QpO1xuICB9XG4gIGhhbmRsZUluY29taW5nUnBjUmVxdWVzdChjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCBtZXRob2QsIHBheWxvYWQsIHJlc3BvbnNlVGltZW91dCwgdmVyc2lvbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB5aWVsZCB0aGlzLmVuZ2luZS5wdWJsaXNoUnBjQWNrKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQpO1xuICAgICAgaWYgKHZlcnNpb24gIT09IDEpIHtcbiAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUucHVibGlzaFJwY1Jlc3BvbnNlKGNhbGxlcklkZW50aXR5LCByZXF1ZXN0SWQsIG51bGwsIFJwY0Vycm9yLmJ1aWx0SW4oJ1VOU1VQUE9SVEVEX1ZFUlNJT04nKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLnJwY0hhbmRsZXJzLmdldChtZXRob2QpO1xuICAgICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCBudWxsLCBScGNFcnJvci5idWlsdEluKCdVTlNVUFBPUlRFRF9NRVRIT0QnKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCByZXNwb25zZUVycm9yID0gbnVsbDtcbiAgICAgIGxldCByZXNwb25zZVBheWxvYWQgPSBudWxsO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBoYW5kbGVyKHtcbiAgICAgICAgICByZXF1ZXN0SWQsXG4gICAgICAgICAgY2FsbGVySWRlbnRpdHksXG4gICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICByZXNwb25zZVRpbWVvdXRcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChieXRlTGVuZ3RoKHJlc3BvbnNlKSA+IE1BWF9QQVlMT0FEX0JZVEVTKSB7XG4gICAgICAgICAgcmVzcG9uc2VFcnJvciA9IFJwY0Vycm9yLmJ1aWx0SW4oJ1JFU1BPTlNFX1BBWUxPQURfVE9PX0xBUkdFJyk7XG4gICAgICAgICAgY29uc29sZS53YXJuKFwiUlBDIFJlc3BvbnNlIHBheWxvYWQgdG9vIGxhcmdlIGZvciBcIi5jb25jYXQobWV0aG9kKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzcG9uc2VQYXlsb2FkID0gcmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIFJwY0Vycm9yKSB7XG4gICAgICAgICAgcmVzcG9uc2VFcnJvciA9IGVycm9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuY2F1Z2h0IGVycm9yIHJldHVybmVkIGJ5IFJQQyBoYW5kbGVyIGZvciBcIi5jb25jYXQobWV0aG9kLCBcIi4gUmV0dXJuaW5nIEFQUExJQ0FUSU9OX0VSUk9SIGluc3RlYWQuXCIpLCBlcnJvcik7XG4gICAgICAgICAgcmVzcG9uc2VFcnJvciA9IFJwY0Vycm9yLmJ1aWx0SW4oJ0FQUExJQ0FUSU9OX0VSUk9SJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMuZW5naW5lLnB1Ymxpc2hScGNSZXNwb25zZShjYWxsZXJJZGVudGl0eSwgcmVxdWVzdElkLCByZXNwb25zZVBheWxvYWQsIHJlc3BvbnNlRXJyb3IpO1xuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzZXRFMkVFRW5hYmxlZChlbmFibGVkKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLmUyZWVNYW5hZ2VyKSB7XG4gICAgICAgIHlpZWxkIFByb21pc2UuYWxsKFt0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0RTJFRUVuYWJsZWQoZW5hYmxlZCldKTtcbiAgICAgICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSAhPT0gJycpIHtcbiAgICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyLnNldFBhcnRpY2lwYW50Q3J5cHRvckVuYWJsZWQoZW5hYmxlZCwgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmlkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2UyZWUgbm90IGNvbmZpZ3VyZWQsIHBsZWFzZSBzZXQgZTJlZSBzZXR0aW5ncyB3aXRoaW4gdGhlIHJvb20gb3B0aW9ucycpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNldHVwRTJFRSgpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5lMmVlKSB7XG4gICAgICBpZiAoJ2UyZWVNYW5hZ2VyJyBpbiB0aGlzLm9wdGlvbnMuZTJlZSkge1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyID0gdGhpcy5vcHRpb25zLmUyZWUuZTJlZU1hbmFnZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmUyZWVNYW5hZ2VyID0gbmV3IEUyRUVNYW5hZ2VyKHRoaXMub3B0aW9ucy5lMmVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LlBhcnRpY2lwYW50RW5jcnlwdGlvblN0YXR1c0NoYW5nZWQsIChlbmFibGVkLCBwYXJ0aWNpcGFudCkgPT4ge1xuICAgICAgICBpZiAoaXNMb2NhbFBhcnRpY2lwYW50KHBhcnRpY2lwYW50KSkge1xuICAgICAgICAgIHRoaXMuaXNFMkVFRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5QYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkLCBlbmFibGVkLCBwYXJ0aWNpcGFudCk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIub24oRW5jcnlwdGlvbkV2ZW50LkVuY3J5cHRpb25FcnJvciwgZXJyb3IgPT4gdGhpcy5lbWl0KFJvb21FdmVudC5FbmNyeXB0aW9uRXJyb3IsIGVycm9yKSk7XG4gICAgICAoX2EgPSB0aGlzLmUyZWVNYW5hZ2VyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0dXAodGhpcyk7XG4gICAgfVxuICB9XG4gIGdldCBsb2dDb250ZXh0KCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4ge1xuICAgICAgcm9vbTogdGhpcy5uYW1lLFxuICAgICAgcm9vbUlEOiAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2lkLFxuICAgICAgcGFydGljaXBhbnQ6IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5pZGVudGl0eSxcbiAgICAgIHBJRDogdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNpZFxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIGlmIHRoZSBjdXJyZW50IHJvb20gaGFzIGEgcGFydGljaXBhbnQgd2l0aCBgcmVjb3JkZXI6IHRydWVgIGluIGl0cyBKV1QgZ3JhbnRcbiAgICoqL1xuICBnZXQgaXNSZWNvcmRpbmcoKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5yb29tSW5mbykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmFjdGl2ZVJlY29yZGluZykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIHNlcnZlciBhc3NpZ25lZCB1bmlxdWUgcm9vbSBpZC5cbiAgICogcmV0dXJucyBvbmNlIGEgc2lkIGhhcyBiZWVuIGlzc3VlZCBieSB0aGUgc2VydmVyLlxuICAgKi9cbiAgZ2V0U2lkKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yb29tSW5mbyAmJiB0aGlzLnJvb21JbmZvLnNpZCAhPT0gJycpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vbUluZm8uc2lkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY29uc3QgaGFuZGxlUm9vbVVwZGF0ZSA9IHJvb21JbmZvID0+IHtcbiAgICAgICAgICBpZiAocm9vbUluZm8uc2lkICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xuICAgICAgICAgICAgcmVzb2x2ZShyb29tSW5mby5zaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUm9vbVVwZGF0ZSwgaGFuZGxlUm9vbVVwZGF0ZSk7XG4gICAgICAgIHRoaXMub25jZShSb29tRXZlbnQuRGlzY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbmdpbmUub2ZmKEVuZ2luZUV2ZW50LlJvb21VcGRhdGUsIGhhbmRsZVJvb21VcGRhdGUpO1xuICAgICAgICAgIHJlamVjdCgnUm9vbSBkaXNjb25uZWN0ZWQgYmVmb3JlIHJvb20gc2VydmVyIGlkIHdhcyBhdmFpbGFibGUnKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAvKiogdXNlciBhc3NpZ25lZCBuYW1lLCBkZXJpdmVkIGZyb20gSldUIHRva2VuICovXG4gIGdldCBuYW1lKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJztcbiAgfVxuICAvKiogcm9vbSBtZXRhZGF0YSAqL1xuICBnZXQgbWV0YWRhdGEoKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWV0YWRhdGE7XG4gIH1cbiAgZ2V0IG51bVBhcnRpY2lwYW50cygpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLnJvb21JbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubnVtUGFydGljaXBhbnRzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICB9XG4gIGdldCBudW1QdWJsaXNoZXJzKCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMucm9vbUluZm8pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5udW1QdWJsaXNoZXJzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAwO1xuICB9XG4gIG1heWJlQ3JlYXRlRW5naW5lKCkge1xuICAgIGlmICh0aGlzLmVuZ2luZSAmJiAhdGhpcy5lbmdpbmUuaXNDbG9zZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5lbmdpbmUgPSBuZXcgUlRDRW5naW5lKHRoaXMub3B0aW9ucyk7XG4gICAgdGhpcy5lbmdpbmUub24oRW5naW5lRXZlbnQuUGFydGljaXBhbnRVcGRhdGUsIHRoaXMuaGFuZGxlUGFydGljaXBhbnRVcGRhdGVzKS5vbihFbmdpbmVFdmVudC5Sb29tVXBkYXRlLCB0aGlzLmhhbmRsZVJvb21VcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlNwZWFrZXJzQ2hhbmdlZCwgdGhpcy5oYW5kbGVTcGVha2Vyc0NoYW5nZWQpLm9uKEVuZ2luZUV2ZW50LlN0cmVhbVN0YXRlQ2hhbmdlZCwgdGhpcy5oYW5kbGVTdHJlYW1TdGF0ZVVwZGF0ZSkub24oRW5naW5lRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUsIHRoaXMuaGFuZGxlQ29ubmVjdGlvblF1YWxpdHlVcGRhdGUpLm9uKEVuZ2luZUV2ZW50LlN1YnNjcmlwdGlvbkVycm9yLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvbkVycm9yKS5vbihFbmdpbmVFdmVudC5TdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlLCB0aGlzLmhhbmRsZVN1YnNjcmlwdGlvblBlcm1pc3Npb25VcGRhdGUpLm9uKEVuZ2luZUV2ZW50Lk1lZGlhVHJhY2tBZGRlZCwgKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpID0+IHtcbiAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkRpc2Nvbm5lY3RlZCwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCh0aGlzLm9wdGlvbnMuc3RvcExvY2FsVHJhY2tPblVucHVibGlzaCwgcmVhc29uKTtcbiAgICB9KS5vbihFbmdpbmVFdmVudC5BY3RpdmVTcGVha2Vyc1VwZGF0ZSwgdGhpcy5oYW5kbGVBY3RpdmVTcGVha2Vyc1VwZGF0ZSkub24oRW5naW5lRXZlbnQuRGF0YVBhY2tldFJlY2VpdmVkLCB0aGlzLmhhbmRsZURhdGFQYWNrZXQpLm9uKEVuZ2luZUV2ZW50LlJlc3VtaW5nLCAoKSA9PiB7XG4gICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgICAgdGhpcy5pc1Jlc3VtaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMubG9nLmluZm8oJ1Jlc3VtaW5nIHNpZ25hbCBjb25uZWN0aW9uJywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIGlmICh0aGlzLnNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUoQ29ubmVjdGlvblN0YXRlLlNpZ25hbFJlY29ubmVjdGluZykpIHtcbiAgICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5TaWduYWxSZWNvbm5lY3RpbmcpO1xuICAgICAgfVxuICAgIH0pLm9uKEVuZ2luZUV2ZW50LlJlc3VtZWQsICgpID0+IHtcbiAgICAgIHRoaXMucmVnaXN0ZXJDb25uZWN0aW9uUmVjb25jaWxlKCk7XG4gICAgICB0aGlzLmlzUmVzdW1pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMubG9nLmluZm8oJ1Jlc3VtZWQgc2lnbmFsIGNvbm5lY3Rpb24nLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdGhpcy51cGRhdGVTdWJzY3JpcHRpb25zKCk7XG4gICAgICB0aGlzLmVtaXRCdWZmZXJlZEV2ZW50cygpO1xuICAgICAgaWYgKHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSkge1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LlJlY29ubmVjdGVkKTtcbiAgICAgIH1cbiAgICB9KS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN1bWVkLCAoKSA9PiB7XG4gICAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzID0gW107XG4gICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLlJlY29ubmVjdGluZyB8fCB0aGlzLmlzUmVzdW1pbmcpIHtcbiAgICAgICAgdGhpcy5zZW5kU3luY1N0YXRlKCk7XG4gICAgICB9XG4gICAgfSkub24oRW5naW5lRXZlbnQuUmVzdGFydGluZywgdGhpcy5oYW5kbGVSZXN0YXJ0aW5nKS5vbihFbmdpbmVFdmVudC5TaWduYWxSZXN0YXJ0ZWQsIHRoaXMuaGFuZGxlU2lnbmFsUmVzdGFydGVkKS5vbihFbmdpbmVFdmVudC5PZmZsaW5lLCAoKSA9PiB7XG4gICAgICBpZiAodGhpcy5zZXRBbmRFbWl0Q29ubmVjdGlvblN0YXRlKENvbm5lY3Rpb25TdGF0ZS5SZWNvbm5lY3RpbmcpKSB7XG4gICAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUmVjb25uZWN0aW5nKTtcbiAgICAgIH1cbiAgICB9KS5vbihFbmdpbmVFdmVudC5EQ0J1ZmZlclN0YXR1c0NoYW5nZWQsIChzdGF0dXMsIGtpbmQpID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRENCdWZmZXJTdGF0dXNDaGFuZ2VkLCBzdGF0dXMsIGtpbmQpO1xuICAgIH0pLm9uKEVuZ2luZUV2ZW50LkxvY2FsVHJhY2tTdWJzY3JpYmVkLCBzdWJzY3JpYmVkU2lkID0+IHtcbiAgICAgIGNvbnN0IHRyYWNrUHVibGljYXRpb24gPSB0aGlzLmxvY2FsUGFydGljaXBhbnQuZ2V0VHJhY2tQdWJsaWNhdGlvbnMoKS5maW5kKF9yZWYyID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICB0cmFja1NpZFxuICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgIHJldHVybiB0cmFja1NpZCA9PT0gc3Vic2NyaWJlZFNpZDtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0cmFja1B1YmxpY2F0aW9uKSB7XG4gICAgICAgIHRoaXMubG9nLndhcm4oJ2NvdWxkIG5vdCBmaW5kIGxvY2FsIHRyYWNrIHN1YnNjcmlwdGlvbiBmb3Igc3Vic2NyaWJlZCBldmVudCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5lbWl0KFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrUHVibGljYXRpb24pO1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuTG9jYWxUcmFja1N1YnNjcmliZWQsIHRyYWNrUHVibGljYXRpb24sIHRoaXMubG9jYWxQYXJ0aWNpcGFudCk7XG4gICAgfSk7XG4gICAgaWYgKHRoaXMubG9jYWxQYXJ0aWNpcGFudCkge1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnNldHVwRW5naW5lKHRoaXMuZW5naW5lKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZTJlZU1hbmFnZXIpIHtcbiAgICAgIHRoaXMuZTJlZU1hbmFnZXIuc2V0dXBFbmdpbmUodGhpcy5lbmdpbmUpO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogZ2V0TG9jYWxEZXZpY2VzIGFic3RyYWN0cyBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmVudW1lcmF0ZURldmljZXMuXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0IHJlcXVlc3RzIGRldmljZSBwZXJtaXNzaW9ucyBieSBkZWZhdWx0IGlmIG5lZWRlZFxuICAgKiBhbmQgbWFrZXMgc3VyZSB0aGUgcmV0dXJuZWQgZGV2aWNlIGRvZXMgbm90IGNvbnNpc3Qgb2YgZHVtbXkgZGV2aWNlc1xuICAgKiBAcGFyYW0ga2luZFxuICAgKiBAcmV0dXJucyBhIGxpc3Qgb2YgYXZhaWxhYmxlIGxvY2FsIGRldmljZXNcbiAgICovXG4gIHN0YXRpYyBnZXRMb2NhbERldmljZXMoa2luZCkge1xuICAgIGxldCByZXF1ZXN0UGVybWlzc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG4gICAgcmV0dXJuIERldmljZU1hbmFnZXIuZ2V0SW5zdGFuY2UoKS5nZXREZXZpY2VzKGtpbmQsIHJlcXVlc3RQZXJtaXNzaW9ucyk7XG4gIH1cbiAgLyoqXG4gICAqIHByZXBhcmVDb25uZWN0aW9uIHNob3VsZCBiZSBjYWxsZWQgYXMgc29vbiBhcyB0aGUgcGFnZSBpcyBsb2FkZWQsIGluIG9yZGVyXG4gICAqIHRvIHNwZWVkIHVwIHRoZSBjb25uZWN0aW9uIGF0dGVtcHQuIFRoaXMgZnVuY3Rpb24gd2lsbFxuICAgKiAtIHBlcmZvcm0gRE5TIHJlc29sdXRpb24gYW5kIHByZS13YXJtIHRoZSBETlMgY2FjaGVcbiAgICogLSBlc3RhYmxpc2ggVExTIGNvbm5lY3Rpb24gYW5kIGNhY2hlIFRMUyBrZXlzXG4gICAqXG4gICAqIFdpdGggTGl2ZUtpdCBDbG91ZCwgaXQgd2lsbCBhbHNvIGRldGVybWluZSB0aGUgYmVzdCBlZGdlIGRhdGEgY2VudGVyIGZvclxuICAgKiB0aGUgY3VycmVudCBjbGllbnQgdG8gY29ubmVjdCB0byBpZiBhIHRva2VuIGlzIHByb3ZpZGVkLlxuICAgKi9cbiAgcHJlcGFyZUNvbm5lY3Rpb24odXJsLCB0b2tlbikge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gQ29ubmVjdGlvblN0YXRlLkRpc2Nvbm5lY3RlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInByZXBhcmVDb25uZWN0aW9uIHRvIFwiLmNvbmNhdCh1cmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGlzQ2xvdWQobmV3IFVSTCh1cmwpKSAmJiB0b2tlbikge1xuICAgICAgICAgIHRoaXMucmVnaW9uVXJsUHJvdmlkZXIgPSBuZXcgUmVnaW9uVXJsUHJvdmlkZXIodXJsLCB0b2tlbik7XG4gICAgICAgICAgY29uc3QgcmVnaW9uVXJsID0geWllbGQgdGhpcy5yZWdpb25VcmxQcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICAgIC8vIHdlIHdpbGwgbm90IHJlcGxhY2UgdGhlIHJlZ2lvblVybCBpZiBhbiBhdHRlbXB0IGhhZCBhbHJlYWR5IHN0YXJ0ZWRcbiAgICAgICAgICAvLyB0byBhdm9pZCBvdmVycmlkaW5nIHJlZ2lvblVybCBhZnRlciBhIG5ldyBjb25uZWN0aW9uIGF0dGVtcHQgaGFkIHN0YXJ0ZWRcbiAgICAgICAgICBpZiAocmVnaW9uVXJsICYmIHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVnaW9uVXJsID0gcmVnaW9uVXJsO1xuICAgICAgICAgICAgeWllbGQgZmV0Y2godG9IdHRwVXJsKHJlZ2lvblVybCksIHtcbiAgICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5sb2cuZGVidWcoXCJwcmVwYXJlZCBjb25uZWN0aW9uIHRvIFwiLmNvbmNhdChyZWdpb25VcmwpLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBmZXRjaCh0b0h0dHBVcmwodXJsKSwge1xuICAgICAgICAgICAgbWV0aG9kOiAnSEVBRCdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB0aGlzLmxvZy53YXJuKCdjb3VsZCBub3QgcHJlcGFyZSBjb25uZWN0aW9uJywgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiByZXRyaWV2ZXMgYSBwYXJ0aWNpcGFudCBieSBpZGVudGl0eVxuICAgKiBAcGFyYW0gaWRlbnRpdHlcbiAgICogQHJldHVybnNcbiAgICovXG4gIGdldFBhcnRpY2lwYW50QnlJZGVudGl0eShpZGVudGl0eSkge1xuICAgIGlmICh0aGlzLmxvY2FsUGFydGljaXBhbnQuaWRlbnRpdHkgPT09IGlkZW50aXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZ2V0KGlkZW50aXR5KTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb25GdXR1cmVzKCkge1xuICAgIHRoaXMuY29ubmVjdEZ1dHVyZSA9IHVuZGVmaW5lZDtcbiAgfVxuICAvKipcbiAgICogQGludGVybmFsIGZvciB0ZXN0aW5nXG4gICAqL1xuICBzaW11bGF0ZVNjZW5hcmlvKHNjZW5hcmlvLCBhcmcpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IHBvc3RBY3Rpb24gPSAoKSA9PiB7fTtcbiAgICAgIGxldCByZXE7XG4gICAgICBzd2l0Y2ggKHNjZW5hcmlvKSB7XG4gICAgICAgIGNhc2UgJ3NpZ25hbC1yZWNvbm5lY3QnOlxuICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgIHlpZWxkIHRoaXMuZW5naW5lLmNsaWVudC5oYW5kbGVPbkNsb3NlKCdzaW11bGF0ZSBkaXNjb25uZWN0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3NwZWFrZXInOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzcGVha2VyVXBkYXRlJyxcbiAgICAgICAgICAgICAgdmFsdWU6IDNcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbm9kZS1mYWlsdXJlJzpcbiAgICAgICAgICByZXEgPSBuZXcgU2ltdWxhdGVTY2VuYXJpbyh7XG4gICAgICAgICAgICBzY2VuYXJpbzoge1xuICAgICAgICAgICAgICBjYXNlOiAnbm9kZUZhaWx1cmUnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZXJ2ZXItbGVhdmUnOlxuICAgICAgICAgIHJlcSA9IG5ldyBTaW11bGF0ZVNjZW5hcmlvKHtcbiAgICAgICAgICAgIHNjZW5hcmlvOiB7XG4gICAgICAgICAgICAgIGNhc2U6ICdzZXJ2ZXJMZWF2ZScsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ21pZ3JhdGlvbic6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ21pZ3JhdGlvbicsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Jlc3VtZS1yZWNvbm5lY3QnOlxuICAgICAgICAgIHRoaXMuZW5naW5lLmZhaWxOZXh0KCk7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3Qtc2lnbmFsLW9uLXJlc3VtZSc6XG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZScsXG4gICAgICAgICAgICAgIHZhbHVlOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3Qtc2lnbmFsLW9uLXJlc3VtZS1uby1tZXNzYWdlcyc6XG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgZnVuY3Rpb24gaXMgcHJpdmF0ZVxuICAgICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIHJlc3VtZS1kaXNjb25uZWN0Jyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ2Rpc2Nvbm5lY3RTaWduYWxPblJlc3VtZU5vTWVzc2FnZXMnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdmdWxsLXJlY29ubmVjdCc6XG4gICAgICAgICAgdGhpcy5lbmdpbmUuZnVsbFJlY29ubmVjdE9uTmV4dCA9IHRydWU7XG4gICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBmdW5jdGlvbiBpcyBwcml2YXRlXG4gICAgICAgICAgeWllbGQgdGhpcy5lbmdpbmUuY2xpZW50LmhhbmRsZU9uQ2xvc2UoJ3NpbXVsYXRlIGZ1bGwtcmVjb25uZWN0Jyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2ZvcmNlLXRjcCc6XG4gICAgICAgIGNhc2UgJ2ZvcmNlLXRscyc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3N3aXRjaENhbmRpZGF0ZVByb3RvY29sJyxcbiAgICAgICAgICAgICAgdmFsdWU6IHNjZW5hcmlvID09PSAnZm9yY2UtdGxzJyA/IDIgOiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcG9zdEFjdGlvbiA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9uTGVhdmUgPSB0aGlzLmVuZ2luZS5jbGllbnQub25MZWF2ZTtcbiAgICAgICAgICAgIGlmIChvbkxlYXZlKSB7XG4gICAgICAgICAgICAgIG9uTGVhdmUobmV3IExlYXZlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgcmVhc29uOiBEaXNjb25uZWN0UmVhc29uLkNMSUVOVF9JTklUSUFURUQsXG4gICAgICAgICAgICAgICAgYWN0aW9uOiBMZWF2ZVJlcXVlc3RfQWN0aW9uLlJFQ09OTkVDVFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3N1YnNjcmliZXItYmFuZHdpZHRoJzpcbiAgICAgICAgICBpZiAoYXJnID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIGFyZyAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc3Vic2NyaWJlci1iYW5kd2lkdGggcmVxdWlyZXMgYSBudW1iZXIgYXMgYXJndW1lbnQnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ3N1YnNjcmliZXJCYW5kd2lkdGgnLFxuICAgICAgICAgICAgICB2YWx1ZTogbnVtYmVyVG9CaWdJbnQoYXJnKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsZWF2ZS1mdWxsLXJlY29ubmVjdCc6XG4gICAgICAgICAgcmVxID0gbmV3IFNpbXVsYXRlU2NlbmFyaW8oe1xuICAgICAgICAgICAgc2NlbmFyaW86IHtcbiAgICAgICAgICAgICAgY2FzZTogJ2xlYXZlUmVxdWVzdEZ1bGxSZWNvbm5lY3QnLFxuICAgICAgICAgICAgICB2YWx1ZTogdHJ1ZVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKHJlcSkge1xuICAgICAgICB5aWVsZCB0aGlzLmVuZ2luZS5jbGllbnQuc2VuZFNpbXVsYXRlU2NlbmFyaW8ocmVxKTtcbiAgICAgICAgeWllbGQgcG9zdEFjdGlvbigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgYXVkaW8gcGxheWJhY2sgaXMgZW5hYmxlZFxuICAgKi9cbiAgZ2V0IGNhblBsYXliYWNrQXVkaW8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYXVkaW9FbmFibGVkO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdmlkZW8gcGxheWJhY2sgaXMgZW5hYmxlZFxuICAgKi9cbiAgZ2V0IGNhblBsYXliYWNrVmlkZW8oKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzVmlkZW9QbGF5YmFja0Jsb2NrZWQ7XG4gIH1cbiAgZ2V0QWN0aXZlRGV2aWNlKGtpbmQpIHtcbiAgICByZXR1cm4gdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5nZXQoa2luZCk7XG4gIH1cbiAgLyoqXG4gICAqIFN3aXRjaGVzIGFsbCBhY3RpdmUgZGV2aWNlcyB1c2VkIGluIHRoaXMgcm9vbSB0byB0aGUgZ2l2ZW4gZGV2aWNlLlxuICAgKlxuICAgKiBOb3RlOiBzZXR0aW5nIEF1ZGlvT3V0cHV0IGlzIG5vdCBzdXBwb3J0ZWQgb24gc29tZSBicm93c2Vycy4gU2VlIFtzZXRTaW5rSWRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9IVE1MTWVkaWFFbGVtZW50L3NldFNpbmtJZCNicm93c2VyX2NvbXBhdGliaWxpdHkpXG4gICAqXG4gICAqIEBwYXJhbSBraW5kIHVzZSBgdmlkZW9pbnB1dGAgZm9yIGNhbWVyYSB0cmFjayxcbiAgICogIGBhdWRpb2lucHV0YCBmb3IgbWljcm9waG9uZSB0cmFjayxcbiAgICogIGBhdWRpb291dHB1dGAgdG8gc2V0IHNwZWFrZXIgZm9yIGFsbCBpbmNvbWluZyBhdWRpbyB0cmFja3NcbiAgICogQHBhcmFtIGRldmljZUlkXG4gICAqL1xuICBzd2l0Y2hBY3RpdmVEZXZpY2Uoa2luZF8xLCBkZXZpY2VJZF8xKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCBhcmd1bWVudHMsIHZvaWQgMCwgZnVuY3Rpb24gKGtpbmQsIGRldmljZUlkKSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcbiAgICAgIGxldCBleGFjdCA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiogKCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYywgX2QsIF9lLCBfZiwgX2c7XG4gICAgICAgIHZhciBfaDtcbiAgICAgICAgbGV0IHN1Y2Nlc3MgPSB0cnVlO1xuICAgICAgICBsZXQgbmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGRldmljZUNvbnN0cmFpbnQgPSBleGFjdCA/IHtcbiAgICAgICAgICBleGFjdDogZGV2aWNlSWRcbiAgICAgICAgfSA6IGRldmljZUlkO1xuICAgICAgICBpZiAoa2luZCA9PT0gJ2F1ZGlvaW5wdXQnKSB7XG4gICAgICAgICAgbmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzID0gX3RoaXMzLmxvY2FsUGFydGljaXBhbnQuYXVkaW9UcmFja1B1YmxpY2F0aW9ucy5zaXplID09PSAwO1xuICAgICAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IChfYSA9IF90aGlzMy5nZXRBY3RpdmVEZXZpY2Uoa2luZCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IF90aGlzMy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkO1xuICAgICAgICAgIF90aGlzMy5vcHRpb25zLmF1ZGlvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gZGV2aWNlQ29uc3RyYWludDtcbiAgICAgICAgICBjb25zdCB0cmFja3MgPSBBcnJheS5mcm9tKF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMudmFsdWVzKCkpLmZpbHRlcih0cmFjayA9PiB0cmFjay5zb3VyY2UgPT09IFRyYWNrLlNvdXJjZS5NaWNyb3Bob25lKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3VjY2VzcyA9ICh5aWVsZCBQcm9taXNlLmFsbCh0cmFja3MubWFwKHQgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgIHJldHVybiAoX2EgPSB0LmF1ZGlvVHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zZXREZXZpY2VJZChkZXZpY2VDb25zdHJhaW50KTtcbiAgICAgICAgICAgIH0pKSkuZXZlcnkodmFsID0+IHZhbCA9PT0gdHJ1ZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgX3RoaXMzLm9wdGlvbnMuYXVkaW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBwcmV2RGV2aWNlSWQ7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChraW5kID09PSAndmlkZW9pbnB1dCcpIHtcbiAgICAgICAgICBuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgPSBfdGhpczMubG9jYWxQYXJ0aWNpcGFudC52aWRlb1RyYWNrUHVibGljYXRpb25zLnNpemUgPT09IDA7XG4gICAgICAgICAgY29uc3QgcHJldkRldmljZUlkID0gKF9iID0gX3RoaXMzLmdldEFjdGl2ZURldmljZShraW5kKSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQ7XG4gICAgICAgICAgX3RoaXMzLm9wdGlvbnMudmlkZW9DYXB0dXJlRGVmYXVsdHMuZGV2aWNlSWQgPSBkZXZpY2VDb25zdHJhaW50O1xuICAgICAgICAgIGNvbnN0IHRyYWNrcyA9IEFycmF5LmZyb20oX3RoaXMzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy52YWx1ZXMoKSkuZmlsdGVyKHRyYWNrID0+IHRyYWNrLnNvdXJjZSA9PT0gVHJhY2suU291cmNlLkNhbWVyYSk7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSAoeWllbGQgUHJvbWlzZS5hbGwodHJhY2tzLm1hcCh0ID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICByZXR1cm4gKF9hID0gdC52aWRlb1RyYWNrKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0RGV2aWNlSWQoZGV2aWNlQ29uc3RyYWludCk7XG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KHZhbCA9PiB2YWwgPT09IHRydWUpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIF90aGlzMy5vcHRpb25zLnZpZGVvQ2FwdHVyZURlZmF1bHRzLmRldmljZUlkID0gcHJldkRldmljZUlkO1xuICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuICAgICAgICAgIGlmICghc3VwcG9ydHNTZXRTaW5rSWQoKSAmJiAhX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXggfHwgX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXggJiYgX3RoaXMzLmF1ZGlvQ29udGV4dCAmJiAhKCdzZXRTaW5rSWQnIGluIF90aGlzMy5hdWRpb0NvbnRleHQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBzd2l0Y2ggYXVkaW8gb3V0cHV0LCBzZXRTaW5rSWQgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoX3RoaXMzLm9wdGlvbnMud2ViQXVkaW9NaXgpIHtcbiAgICAgICAgICAgIC8vIHNldHRpbmcgYGRlZmF1bHRgIGZvciB3ZWIgYXVkaW8gb3V0cHV0IGRvZXNuJ3Qgd29yaywgc28gd2UgbmVlZCB0byBub3JtYWxpemUgdGhlIGlkIGJlZm9yZVxuICAgICAgICAgICAgZGV2aWNlSWQgPSAoX2MgPSB5aWVsZCBEZXZpY2VNYW5hZ2VyLmdldEluc3RhbmNlKCkubm9ybWFsaXplRGV2aWNlSWQoJ2F1ZGlvb3V0cHV0JywgZGV2aWNlSWQpKSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiAnJztcbiAgICAgICAgICB9XG4gICAgICAgICAgKF9kID0gKF9oID0gX3RoaXMzLm9wdGlvbnMpLmF1ZGlvT3V0cHV0KSAhPT0gbnVsbCAmJiBfZCAhPT0gdm9pZCAwID8gX2QgOiBfaC5hdWRpb091dHB1dCA9IHt9O1xuICAgICAgICAgIGNvbnN0IHByZXZEZXZpY2VJZCA9IChfZSA9IF90aGlzMy5nZXRBY3RpdmVEZXZpY2Uoa2luZCkpICE9PSBudWxsICYmIF9lICE9PSB2b2lkIDAgPyBfZSA6IF90aGlzMy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkO1xuICAgICAgICAgIF90aGlzMy5vcHRpb25zLmF1ZGlvT3V0cHV0LmRldmljZUlkID0gZGV2aWNlSWQ7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChfdGhpczMub3B0aW9ucy53ZWJBdWRpb01peCkge1xuICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHNldFNpbmtJZCBpcyBub3QgeWV0IGluIHRoZSB0eXBlc2NyaXB0IHR5cGUgb2YgQXVkaW9Db250ZXh0XG4gICAgICAgICAgICAgIChfZiA9IF90aGlzMy5hdWRpb0NvbnRleHQpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi5zZXRTaW5rSWQoZGV2aWNlSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gYWxzbyBzZXQgYXVkaW8gb3V0cHV0IG9uIGFsbCBhdWRpbyBlbGVtZW50cywgZXZlbiBpZiB3ZWJBdWRpb01peCBpcyBlbmFibGVkIGluIG9yZGVyIHRvIHdvcmthcm91bmQgZWNobyBjYW5jZWxsYXRpb24gbm90IHdvcmtpbmcgb24gY2hyb21lIHdpdGggbm9uLWRlZmF1bHQgb3V0cHV0IGRldmljZXNcbiAgICAgICAgICAgIC8vIHNlZSBodHRwczovL2lzc3Vlcy5jaHJvbWl1bS5vcmcvaXNzdWVzLzQwMjUyOTExI2NvbW1lbnQ3XG4gICAgICAgICAgICB5aWVsZCBQcm9taXNlLmFsbChBcnJheS5mcm9tKF90aGlzMy5yZW1vdGVQYXJ0aWNpcGFudHMudmFsdWVzKCkpLm1hcChwID0+IHAuc2V0QXVkaW9PdXRwdXQoe1xuICAgICAgICAgICAgICBkZXZpY2VJZFxuICAgICAgICAgICAgfSkpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBfdGhpczMub3B0aW9ucy5hdWRpb091dHB1dC5kZXZpY2VJZCA9IHByZXZEZXZpY2VJZDtcbiAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChuZWVkc1VwZGF0ZVdpdGhvdXRUcmFja3MgfHwga2luZCA9PT0gJ2F1ZGlvb3V0cHV0Jykge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIGFyZSBub3QgYWN0aXZlIHRyYWNrcyB5ZXQgb3Igd2UncmUgc3dpdGNoaW5nIGF1ZGlvb3V0cHV0LCB3ZSBuZWVkIHRvIG1hbnVhbGx5IHVwZGF0ZSB0aGUgYWN0aXZlIGRldmljZSBtYXAgaGVyZSBhcyBjaGFuZ2luZyBhdWRpbyBvdXRwdXQgd29uJ3QgcmVzdWx0IGluIGEgdHJhY2sgcmVzdGFydFxuICAgICAgICAgIF90aGlzMy5sb2NhbFBhcnRpY2lwYW50LmFjdGl2ZURldmljZU1hcC5zZXQoa2luZCwga2luZCA9PT0gJ2F1ZGlvb3V0cHV0JyAmJiAoKF9nID0gX3RoaXMzLm9wdGlvbnMuYXVkaW9PdXRwdXQpID09PSBudWxsIHx8IF9nID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZy5kZXZpY2VJZCkgfHwgZGV2aWNlSWQpO1xuICAgICAgICAgIF90aGlzMy5lbWl0KFJvb21FdmVudC5BY3RpdmVEZXZpY2VDaGFuZ2VkLCBraW5kLCBkZXZpY2VJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1Y2Nlc3M7XG4gICAgICB9KCk7XG4gICAgfSk7XG4gIH1cbiAgc2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzKCkge1xuICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF0dHJpYnV0ZXNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxBdHRyaWJ1dGVzQ2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5UcmFja011dGVkLCB0aGlzLm9uTG9jYWxUcmFja011dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tQdWJsaXNoZWQsIHRoaXMub25Mb2NhbFRyYWNrUHVibGlzaGVkKS5vbihQYXJ0aWNpcGFudEV2ZW50LkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCkub24oUGFydGljaXBhbnRFdmVudC5NZWRpYURldmljZXNFcnJvciwgdGhpcy5vbk1lZGlhRGV2aWNlc0Vycm9yKS5vbihQYXJ0aWNpcGFudEV2ZW50LkF1ZGlvU3RyZWFtQWNxdWlyZWQsIHRoaXMuc3RhcnRBdWRpbykub24oUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCk7XG4gIH1cbiAgcmVjcmVhdGVFbmdpbmUoKSB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IHRoaXMuZW5naW5lKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2xvc2UoKTtcbiAgICAvKiBAdHMtaWdub3JlICovXG4gICAgdGhpcy5lbmdpbmUgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5pc1Jlc3VtaW5nID0gZmFsc2U7XG4gICAgLy8gY2xlYXIgb3V0IGV4aXN0aW5nIHJlbW90ZSBwYXJ0aWNpcGFudHMsIHNpbmNlIHRoZXkgbWF5IGhhdmUgYXR0YWNoZWRcbiAgICAvLyB0aGUgb2xkIGVuZ2luZVxuICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmNsZWFyKCk7XG4gICAgdGhpcy5zaWRUb0lkZW50aXR5LmNsZWFyKCk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICAgIHRoaXMubWF5YmVDcmVhdGVFbmdpbmUoKTtcbiAgfVxuICBvblRyYWNrQWRkZWQobWVkaWFUcmFjaywgc3RyZWFtLCByZWNlaXZlcikge1xuICAgIC8vIGRvbid0IGZpcmUgb25TdWJzY3JpYmVkIHdoZW4gY29ubmVjdGluZ1xuICAgIC8vIFdlYlJUQyBmaXJlcyBvblRyYWNrIGFzIHNvb24gYXMgc2V0UmVtb3RlRGVzY3JpcHRpb24gaXMgY2FsbGVkIG9uIHRoZSBvZmZlclxuICAgIC8vIGF0IHRoYXQgdGltZSwgSUNFIGNvbm5lY3Rpdml0eSBoYXMgbm90IGJlZW4gZXN0YWJsaXNoZWQgc28gdGhlIHRyYWNrIGlzIG5vdFxuICAgIC8vIHRlY2huaWNhbGx5IHN1YnNjcmliZWQuXG4gICAgLy8gV2UnbGwgZGVmZXIgdGhlc2UgZXZlbnRzIHVudGlsIHdoZW4gdGhlIHJvb20gaXMgY29ubmVjdGVkIG9yIGV2ZW50dWFsbHkgZGlzY29ubmVjdGVkLlxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGluZyB8fCB0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nKSB7XG4gICAgICBjb25zdCByZWNvbm5lY3RlZEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMub25UcmFja0FkZGVkKG1lZGlhVHJhY2ssIHN0cmVhbSwgcmVjZWl2ZXIpO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5vZmYoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuQ29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLm9mZihSb29tRXZlbnQuRGlzY29ubmVjdGVkLCBjbGVhbnVwKTtcbiAgICAgIH07XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LlJlY29ubmVjdGVkLCByZWNvbm5lY3RlZEhhbmRsZXIpO1xuICAgICAgdGhpcy5vbmNlKFJvb21FdmVudC5Db25uZWN0ZWQsIHJlY29ubmVjdGVkSGFuZGxlcik7XG4gICAgICB0aGlzLm9uY2UoUm9vbUV2ZW50LkRpc2Nvbm5lY3RlZCwgY2xlYW51cCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCdza2lwcGluZyBpbmNvbWluZyB0cmFjayBhZnRlciBSb29tIGRpc2Nvbm5lY3RlZCcsIHRoaXMubG9nQ29udGV4dCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChtZWRpYVRyYWNrLnJlYWR5U3RhdGUgPT09ICdlbmRlZCcpIHtcbiAgICAgIHRoaXMubG9nLmluZm8oJ3NraXBwaW5nIGluY29taW5nIHRyYWNrIGFzIGl0IGFscmVhZHkgZW5kZWQnLCB0aGlzLmxvZ0NvbnRleHQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYXJ0cyA9IHVucGFja1N0cmVhbUlkKHN0cmVhbS5pZCk7XG4gICAgY29uc3QgcGFydGljaXBhbnRTaWQgPSBwYXJ0c1swXTtcbiAgICBsZXQgc3RyZWFtSWQgPSBwYXJ0c1sxXTtcbiAgICBsZXQgdHJhY2tJZCA9IG1lZGlhVHJhY2suaWQ7XG4gICAgLy8gZmlyZWZveCB3aWxsIGdldCBzdHJlYW1JZCAocElEfHRyYWNrSWQpIGluc3RlYWQgb2YgKHBJRHxzdHJlYW1JZCkgYXMgaXQgZG9lc24ndCBzdXBwb3J0IHN5bmMgdHJhY2tzIGJ5IHN0cmVhbVxuICAgIC8vIGFuZCBnZW5lcmF0ZXMgaXRzIG93biB0cmFjayBpZCBpbnN0ZWFkIG9mIGluZmVyIGZyb20gc2RwIHRyYWNrIGlkLlxuICAgIGlmIChzdHJlYW1JZCAmJiBzdHJlYW1JZC5zdGFydHNXaXRoKCdUUicpKSB0cmFja0lkID0gc3RyZWFtSWQ7XG4gICAgaWYgKHBhcnRpY2lwYW50U2lkID09PSB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2lkKSB7XG4gICAgICB0aGlzLmxvZy53YXJuKCd0cmllZCB0byBjcmVhdGUgUmVtb3RlUGFydGljaXBhbnQgZm9yIGxvY2FsIHBhcnRpY2lwYW50JywgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcGFydGljaXBhbnQgPSBBcnJheS5mcm9tKHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5maW5kKHAgPT4gcC5zaWQgPT09IHBhcnRpY2lwYW50U2lkKTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICB0aGlzLmxvZy5lcnJvcihcIlRyaWVkIHRvIGFkZCBhIHRyYWNrIGZvciBhIHBhcnRpY2lwYW50LCB0aGF0J3Mgbm90IHByZXNlbnQuIFNpZDogXCIuY29uY2F0KHBhcnRpY2lwYW50U2lkKSwgdGhpcy5sb2dDb250ZXh0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGFkYXB0aXZlU3RyZWFtU2V0dGluZ3M7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5hZGFwdGl2ZVN0cmVhbSkge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW0gPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MgPSB0aGlzLm9wdGlvbnMuYWRhcHRpdmVTdHJlYW07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhZGFwdGl2ZVN0cmVhbVNldHRpbmdzID0ge307XG4gICAgICB9XG4gICAgfVxuICAgIHBhcnRpY2lwYW50LmFkZFN1YnNjcmliZWRNZWRpYVRyYWNrKG1lZGlhVHJhY2ssIHRyYWNrSWQsIHN0cmVhbSwgcmVjZWl2ZXIsIGFkYXB0aXZlU3RyZWFtU2V0dGluZ3MpO1xuICB9XG4gIGhhbmRsZURpc2Nvbm5lY3QoKSB7XG4gICAgbGV0IHNob3VsZFN0b3BUcmFja3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgbGV0IHJlYXNvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkO1xuICAgIHZhciBfYTtcbiAgICB0aGlzLmNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSgpO1xuICAgIHRoaXMuaXNSZXN1bWluZyA9IGZhbHNlO1xuICAgIHRoaXMuYnVmZmVyZWRFdmVudHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zY3JpcHRpb25SZWNlaXZlZFRpbWVzLmNsZWFyKCk7XG4gICAgaWYgKHRoaXMuc3RhdGUgPT09IENvbm5lY3Rpb25TdGF0ZS5EaXNjb25uZWN0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZWdpb25VcmwgPSB1bmRlZmluZWQ7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAudHJhY2tQdWJsaWNhdGlvbnMuZm9yRWFjaChwdWIgPT4ge1xuICAgICAgICAgIHAudW5wdWJsaXNoVHJhY2socHViLnRyYWNrU2lkKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC50cmFja1B1YmxpY2F0aW9ucy5mb3JFYWNoKHB1YiA9PiB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAocHViLnRyYWNrKSB7XG4gICAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnVucHVibGlzaFRyYWNrKHB1Yi50cmFjaywgc2hvdWxkU3RvcFRyYWNrcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZFN0b3BUcmFja3MpIHtcbiAgICAgICAgICAoX2EgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXRhY2goKTtcbiAgICAgICAgICAoX2IgPSBwdWIudHJhY2spID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdG9wKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgKF9jID0gcHViLnRyYWNrKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Muc3RvcE1vbml0b3IoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQub2ZmKFBhcnRpY2lwYW50RXZlbnQuUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQsIHRoaXMub25Mb2NhbFBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudE5hbWVDaGFuZ2VkLCB0aGlzLm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkKS5vZmYoUGFydGljaXBhbnRFdmVudC5BdHRyaWJ1dGVzQ2hhbmdlZCwgdGhpcy5vbkxvY2FsQXR0cmlidXRlc0NoYW5nZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrTXV0ZWQsIHRoaXMub25Mb2NhbFRyYWNrTXV0ZWQpLm9mZihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrVW5tdXRlZCwgdGhpcy5vbkxvY2FsVHJhY2tVbm11dGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1B1Ymxpc2hlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTG9jYWxUcmFja1VucHVibGlzaGVkLCB0aGlzLm9uTG9jYWxUcmFja1VucHVibGlzaGVkKS5vZmYoUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHRoaXMub25Mb2NhbENvbm5lY3Rpb25RdWFsaXR5Q2hhbmdlZCkub2ZmKFBhcnRpY2lwYW50RXZlbnQuTWVkaWFEZXZpY2VzRXJyb3IsIHRoaXMub25NZWRpYURldmljZXNFcnJvcikub2ZmKFBhcnRpY2lwYW50RXZlbnQuQXVkaW9TdHJlYW1BY3F1aXJlZCwgdGhpcy5zdGFydEF1ZGlvKS5vZmYoUGFydGljaXBhbnRFdmVudC5DaGF0TWVzc2FnZSwgdGhpcy5vbkxvY2FsQ2hhdE1lc3NhZ2VTZW50KS5vZmYoUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgdGhpcy5vbkxvY2FsUGFydGljaXBhbnRQZXJtaXNzaW9uc0NoYW5nZWQpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmNsZWFyKCk7XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQudmlkZW9UcmFja1B1YmxpY2F0aW9ucy5jbGVhcigpO1xuICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMuY2xlYXIoKTtcbiAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmNsZWFyKCk7XG4gICAgICB0aGlzLnNpZFRvSWRlbnRpdHkuY2xlYXIoKTtcbiAgICAgIHRoaXMuYWN0aXZlU3BlYWtlcnMgPSBbXTtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4ID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5hdWRpb0NvbnRleHQgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAoaXNXZWIoKSkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdwYWdlaGlkZScsIHRoaXMub25QYWdlTGVhdmUpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZnJlZXplJywgdGhpcy5vblBhZ2VMZWF2ZSk7XG4gICAgICAgIChfYSA9IG5hdmlnYXRvci5tZWRpYURldmljZXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVFdmVudExpc3RlbmVyKCdkZXZpY2VjaGFuZ2UnLCB0aGlzLmhhbmRsZURldmljZUNoYW5nZSk7XG4gICAgICB9XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuRGlzY29ubmVjdGVkLCByZWFzb24pO1xuICAgIH1cbiAgfVxuICBoYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChpZGVudGl0eSwgcGFydGljaXBhbnQpIHtcbiAgICB2YXIgX2E7XG4gICAgLy8gcmVtb3ZlIGFuZCBzZW5kIGV2ZW50XG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuZGVsZXRlKGlkZW50aXR5KTtcbiAgICBpZiAoIXBhcnRpY2lwYW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHBhcnRpY2lwYW50LnRyYWNrUHVibGljYXRpb25zLmZvckVhY2gocHVibGljYXRpb24gPT4ge1xuICAgICAgcGFydGljaXBhbnQudW5wdWJsaXNoVHJhY2socHVibGljYXRpb24udHJhY2tTaWQsIHRydWUpO1xuICAgIH0pO1xuICAgIHRoaXMuZW1pdChSb29tRXZlbnQuUGFydGljaXBhbnREaXNjb25uZWN0ZWQsIHBhcnRpY2lwYW50KTtcbiAgICAoX2EgPSB0aGlzLmxvY2FsUGFydGljaXBhbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYW5kbGVQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZChwYXJ0aWNpcGFudC5pZGVudGl0eSk7XG4gIH1cbiAgaGFuZGxlU3RyZWFtSGVhZGVyKHN0cmVhbUhlYWRlciwgcGFydGljaXBhbnRJZGVudGl0eSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBpZiAoc3RyZWFtSGVhZGVyLmNvbnRlbnRIZWFkZXIuY2FzZSA9PT0gJ2J5dGVIZWFkZXInKSB7XG4gICAgICAgIGNvbnN0IHN0cmVhbUhhbmRsZXJDYWxsYmFjayA9IHRoaXMuYnl0ZVN0cmVhbUhhbmRsZXJzLmdldChzdHJlYW1IZWFkZXIudG9waWMpO1xuICAgICAgICBpZiAoIXN0cmVhbUhhbmRsZXJDYWxsYmFjaykge1xuICAgICAgICAgIHRoaXMubG9nLmRlYnVnKCdpZ25vcmluZyBpbmNvbWluZyBieXRlIHN0cmVhbSBkdWUgdG8gbm8gaGFuZGxlciBmb3IgdG9waWMnLCBzdHJlYW1IZWFkZXIudG9waWMpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RyZWFtQ29udHJvbGxlcjtcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICBpZDogc3RyZWFtSGVhZGVyLnN0cmVhbUlkLFxuICAgICAgICAgIG5hbWU6IChfYSA9IHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLnZhbHVlLm5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICd1bmtub3duJyxcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxuICAgICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRvcGljOiBzdHJlYW1IZWFkZXIudG9waWMsXG4gICAgICAgICAgdGltZXN0YW1wOiBiaWdJbnRUb051bWJlcihzdHJlYW1IZWFkZXIudGltZXN0YW1wKSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiBzdHJlYW1IZWFkZXIuYXR0cmlidXRlc1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgICAgIHN0YXJ0OiBjb250cm9sbGVyID0+IHtcbiAgICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIgPSBjb250cm9sbGVyO1xuICAgICAgICAgICAgdGhpcy5ieXRlU3RyZWFtQ29udHJvbGxlcnMuc2V0KHN0cmVhbUhlYWRlci5zdHJlYW1JZCwge1xuICAgICAgICAgICAgICBpbmZvLFxuICAgICAgICAgICAgICBjb250cm9sbGVyOiBzdHJlYW1Db250cm9sbGVyLFxuICAgICAgICAgICAgICBzdGFydFRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHN0cmVhbUhhbmRsZXJDYWxsYmFjayhuZXcgQnl0ZVN0cmVhbVJlYWRlcihpbmZvLCBzdHJlYW0sIGJpZ0ludFRvTnVtYmVyKHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCkpLCB7XG4gICAgICAgICAgaWRlbnRpdHk6IHBhcnRpY2lwYW50SWRlbnRpdHlcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHN0cmVhbUhlYWRlci5jb250ZW50SGVhZGVyLmNhc2UgPT09ICd0ZXh0SGVhZGVyJykge1xuICAgICAgICBjb25zdCBzdHJlYW1IYW5kbGVyQ2FsbGJhY2sgPSB0aGlzLnRleHRTdHJlYW1IYW5kbGVycy5nZXQoc3RyZWFtSGVhZGVyLnRvcGljKTtcbiAgICAgICAgaWYgKCFzdHJlYW1IYW5kbGVyQ2FsbGJhY2spIHtcbiAgICAgICAgICB0aGlzLmxvZy5kZWJ1ZygnaWdub3JpbmcgaW5jb21pbmcgdGV4dCBzdHJlYW0gZHVlIHRvIG5vIGhhbmRsZXIgZm9yIHRvcGljJywgc3RyZWFtSGVhZGVyLnRvcGljKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHN0cmVhbUNvbnRyb2xsZXI7XG4gICAgICAgIGNvbnN0IGluZm8gPSB7XG4gICAgICAgICAgaWQ6IHN0cmVhbUhlYWRlci5zdHJlYW1JZCxcbiAgICAgICAgICBtaW1lVHlwZTogc3RyZWFtSGVhZGVyLm1pbWVUeXBlLFxuICAgICAgICAgIHNpemU6IHN0cmVhbUhlYWRlci50b3RhbExlbmd0aCA/IE51bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIHRvcGljOiBzdHJlYW1IZWFkZXIudG9waWMsXG4gICAgICAgICAgdGltZXN0YW1wOiBOdW1iZXIoc3RyZWFtSGVhZGVyLnRpbWVzdGFtcCksXG4gICAgICAgICAgYXR0cmlidXRlczogc3RyZWFtSGVhZGVyLmF0dHJpYnV0ZXNcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgICBzdGFydDogY29udHJvbGxlciA9PiB7XG4gICAgICAgICAgICBzdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgICAgIHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLnNldChzdHJlYW1IZWFkZXIuc3RyZWFtSWQsIHtcbiAgICAgICAgICAgICAgaW5mbyxcbiAgICAgICAgICAgICAgY29udHJvbGxlcjogc3RyZWFtQ29udHJvbGxlcixcbiAgICAgICAgICAgICAgc3RhcnRUaW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1IYW5kbGVyQ2FsbGJhY2sobmV3IFRleHRTdHJlYW1SZWFkZXIoaW5mbywgc3RyZWFtLCBiaWdJbnRUb051bWJlcihzdHJlYW1IZWFkZXIudG90YWxMZW5ndGgpKSwge1xuICAgICAgICAgIGlkZW50aXR5OiBwYXJ0aWNpcGFudElkZW50aXR5XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGhhbmRsZVN0cmVhbUNodW5rKGNodW5rKSB7XG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldChjaHVuay5zdHJlYW1JZCk7XG4gICAgaWYgKGZpbGVCdWZmZXIpIHtcbiAgICAgIGlmIChjaHVuay5jb250ZW50Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgZmlsZUJ1ZmZlci5jb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZXh0QnVmZmVyID0gdGhpcy50ZXh0U3RyZWFtQ29udHJvbGxlcnMuZ2V0KGNodW5rLnN0cmVhbUlkKTtcbiAgICBpZiAodGV4dEJ1ZmZlcikge1xuICAgICAgaWYgKGNodW5rLmNvbnRlbnQubGVuZ3RoID4gMCkge1xuICAgICAgICB0ZXh0QnVmZmVyLmNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGhhbmRsZVN0cmVhbVRyYWlsZXIodHJhaWxlcikge1xuICAgIGNvbnN0IHRleHRCdWZmZXIgPSB0aGlzLnRleHRTdHJlYW1Db250cm9sbGVycy5nZXQodHJhaWxlci5zdHJlYW1JZCk7XG4gICAgaWYgKHRleHRCdWZmZXIpIHtcbiAgICAgIHRleHRCdWZmZXIuaW5mby5hdHRyaWJ1dGVzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0ZXh0QnVmZmVyLmluZm8uYXR0cmlidXRlcyksIHRyYWlsZXIuYXR0cmlidXRlcyk7XG4gICAgICB0ZXh0QnVmZmVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIHRoaXMudGV4dFN0cmVhbUNvbnRyb2xsZXJzLmRlbGV0ZSh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICB9XG4gICAgY29uc3QgZmlsZUJ1ZmZlciA9IHRoaXMuYnl0ZVN0cmVhbUNvbnRyb2xsZXJzLmdldCh0cmFpbGVyLnN0cmVhbUlkKTtcbiAgICBpZiAoZmlsZUJ1ZmZlcikge1xuICAgICAge1xuICAgICAgICBmaWxlQnVmZmVyLmluZm8uYXR0cmlidXRlcyA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZmlsZUJ1ZmZlci5pbmZvLmF0dHJpYnV0ZXMpLCB0cmFpbGVyLmF0dHJpYnV0ZXMpO1xuICAgICAgICBmaWxlQnVmZmVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5ieXRlU3RyZWFtQ29udHJvbGxlcnMuZGVsZXRlKHRyYWlsZXIuc3RyZWFtSWQpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBhY3F1aXJlQXVkaW9Db250ZXh0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXggIT09ICdib29sZWFuJyAmJiB0aGlzLm9wdGlvbnMud2ViQXVkaW9NaXguYXVkaW9Db250ZXh0KSB7XG4gICAgICAgIC8vIG92ZXJyaWRlIGF1ZGlvIGNvbnRleHQgd2l0aCBjdXN0b20gYXVkaW8gY29udGV4dCBpZiBzdXBwbGllZCBieSB1c2VyXG4gICAgICAgIHRoaXMuYXVkaW9Db250ZXh0ID0gdGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4LmF1ZGlvQ29udGV4dDtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYXVkaW9Db250ZXh0IHx8IHRoaXMuYXVkaW9Db250ZXh0LnN0YXRlID09PSAnY2xvc2VkJykge1xuICAgICAgICAvLyBieSB1c2luZyBhbiBBdWRpb0NvbnRleHQsIGl0IHJlZHVjZXMgbGFnIG9uIGF1ZGlvIGVsZW1lbnRzXG4gICAgICAgIC8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk4MTE0MjkvaHRtbDUtYXVkaW8tdGFnLW9uLXNhZmFyaS1oYXMtYS1kZWxheS81NDExOTg1NCM1NDExOTg1NFxuICAgICAgICB0aGlzLmF1ZGlvQ29udGV4dCA9IChfYSA9IGdldE5ld0F1ZGlvQ29udGV4dCgpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5vcHRpb25zLndlYkF1ZGlvTWl4KSB7XG4gICAgICAgIHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmZvckVhY2gocGFydGljaXBhbnQgPT4gcGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KSk7XG4gICAgICB9XG4gICAgICB0aGlzLmxvY2FsUGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcbiAgICAgIGlmICh0aGlzLmF1ZGlvQ29udGV4dCAmJiB0aGlzLmF1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcbiAgICAgICAgLy8gZm9yIGlPUyBhIG5ld2x5IGNyZWF0ZWQgQXVkaW9Db250ZXh0IGlzIGFsd2F5cyBpbiBgc3VzcGVuZGVkYCBzdGF0ZS5cbiAgICAgICAgLy8gd2UgdHJ5IG91ciBiZXN0IHRvIHJlc3VtZSB0aGUgY29udGV4dCBoZXJlLCBpZiB0aGF0IGRvZXNuJ3Qgd29yaywgd2UganVzdCBjb250aW51ZSB3aXRoIHJlZ3VsYXIgcHJvY2Vzc2luZ1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHlpZWxkIFByb21pc2UucmFjZShbdGhpcy5hdWRpb0NvbnRleHQucmVzdW1lKCksIHNsZWVwKDIwMCldKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHRoaXMubG9nLndhcm4oJ0NvdWxkIG5vdCByZXN1bWUgYXVkaW8gY29udGV4dCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgICAgZXJyb3I6IGVcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IG5ld0NvbnRleHRJc1J1bm5pbmcgPSAoKF9iID0gdGhpcy5hdWRpb0NvbnRleHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGF0ZSkgPT09ICdydW5uaW5nJztcbiAgICAgIGlmIChuZXdDb250ZXh0SXNSdW5uaW5nICE9PSB0aGlzLmNhblBsYXliYWNrQXVkaW8pIHtcbiAgICAgICAgdGhpcy5hdWRpb0VuYWJsZWQgPSBuZXdDb250ZXh0SXNSdW5uaW5nO1xuICAgICAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkF1ZGlvUGxheWJhY2tTdGF0dXNDaGFuZ2VkLCBuZXdDb250ZXh0SXNSdW5uaW5nKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBjcmVhdGVQYXJ0aWNpcGFudChpZGVudGl0eSwgaW5mbykge1xuICAgIHZhciBfYTtcbiAgICBsZXQgcGFydGljaXBhbnQ7XG4gICAgaWYgKGluZm8pIHtcbiAgICAgIHBhcnRpY2lwYW50ID0gUmVtb3RlUGFydGljaXBhbnQuZnJvbVBhcnRpY2lwYW50SW5mbyh0aGlzLmVuZ2luZS5jbGllbnQsIGluZm8sIHtcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydGljaXBhbnQgPSBuZXcgUmVtb3RlUGFydGljaXBhbnQodGhpcy5lbmdpbmUuY2xpZW50LCAnJywgaWRlbnRpdHksIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHtcbiAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHQsXG4gICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHRoaXMub3B0aW9ucy53ZWJBdWRpb01peCkge1xuICAgICAgcGFydGljaXBhbnQuc2V0QXVkaW9Db250ZXh0KHRoaXMuYXVkaW9Db250ZXh0KTtcbiAgICB9XG4gICAgaWYgKChfYSA9IHRoaXMub3B0aW9ucy5hdWRpb091dHB1dCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRldmljZUlkKSB7XG4gICAgICBwYXJ0aWNpcGFudC5zZXRBdWRpb091dHB1dCh0aGlzLm9wdGlvbnMuYXVkaW9PdXRwdXQpLmNhdGNoKGUgPT4gdGhpcy5sb2cud2FybihcIkNvdWxkIG5vdCBzZXQgYXVkaW8gb3V0cHV0OiBcIi5jb25jYXQoZS5tZXNzYWdlKSwgdGhpcy5sb2dDb250ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBwYXJ0aWNpcGFudDtcbiAgfVxuICBnZXRPckNyZWF0ZVBhcnRpY2lwYW50KGlkZW50aXR5LCBpbmZvKSB7XG4gICAgaWYgKHRoaXMucmVtb3RlUGFydGljaXBhbnRzLmhhcyhpZGVudGl0eSkpIHtcbiAgICAgIGNvbnN0IGV4aXN0aW5nUGFydGljaXBhbnQgPSB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xuICAgICAgaWYgKGluZm8pIHtcbiAgICAgICAgY29uc3Qgd2FzVXBkYXRlZCA9IGV4aXN0aW5nUGFydGljaXBhbnQudXBkYXRlSW5mbyhpbmZvKTtcbiAgICAgICAgaWYgKHdhc1VwZGF0ZWQpIHtcbiAgICAgICAgICB0aGlzLnNpZFRvSWRlbnRpdHkuc2V0KGluZm8uc2lkLCBpbmZvLmlkZW50aXR5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGV4aXN0aW5nUGFydGljaXBhbnQ7XG4gICAgfVxuICAgIGNvbnN0IHBhcnRpY2lwYW50ID0gdGhpcy5jcmVhdGVQYXJ0aWNpcGFudChpZGVudGl0eSwgaW5mbyk7XG4gICAgdGhpcy5yZW1vdGVQYXJ0aWNpcGFudHMuc2V0KGlkZW50aXR5LCBwYXJ0aWNpcGFudCk7XG4gICAgdGhpcy5zaWRUb0lkZW50aXR5LnNldChpbmZvLnNpZCwgaW5mby5pZGVudGl0eSk7XG4gICAgLy8gaWYgd2UgaGF2ZSB2YWxpZCBpbmZvIGFuZCB0aGUgcGFydGljaXBhbnQgd2Fzbid0IGluIHRoZSBtYXAgYmVmb3JlLCB3ZSBjYW4gYXNzdW1lIHRoZSBwYXJ0aWNpcGFudCBpcyBuZXdcbiAgICAvLyBmaXJpbmcgaGVyZSB0byBtYWtlIHN1cmUgdGhhdCBgUGFydGljaXBhbnRDb25uZWN0ZWRgIGZpcmVzIGJlZm9yZSB0aGUgaW5pdGlhbCB0cmFjayBldmVudHNcbiAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudENvbm5lY3RlZCwgcGFydGljaXBhbnQpO1xuICAgIC8vIGFsc28gZm9yd2FyZCBldmVudHNcbiAgICAvLyB0cmFja1B1Ymxpc2hlZCBpcyBvbmx5IGZpcmVkIGZvciB0cmFja3MgYWRkZWQgYWZ0ZXIgYm90aCBsb2NhbCBwYXJ0aWNpcGFudFxuICAgIC8vIGFuZCByZW1vdGUgcGFydGljaXBhbnQgam9pbmVkIHRoZSByb29tXG4gICAgcGFydGljaXBhbnQub24oUGFydGljaXBhbnRFdmVudC5UcmFja1B1Ymxpc2hlZCwgdHJhY2tQdWJsaWNhdGlvbiA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1B1Ymxpc2hlZCwgdHJhY2tQdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tTdWJzY3JpYmVkLCAodHJhY2ssIHB1YmxpY2F0aW9uKSA9PiB7XG4gICAgICAvLyBtb25pdG9yIHBsYXliYWNrIHN0YXR1c1xuICAgICAgaWYgKHRyYWNrLmtpbmQgPT09IFRyYWNrLktpbmQuQXVkaW8pIHtcbiAgICAgICAgdHJhY2sub24oVHJhY2tFdmVudC5BdWRpb1BsYXliYWNrU3RhcnRlZCwgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCk7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuQXVkaW9QbGF5YmFja0ZhaWxlZCwgdGhpcy5oYW5kbGVBdWRpb1BsYXliYWNrRmFpbGVkKTtcbiAgICAgIH0gZWxzZSBpZiAodHJhY2sua2luZCA9PT0gVHJhY2suS2luZC5WaWRlbykge1xuICAgICAgICB0cmFjay5vbihUcmFja0V2ZW50LlZpZGVvUGxheWJhY2tGYWlsZWQsIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja0ZhaWxlZCk7XG4gICAgICAgIHRyYWNrLm9uKFRyYWNrRXZlbnQuVmlkZW9QbGF5YmFja1N0YXJ0ZWQsIHRoaXMuaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnB1Ymxpc2hlZCwgcHVibGljYXRpb24gPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1VucHVibGlzaGVkLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsICh0cmFjaywgcHVibGljYXRpb24pID0+IHtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuVHJhY2tVbnN1YnNjcmliZWQsIHRyYWNrLCBwdWJsaWNhdGlvbiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tNdXRlZCwgcHViID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrTXV0ZWQsIHB1YiwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuVHJhY2tVbm11dGVkLCBwdWIgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuVHJhY2tVbm11dGVkLCBwdWIsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TWV0YWRhdGFDaGFuZ2VkLCBtZXRhZGF0YSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5QYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCwgbWV0YWRhdGEsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlBhcnRpY2lwYW50TmFtZUNoYW5nZWQsIG5hbWUgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuUGFydGljaXBhbnROYW1lQ2hhbmdlZCwgbmFtZSwgcGFydGljaXBhbnQpO1xuICAgIH0pLm9uKFBhcnRpY2lwYW50RXZlbnQuQXR0cmlidXRlc0NoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50QXR0cmlidXRlc0NoYW5nZWQsIGNoYW5nZWRBdHRyaWJ1dGVzLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5Db25uZWN0aW9uUXVhbGl0eUNoYW5nZWQsIHF1YWxpdHkgPT4ge1xuICAgICAgdGhpcy5lbWl0V2hlbkNvbm5lY3RlZChSb29tRXZlbnQuQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkLCBxdWFsaXR5LCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5QYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCwgcHJldlBlcm1pc3Npb25zID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkLCBwcmV2UGVybWlzc2lvbnMsIHBhcnRpY2lwYW50KTtcbiAgICB9KS5vbihQYXJ0aWNpcGFudEV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uU3RhdHVzQ2hhbmdlZCwgKHB1Yiwgc3RhdHVzKSA9PiB7XG4gICAgICB0aGlzLmVtaXRXaGVuQ29ubmVjdGVkKFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvblN0YXR1c0NoYW5nZWQsIHB1Yiwgc3RhdHVzLCBwYXJ0aWNpcGFudCk7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgKHRyYWNrU2lkLCBlcnJvcikgPT4ge1xuICAgICAgdGhpcy5lbWl0KFJvb21FdmVudC5UcmFja1N1YnNjcmlwdGlvbkZhaWxlZCwgdHJhY2tTaWQsIHBhcnRpY2lwYW50LCBlcnJvcik7XG4gICAgfSkub24oUGFydGljaXBhbnRFdmVudC5UcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkLCAocHViLCBzdGF0dXMpID0+IHtcbiAgICAgIHRoaXMuZW1pdFdoZW5Db25uZWN0ZWQoUm9vbUV2ZW50LlRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbkNoYW5nZWQsIHB1Yiwgc3RhdHVzLCBwYXJ0aWNpcGFudCk7XG4gICAgfSk7XG4gICAgLy8gdXBkYXRlIGluZm8gYXQgdGhlIGVuZCBhZnRlciBjYWxsYmFja3MgaGF2ZSBiZWVuIHNldCB1cFxuICAgIGlmIChpbmZvKSB7XG4gICAgICBwYXJ0aWNpcGFudC51cGRhdGVJbmZvKGluZm8pO1xuICAgIH1cbiAgICByZXR1cm4gcGFydGljaXBhbnQ7XG4gIH1cbiAgc2VuZFN5bmNTdGF0ZSgpIHtcbiAgICBjb25zdCByZW1vdGVUcmFja3MgPSBBcnJheS5mcm9tKHRoaXMucmVtb3RlUGFydGljaXBhbnRzLnZhbHVlcygpKS5yZWR1Y2UoKGFjYywgcGFydGljaXBhbnQpID0+IHtcbiAgICAgIGFjYy5wdXNoKC4uLnBhcnRpY2lwYW50LmdldFRyYWNrUHVibGljYXRpb25zKCkpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gUmVtb3RlVHJhY2tQdWJsaWNhdGlvbnMgZGlyZWN0bHkgaW5zdGVhZCBvZiB0aGUgdHlwZSBjYXN0XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIFtdKTtcbiAgICBjb25zdCBsb2NhbFRyYWNrcyA9IHRoaXMubG9jYWxQYXJ0aWNpcGFudC5nZXRUcmFja1B1YmxpY2F0aW9ucygpOyAvLyBGSVhNRSB3b3VsZCBiZSBuaWNlIHRvIGhhdmUgdGhpcyByZXR1cm4gTG9jYWxUcmFja1B1YmxpY2F0aW9ucyBkaXJlY3RseSBpbnN0ZWFkIG9mIHRoZSB0eXBlIGNhc3RcbiAgICB0aGlzLmVuZ2luZS5zZW5kU3luY1N0YXRlKHJlbW90ZVRyYWNrcywgbG9jYWxUcmFja3MpO1xuICB9XG4gIC8qKlxuICAgKiBBZnRlciByZXN1bWluZywgd2UnbGwgbmVlZCB0byBub3RpZnkgdGhlIHNlcnZlciBvZiB0aGUgY3VycmVudFxuICAgKiBzdWJzY3JpcHRpb24gc2V0dGluZ3MuXG4gICAqL1xuICB1cGRhdGVTdWJzY3JpcHRpb25zKCkge1xuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy52YWx1ZXMoKSkge1xuICAgICAgZm9yIChjb25zdCBwdWIgb2YgcC52aWRlb1RyYWNrUHVibGljYXRpb25zLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChwdWIuaXNTdWJzY3JpYmVkICYmIGlzUmVtb3RlUHViKHB1YikpIHtcbiAgICAgICAgICBwdWIuZW1pdFRyYWNrVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2V0UmVtb3RlUGFydGljaXBhbnRCeVNpZChzaWQpIHtcbiAgICBjb25zdCBpZGVudGl0eSA9IHRoaXMuc2lkVG9JZGVudGl0eS5nZXQoc2lkKTtcbiAgICBpZiAoaWRlbnRpdHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlbW90ZVBhcnRpY2lwYW50cy5nZXQoaWRlbnRpdHkpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgdGhpcy5jbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKTtcbiAgICBsZXQgY29uc2VjdXRpdmVGYWlsdXJlcyA9IDA7XG4gICAgdGhpcy5jb25uZWN0aW9uUmVjb25jaWxlSW50ZXJ2YWwgPSBDcml0aWNhbFRpbWVycy5zZXRJbnRlcnZhbCgoKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAvLyBlbnN1cmUgd2UgZGlkbid0IHRlYXIgaXQgZG93blxuICAgICAgIXRoaXMuZW5naW5lIHx8XG4gICAgICAvLyBlbmdpbmUgZGV0ZWN0ZWQgY2xvc2UsIGJ1dCBSb29tIG1pc3NlZCBpdFxuICAgICAgdGhpcy5lbmdpbmUuaXNDbG9zZWQgfHxcbiAgICAgIC8vIHRyYW5zcG9ydHMgZmFpbGVkIHdpdGhvdXQgbm90aWZ5aW5nIGVuZ2luZVxuICAgICAgIXRoaXMuZW5naW5lLnZlcmlmeVRyYW5zcG9ydCgpKSB7XG4gICAgICAgIGNvbnNlY3V0aXZlRmFpbHVyZXMrKztcbiAgICAgICAgdGhpcy5sb2cud2FybignZGV0ZWN0ZWQgY29ubmVjdGlvbiBzdGF0ZSBtaXNtYXRjaCcsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5sb2dDb250ZXh0KSwge1xuICAgICAgICAgIG51bUZhaWx1cmVzOiBjb25zZWN1dGl2ZUZhaWx1cmVzLFxuICAgICAgICAgIGVuZ2luZTogdGhpcy5lbmdpbmUgPyB7XG4gICAgICAgICAgICBjbG9zZWQ6IHRoaXMuZW5naW5lLmlzQ2xvc2VkLFxuICAgICAgICAgICAgdHJhbnNwb3J0c0Nvbm5lY3RlZDogdGhpcy5lbmdpbmUudmVyaWZ5VHJhbnNwb3J0KClcbiAgICAgICAgICB9IDogdW5kZWZpbmVkXG4gICAgICAgIH0pKTtcbiAgICAgICAgaWYgKGNvbnNlY3V0aXZlRmFpbHVyZXMgPj0gMykge1xuICAgICAgICAgIHRoaXMucmVjcmVhdGVFbmdpbmUoKTtcbiAgICAgICAgICB0aGlzLmhhbmRsZURpc2Nvbm5lY3QodGhpcy5vcHRpb25zLnN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2gsIERpc2Nvbm5lY3RSZWFzb24uU1RBVEVfTUlTTUFUQ0gpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zZWN1dGl2ZUZhaWx1cmVzID0gMDtcbiAgICAgIH1cbiAgICB9LCBjb25uZWN0aW9uUmVjb25jaWxlRnJlcXVlbmN5KTtcbiAgfVxuICBjbGVhckNvbm5lY3Rpb25SZWNvbmNpbGUoKSB7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKSB7XG4gICAgICBDcml0aWNhbFRpbWVycy5jbGVhckludGVydmFsKHRoaXMuY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsKTtcbiAgICB9XG4gIH1cbiAgc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShzdGF0ZSkge1xuICAgIGlmIChzdGF0ZSA9PT0gdGhpcy5zdGF0ZSkge1xuICAgICAgLy8gdW5jaGFuZ2VkXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuc3RhdGUgPSBzdGF0ZTtcbiAgICB0aGlzLmVtaXQoUm9vbUV2ZW50LkNvbm5lY3Rpb25TdGF0ZUNoYW5nZWQsIHRoaXMuc3RhdGUpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGVtaXRCdWZmZXJlZEV2ZW50cygpIHtcbiAgICB0aGlzLmJ1ZmZlcmVkRXZlbnRzLmZvckVhY2goX3JlZjMgPT4ge1xuICAgICAgbGV0IFtldiwgYXJnc10gPSBfcmVmMztcbiAgICAgIHRoaXMuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfSk7XG4gICAgdGhpcy5idWZmZXJlZEV2ZW50cyA9IFtdO1xuICB9XG4gIGVtaXRXaGVuQ29ubmVjdGVkKGV2ZW50KSB7XG4gICAgZm9yICh2YXIgX2xlbjIgPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4yID4gMSA/IF9sZW4yIC0gMSA6IDApLCBfa2V5MiA9IDE7IF9rZXkyIDwgX2xlbjI7IF9rZXkyKyspIHtcbiAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuUmVjb25uZWN0aW5nIHx8IHRoaXMuaXNSZXN1bWluZyB8fCAhdGhpcy5lbmdpbmUgfHwgdGhpcy5lbmdpbmUucGVuZGluZ1JlY29ubmVjdCkge1xuICAgICAgLy8gaW4gY2FzZSB0aGUgcm9vbSBpcyByZWNvbm5lY3RpbmcsIGJ1ZmZlciB0aGUgZXZlbnRzIGJ5IGZpcmluZyB0aGVtIGxhdGVyIGFmdGVyIGVtaXR0aW5nIFJvb21FdmVudC5SZWNvbm5lY3RlZFxuICAgICAgdGhpcy5idWZmZXJlZEV2ZW50cy5wdXNoKFtldmVudCwgYXJnc10pO1xuICAgIH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gQ29ubmVjdGlvblN0YXRlLkNvbm5lY3RlZCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW1pdChldmVudCwgLi4uYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogQWxsb3dzIHRvIHBvcHVsYXRlIGEgcm9vbSB3aXRoIHNpbXVsYXRlZCBwYXJ0aWNpcGFudHMuXG4gICAqIE5vIGFjdHVhbCBjb25uZWN0aW9uIHRvIGEgc2VydmVyIHdpbGwgYmUgZXN0YWJsaXNoZWQsIGFsbCBzdGF0ZSBpc1xuICAgKiBAZXhwZXJpbWVudGFsXG4gICAqL1xuICBzaW11bGF0ZVBhcnRpY2lwYW50cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYSwgX2I7XG4gICAgICBjb25zdCBwdWJsaXNoT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICBhdWRpbzogdHJ1ZSxcbiAgICAgICAgdmlkZW86IHRydWUsXG4gICAgICAgIHVzZVJlYWxUcmFja3M6IGZhbHNlXG4gICAgICB9LCBvcHRpb25zLnB1Ymxpc2gpO1xuICAgICAgY29uc3QgcGFydGljaXBhbnRPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIGNvdW50OiA5LFxuICAgICAgICBhdWRpbzogZmFsc2UsXG4gICAgICAgIHZpZGVvOiB0cnVlLFxuICAgICAgICBhc3BlY3RSYXRpb3M6IFsxLjY2LCAxLjcsIDEuM11cbiAgICAgIH0sIG9wdGlvbnMucGFydGljaXBhbnRzKTtcbiAgICAgIHRoaXMuaGFuZGxlRGlzY29ubmVjdCgpO1xuICAgICAgdGhpcy5yb29tSW5mbyA9IG5ldyBSb29tJDEoe1xuICAgICAgICBzaWQ6ICdSTV9TSU1VTEFURUQnLFxuICAgICAgICBuYW1lOiAnc2ltdWxhdGVkLXJvb20nLFxuICAgICAgICBlbXB0eVRpbWVvdXQ6IDAsXG4gICAgICAgIG1heFBhcnRpY2lwYW50czogMCxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBwcm90b0ludDY0LnBhcnNlKG5ldyBEYXRlKCkuZ2V0VGltZSgpKSxcbiAgICAgICAgbWV0YWRhdGE6ICcnLFxuICAgICAgICBudW1QYXJ0aWNpcGFudHM6IDEsXG4gICAgICAgIG51bVB1Ymxpc2hlcnM6IDEsXG4gICAgICAgIHR1cm5QYXNzd29yZDogJycsXG4gICAgICAgIGVuYWJsZWRDb2RlY3M6IFtdLFxuICAgICAgICBhY3RpdmVSZWNvcmRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC51cGRhdGVJbmZvKG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICBpZGVudGl0eTogJ3NpbXVsYXRlZC1sb2NhbCcsXG4gICAgICAgIG5hbWU6ICdsb2NhbC1uYW1lJ1xuICAgICAgfSkpO1xuICAgICAgdGhpcy5zZXR1cExvY2FsUGFydGljaXBhbnRFdmVudHMoKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuU2lnbmFsQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuZW1pdChSb29tRXZlbnQuQ29ubmVjdGVkKTtcbiAgICAgIHRoaXMuc2V0QW5kRW1pdENvbm5lY3Rpb25TdGF0ZShDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKTtcbiAgICAgIGlmIChwdWJsaXNoT3B0aW9ucy52aWRlbykge1xuICAgICAgICBjb25zdCBjYW1QdWIgPSBuZXcgTG9jYWxUcmFja1B1YmxpY2F0aW9uKFRyYWNrLktpbmQuVmlkZW8sIG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgIHNvdXJjZTogVHJhY2tTb3VyY2UuQ0FNRVJBLFxuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPLFxuICAgICAgICAgIG5hbWU6ICd2aWRlby1kdW1teSdcbiAgICAgICAgfSksIG5ldyBMb2NhbFZpZGVvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCB3aW5kb3cubmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoe1xuICAgICAgICAgIHZpZGVvOiB0cnVlXG4gICAgICAgIH0pKS5nZXRWaWRlb1RyYWNrcygpWzBdIDogY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrKDE2MCAqICgoX2EgPSBwYXJ0aWNpcGFudE9wdGlvbnMuYXNwZWN0UmF0aW9zWzBdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAxKSwgMTYwLCB0cnVlLCB0cnVlKSwgdW5kZWZpbmVkLCBmYWxzZSwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pLCB7XG4gICAgICAgICAgbG9nZ2VyTmFtZTogdGhpcy5vcHRpb25zLmxvZ2dlck5hbWUsXG4gICAgICAgICAgbG9nZ2VyQ29udGV4dENiOiAoKSA9PiB0aGlzLmxvZ0NvbnRleHRcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmFkZFRyYWNrUHVibGljYXRpb24oY2FtUHViKTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBjYW1QdWIpO1xuICAgICAgfVxuICAgICAgaWYgKHB1Ymxpc2hPcHRpb25zLmF1ZGlvKSB7XG4gICAgICAgIGNvbnN0IGF1ZGlvUHViID0gbmV3IExvY2FsVHJhY2tQdWJsaWNhdGlvbihUcmFjay5LaW5kLkF1ZGlvLCBuZXcgVHJhY2tJbmZvKHtcbiAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgc2lkOiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAxMDAwMCkudG9TdHJpbmcoKSxcbiAgICAgICAgICB0eXBlOiBUcmFja1R5cGUuQVVESU9cbiAgICAgICAgfSksIG5ldyBMb2NhbEF1ZGlvVHJhY2socHVibGlzaE9wdGlvbnMudXNlUmVhbFRyYWNrcyA/ICh5aWVsZCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYSh7XG4gICAgICAgICAgYXVkaW86IHRydWVcbiAgICAgICAgfSkpLmdldEF1ZGlvVHJhY2tzKClbMF0gOiBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKSwgdW5kZWZpbmVkLCBmYWxzZSwgdGhpcy5hdWRpb0NvbnRleHQsIHtcbiAgICAgICAgICBsb2dnZXJOYW1lOiB0aGlzLm9wdGlvbnMubG9nZ2VyTmFtZSxcbiAgICAgICAgICBsb2dnZXJDb250ZXh0Q2I6ICgpID0+IHRoaXMubG9nQ29udGV4dFxuICAgICAgICB9KSwge1xuICAgICAgICAgIGxvZ2dlck5hbWU6IHRoaXMub3B0aW9ucy5sb2dnZXJOYW1lLFxuICAgICAgICAgIGxvZ2dlckNvbnRleHRDYjogKCkgPT4gdGhpcy5sb2dDb250ZXh0XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMubG9jYWxQYXJ0aWNpcGFudC5hZGRUcmFja1B1YmxpY2F0aW9uKGF1ZGlvUHViKTtcbiAgICAgICAgdGhpcy5sb2NhbFBhcnRpY2lwYW50LmVtaXQoUGFydGljaXBhbnRFdmVudC5Mb2NhbFRyYWNrUHVibGlzaGVkLCBhdWRpb1B1Yik7XG4gICAgICB9XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRpY2lwYW50T3B0aW9ucy5jb3VudCAtIDE7IGkgKz0gMSkge1xuICAgICAgICBsZXQgaW5mbyA9IG5ldyBQYXJ0aWNpcGFudEluZm8oe1xuICAgICAgICAgIHNpZDogTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMTAwMDApLnRvU3RyaW5nKCksXG4gICAgICAgICAgaWRlbnRpdHk6IFwic2ltdWxhdGVkLVwiLmNvbmNhdChpKSxcbiAgICAgICAgICBzdGF0ZTogUGFydGljaXBhbnRJbmZvX1N0YXRlLkFDVElWRSxcbiAgICAgICAgICB0cmFja3M6IFtdLFxuICAgICAgICAgIGpvaW5lZEF0OiBwcm90b0ludDY0LnBhcnNlKERhdGUubm93KCkpXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRPckNyZWF0ZVBhcnRpY2lwYW50KGluZm8uaWRlbnRpdHksIGluZm8pO1xuICAgICAgICBpZiAocGFydGljaXBhbnRPcHRpb25zLnZpZGVvKSB7XG4gICAgICAgICAgY29uc3QgZHVtbXlWaWRlbyA9IGNyZWF0ZUR1bW15VmlkZW9TdHJlYW1UcmFjaygxNjAgKiAoKF9iID0gcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvc1tpICUgcGFydGljaXBhbnRPcHRpb25zLmFzcGVjdFJhdGlvcy5sZW5ndGhdKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxKSwgMTYwLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgY29uc3QgdmlkZW9UcmFjayA9IG5ldyBUcmFja0luZm8oe1xuICAgICAgICAgICAgc291cmNlOiBUcmFja1NvdXJjZS5DQU1FUkEsXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVZpZGVvLCB2aWRlb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVZpZGVvXSksIG5ldyBSVENSdHBSZWNlaXZlcigpKTtcbiAgICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgdmlkZW9UcmFja107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcnRpY2lwYW50T3B0aW9ucy5hdWRpbykge1xuICAgICAgICAgIGNvbnN0IGR1bW15VHJhY2sgPSBnZXRFbXB0eUF1ZGlvU3RyZWFtVHJhY2soKTtcbiAgICAgICAgICBjb25zdCBhdWRpb1RyYWNrID0gbmV3IFRyYWNrSW5mbyh7XG4gICAgICAgICAgICBzb3VyY2U6IFRyYWNrU291cmNlLk1JQ1JPUEhPTkUsXG4gICAgICAgICAgICBzaWQ6IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwKS50b1N0cmluZygpLFxuICAgICAgICAgICAgdHlwZTogVHJhY2tUeXBlLkFVRElPXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcC5hZGRTdWJzY3JpYmVkTWVkaWFUcmFjayhkdW1teVRyYWNrLCBhdWRpb1RyYWNrLnNpZCwgbmV3IE1lZGlhU3RyZWFtKFtkdW1teVRyYWNrXSksIG5ldyBSVENSdHBSZWNlaXZlcigpKTtcbiAgICAgICAgICBpbmZvLnRyYWNrcyA9IFsuLi5pbmZvLnRyYWNrcywgYXVkaW9UcmFja107XG4gICAgICAgIH1cbiAgICAgICAgcC51cGRhdGVJbmZvKGluZm8pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8vIC8qKiBAaW50ZXJuYWwgKi9cbiAgZW1pdChldmVudCkge1xuICAgIGZvciAodmFyIF9sZW4zID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMyA+IDEgPyBfbGVuMyAtIDEgOiAwKSwgX2tleTMgPSAxOyBfa2V5MyA8IF9sZW4zOyBfa2V5MysrKSB7XG4gICAgICBhcmdzW19rZXkzIC0gMV0gPSBhcmd1bWVudHNbX2tleTNdO1xuICAgIH1cbiAgICAvLyBhY3RpdmUgc3BlYWtlciB1cGRhdGVzIGFyZSB0b28gc3BhbW15XG4gICAgaWYgKGV2ZW50ICE9PSBSb29tRXZlbnQuQWN0aXZlU3BlYWtlcnNDaGFuZ2VkICYmIGV2ZW50ICE9PSBSb29tRXZlbnQuVHJhbnNjcmlwdGlvblJlY2VpdmVkKSB7XG4gICAgICAvLyBvbmx5IGV4dHJhY3QgbG9nQ29udGV4dCBmcm9tIGFyZ3VtZW50cyBpbiBvcmRlciB0byBhdm9pZCBsb2dnaW5nIHRoZSB3aG9sZSBvYmplY3QgdHJlZVxuICAgICAgY29uc3QgbWluaW1pemVkQXJncyA9IG1hcEFyZ3MoYXJncykuZmlsdGVyKGFyZyA9PiBhcmcgIT09IHVuZGVmaW5lZCk7XG4gICAgICB0aGlzLmxvZy5kZWJ1ZyhcInJvb20gZXZlbnQgXCIuY29uY2F0KGV2ZW50KSwgT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB0aGlzLmxvZ0NvbnRleHQpLCB7XG4gICAgICAgIGV2ZW50LFxuICAgICAgICBhcmdzOiBtaW5pbWl6ZWRBcmdzXG4gICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfVxufVxuUm9vbS5jbGVhbnVwUmVnaXN0cnkgPSB0eXBlb2YgRmluYWxpemF0aW9uUmVnaXN0cnkgIT09ICd1bmRlZmluZWQnICYmIG5ldyBGaW5hbGl6YXRpb25SZWdpc3RyeShjbGVhbnVwID0+IHtcbiAgY2xlYW51cCgpO1xufSk7XG5mdW5jdGlvbiBtYXBBcmdzKGFyZ3MpIHtcbiAgcmV0dXJuIGFyZ3MubWFwKGFyZyA9PiB7XG4gICAgaWYgKCFhcmcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuICAgICAgcmV0dXJuIG1hcEFyZ3MoYXJnKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gJ2xvZ0NvbnRleHQnIGluIGFyZyA/IGFyZy5sb2dDb250ZXh0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYXJnO1xuICB9KTtcbn1cblxudmFyIENoZWNrU3RhdHVzO1xuKGZ1bmN0aW9uIChDaGVja1N0YXR1cykge1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIklETEVcIl0gPSAwXSA9IFwiSURMRVwiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlJVTk5JTkdcIl0gPSAxXSA9IFwiUlVOTklOR1wiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlNLSVBQRURcIl0gPSAyXSA9IFwiU0tJUFBFRFwiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIlNVQ0NFU1NcIl0gPSAzXSA9IFwiU1VDQ0VTU1wiO1xuICBDaGVja1N0YXR1c1tDaGVja1N0YXR1c1tcIkZBSUxFRFwiXSA9IDRdID0gXCJGQUlMRURcIjtcbn0pKENoZWNrU3RhdHVzIHx8IChDaGVja1N0YXR1cyA9IHt9KSk7XG5jbGFzcyBDaGVja2VyIGV4dGVuZHMgZXZlbnRzRXhwb3J0cy5FdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwsIHRva2VuKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5zdGF0dXMgPSBDaGVja1N0YXR1cy5JRExFO1xuICAgIHRoaXMubG9ncyA9IFtdO1xuICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgIHRoaXMudXJsID0gdXJsO1xuICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICB0aGlzLm5hbWUgPSB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgdGhpcy5yb29tID0gbmV3IFJvb20ob3B0aW9ucy5yb29tT3B0aW9ucyk7XG4gICAgdGhpcy5jb25uZWN0T3B0aW9ucyA9IG9wdGlvbnMuY29ubmVjdE9wdGlvbnM7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBydW4ob25Db21wbGV0ZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMgIT09IENoZWNrU3RhdHVzLklETEUpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ2NoZWNrIGlzIHJ1bm5pbmcgYWxyZWFkeScpO1xuICAgICAgfVxuICAgICAgdGhpcy5zZXRTdGF0dXMoQ2hlY2tTdGF0dXMuUlVOTklORyk7XG4gICAgICB0cnkge1xuICAgICAgICB5aWVsZCB0aGlzLnBlcmZvcm0oKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmVycm9yc0FzV2FybmluZ3MpIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kV2FybmluZyhlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYXBwZW5kRXJyb3IoZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAvLyBzbGVlcCBmb3IgYSBiaXQgdG8gZW5zdXJlIGRpc2Nvbm5lY3RcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDApKTtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGlmICh0aGlzLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuU0tJUFBFRCkge1xuICAgICAgICB0aGlzLnNldFN0YXR1cyh0aGlzLmlzU3VjY2VzcygpID8gQ2hlY2tTdGF0dXMuU1VDQ0VTUyA6IENoZWNrU3RhdHVzLkZBSUxFRCk7XG4gICAgICB9XG4gICAgICBpZiAob25Db21wbGV0ZSkge1xuICAgICAgICBvbkNvbXBsZXRlKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5nZXRJbmZvKCk7XG4gICAgfSk7XG4gIH1cbiAgaXNTdWNjZXNzKCkge1xuICAgIHJldHVybiAhdGhpcy5sb2dzLnNvbWUobCA9PiBsLmxldmVsID09PSAnZXJyb3InKTtcbiAgfVxuICBjb25uZWN0KHVybCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBpZiAodGhpcy5yb29tLnN0YXRlID09PSBDb25uZWN0aW9uU3RhdGUuQ29ubmVjdGVkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb207XG4gICAgICB9XG4gICAgICBpZiAoIXVybCkge1xuICAgICAgICB1cmwgPSB0aGlzLnVybDtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHRoaXMucm9vbS5jb25uZWN0KHVybCwgdGhpcy50b2tlbiwgdGhpcy5jb25uZWN0T3B0aW9ucyk7XG4gICAgICByZXR1cm4gdGhpcy5yb29tO1xuICAgIH0pO1xuICB9XG4gIGRpc2Nvbm5lY3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmICh0aGlzLnJvb20gJiYgdGhpcy5yb29tLnN0YXRlICE9PSBDb25uZWN0aW9uU3RhdGUuRGlzY29ubmVjdGVkKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucm9vbS5kaXNjb25uZWN0KCk7XG4gICAgICAgIC8vIHdhaXQgZm9yIGl0IHRvIGdvIHRocm91Z2hcbiAgICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDUwMCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHNraXAoKSB7XG4gICAgdGhpcy5zZXRTdGF0dXMoQ2hlY2tTdGF0dXMuU0tJUFBFRCk7XG4gIH1cbiAgc3dpdGNoUHJvdG9jb2wocHJvdG9jb2wpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgbGV0IGhhc1JlY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgbGV0IGhhc1JlY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnJvb20ub24oUm9vbUV2ZW50LlJlY29ubmVjdGluZywgKCkgPT4ge1xuICAgICAgICBoYXNSZWNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb20ub25jZShSb29tRXZlbnQuUmVjb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgaGFzUmVjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgfSk7XG4gICAgICB0aGlzLnJvb20uc2ltdWxhdGVTY2VuYXJpbyhcImZvcmNlLVwiLmNvbmNhdChwcm90b2NvbCkpO1xuICAgICAgeWllbGQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDEwMDApKTtcbiAgICAgIGlmICghaGFzUmVjb25uZWN0aW5nKSB7XG4gICAgICAgIC8vIG5vIG5lZWQgdG8gd2FpdCBmb3IgcmVjb25uZWN0aW9uXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIHdhaXQgZm9yIDEwIHNlY29uZHMgZm9yIHJlY29ubmVjdGlvblxuICAgICAgY29uc3QgdGltZW91dCA9IERhdGUubm93KCkgKyAxMDAwMDtcbiAgICAgIHdoaWxlIChEYXRlLm5vdygpIDwgdGltZW91dCkge1xuICAgICAgICBpZiAoaGFzUmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgeWllbGQgc2xlZXAoMTAwKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCByZWNvbm5lY3QgdXNpbmcgXCIuY29uY2F0KHByb3RvY29sLCBcIiBwcm90b2NvbCBhZnRlciAxMCBzZWNvbmRzXCIpKTtcbiAgICB9KTtcbiAgfVxuICBhcHBlbmRNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICB0aGlzLmxvZ3MucHVzaCh7XG4gICAgICBsZXZlbDogJ2luZm8nLFxuICAgICAgbWVzc2FnZVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIGFwcGVuZFdhcm5pbmcobWVzc2FnZSkge1xuICAgIHRoaXMubG9ncy5wdXNoKHtcbiAgICAgIGxldmVsOiAnd2FybmluZycsXG4gICAgICBtZXNzYWdlXG4gICAgfSk7XG4gICAgdGhpcy5lbWl0KCd1cGRhdGUnLCB0aGlzLmdldEluZm8oKSk7XG4gIH1cbiAgYXBwZW5kRXJyb3IobWVzc2FnZSkge1xuICAgIHRoaXMubG9ncy5wdXNoKHtcbiAgICAgIGxldmVsOiAnZXJyb3InLFxuICAgICAgbWVzc2FnZVxuICAgIH0pO1xuICAgIHRoaXMuZW1pdCgndXBkYXRlJywgdGhpcy5nZXRJbmZvKCkpO1xuICB9XG4gIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIHRoaXMuZ2V0SW5mbygpKTtcbiAgfVxuICBnZXQgZW5naW5lKCkge1xuICAgIHZhciBfYTtcbiAgICByZXR1cm4gKF9hID0gdGhpcy5yb29tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW5naW5lO1xuICB9XG4gIGdldEluZm8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvZ3M6IHRoaXMubG9ncyxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIHN0YXR1czogdGhpcy5zdGF0dXMsXG4gICAgICBkZXNjcmlwdGlvbjogdGhpcy5kZXNjcmlwdGlvblxuICAgIH07XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVja3MgZm9yIGNvbm5lY3Rpb25zIHF1YWxpdHkgdG8gY2xvc2VzdHMgQ2xvdWQgcmVnaW9ucyBhbmQgZGV0ZXJtaW5pbmcgdGhlIGJlc3QgcXVhbGl0eVxuICovXG5jbGFzcyBDbG91ZFJlZ2lvbkNoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0Nsb3VkIHJlZ2lvbnMnO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHJlZ2lvblByb3ZpZGVyID0gbmV3IFJlZ2lvblVybFByb3ZpZGVyKHRoaXMudXJsLCB0aGlzLnRva2VuKTtcbiAgICAgIGlmICghcmVnaW9uUHJvdmlkZXIuaXNDbG91ZCgpKSB7XG4gICAgICAgIHRoaXMuc2tpcCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWdpb25TdGF0cyA9IFtdO1xuICAgICAgY29uc3Qgc2VlblVybHMgPSBuZXcgU2V0KCk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICBjb25zdCByZWdpb25VcmwgPSB5aWVsZCByZWdpb25Qcm92aWRlci5nZXROZXh0QmVzdFJlZ2lvblVybCgpO1xuICAgICAgICBpZiAoIXJlZ2lvblVybCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWVuVXJscy5oYXMocmVnaW9uVXJsKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHNlZW5VcmxzLmFkZChyZWdpb25VcmwpO1xuICAgICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRoaXMuY2hlY2tDbG91ZFJlZ2lvbihyZWdpb25VcmwpO1xuICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJcIi5jb25jYXQoc3RhdHMucmVnaW9uLCBcIiBSVFQ6IFwiKS5jb25jYXQoc3RhdHMucnR0LCBcIm1zLCBkdXJhdGlvbjogXCIpLmNvbmNhdChzdGF0cy5kdXJhdGlvbiwgXCJtc1wiKSk7XG4gICAgICAgIHJlZ2lvblN0YXRzLnB1c2goc3RhdHMpO1xuICAgICAgfVxuICAgICAgcmVnaW9uU3RhdHMuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICByZXR1cm4gKGEuZHVyYXRpb24gLSBiLmR1cmF0aW9uKSAqIDAuNSArIChhLnJ0dCAtIGIucnR0KSAqIDAuNTtcbiAgICAgIH0pO1xuICAgICAgY29uc3QgYmVzdFJlZ2lvbiA9IHJlZ2lvblN0YXRzWzBdO1xuICAgICAgdGhpcy5iZXN0U3RhdHMgPSBiZXN0UmVnaW9uO1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiYmVzdCBDbG91ZCByZWdpb246IFwiLmNvbmNhdChiZXN0UmVnaW9uLnJlZ2lvbikpO1xuICAgIH0pO1xuICB9XG4gIGdldEluZm8oKSB7XG4gICAgY29uc3QgaW5mbyA9IHN1cGVyLmdldEluZm8oKTtcbiAgICBpbmZvLmRhdGEgPSB0aGlzLmJlc3RTdGF0cztcbiAgICByZXR1cm4gaW5mbztcbiAgfVxuICBjaGVja0Nsb3VkUmVnaW9uKHVybCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iO1xuICAgICAgeWllbGQgdGhpcy5jb25uZWN0KHVybCk7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLnByb3RvY29sID09PSAndGNwJykge1xuICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaFByb3RvY29sKCd0Y3AnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlZ2lvbiA9IChfYSA9IHRoaXMucm9vbS5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVnaW9uO1xuICAgICAgaWYgKCFyZWdpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZWdpb24gbm90IGZvdW5kJyk7XG4gICAgICB9XG4gICAgICBjb25zdCB3cml0ZXIgPSB5aWVsZCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5zdHJlYW1UZXh0KHtcbiAgICAgICAgdG9waWM6ICd0ZXN0J1xuICAgICAgfSk7XG4gICAgICBjb25zdCBjaHVua1NpemUgPSAxMDAwOyAvLyBlYWNoIGNodW5rIGlzIGFib3V0IDEwMDAgYnl0ZXNcbiAgICAgIGNvbnN0IHRvdGFsU2l6ZSA9IDEwMDAwMDA7IC8vIGFwcHJveGltYXRlbHkgMU1CIG9mIGRhdGFcbiAgICAgIGNvbnN0IG51bUNodW5rcyA9IHRvdGFsU2l6ZSAvIGNodW5rU2l6ZTsgLy8gd2lsbCB5aWVsZCAxMDAwIGNodW5rc1xuICAgICAgY29uc3QgY2h1bmtEYXRhID0gJ0EnLnJlcGVhdChjaHVua1NpemUpOyAvLyBjcmVhdGUgYSBzdHJpbmcgb2YgMTAwMCAnQScgY2hhcmFjdGVyc1xuICAgICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQ2h1bmtzOyBpKyspIHtcbiAgICAgICAgeWllbGQgd3JpdGVyLndyaXRlKGNodW5rRGF0YSk7XG4gICAgICB9XG4gICAgICB5aWVsZCB3cml0ZXIuY2xvc2UoKTtcbiAgICAgIGNvbnN0IGVuZFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgY29uc3Qgc3RhdHMgPSB5aWVsZCAoX2IgPSB0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlcikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnB1Ymxpc2hlci5nZXRTdGF0cygpO1xuICAgICAgY29uc3QgcmVnaW9uU3RhdHMgPSB7XG4gICAgICAgIHJlZ2lvbjogcmVnaW9uLFxuICAgICAgICBydHQ6IDEwMDAwLFxuICAgICAgICBkdXJhdGlvbjogZW5kVGltZSAtIHN0YXJ0VGltZVxuICAgICAgfTtcbiAgICAgIHN0YXRzID09PSBudWxsIHx8IHN0YXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICBpZiAoc3RhdC50eXBlID09PSAnY2FuZGlkYXRlLXBhaXInICYmIHN0YXQubm9taW5hdGVkKSB7XG4gICAgICAgICAgcmVnaW9uU3RhdHMucnR0ID0gc3RhdC5jdXJyZW50Um91bmRUcmlwVGltZSAqIDEwMDA7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgeWllbGQgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICByZXR1cm4gcmVnaW9uU3RhdHM7XG4gICAgfSk7XG4gIH1cbn1cblxuY29uc3QgVEVTVF9EVVJBVElPTiA9IDEwMDAwO1xuY2xhc3MgQ29ubmVjdGlvblByb3RvY29sQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ29ubmVjdGlvbiB2aWEgVURQIHZzIFRDUCc7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgY29uc3QgdWRwU3RhdHMgPSB5aWVsZCB0aGlzLmNoZWNrQ29ubmVjdGlvblByb3RvY29sKCd1ZHAnKTtcbiAgICAgIGNvbnN0IHRjcFN0YXRzID0geWllbGQgdGhpcy5jaGVja0Nvbm5lY3Rpb25Qcm90b2NvbCgndGNwJyk7XG4gICAgICB0aGlzLmJlc3RTdGF0cyA9IHVkcFN0YXRzO1xuICAgICAgLy8gdWRwIHNob3VsZCBpcyB0aGUgYmV0dGVyIHByb3RvY29sIHR5cGljYWxseS4gaG93ZXZlciwgd2UnZCBwcmVmZXIgVENQIHdoZW4gZWl0aGVyIG9mIHRoZXNlIGNvbmRpdGlvbnMgYXJlIHRydWU6XG4gICAgICAvLyAxLiB0aGUgYmFuZHdpZHRoIGxpbWl0YXRpb24gaXMgd29yc2Ugb24gVURQIGJ5IDUwMG1zXG4gICAgICAvLyAyLiB0aGUgcGFja2V0IGxvc3MgaXMgaGlnaGVyIG9uIFVEUCBieSAxJVxuICAgICAgaWYgKHVkcFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCAtIHRjcFN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCA+IDAuNSB8fCAodWRwU3RhdHMucGFja2V0c0xvc3QgLSB0Y3BTdGF0cy5wYWNrZXRzTG9zdCkgLyB1ZHBTdGF0cy5wYWNrZXRzU2VudCA+IDAuMDEpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKCdiZXN0IGNvbm5lY3Rpb24gcXVhbGl0eSB2aWEgdGNwJyk7XG4gICAgICAgIHRoaXMuYmVzdFN0YXRzID0gdGNwU3RhdHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2Jlc3QgY29ubmVjdGlvbiBxdWFsaXR5IHZpYSB1ZHAnKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHN0YXRzID0gdGhpcy5iZXN0U3RhdHM7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJ1cHN0cmVhbSBiaXRyYXRlOiBcIi5jb25jYXQoKHN0YXRzLmJpdHJhdGVUb3RhbCAvIHN0YXRzLmNvdW50IC8gMTAwMCAvIDEwMDApLnRvRml4ZWQoMiksIFwiIG1icHNcIikpO1xuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwiUlRUOiBcIi5jb25jYXQoKHN0YXRzLnJ0dFRvdGFsIC8gc3RhdHMuY291bnQgKiAxMDAwKS50b0ZpeGVkKDIpLCBcIiBtc1wiKSk7XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJqaXR0ZXI6IFwiLmNvbmNhdCgoc3RhdHMuaml0dGVyVG90YWwgLyBzdGF0cy5jb3VudCAqIDEwMDApLnRvRml4ZWQoMiksIFwiIG1zXCIpKTtcbiAgICAgIGlmIChzdGF0cy5wYWNrZXRzTG9zdCA+IDApIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwicGFja2V0cyBsb3N0OiBcIi5jb25jYXQoKHN0YXRzLnBhY2tldHNMb3N0IC8gc3RhdHMucGFja2V0c1NlbnQgKiAxMDApLnRvRml4ZWQoMiksIFwiJVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuYmFuZHdpZHRoID4gMSkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJiYW5kd2lkdGggbGltaXRlZCBcIi5jb25jYXQoKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmJhbmR3aWR0aCAvIChURVNUX0RVUkFUSU9OIC8gMTAwMCkgKiAxMDApLnRvRml4ZWQoMiksIFwiJVwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMuY3B1ID4gMCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoXCJjcHUgbGltaXRlZCBcIi5jb25jYXQoKHN0YXRzLnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zLmNwdSAvIChURVNUX0RVUkFUSU9OIC8gMTAwMCkgKiAxMDApLnRvRml4ZWQoMiksIFwiJVwiKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0SW5mbygpIHtcbiAgICBjb25zdCBpbmZvID0gc3VwZXIuZ2V0SW5mbygpO1xuICAgIGluZm8uZGF0YSA9IHRoaXMuYmVzdFN0YXRzO1xuICAgIHJldHVybiBpbmZvO1xuICB9XG4gIGNoZWNrQ29ubmVjdGlvblByb3RvY29sKHByb3RvY29sKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgaWYgKHByb3RvY29sID09PSAndGNwJykge1xuICAgICAgICB5aWVsZCB0aGlzLnN3aXRjaFByb3RvY29sKCd0Y3AnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIHRoaXMuc3dpdGNoUHJvdG9jb2woJ3VkcCcpO1xuICAgICAgfVxuICAgICAgLy8gY3JlYXRlIGEgY2FudmFzIHdpdGggYW5pbWF0ZWQgY29udGVudFxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICBjYW52YXMud2lkdGggPSAxMjgwO1xuICAgICAgY2FudmFzLmhlaWdodCA9IDcyMDtcbiAgICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgaWYgKCFjdHgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZ2V0IGNhbnZhcyBjb250ZXh0Jyk7XG4gICAgICB9XG4gICAgICBsZXQgaHVlID0gMDtcbiAgICAgIGNvbnN0IGFuaW1hdGUgPSAoKSA9PiB7XG4gICAgICAgIGh1ZSA9IChodWUgKyAxKSAlIDM2MDtcbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IFwiaHNsKFwiLmNvbmNhdChodWUsIFwiLCAxMDAlLCA1MCUpXCIpO1xuICAgICAgICBjdHguZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGUpO1xuICAgICAgfTtcbiAgICAgIGFuaW1hdGUoKTtcbiAgICAgIC8vIGNyZWF0ZSB2aWRlbyB0cmFjayBmcm9tIGNhbnZhc1xuICAgICAgY29uc3Qgc3RyZWFtID0gY2FudmFzLmNhcHR1cmVTdHJlYW0oMzApOyAvLyAzMGZwc1xuICAgICAgY29uc3QgdmlkZW9UcmFjayA9IHN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgLy8gcHVibGlzaCB0byByb29tXG4gICAgICBjb25zdCBwdWIgPSB5aWVsZCB0aGlzLnJvb20ubG9jYWxQYXJ0aWNpcGFudC5wdWJsaXNoVHJhY2sodmlkZW9UcmFjaywge1xuICAgICAgICBzaW11bGNhc3Q6IGZhbHNlLFxuICAgICAgICBkZWdyYWRhdGlvblByZWZlcmVuY2U6ICdtYWludGFpbi1yZXNvbHV0aW9uJyxcbiAgICAgICAgdmlkZW9FbmNvZGluZzoge1xuICAgICAgICAgIG1heEJpdHJhdGU6IDIwMDAwMDBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zdCB0cmFjayA9IHB1Yi50cmFjaztcbiAgICAgIGNvbnN0IHByb3RvY29sU3RhdHMgPSB7XG4gICAgICAgIHByb3RvY29sLFxuICAgICAgICBwYWNrZXRzTG9zdDogMCxcbiAgICAgICAgcGFja2V0c1NlbnQ6IDAsXG4gICAgICAgIHF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zOiB7fSxcbiAgICAgICAgcnR0VG90YWw6IDAsXG4gICAgICAgIGppdHRlclRvdGFsOiAwLFxuICAgICAgICBiaXRyYXRlVG90YWw6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuICAgICAgLy8gZ2F0aGVyIHN0YXRzIG9uY2UgYSBzZWNvbmRcbiAgICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIHRyYWNrLmdldFJUQ1N0YXRzUmVwb3J0KCk7XG4gICAgICAgIHN0YXRzID09PSBudWxsIHx8IHN0YXRzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdGF0cy5mb3JFYWNoKHN0YXQgPT4ge1xuICAgICAgICAgIGlmIChzdGF0LnR5cGUgPT09ICdvdXRib3VuZC1ydHAnKSB7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnBhY2tldHNTZW50ID0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMucXVhbGl0eUxpbWl0YXRpb25EdXJhdGlvbnMgPSBzdGF0LnF1YWxpdHlMaW1pdGF0aW9uRHVyYXRpb25zO1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5iaXRyYXRlVG90YWwgKz0gc3RhdC50YXJnZXRCaXRyYXRlO1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5jb3VudCsrO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhdC50eXBlID09PSAncmVtb3RlLWluYm91bmQtcnRwJykge1xuICAgICAgICAgICAgcHJvdG9jb2xTdGF0cy5wYWNrZXRzTG9zdCA9IHN0YXQucGFja2V0c0xvc3Q7XG4gICAgICAgICAgICBwcm90b2NvbFN0YXRzLnJ0dFRvdGFsICs9IHN0YXQucm91bmRUcmlwVGltZTtcbiAgICAgICAgICAgIHByb3RvY29sU3RhdHMuaml0dGVyVG90YWwgKz0gc3RhdC5qaXR0ZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pLCAxMDAwKTtcbiAgICAgIC8vIHdhaXQgYSBiaXQgdG8gZ2F0aGVyIHN0YXRzXG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgVEVTVF9EVVJBVElPTikpO1xuICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gICAgICB2aWRlb1RyYWNrLnN0b3AoKTtcbiAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgIHlpZWxkIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgICAgcmV0dXJuIHByb3RvY29sU3RhdHM7XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgUHVibGlzaEF1ZGlvQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ2FuIHB1Ymxpc2ggYXVkaW8nO1xuICB9XG4gIHBlcmZvcm0oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBfYTtcbiAgICAgIGNvbnN0IHJvb20gPSB5aWVsZCB0aGlzLmNvbm5lY3QoKTtcbiAgICAgIGNvbnN0IHRyYWNrID0geWllbGQgY3JlYXRlTG9jYWxBdWRpb1RyYWNrKCk7XG4gICAgICBjb25zdCB0cmFja0lzU2lsZW50ID0geWllbGQgZGV0ZWN0U2lsZW5jZSh0cmFjaywgMTAwMCk7XG4gICAgICBpZiAodHJhY2tJc1NpbGVudCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3VuYWJsZSB0byBkZXRlY3QgYXVkaW8gZnJvbSBtaWNyb3Bob25lJyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ2RldGVjdGVkIGF1ZGlvIGZyb20gbWljcm9waG9uZScpO1xuICAgICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAzMDAwKSk7XG4gICAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYSA9IHRyYWNrLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKCk7XG4gICAgICBpZiAoIXN0YXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBSVENTdGF0cycpO1xuICAgICAgfVxuICAgICAgbGV0IG51bVBhY2tldHMgPSAwO1xuICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgKHN0YXQua2luZCA9PT0gJ2F1ZGlvJyB8fCAhc3RhdC5raW5kICYmIHN0YXQubWVkaWFUeXBlID09PSAnYXVkaW8nKSkge1xuICAgICAgICAgIG51bVBhY2tldHMgPSBzdGF0LnBhY2tldHNTZW50O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGlmIChudW1QYWNrZXRzID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGRldGVybWluZSBwYWNrZXRzIGFyZSBzZW50Jyk7XG4gICAgICB9XG4gICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJwdWJsaXNoZWQgXCIuY29uY2F0KG51bVBhY2tldHMsIFwiIGF1ZGlvIHBhY2tldHNcIikpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFB1Ymxpc2hWaWRlb0NoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ0NhbiBwdWJsaXNoIHZpZGVvJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBjb25zdCB0cmFjayA9IHlpZWxkIGNyZWF0ZUxvY2FsVmlkZW9UcmFjaygpO1xuICAgICAgLy8gY2hlY2sgaWYgd2UgaGF2ZSB2aWRlbyBmcm9tIGNhbWVyYVxuICAgICAgeWllbGQgdGhpcy5jaGVja0ZvclZpZGVvKHRyYWNrLm1lZGlhU3RyZWFtVHJhY2spO1xuICAgICAgcm9vbS5sb2NhbFBhcnRpY2lwYW50LnB1Ymxpc2hUcmFjayh0cmFjayk7XG4gICAgICAvLyB3YWl0IGZvciBhIGZldyBzZWNvbmRzIHRvIHB1Ymxpc2hcbiAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKSk7XG4gICAgICAvLyB2ZXJpZnkgUlRDIHN0YXRzIHRoYXQgaXQncyBwdWJsaXNoaW5nXG4gICAgICBjb25zdCBzdGF0cyA9IHlpZWxkIChfYSA9IHRyYWNrLnNlbmRlcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmdldFN0YXRzKCk7XG4gICAgICBpZiAoIXN0YXRzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGdldCBSVENTdGF0cycpO1xuICAgICAgfVxuICAgICAgbGV0IG51bVBhY2tldHMgPSAwO1xuICAgICAgc3RhdHMuZm9yRWFjaChzdGF0ID0+IHtcbiAgICAgICAgaWYgKHN0YXQudHlwZSA9PT0gJ291dGJvdW5kLXJ0cCcgJiYgKHN0YXQua2luZCA9PT0gJ3ZpZGVvJyB8fCAhc3RhdC5raW5kICYmIHN0YXQubWVkaWFUeXBlID09PSAndmlkZW8nKSkge1xuICAgICAgICAgIG51bVBhY2tldHMgKz0gc3RhdC5wYWNrZXRzU2VudDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAobnVtUGFja2V0cyA9PT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBkZXRlcm1pbmUgcGFja2V0cyBhcmUgc2VudCcpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKFwicHVibGlzaGVkIFwiLmNvbmNhdChudW1QYWNrZXRzLCBcIiB2aWRlbyBwYWNrZXRzXCIpKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja0ZvclZpZGVvKHRyYWNrKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgc3RyZWFtLmFkZFRyYWNrKHRyYWNrLmNsb25lKCkpO1xuICAgICAgLy8gQ3JlYXRlIHZpZGVvIGVsZW1lbnQgdG8gY2hlY2sgZnJhbWVzXG4gICAgICBjb25zdCB2aWRlbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICB2aWRlby5zcmNPYmplY3QgPSBzdHJlYW07XG4gICAgICB2aWRlby5tdXRlZCA9IHRydWU7XG4gICAgICB5aWVsZCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgdmlkZW8ub25wbGF5ID0gKCkgPT4ge1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjb25zdCBzZXR0aW5ncyA9IHRyYWNrLmdldFNldHRpbmdzKCk7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IChfYiA9IChfYSA9IHNldHRpbmdzLndpZHRoKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB2aWRlby52aWRlb1dpZHRoKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAxMjgwO1xuICAgICAgICAgICAgY29uc3QgaGVpZ2h0ID0gKF9kID0gKF9jID0gc2V0dGluZ3MuaGVpZ2h0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiB2aWRlby52aWRlb0hlaWdodCkgIT09IG51bGwgJiYgX2QgIT09IHZvaWQgMCA/IF9kIDogNzIwO1xuICAgICAgICAgICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgICAvLyBEcmF3IHZpZGVvIGZyYW1lIHRvIGNhbnZhc1xuICAgICAgICAgICAgY3R4LmRyYXdJbWFnZSh2aWRlbywgMCwgMCk7XG4gICAgICAgICAgICAvLyBHZXQgaW1hZ2UgZGF0YSBhbmQgY2hlY2sgaWYgYWxsIHBpeGVscyBhcmUgYmxhY2tcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbiAgICAgICAgICAgIGxldCBpc0FsbEJsYWNrID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgICBpZiAoZGF0YVtpXSAhPT0gMCB8fCBkYXRhW2kgKyAxXSAhPT0gMCB8fCBkYXRhW2kgKyAyXSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlzQWxsQmxhY2sgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQWxsQmxhY2spIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRFcnJvcignY2FtZXJhIGFwcGVhcnMgdG8gYmUgcHJvZHVjaW5nIG9ubHkgYmxhY2sgZnJhbWVzJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoJ3JlY2VpdmVkIHZpZGVvIGZyYW1lcycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9O1xuICAgICAgICB2aWRlby5wbGF5KCk7XG4gICAgICB9KTtcbiAgICAgIHZpZGVvLnJlbW92ZSgpO1xuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFJlY29ubmVjdENoZWNrIGV4dGVuZHMgQ2hlY2tlciB7XG4gIGdldCBkZXNjcmlwdGlvbigpIHtcbiAgICByZXR1cm4gJ1Jlc3VtaW5nIGNvbm5lY3Rpb24gYWZ0ZXIgaW50ZXJydXB0aW9uJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCByb29tID0geWllbGQgdGhpcy5jb25uZWN0KCk7XG4gICAgICBsZXQgcmVjb25uZWN0aW5nVHJpZ2dlcmVkID0gZmFsc2U7XG4gICAgICBsZXQgcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGxldCByZWNvbm5lY3RSZXNvbHZlcjtcbiAgICAgIGNvbnN0IHJlY29ubmVjdFRpbWVvdXQgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCA1MDAwKTtcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIgPSByZXNvbHZlO1xuICAgICAgfSk7XG4gICAgICBjb25zdCBoYW5kbGVSZWNvbm5lY3RpbmcgPSAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGluZ1RyaWdnZXJlZCA9IHRydWU7XG4gICAgICB9O1xuICAgICAgcm9vbS5vbihSb29tRXZlbnQuU2lnbmFsUmVjb25uZWN0aW5nLCBoYW5kbGVSZWNvbm5lY3RpbmcpLm9uKFJvb21FdmVudC5SZWNvbm5lY3RpbmcsIGhhbmRsZVJlY29ubmVjdGluZykub24oUm9vbUV2ZW50LlJlY29ubmVjdGVkLCAoKSA9PiB7XG4gICAgICAgIHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmVjb25uZWN0UmVzb2x2ZXIodHJ1ZSk7XG4gICAgICB9KTtcbiAgICAgIChfYSA9IHJvb20uZW5naW5lLmNsaWVudC53cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICBjb25zdCBvbkNsb3NlID0gcm9vbS5lbmdpbmUuY2xpZW50Lm9uQ2xvc2U7XG4gICAgICBpZiAob25DbG9zZSkge1xuICAgICAgICBvbkNsb3NlKCcnKTtcbiAgICAgIH1cbiAgICAgIHlpZWxkIHJlY29ubmVjdFRpbWVvdXQ7XG4gICAgICBpZiAoIXJlY29ubmVjdGluZ1RyaWdnZXJlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0RpZCBub3QgYXR0ZW1wdCB0byByZWNvbm5lY3QnKTtcbiAgICAgIH0gZWxzZSBpZiAoIXJlY29ubmVjdGVkIHx8IHJvb20uc3RhdGUgIT09IENvbm5lY3Rpb25TdGF0ZS5Db25uZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdyZWNvbm5lY3Rpb24gaXMgb25seSBwb3NzaWJsZSBpbiBSZWRpcy1iYXNlZCBjb25maWd1cmF0aW9ucycpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhYmxlIHRvIHJlY29ubmVjdCcpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5cbmNsYXNzIFRVUk5DaGVjayBleHRlbmRzIENoZWNrZXIge1xuICBnZXQgZGVzY3JpcHRpb24oKSB7XG4gICAgcmV0dXJuICdDYW4gY29ubmVjdCB2aWEgVFVSTic7XG4gIH1cbiAgcGVyZm9ybSgpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGNvbnN0IHNpZ25hbENsaWVudCA9IG5ldyBTaWduYWxDbGllbnQoKTtcbiAgICAgIGNvbnN0IGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICAgICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwXG4gICAgICB9KTtcbiAgICAgIGxldCBoYXNUTFMgPSBmYWxzZTtcbiAgICAgIGxldCBoYXNUVVJOID0gZmFsc2U7XG4gICAgICBsZXQgaGFzU1RVTiA9IGZhbHNlO1xuICAgICAgZm9yIChsZXQgaWNlU2VydmVyIG9mIGpvaW5SZXMuaWNlU2VydmVycykge1xuICAgICAgICBmb3IgKGxldCB1cmwgb2YgaWNlU2VydmVyLnVybHMpIHtcbiAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3R1cm46JykpIHtcbiAgICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICh1cmwuc3RhcnRzV2l0aCgndHVybnM6JykpIHtcbiAgICAgICAgICAgIGhhc1RVUk4gPSB0cnVlO1xuICAgICAgICAgICAgaGFzU1RVTiA9IHRydWU7XG4gICAgICAgICAgICBoYXNUTFMgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodXJsLnN0YXJ0c1dpdGgoJ3N0dW46JykpIHtcbiAgICAgICAgICAgIGhhc1NUVU4gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNTVFVOKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gU1RVTiBzZXJ2ZXJzIGNvbmZpZ3VyZWQgb24gc2VydmVyIHNpZGUuJyk7XG4gICAgICB9IGVsc2UgaWYgKGhhc1RVUk4gJiYgIWhhc1RMUykge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1RVUk4gaXMgY29uZmlndXJlZCBzZXJ2ZXIgc2lkZSwgYnV0IFRVUk4vVExTIGlzIHVuYXZhaWxhYmxlLicpO1xuICAgICAgfVxuICAgICAgeWllbGQgc2lnbmFsQ2xpZW50LmNsb3NlKCk7XG4gICAgICBpZiAoKChfYiA9IChfYSA9IHRoaXMuY29ubmVjdE9wdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5ydGNDb25maWcpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5pY2VTZXJ2ZXJzKSB8fCBoYXNUVVJOKSB7XG4gICAgICAgIHlpZWxkIHRoaXMucm9vbS5jb25uZWN0KHRoaXMudXJsLCB0aGlzLnRva2VuLCB7XG4gICAgICAgICAgcnRjQ29uZmlnOiB7XG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdyZWxheSdcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKCdObyBUVVJOIHNlcnZlcnMgY29uZmlndXJlZC4nKTtcbiAgICAgICAgdGhpcy5za2lwKCk7XG4gICAgICAgIHlpZWxkIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAwKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cblxuY2xhc3MgV2ViUlRDQ2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnRXN0YWJsaXNoaW5nIFdlYlJUQyBjb25uZWN0aW9uJztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBsZXQgaGFzVGNwID0gZmFsc2U7XG4gICAgICBsZXQgaGFzSXB2NFVkcCA9IGZhbHNlO1xuICAgICAgdGhpcy5yb29tLm9uKFJvb21FdmVudC5TaWduYWxDb25uZWN0ZWQsICgpID0+IHtcbiAgICAgICAgY29uc3QgcHJldlRyaWNrbGUgPSB0aGlzLnJvb20uZW5naW5lLmNsaWVudC5vblRyaWNrbGU7XG4gICAgICAgIHRoaXMucm9vbS5lbmdpbmUuY2xpZW50Lm9uVHJpY2tsZSA9IChzZCwgdGFyZ2V0KSA9PiB7XG4gICAgICAgICAgaWYgKHNkLmNhbmRpZGF0ZSkge1xuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShzZCk7XG4gICAgICAgICAgICBsZXQgc3RyID0gXCJcIi5jb25jYXQoY2FuZGlkYXRlLnByb3RvY29sLCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS5hZGRyZXNzLCBcIjpcIikuY29uY2F0KGNhbmRpZGF0ZS5wb3J0LCBcIiBcIikuY29uY2F0KGNhbmRpZGF0ZS50eXBlKTtcbiAgICAgICAgICAgIGlmIChjYW5kaWRhdGUuYWRkcmVzcykge1xuICAgICAgICAgICAgICBpZiAoaXNJUFByaXZhdGUoY2FuZGlkYXRlLmFkZHJlc3MpKSB7XG4gICAgICAgICAgICAgICAgc3RyICs9ICcgKHByaXZhdGUpJztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoY2FuZGlkYXRlLnByb3RvY29sID09PSAndGNwJyAmJiBjYW5kaWRhdGUudGNwVHlwZSA9PT0gJ3Bhc3NpdmUnKSB7XG4gICAgICAgICAgICAgICAgICBoYXNUY3AgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgc3RyICs9ICcgKHBhc3NpdmUpJztcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNhbmRpZGF0ZS5wcm90b2NvbCA9PT0gJ3VkcCcpIHtcbiAgICAgICAgICAgICAgICAgIGhhc0lwdjRVZHAgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hcHBlbmRNZXNzYWdlKHN0cik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwcmV2VHJpY2tsZSkge1xuICAgICAgICAgICAgcHJldlRyaWNrbGUoc2QsIHRhcmdldCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5yb29tLmVuZ2luZS5wY01hbmFnZXIpIHtcbiAgICAgICAgICB0aGlzLnJvb20uZW5naW5lLnBjTWFuYWdlci5zdWJzY3JpYmVyLm9uSWNlQ2FuZGlkYXRlRXJyb3IgPSBldiA9PiB7XG4gICAgICAgICAgICBpZiAoZXYgaW5zdGFuY2VvZiBSVENQZWVyQ29ubmVjdGlvbkljZUVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgICAgdGhpcy5hcHBlbmRXYXJuaW5nKFwiZXJyb3Igd2l0aCBJQ0UgY2FuZGlkYXRlOiBcIi5jb25jYXQoZXYuZXJyb3JDb2RlLCBcIiBcIikuY29uY2F0KGV2LmVycm9yVGV4dCwgXCIgXCIpLmNvbmNhdChldi51cmwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHlpZWxkIHRoaXMuY29ubmVjdCgpO1xuICAgICAgICBsaXZla2l0TG9nZ2VyLmluZm8oJ25vdyB0aGUgcm9vbSBpcyBjb25uZWN0ZWQnKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ3BvcnRzIG5lZWQgdG8gYmUgb3BlbiBvbiBmaXJld2FsbCBpbiBvcmRlciB0byBjb25uZWN0LicpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgICBpZiAoIWhhc1RjcCkge1xuICAgICAgICB0aGlzLmFwcGVuZFdhcm5pbmcoJ1NlcnZlciBpcyBub3QgY29uZmlndXJlZCBmb3IgSUNFL1RDUCcpO1xuICAgICAgfVxuICAgICAgaWYgKCFoYXNJcHY0VWRwKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnTm8gcHVibGljIElQdjQgVURQIGNhbmRpZGF0ZXMgd2VyZSBmb3VuZC4gWW91ciBzZXJ2ZXIgaXMgbGlrZWx5IG5vdCBjb25maWd1cmVkIGNvcnJlY3RseScpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBpc0lQUHJpdmF0ZShhZGRyZXNzKSB7XG4gIGNvbnN0IHBhcnRzID0gYWRkcmVzcy5zcGxpdCgnLicpO1xuICBpZiAocGFydHMubGVuZ3RoID09PSA0KSB7XG4gICAgaWYgKHBhcnRzWzBdID09PSAnMTAnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcnRzWzBdID09PSAnMTkyJyAmJiBwYXJ0c1sxXSA9PT0gJzE2OCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFydHNbMF0gPT09ICcxNzInKSB7XG4gICAgICBjb25zdCBzZWNvbmQgPSBwYXJzZUludChwYXJ0c1sxXSwgMTApO1xuICAgICAgaWYgKHNlY29uZCA+PSAxNiAmJiBzZWNvbmQgPD0gMzEpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuY2xhc3MgV2ViU29ja2V0Q2hlY2sgZXh0ZW5kcyBDaGVja2VyIHtcbiAgZ2V0IGRlc2NyaXB0aW9uKCkge1xuICAgIHJldHVybiAnQ29ubmVjdGluZyB0byBzaWduYWwgY29ubmVjdGlvbiB2aWEgV2ViU29ja2V0JztcbiAgfVxuICBwZXJmb3JtKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgIGlmICh0aGlzLnVybC5zdGFydHNXaXRoKCd3czonKSB8fCB0aGlzLnVybC5zdGFydHNXaXRoKCdodHRwOicpKSB7XG4gICAgICAgIHRoaXMuYXBwZW5kV2FybmluZygnU2VydmVyIGlzIGluc2VjdXJlLCBjbGllbnRzIG1heSBibG9jayBjb25uZWN0aW9ucyB0byBpdCcpO1xuICAgICAgfVxuICAgICAgbGV0IHNpZ25hbENsaWVudCA9IG5ldyBTaWduYWxDbGllbnQoKTtcbiAgICAgIGNvbnN0IGpvaW5SZXMgPSB5aWVsZCBzaWduYWxDbGllbnQuam9pbih0aGlzLnVybCwgdGhpcy50b2tlbiwge1xuICAgICAgICBhdXRvU3Vic2NyaWJlOiB0cnVlLFxuICAgICAgICBtYXhSZXRyaWVzOiAwLFxuICAgICAgICBlMmVlRW5hYmxlZDogZmFsc2UsXG4gICAgICAgIHdlYnNvY2tldFRpbWVvdXQ6IDE1MDAwXG4gICAgICB9KTtcbiAgICAgIHRoaXMuYXBwZW5kTWVzc2FnZShcIkNvbm5lY3RlZCB0byBzZXJ2ZXIsIHZlcnNpb24gXCIuY29uY2F0KGpvaW5SZXMuc2VydmVyVmVyc2lvbiwgXCIuXCIpKTtcbiAgICAgIGlmICgoKF9hID0gam9pblJlcy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZWRpdGlvbikgPT09IFNlcnZlckluZm9fRWRpdGlvbi5DbG91ZCAmJiAoKF9iID0gam9pblJlcy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IucmVnaW9uKSkge1xuICAgICAgICB0aGlzLmFwcGVuZE1lc3NhZ2UoXCJMaXZlS2l0IENsb3VkOiBcIi5jb25jYXQoKF9jID0gam9pblJlcy5zZXJ2ZXJJbmZvKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVnaW9uKSk7XG4gICAgICB9XG4gICAgICB5aWVsZCBzaWduYWxDbGllbnQuY2xvc2UoKTtcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBDb25uZWN0aW9uQ2hlY2sgZXh0ZW5kcyBldmVudHNFeHBvcnRzLkV2ZW50RW1pdHRlciB7XG4gIGNvbnN0cnVjdG9yKHVybCwgdG9rZW4pIHtcbiAgICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICB0aGlzLmNoZWNrUmVzdWx0cyA9IG5ldyBNYXAoKTtcbiAgICB0aGlzLnVybCA9IHVybDtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuICBnZXROZXh0Q2hlY2tJZCgpIHtcbiAgICBjb25zdCBuZXh0SWQgPSB0aGlzLmNoZWNrUmVzdWx0cy5zaXplO1xuICAgIHRoaXMuY2hlY2tSZXN1bHRzLnNldChuZXh0SWQsIHtcbiAgICAgIGxvZ3M6IFtdLFxuICAgICAgc3RhdHVzOiBDaGVja1N0YXR1cy5JRExFLFxuICAgICAgbmFtZTogJycsXG4gICAgICBkZXNjcmlwdGlvbjogJydcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dElkO1xuICB9XG4gIHVwZGF0ZUNoZWNrKGNoZWNrSWQsIGluZm8pIHtcbiAgICB0aGlzLmNoZWNrUmVzdWx0cy5zZXQoY2hlY2tJZCwgaW5mbyk7XG4gICAgdGhpcy5lbWl0KCdjaGVja1VwZGF0ZScsIGNoZWNrSWQsIGluZm8pO1xuICB9XG4gIGlzU3VjY2VzcygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmNoZWNrUmVzdWx0cy52YWx1ZXMoKSkuZXZlcnkociA9PiByLnN0YXR1cyAhPT0gQ2hlY2tTdGF0dXMuRkFJTEVEKTtcbiAgfVxuICBnZXRSZXN1bHRzKCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHRoaXMuY2hlY2tSZXN1bHRzLnZhbHVlcygpKTtcbiAgfVxuICBjcmVhdGVBbmRSdW5DaGVjayhjaGVjaykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICBjb25zdCBjaGVja0lkID0gdGhpcy5nZXROZXh0Q2hlY2tJZCgpO1xuICAgICAgY29uc3QgdGVzdCA9IG5ldyBjaGVjayh0aGlzLnVybCwgdGhpcy50b2tlbiwgdGhpcy5vcHRpb25zKTtcbiAgICAgIGNvbnN0IGhhbmRsZVVwZGF0ZSA9IGluZm8gPT4ge1xuICAgICAgICB0aGlzLnVwZGF0ZUNoZWNrKGNoZWNrSWQsIGluZm8pO1xuICAgICAgfTtcbiAgICAgIHRlc3Qub24oJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0ZXN0LnJ1bigpO1xuICAgICAgdGVzdC5vZmYoJ3VwZGF0ZScsIGhhbmRsZVVwZGF0ZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIGNoZWNrV2Vic29ja2V0KCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhXZWJTb2NrZXRDaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tXZWJSVEMoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFdlYlJUQ0NoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1RVUk4oKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFRVUk5DaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tSZWNvbm5lY3QoKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKFJlY29ubmVjdENoZWNrKTtcbiAgICB9KTtcbiAgfVxuICBjaGVja1B1Ymxpc2hBdWRpbygpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soUHVibGlzaEF1ZGlvQ2hlY2spO1xuICAgIH0pO1xuICB9XG4gIGNoZWNrUHVibGlzaFZpZGVvKCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jcmVhdGVBbmRSdW5DaGVjayhQdWJsaXNoVmlkZW9DaGVjayk7XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tDb25uZWN0aW9uUHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgIGNvbnN0IGluZm8gPSB5aWVsZCB0aGlzLmNyZWF0ZUFuZFJ1bkNoZWNrKENvbm5lY3Rpb25Qcm90b2NvbENoZWNrKTtcbiAgICAgIGlmIChpbmZvLmRhdGEgJiYgJ3Byb3RvY29sJyBpbiBpbmZvLmRhdGEpIHtcbiAgICAgICAgY29uc3Qgc3RhdHMgPSBpbmZvLmRhdGE7XG4gICAgICAgIHRoaXMub3B0aW9ucy5wcm90b2NvbCA9IHN0YXRzLnByb3RvY29sO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZm87XG4gICAgfSk7XG4gIH1cbiAgY2hlY2tDbG91ZFJlZ2lvbigpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQW5kUnVuQ2hlY2soQ2xvdWRSZWdpb25DaGVjayk7XG4gICAgfSk7XG4gIH1cbn1cblxuLyoqXG4gKiBUcnkgdG8gYW5hbHl6ZSB0aGUgbG9jYWwgdHJhY2sgdG8gZGV0ZXJtaW5lIHRoZSBmYWNpbmcgbW9kZSBvZiBhIHRyYWNrLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGVyZSBpcyBubyBwcm9wZXJ0eSBzdXBwb3J0ZWQgYnkgYWxsIGJyb3dzZXJzIHRvIGRldGVjdCB3aGV0aGVyIGEgdmlkZW8gdHJhY2sgb3JpZ2luYXRlZCBmcm9tIGEgdXNlci0gb3IgZW52aXJvbm1lbnQtZmFjaW5nIGNhbWVyYSBkZXZpY2UuXG4gKiBGb3IgdGhpcyByZWFzb24sIHdlIHVzZSB0aGUgYGZhY2luZ01vZGVgIHByb3BlcnR5IHdoZW4gYXZhaWxhYmxlLCBidXQgd2lsbCBmYWxsIGJhY2sgb24gYSBzdHJpbmctYmFzZWQgYW5hbHlzaXMgb2YgdGhlIGRldmljZSBsYWJlbCB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlLlxuICogSWYgYm90aCBtZXRob2RzIGZhaWwsIHRoZSBkZWZhdWx0IGZhY2luZyBtb2RlIHdpbGwgYmUgdXNlZC5cbiAqXG4gKiBAc2VlIHtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvTWVkaWFUcmFja0NvbnN0cmFpbnRzL2ZhY2luZ01vZGUgfCBNRE4gZG9jcyBvbiBmYWNpbmdNb2RlfVxuICogQGV4cGVyaW1lbnRhbFxuICovXG5mdW5jdGlvbiBmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2sobG9jYWxUcmFjaykge1xuICBsZXQgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gIHZhciBfYTtcbiAgY29uc3QgdHJhY2sgPSBpc0xvY2FsVHJhY2sobG9jYWxUcmFjaykgPyBsb2NhbFRyYWNrLm1lZGlhU3RyZWFtVHJhY2sgOiBsb2NhbFRyYWNrO1xuICBjb25zdCB0cmFja1NldHRpbmdzID0gdHJhY2suZ2V0U2V0dGluZ3MoKTtcbiAgbGV0IHJlc3VsdCA9IHtcbiAgICBmYWNpbmdNb2RlOiAoX2EgPSBvcHRpb25zLmRlZmF1bHRGYWNpbmdNb2RlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAndXNlcicsXG4gICAgY29uZmlkZW5jZTogJ2xvdydcbiAgfTtcbiAgLy8gMS4gVHJ5IHRvIGdldCBmYWNpbmdNb2RlIGZyb20gdHJhY2sgc2V0dGluZ3MuXG4gIGlmICgnZmFjaW5nTW9kZScgaW4gdHJhY2tTZXR0aW5ncykge1xuICAgIGNvbnN0IHJhd0ZhY2luZ01vZGUgPSB0cmFja1NldHRpbmdzLmZhY2luZ01vZGU7XG4gICAgbGl2ZWtpdExvZ2dlci50cmFjZSgncmF3RmFjaW5nTW9kZScsIHtcbiAgICAgIHJhd0ZhY2luZ01vZGVcbiAgICB9KTtcbiAgICBpZiAocmF3RmFjaW5nTW9kZSAmJiB0eXBlb2YgcmF3RmFjaW5nTW9kZSA9PT0gJ3N0cmluZycgJiYgaXNGYWNpbmdNb2RlVmFsdWUocmF3RmFjaW5nTW9kZSkpIHtcbiAgICAgIHJlc3VsdCA9IHtcbiAgICAgICAgZmFjaW5nTW9kZTogcmF3RmFjaW5nTW9kZSxcbiAgICAgICAgY29uZmlkZW5jZTogJ2hpZ2gnXG4gICAgICB9O1xuICAgIH1cbiAgfVxuICAvLyAyLiBJZiB3ZSBkb24ndCBoYXZlIGEgaGlnaCBjb25maWRlbmNlIHdlIHRyeSB0byBnZXQgdGhlIGZhY2luZyBtb2RlIGZyb20gdGhlIGRldmljZSBsYWJlbC5cbiAgaWYgKFsnbG93JywgJ21lZGl1bSddLmluY2x1ZGVzKHJlc3VsdC5jb25maWRlbmNlKSkge1xuICAgIGxpdmVraXRMb2dnZXIudHJhY2UoXCJUcnkgdG8gZ2V0IGZhY2luZyBtb2RlIGZyb20gZGV2aWNlIGxhYmVsOiAoXCIuY29uY2F0KHRyYWNrLmxhYmVsLCBcIilcIikpO1xuICAgIGNvbnN0IGxhYmVsQW5hbHlzaXNSZXN1bHQgPSBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsKHRyYWNrLmxhYmVsKTtcbiAgICBpZiAobGFiZWxBbmFseXNpc1Jlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXN1bHQgPSBsYWJlbEFuYWx5c2lzUmVzdWx0O1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3Qga25vd25EZXZpY2VMYWJlbHMgPSBuZXcgTWFwKFtbJ29icyB2aXJ0dWFsIGNhbWVyYScsIHtcbiAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcbn1dXSk7XG5jb25zdCBrbm93bkRldmljZUxhYmVsU2VjdGlvbnMgPSBuZXcgTWFwKFtbJ2lwaG9uZScsIHtcbiAgZmFjaW5nTW9kZTogJ2Vudmlyb25tZW50JyxcbiAgY29uZmlkZW5jZTogJ21lZGl1bSdcbn1dLCBbJ2lwYWQnLCB7XG4gIGZhY2luZ01vZGU6ICdlbnZpcm9ubWVudCcsXG4gIGNvbmZpZGVuY2U6ICdtZWRpdW0nXG59XV0pO1xuLyoqXG4gKiBBdHRlbXB0IHRvIGFuYWx5emUgdGhlIGRldmljZSBsYWJlbCB0byBkZXRlcm1pbmUgdGhlIGZhY2luZyBtb2RlLlxuICpcbiAqIEBleHBlcmltZW50YWxcbiAqL1xuZnVuY3Rpb24gZmFjaW5nTW9kZUZyb21EZXZpY2VMYWJlbChkZXZpY2VMYWJlbCkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGxhYmVsID0gZGV2aWNlTGFiZWwudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG4gIC8vIEVtcHR5IHN0cmluZyBpcyBhIHZhbGlkIGRldmljZSBsYWJlbCBidXQgd2UgY2FuJ3QgaW5mZXIgYW55dGhpbmcgZnJvbSBpdC5cbiAgaWYgKGxhYmVsID09PSAnJykge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgLy8gQ2FuIHdlIG1hdGNoIGFnYWluc3Qgd2lkZWx5IGtub3duIGRldmljZSBsYWJlbHMuXG4gIGlmIChrbm93bkRldmljZUxhYmVscy5oYXMobGFiZWwpKSB7XG4gICAgcmV0dXJuIGtub3duRGV2aWNlTGFiZWxzLmdldChsYWJlbCk7XG4gIH1cbiAgLy8gQ2FuIHdlIG1hdGNoIGFnYWluc3Qgc2VjdGlvbnMgb2YgdGhlIGRldmljZSBsYWJlbC5cbiAgcmV0dXJuIChfYSA9IEFycmF5LmZyb20oa25vd25EZXZpY2VMYWJlbFNlY3Rpb25zLmVudHJpZXMoKSkuZmluZChfcmVmID0+IHtcbiAgICBsZXQgW3NlY3Rpb25dID0gX3JlZjtcbiAgICByZXR1cm4gbGFiZWwuaW5jbHVkZXMoc2VjdGlvbik7XG4gIH0pKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMV07XG59XG5mdW5jdGlvbiBpc0ZhY2luZ01vZGVWYWx1ZShpdGVtKSB7XG4gIGNvbnN0IGFsbG93ZWRWYWx1ZXMgPSBbJ3VzZXInLCAnZW52aXJvbm1lbnQnLCAnbGVmdCcsICdyaWdodCddO1xuICByZXR1cm4gaXRlbSA9PT0gdW5kZWZpbmVkIHx8IGFsbG93ZWRWYWx1ZXMuaW5jbHVkZXMoaXRlbSk7XG59XG5cbmV4cG9ydCB7IEF1ZGlvUHJlc2V0cywgQmFja3VwQ29kZWNQb2xpY3ksIEJhc2VLZXlQcm92aWRlciwgQ2hlY2tTdGF0dXMsIENoZWNrZXIsIENvbm5lY3Rpb25DaGVjaywgQ29ubmVjdGlvbkVycm9yLCBDb25uZWN0aW9uRXJyb3JSZWFzb24sIENvbm5lY3Rpb25RdWFsaXR5LCBDb25uZWN0aW9uU3RhdGUsIENyaXRpY2FsVGltZXJzLCBDcnlwdG9yRXJyb3IsIENyeXB0b3JFcnJvclJlYXNvbiwgQ3J5cHRvckV2ZW50LCBEYXRhUGFja2V0X0tpbmQsIERlZmF1bHRSZWNvbm5lY3RQb2xpY3ksIERldmljZVVuc3VwcG9ydGVkRXJyb3IsIERpc2Nvbm5lY3RSZWFzb24sIEVuY3J5cHRpb25FdmVudCwgRW5naW5lRXZlbnQsIEV4dGVybmFsRTJFRUtleVByb3ZpZGVyLCBLZXlIYW5kbGVyRXZlbnQsIEtleVByb3ZpZGVyRXZlbnQsIExpdmVraXRFcnJvciwgTG9jYWxBdWRpb1RyYWNrLCBMb2NhbFBhcnRpY2lwYW50LCBMb2NhbFRyYWNrLCBMb2NhbFRyYWNrUHVibGljYXRpb24sIExvY2FsVmlkZW9UcmFjaywgTG9nTGV2ZWwsIExvZ2dlck5hbWVzLCBNZWRpYURldmljZUZhaWx1cmUsIF8gYXMgTXV0ZXgsIE5lZ290aWF0aW9uRXJyb3IsIFBhcnRpY2lwYW50LCBQYXJ0aWNpcGFudEV2ZW50LCBQYXJ0aWNpcGFudEluZm9fS2luZCBhcyBQYXJ0aWNpcGFudEtpbmQsIFB1Ymxpc2hEYXRhRXJyb3IsIFB1Ymxpc2hUcmFja0Vycm9yLCBSZW1vdGVBdWRpb1RyYWNrLCBSZW1vdGVQYXJ0aWNpcGFudCwgUmVtb3RlVHJhY2ssIFJlbW90ZVRyYWNrUHVibGljYXRpb24sIFJlbW90ZVZpZGVvVHJhY2ssIFJvb20sIFJvb21FdmVudCwgUnBjRXJyb3IsIFNjcmVlblNoYXJlUHJlc2V0cywgU2lnbmFsUmVxdWVzdEVycm9yLCBTdWJzY3JpcHRpb25FcnJvciwgVHJhY2ssIFRyYWNrRXZlbnQsIFRyYWNrSW52YWxpZEVycm9yLCBUcmFja1B1YmxpY2F0aW9uLCBUcmFja1R5cGUsIFVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUsIFVuc3VwcG9ydGVkU2VydmVyLCBWaWRlb1ByZXNldCwgVmlkZW9QcmVzZXRzLCBWaWRlb1ByZXNldHM0MywgVmlkZW9RdWFsaXR5LCBhdHRhY2hUb0VsZW1lbnQsIGNvbXBhcmVWZXJzaW9ucywgY3JlYXRlQXVkaW9BbmFseXNlciwgY3JlYXRlRTJFRUtleSwgY3JlYXRlS2V5TWF0ZXJpYWxGcm9tQnVmZmVyLCBjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmcsIGNyZWF0ZUxvY2FsQXVkaW9UcmFjaywgY3JlYXRlTG9jYWxTY3JlZW5UcmFja3MsIGNyZWF0ZUxvY2FsVHJhY2tzLCBjcmVhdGVMb2NhbFZpZGVvVHJhY2ssIGRlcml2ZUtleXMsIGRldGFjaFRyYWNrLCBmYWNpbmdNb2RlRnJvbURldmljZUxhYmVsLCBmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2ssIGdldEJyb3dzZXIsIGdldEVtcHR5QXVkaW9TdHJlYW1UcmFjaywgZ2V0RW1wdHlWaWRlb1N0cmVhbVRyYWNrLCBnZXRMb2dnZXIsIGltcG9ydEtleSwgaXNBdWRpb1RyYWNrLCBpc0JhY2t1cENvZGVjLCBpc0Jyb3dzZXJTdXBwb3J0ZWQsIGlzRTJFRVN1cHBvcnRlZCwgaXNJbnNlcnRhYmxlU3RyZWFtU3VwcG9ydGVkLCBpc0xvY2FsUGFydGljaXBhbnQsIGlzTG9jYWxUcmFjaywgaXNSZW1vdGVQYXJ0aWNpcGFudCwgaXNSZW1vdGVUcmFjaywgaXNTY3JpcHRUcmFuc2Zvcm1TdXBwb3J0ZWQsIGlzVmlkZW9GcmFtZSwgaXNWaWRlb1RyYWNrLCBuZWVkc1Jic3BVbmVzY2FwaW5nLCBwYXJzZVJic3AsIHByb3RvY29sVmVyc2lvbiwgcmF0Y2hldCwgc2V0TG9nRXh0ZW5zaW9uLCBzZXRMb2dMZXZlbCwgc3VwcG9ydHNBVjEsIHN1cHBvcnRzQWRhcHRpdmVTdHJlYW0sIHN1cHBvcnRzRHluYWNhc3QsIHN1cHBvcnRzVlA5LCB2ZXJzaW9uLCB2aWRlb0NvZGVjcywgd3JpdGVSYnNwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1saXZla2l0LWNsaWVudC5lc20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbIl9tZXJnZU5hbWVzcGFjZXMiLCJuIiwibSIsImZvckVhY2giLCJlIiwiQXJyYXkiLCJpc0FycmF5IiwiT2JqZWN0Iiwia2V5cyIsImsiLCJkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJnZXQiLCJlbnVtZXJhYmxlIiwiZnJlZXplIiwiaCIsImkiLCJzIiwidCIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwidmFsdWUiLCJvIiwiXyIsImNvbnN0cnVjdG9yIiwiX2xvY2tpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsIl9sb2NrcyIsImlzTG9ja2VkIiwibG9jayIsImwiLCJjIiwidGhlbiIsImFzc2VydCIsImNvbmRpdGlvbiIsIm1zZyIsIkVycm9yIiwiRkxPQVQzMl9NQVgiLCJGTE9BVDMyX01JTiIsIlVJTlQzMl9NQVgiLCJJTlQzMl9NQVgiLCJJTlQzMl9NSU4iLCJhc3NlcnRJbnQzMiIsImFyZyIsIk51bWJlciIsImlzSW50ZWdlciIsImFzc2VydFVJbnQzMiIsImFzc2VydEZsb2F0MzIiLCJpc0Zpbml0ZSIsImVudW1UeXBlU3ltYm9sIiwiU3ltYm9sIiwiZ2V0RW51bVR5cGUiLCJlbnVtT2JqZWN0Iiwic2V0RW51bVR5cGUiLCJ0eXBlTmFtZSIsInZhbHVlcyIsIm9wdCIsIm1ha2VFbnVtVHlwZSIsIm1hcCIsInYiLCJubyIsIm5hbWUiLCJsb2NhbE5hbWUiLCJfb3B0IiwibmFtZXMiLCJjcmVhdGUiLCJudW1iZXJzIiwibm9ybWFsVmFsdWVzIiwibm9ybWFsaXplRW51bVZhbHVlIiwicHVzaCIsImZpbmROYW1lIiwiZmluZE51bWJlciIsIm1ha2VFbnVtIiwiYXNzaWduIiwiTWVzc2FnZSIsImVxdWFscyIsIm90aGVyIiwiZ2V0VHlwZSIsInJ1bnRpbWUiLCJ1dGlsIiwiY2xvbmUiLCJmcm9tQmluYXJ5IiwiYnl0ZXMiLCJvcHRpb25zIiwidHlwZSIsImZvcm1hdCIsImJpbiIsIm1ha2VSZWFkT3B0aW9ucyIsInJlYWRNZXNzYWdlIiwicmVhZGVyRmFjdG9yeSIsImJ5dGVMZW5ndGgiLCJmcm9tSnNvbiIsImpzb25WYWx1ZSIsImpzb24iLCJmcm9tSnNvblN0cmluZyIsImpzb25TdHJpbmciLCJKU09OIiwicGFyc2UiLCJjb25jYXQiLCJtZXNzYWdlIiwiU3RyaW5nIiwidG9CaW5hcnkiLCJtYWtlV3JpdGVPcHRpb25zIiwid3JpdGVyIiwid3JpdGVyRmFjdG9yeSIsIndyaXRlTWVzc2FnZSIsImZpbmlzaCIsInRvSnNvbiIsInRvSnNvblN0cmluZyIsIl9hIiwic3RyaW5naWZ5IiwicHJldHR5U3BhY2VzIiwidG9KU09OIiwiZW1pdERlZmF1bHRWYWx1ZXMiLCJnZXRQcm90b3R5cGVPZiIsIm1ha2VNZXNzYWdlVHlwZSIsImZpZWxkcyIsInN1YnN0cmluZyIsImxhc3RJbmRleE9mIiwiZGF0YSIsImluaXRGaWVsZHMiLCJpbml0UGFydGlhbCIsInNldFByb3RvdHlwZU9mIiwicHJvdG90eXBlIiwibmV3RmllbGRMaXN0IiwiYSIsImIiLCJ2YXJpbnQ2NHJlYWQiLCJsb3dCaXRzIiwiaGlnaEJpdHMiLCJzaGlmdCIsImJ1ZiIsInBvcyIsImFzc2VydEJvdW5kcyIsIm1pZGRsZUJ5dGUiLCJ2YXJpbnQ2NHdyaXRlIiwibG8iLCJoaSIsImhhc05leHQiLCJieXRlIiwic3BsaXRCaXRzIiwiaGFzTW9yZUJpdHMiLCJUV09fUFdSXzMyX0RCTCIsImludDY0RnJvbVN0cmluZyIsImRlYyIsIm1pbnVzIiwic2xpY2UiLCJiYXNlIiwiYWRkMWU2ZGlnaXQiLCJiZWdpbiIsImVuZCIsImRpZ2l0MWU2IiwibmVnYXRlIiwibmV3Qml0cyIsImludDY0VG9TdHJpbmciLCJiaXRzIiwibmVnYXRpdmUiLCJyZXN1bHQiLCJ1SW50NjRUb1N0cmluZyIsInRvVW5zaWduZWQiLCJsb3ciLCJtaWQiLCJoaWdoIiwiZGlnaXRBIiwiZGlnaXRCIiwiZGlnaXRDIiwiTWF0aCIsImZsb29yIiwidG9TdHJpbmciLCJkZWNpbWFsRnJvbTFlN1dpdGhMZWFkaW5nWmVyb3MiLCJkaWdpdDFlNyIsInBhcnRpYWwiLCJsZW5ndGgiLCJ2YXJpbnQzMndyaXRlIiwidmFyaW50MzJyZWFkIiwicmVhZEJ5dGVzIiwibWFrZUludDY0U3VwcG9ydCIsImR2IiwiRGF0YVZpZXciLCJBcnJheUJ1ZmZlciIsIm9rIiwiQmlnSW50IiwiZ2V0QmlnSW50NjQiLCJnZXRCaWdVaW50NjQiLCJzZXRCaWdJbnQ2NCIsInNldEJpZ1VpbnQ2NCIsInByb2Nlc3MiLCJlbnYiLCJCVUZfQklHSU5UX0RJU0FCTEUiLCJNSU4iLCJNQVgiLCJVTUlOIiwiVU1BWCIsInplcm8iLCJzdXBwb3J0ZWQiLCJiaSIsInVQYXJzZSIsImVuYyIsImdldEludDMyIiwidUVuYyIsInNldEludDMyIiwidURlYyIsImFzc2VydEludDY0U3RyaW5nIiwidGVzdCIsImFzc2VydFVJbnQ2NFN0cmluZyIsInByb3RvSW50NjQiLCJTY2FsYXJUeXBlIiwiTG9uZ1R5cGUiLCJzY2FsYXJFcXVhbHMiLCJCWVRFUyIsIlVpbnQ4QXJyYXkiLCJVSU5UNjQiLCJGSVhFRDY0IiwiSU5UNjQiLCJTRklYRUQ2NCIsIlNJTlQ2NCIsInNjYWxhclplcm9WYWx1ZSIsImxvbmdUeXBlIiwiQk9PTCIsIkRPVUJMRSIsIkZMT0FUIiwiU1RSSU5HIiwiaXNTY2FsYXJaZXJvVmFsdWUiLCJXaXJlVHlwZSIsIkJpbmFyeVdyaXRlciIsInRleHRFbmNvZGVyIiwic3RhY2siLCJUZXh0RW5jb2RlciIsImNodW5rcyIsImxlbiIsIm9mZnNldCIsInNldCIsImZvcmsiLCJqb2luIiwiY2h1bmsiLCJwcmV2IiwicG9wIiwidWludDMyIiwicmF3IiwidGFnIiwiZmllbGRObyIsImludDMyIiwiYm9vbCIsInN0cmluZyIsImVuY29kZSIsImZsb2F0IiwiYnVmZmVyIiwic2V0RmxvYXQzMiIsImRvdWJsZSIsInNldEZsb2F0NjQiLCJmaXhlZDMyIiwic2V0VWludDMyIiwic2ZpeGVkMzIiLCJzaW50MzIiLCJzZml4ZWQ2NCIsInZpZXciLCJ0YyIsImZpeGVkNjQiLCJpbnQ2NCIsInNpbnQ2NCIsInNpZ24iLCJ1aW50NjQiLCJCaW5hcnlSZWFkZXIiLCJ0ZXh0RGVjb2RlciIsInZhcmludDY0IiwiYnl0ZU9mZnNldCIsIlRleHREZWNvZGVyIiwid2lyZVR5cGUiLCJza2lwIiwic3RhcnQiLCJWYXJpbnQiLCJCaXQ2NCIsIkJpdDMyIiwiTGVuZ3RoRGVsaW1pdGVkIiwiU3RhcnRHcm91cCIsImZuIiwid3QiLCJFbmRHcm91cCIsInVuZGVmaW5lZCIsInN1YmFycmF5IiwiUmFuZ2VFcnJvciIsInp6ZSIsImdldFVpbnQzMiIsImdldEZsb2F0MzIiLCJnZXRGbG9hdDY0IiwiZGVjb2RlIiwibWFrZUV4dGVuc2lvbiIsImV4dGVuZGVlIiwiZmllbGQiLCJmaSIsInNwbGl0IiwianNvbk5hbWUiLCJsaXN0IiwiY3JlYXRlRXh0ZW5zaW9uQ29udGFpbmVyIiwiZXh0ZW5zaW9uIiwiY29udGFpbmVyIiwiaW5pdEV4dGVuc2lvbkZpZWxkIiwiZXh0IiwicmVwZWF0ZWQiLCJkZWZhdWx0Iiwia2luZCIsIlQiLCJMIiwiZmllbGRXcmFwcGVyIiwidW53cmFwRmllbGQiLCJmaWx0ZXJVbmtub3duRmllbGRzIiwidW5rbm93bkZpZWxkcyIsImZpbHRlciIsInVmIiwiZW5jVGFibGUiLCJkZWNUYWJsZSIsImNoYXJDb2RlQXQiLCJpbmRleE9mIiwicHJvdG9CYXNlNjQiLCJiYXNlNjRTdHIiLCJlcyIsImJ5dGVQb3MiLCJncm91cFBvcyIsInAiLCJiYXNlNjQiLCJnZXRFeHRlbnNpb24iLCJhc3NlcnRFeHRlbmRlZSIsInVmcyIsImxpc3RVbmtub3duRmllbGRzIiwicmVhZEZpZWxkIiwic2V0RXh0ZW5zaW9uIiwicmVhZE9wdCIsIndyaXRlT3B0IiwiaGFzRXh0ZW5zaW9uIiwiZGlzY2FyZFVua25vd25GaWVsZHMiLCJvblVua25vd25GaWVsZCIsImYiLCJ3cml0ZUZpZWxkIiwicmVhZGVyIiwibWVzc2FnZVR5cGUiLCJmaW5kIiwiaXNGaWVsZFNldCIsInRhcmdldCIsIm9uZW9mIiwiY2FzZSIsInJlcSIsImNsZWFyRmllbGQiLCJpbXBsaWNpdFByZXNlbmNlIiwiaXNNZXNzYWdlIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImV2ZXJ5IiwiYWN0dWFsVHlwZSIsIndyYXBGaWVsZCIsIklOVDMyIiwiVUlOVDMyIiwianNvblJlYWREZWZhdWx0cyIsImlnbm9yZVVua25vd25GaWVsZHMiLCJqc29uV3JpdGVEZWZhdWx0cyIsImVudW1Bc0ludGVnZXIiLCJ1c2VQcm90b0ZpZWxkTmFtZSIsIm1ha2VSZWFkT3B0aW9ucyQxIiwibWFrZVdyaXRlT3B0aW9ucyQxIiwidG9rZW5OdWxsIiwidG9rZW5JZ25vcmVkVW5rbm93bkVudW0iLCJtYWtlSnNvbkZvcm1hdCIsImRlYnVnSnNvblZhbHVlIiwib25lb2ZTZWVuIiwiTWFwIiwicmVnaXN0cnkiLCJ0eXBlUmVnaXN0cnkiLCJqc29uS2V5IiwiZW50cmllcyIsImZpbmRKc29uTmFtZSIsInNlZW4iLCJyZWFkRmllbGQkMSIsImZvdW5kIiwiZmluZEV4dGVuc2lvbiIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsImJ5TnVtYmVyIiwiY2FuRW1pdEZpZWxkRGVmYXVsdFZhbHVlIiwid3JpdGVGaWVsZCQxIiwiZmluZEV4dGVuc2lvbkZvciIsInIiLCJyZWFkU2NhbGFyIiwicmVhZFNjYWxhciQxIiwiQklHSU5UIiwid3JpdGVTY2FsYXIiLCJ3cml0ZVNjYWxhciQxIiwiZGVidWciLCJwYXJlbnRUeXBlIiwidGFyZ2V0QXJyYXkiLCJqc29uSXRlbSIsImVudW1WYWx1ZSIsInJlYWRFbnVtIiwidGFyZ2V0TWFwIiwianNvbk1hcEtleSIsImpzb25NYXBWYWx1ZSIsImtleSIsInJlYWRNYXBLZXkiLCJLIiwiViIsImN1cnJlbnRWYWx1ZSIsInNjYWxhclZhbHVlIiwibnVsbEFzWmVyb1ZhbHVlIiwiTmFOIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJORUdBVElWRV9JTkZJTklUWSIsInRyaW0iLCJpc05hTiIsIkZJWEVEMzIiLCJTRklYRUQzMiIsIlNJTlQzMiIsImxvbmciLCJ1TG9uZyIsImVuY29kZVVSSUNvbXBvbmVudCIsImpzb25PYmoiLCJlbnRyeUtleSIsImVudHJ5VmFsdWUiLCJlbnVtVHlwZSIsIndyaXRlRW51bSIsImpzb25BcnIiLCJ2YWwiLCJ1bmtub3duRmllbGRzU3ltYm9sIiwicmVhZERlZmF1bHRzIiwicmVhZFVua25vd25GaWVsZHMiLCJ3cml0ZURlZmF1bHRzIiwid3JpdGVVbmtub3duRmllbGRzIiwibWFrZUJpbmFyeUZvcm1hdCIsImxlbmd0aE9yRW5kVGFnRmllbGRObyIsImRlbGltaXRlZE1lc3NhZ2VFbmNvZGluZyIsInNjYWxhclR5cGUiLCJyZWFkIiwicmVhZFNjYWxhckxUU3RyaW5nIiwiYXJyIiwiaXNQYWNrZWQiLCJyZWFkTWVzc2FnZUZpZWxkIiwibWFwS2V5IiwibWFwVmFsIiwicmVhZE1hcEVudHJ5IiwiZGVsaW1pdGVkIiwicGFja2VkIiwid3JpdGVQYWNrZWQiLCJpdGVtIiwid3JpdGVNZXNzYWdlRmllbGQiLCJ3cml0ZU1hcEVudHJ5Iiwia2V5VmFsdWUiLCJwYXJzZUludCIsIm1ldGhvZCIsInNjYWxhclR5cGVJbmZvIiwidG9Mb3dlckNhc2UiLCJtYWtlVXRpbENvbW1vbiIsInNvdXJjZSIsIm1lbWJlciIsImJ5TWVtYmVyIiwic2siLCJzb3VyY2VGaWVsZCIsImZpbmRGaWVsZCIsInRvVThBcnIiLCJjb3B5IiwibXQiLCJ2YSIsInZiIiwiYW55IiwiY2xvbmVTaW5ndWxhckZpZWxkIiwiaW5wdXQiLCJtYWtlUHJvdG9SdW50aW1lIiwic3ludGF4IiwiSW50ZXJuYWxGaWVsZExpc3QiLCJub3JtYWxpemVyIiwiX2ZpZWxkcyIsIl9ub3JtYWxpemVyIiwianNvbk5hbWVzIiwiYWxsIiwibnVtYmVyc0FzYyIsInNvcnQiLCJtZW1iZXJzIiwibG9jYWxGaWVsZE5hbWUiLCJwcm90b05hbWUiLCJpbk9uZW9mIiwicHJvdG9DYW1lbENhc2UiLCJzYWZlT2JqZWN0UHJvcGVydHkiLCJzYWZlTWVzc2FnZVByb3BlcnR5IiwibG9jYWxPbmVvZk5hbWUiLCJmaWVsZEpzb25OYW1lIiwic25ha2VDYXNlIiwiY2FwTmV4dCIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwicmVzZXJ2ZWRPYmplY3RQcm9wZXJ0aWVzIiwiU2V0IiwicmVzZXJ2ZWRNZXNzYWdlUHJvcGVydGllcyIsImZhbGxiYWNrIiwiaGFzIiwiSW50ZXJuYWxPbmVvZkluZm8iLCJhZGRGaWVsZCIsIl9sb29rdXAiLCJub3JtYWxpemVGaWVsZEluZm9zIiwiZmllbGRJbmZvcyIsInBhY2tlZEJ5RGVmYXVsdCIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJvb25hbWUiLCJwcm90bzMiLCJUaW1lc3RhbXAiLCJzZWNvbmRzIiwibmFub3MiLCJtYXRjaGVzIiwibWF0Y2giLCJtcyIsIkRhdGUiLCJyZXBlYXQiLCJ6IiwibmFub3NTdHIiLCJ0b0lTT1N0cmluZyIsInJlcGxhY2UiLCJ0b0RhdGUiLCJjZWlsIiwibm93IiwiZnJvbURhdGUiLCJkYXRlIiwiZ2V0VGltZSIsIk1ldHJpY3NCYXRjaCIsIlRpbWVTZXJpZXNNZXRyaWMiLCJFdmVudE1ldHJpYyIsIk1ldHJpY1NhbXBsZSIsIkJhY2t1cENvZGVjUG9saWN5JDEiLCJUcmFja1R5cGUiLCJUcmFja1NvdXJjZSIsIlZpZGVvUXVhbGl0eSQxIiwiQ29ubmVjdGlvblF1YWxpdHkkMSIsIkNsaWVudENvbmZpZ1NldHRpbmciLCJEaXNjb25uZWN0UmVhc29uIiwiUmVjb25uZWN0UmVhc29uIiwiU3Vic2NyaXB0aW9uRXJyb3IiLCJBdWRpb1RyYWNrRmVhdHVyZSIsIlJvb20kMSIsIkNvZGVjIiwiVGltZWRWZXJzaW9uIiwiUGFydGljaXBhbnRQZXJtaXNzaW9uIiwiUGFydGljaXBhbnRJbmZvIiwiUGFydGljaXBhbnRJbmZvX1N0YXRlIiwiVHJhY2tJbmZvIiwiUGFydGljaXBhbnRJbmZvX0tpbmQiLCJQYXJ0aWNpcGFudEluZm9fS2luZERldGFpbCIsIkVuY3J5cHRpb25fVHlwZSIsIlNpbXVsY2FzdENvZGVjSW5mbyIsIlZpZGVvTGF5ZXIiLCJEYXRhUGFja2V0IiwiRGF0YVBhY2tldF9LaW5kIiwiVXNlclBhY2tldCIsIkFjdGl2ZVNwZWFrZXJVcGRhdGUiLCJTaXBEVE1GIiwiVHJhbnNjcmlwdGlvbiIsIkNoYXRNZXNzYWdlIiwiUnBjUmVxdWVzdCIsIlJwY0FjayIsIlJwY1Jlc3BvbnNlIiwiRGF0YVN0cmVhbV9IZWFkZXIiLCJEYXRhU3RyZWFtX0NodW5rIiwiRGF0YVN0cmVhbV9UcmFpbGVyIiwiU3BlYWtlckluZm8iLCJUcmFuc2NyaXB0aW9uU2VnbWVudCIsIlJwY0Vycm9yJDEiLCJQYXJ0aWNpcGFudFRyYWNrcyIsIlNlcnZlckluZm8iLCJTZXJ2ZXJJbmZvX0VkaXRpb24iLCJDbGllbnRJbmZvIiwiQ2xpZW50SW5mb19TREsiLCJDbGllbnRDb25maWd1cmF0aW9uIiwiVmlkZW9Db25maWd1cmF0aW9uIiwiRGlzYWJsZWRDb2RlY3MiLCJEYXRhU3RyZWFtX09wZXJhdGlvblR5cGUiLCJEYXRhU3RyZWFtX1RleHRIZWFkZXIiLCJEYXRhU3RyZWFtX0J5dGVIZWFkZXIiLCJTaWduYWxUYXJnZXQiLCJTdHJlYW1TdGF0ZSIsIkNhbmRpZGF0ZVByb3RvY29sIiwiU2lnbmFsUmVxdWVzdCIsIlNlc3Npb25EZXNjcmlwdGlvbiIsIlRyaWNrbGVSZXF1ZXN0IiwiQWRkVHJhY2tSZXF1ZXN0IiwiTXV0ZVRyYWNrUmVxdWVzdCIsIlVwZGF0ZVN1YnNjcmlwdGlvbiIsIlVwZGF0ZVRyYWNrU2V0dGluZ3MiLCJMZWF2ZVJlcXVlc3QiLCJVcGRhdGVWaWRlb0xheWVycyIsIlN1YnNjcmlwdGlvblBlcm1pc3Npb24iLCJTeW5jU3RhdGUiLCJTaW11bGF0ZVNjZW5hcmlvIiwiVXBkYXRlUGFydGljaXBhbnRNZXRhZGF0YSIsIlBpbmciLCJVcGRhdGVMb2NhbEF1ZGlvVHJhY2siLCJVcGRhdGVMb2NhbFZpZGVvVHJhY2siLCJTaWduYWxSZXNwb25zZSIsIkpvaW5SZXNwb25zZSIsIlBhcnRpY2lwYW50VXBkYXRlIiwiVHJhY2tQdWJsaXNoZWRSZXNwb25zZSIsIlNwZWFrZXJzQ2hhbmdlZCIsIlJvb21VcGRhdGUiLCJDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSIsIlN0cmVhbVN0YXRlVXBkYXRlIiwiU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uVXBkYXRlIiwiVHJhY2tVbnB1Ymxpc2hlZFJlc3BvbnNlIiwiUmVjb25uZWN0UmVzcG9uc2UiLCJQb25nIiwiU3Vic2NyaXB0aW9uUmVzcG9uc2UiLCJSZXF1ZXN0UmVzcG9uc2UiLCJUcmFja1N1YnNjcmliZWQiLCJTaW11bGNhc3RDb2RlYyIsIklDRVNlcnZlciIsIkxlYXZlUmVxdWVzdF9BY3Rpb24iLCJSZWdpb25TZXR0aW5ncyIsIkNvbm5lY3Rpb25RdWFsaXR5SW5mbyIsIlN0cmVhbVN0YXRlSW5mbyIsIlN1YnNjcmliZWRRdWFsaXR5IiwiU3Vic2NyaWJlZENvZGVjIiwiVHJhY2tQZXJtaXNzaW9uIiwiRGF0YUNoYW5uZWxJbmZvIiwiUmVnaW9uSW5mbyIsIlJlcXVlc3RSZXNwb25zZV9SZWFzb24iLCJnZXREZWZhdWx0RXhwb3J0RnJvbUNqcyIsIngiLCJfX2VzTW9kdWxlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwibG9nbGV2ZWwkMSIsImV4cG9ydHMiLCJsb2dsZXZlbCIsImhhc1JlcXVpcmVkTG9nbGV2ZWwiLCJyZXF1aXJlTG9nbGV2ZWwiLCJtb2R1bGUiLCJyb290IiwiZGVmaW5pdGlvbiIsImxvZyIsIm5vb3AiLCJ1bmRlZmluZWRUeXBlIiwiaXNJRSIsIndpbmRvdyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImxvZ01ldGhvZHMiLCJfbG9nZ2Vyc0J5TmFtZSIsImRlZmF1bHRMb2dnZXIiLCJiaW5kTWV0aG9kIiwib2JqIiwibWV0aG9kTmFtZSIsImJpbmQiLCJGdW5jdGlvbiIsImFwcGx5IiwiYXJndW1lbnRzIiwidHJhY2VGb3JJRSIsImNvbnNvbGUiLCJ0cmFjZSIsInJlYWxNZXRob2QiLCJyZXBsYWNlTG9nZ2luZ01ldGhvZHMiLCJsZXZlbCIsImdldExldmVsIiwibWV0aG9kRmFjdG9yeSIsImxldmVscyIsIlNJTEVOVCIsImVuYWJsZUxvZ2dpbmdXaGVuQ29uc29sZUFycml2ZXMiLCJkZWZhdWx0TWV0aG9kRmFjdG9yeSIsIl9sZXZlbCIsIl9sb2dnZXJOYW1lIiwiTG9nZ2VyIiwiZmFjdG9yeSIsInNlbGYiLCJpbmhlcml0ZWRMZXZlbCIsImRlZmF1bHRMZXZlbCIsInVzZXJMZXZlbCIsInN0b3JhZ2VLZXkiLCJwZXJzaXN0TGV2ZWxJZlBvc3NpYmxlIiwibGV2ZWxOdW0iLCJsZXZlbE5hbWUiLCJsb2NhbFN0b3JhZ2UiLCJpZ25vcmUiLCJkb2N1bWVudCIsImNvb2tpZSIsImdldFBlcnNpc3RlZExldmVsIiwic3RvcmVkTGV2ZWwiLCJjb29raWVOYW1lIiwibG9jYXRpb24iLCJleGVjIiwiY2xlYXJQZXJzaXN0ZWRMZXZlbCIsInJlbW92ZUl0ZW0iLCJub3JtYWxpemVMZXZlbCIsIlR5cGVFcnJvciIsInNldExldmVsIiwicGVyc2lzdCIsInNldERlZmF1bHRMZXZlbCIsInJlc2V0TGV2ZWwiLCJlbmFibGVBbGwiLCJUUkFDRSIsImRpc2FibGVBbGwiLCJyZWJ1aWxkIiwiY2hpbGROYW1lIiwiaW5pdGlhbExldmVsIiwiZ2V0TG9nZ2VyIiwibG9nZ2VyIiwiX2xvZyIsIm5vQ29uZmxpY3QiLCJnZXRMb2dnZXJzIiwibG9nbGV2ZWxFeHBvcnRzIiwiTG9nTGV2ZWwiLCJMb2dnZXJOYW1lcyIsImxpdmVraXRMb2dnZXIiLCJsaXZla2l0TG9nZ2VycyIsImluZm8iLCJzZXRMb2dMZXZlbCIsImxvZ2dlck5hbWUiLCJzZXRMb2dFeHRlbnNpb24iLCJsb2dnZXJzIiwibG9nUiIsIm9yaWdpbmFsRmFjdG9yeSIsImNvbmZpZ0xldmVsIiwicmF3TWV0aG9kIiwibG9nTGV2ZWwiLCJuZWVkTG9nIiwic2lsZW50IiwiY29udGV4dCIsIndvcmtlckxvZ2dlciIsIm1heFJldHJ5RGVsYXkiLCJERUZBVUxUX1JFVFJZX0RFTEFZU19JTl9NUyIsIkRlZmF1bHRSZWNvbm5lY3RQb2xpY3kiLCJyZXRyeURlbGF5cyIsIl9yZXRyeURlbGF5cyIsIm5leHRSZXRyeURlbGF5SW5NcyIsInJldHJ5Q291bnQiLCJyZXRyeURlbGF5IiwicmFuZG9tIiwiX19yZXN0IiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwicmVqZWN0ZWQiLCJkb25lIiwiX192YWx1ZXMiLCJpdGVyYXRvciIsIl9fYXN5bmNWYWx1ZXMiLCJhc3luY0l0ZXJhdG9yIiwidmVyYiIsInNldHRsZSIsIlN1cHByZXNzZWRFcnJvciIsImVycm9yIiwic3VwcHJlc3NlZCIsImV2ZW50cyIsImhhc1JlcXVpcmVkRXZlbnRzIiwicmVxdWlyZUV2ZW50cyIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwicmVjZWl2ZXIiLCJhcmdzIiwiUmVmbGVjdE93bktleXMiLCJvd25LZXlzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIndhcm4iLCJOdW1iZXJJc05hTiIsIkV2ZW50RW1pdHRlciIsImluaXQiLCJvbmNlIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJlbWl0IiwiZG9FcnJvciIsImVyIiwiZXJyIiwiaGFuZGxlciIsImxpc3RlbmVycyIsImFycmF5Q2xvbmUiLCJfYWRkTGlzdGVuZXIiLCJwcmVwZW5kIiwiZXhpc3RpbmciLCJuZXdMaXN0ZW5lciIsInVuc2hpZnQiLCJ3YXJuZWQiLCJ3IiwiZW1pdHRlciIsImNvdW50IiwiYWRkTGlzdGVuZXIiLCJvbiIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJyZW1vdmVMaXN0ZW5lciIsIndyYXBGbiIsIl9vbmNlV3JhcCIsInN0YXRlIiwid3JhcHBlZCIsInByZXBlbmRPbmNlTGlzdGVuZXIiLCJwb3NpdGlvbiIsIm9yaWdpbmFsTGlzdGVuZXIiLCJzcGxpY2VPbmUiLCJvZmYiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJfbGlzdGVuZXJzIiwidW53cmFwIiwiZXZsaXN0ZW5lciIsInVud3JhcExpc3RlbmVycyIsInJhd0xpc3RlbmVycyIsImxpc3RlbmVyQ291bnQiLCJldmVudE5hbWVzIiwiaW5kZXgiLCJyZXQiLCJlcnJvckxpc3RlbmVyIiwicmVzb2x2ZXIiLCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIiLCJhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlciIsImZsYWdzIiwiYWRkRXZlbnRMaXN0ZW5lciIsIndyYXBMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJldmVudHNFeHBvcnRzIiwibG9nRGlzYWJsZWRfIiwiZGVwcmVjYXRpb25XYXJuaW5nc18iLCJleHRyYWN0VmVyc2lvbiIsInVhc3RyaW5nIiwiZXhwciIsIndyYXBQZWVyQ29ubmVjdGlvbkV2ZW50IiwiZXZlbnROYW1lVG9XcmFwIiwid3JhcHBlciIsIlJUQ1BlZXJDb25uZWN0aW9uIiwicHJvdG8iLCJuYXRpdmVBZGRFdmVudExpc3RlbmVyIiwibmF0aXZlRXZlbnROYW1lIiwiY2IiLCJ3cmFwcGVkQ2FsbGJhY2siLCJtb2RpZmllZEV2ZW50IiwiaGFuZGxlRXZlbnQiLCJfZXZlbnRNYXAiLCJuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyIiwidW53cmFwcGVkQ2IiLCJkZWxldGUiLCJzaXplIiwiZGlzYWJsZUxvZyIsImRpc2FibGVXYXJuaW5ncyIsImRlcHJlY2F0ZWQiLCJvbGRNZXRob2QiLCJuZXdNZXRob2QiLCJkZXRlY3RCcm93c2VyIiwiYnJvd3NlciIsInZlcnNpb24iLCJ1c2VyQWdlbnREYXRhIiwiYnJhbmRzIiwiY2hyb21pdW0iLCJicmFuZCIsIm1vekdldFVzZXJNZWRpYSIsIndlYmtpdEdldFVzZXJNZWRpYSIsImlzU2VjdXJlQ29udGV4dCIsIndlYmtpdFJUQ1BlZXJDb25uZWN0aW9uIiwic3VwcG9ydHNVbmlmaWVkUGxhbiIsIlJUQ1J0cFRyYW5zY2VpdmVyIiwiaXNPYmplY3QiLCJjb21wYWN0T2JqZWN0IiwicmVkdWNlIiwiYWNjdW11bGF0b3IiLCJpc09iaiIsImlzRW1wdHlPYmplY3QiLCJ3YWxrU3RhdHMiLCJzdGF0cyIsInJlc3VsdFNldCIsImlkIiwiZmlsdGVyU3RhdHMiLCJ0cmFjayIsIm91dGJvdW5kIiwic3RyZWFtU3RhdHNUeXBlIiwiZmlsdGVyZWRSZXN1bHQiLCJ0cmFja1N0YXRzIiwidHJhY2tJZGVudGlmaWVyIiwidHJhY2tTdGF0IiwidHJhY2tJZCIsImxvZ2dpbmciLCJzaGltR2V0VXNlck1lZGlhJDIiLCJicm93c2VyRGV0YWlscyIsIm1lZGlhRGV2aWNlcyIsImNvbnN0cmFpbnRzVG9DaHJvbWVfIiwibWFuZGF0b3J5Iiwib3B0aW9uYWwiLCJjYyIsImlkZWFsIiwiZXhhY3QiLCJtaW4iLCJtYXgiLCJvbGRuYW1lXyIsInByZWZpeCIsIm9jIiwibWl4IiwiYWR2YW5jZWQiLCJzaGltQ29uc3RyYWludHNfIiwiY29uc3RyYWludHMiLCJmdW5jIiwiYXVkaW8iLCJyZW1hcCIsInZpZGVvIiwiZmFjZSIsImZhY2luZ01vZGUiLCJnZXRTdXBwb3J0ZWRGYWNpbmdNb2RlTGllcyIsImdldFN1cHBvcnRlZENvbnN0cmFpbnRzIiwiZW51bWVyYXRlRGV2aWNlcyIsImRldmljZXMiLCJkZXYiLCJzb21lIiwibGFiZWwiLCJpbmNsdWRlcyIsImRldmljZUlkIiwic2hpbUVycm9yXyIsIlBlcm1pc3Npb25EZW5pZWRFcnJvciIsIlBlcm1pc3Npb25EaXNtaXNzZWRFcnJvciIsIkludmFsaWRTdGF0ZUVycm9yIiwiRGV2aWNlc05vdEZvdW5kRXJyb3IiLCJDb25zdHJhaW50Tm90U2F0aXNmaWVkRXJyb3IiLCJUcmFja1N0YXJ0RXJyb3IiLCJNZWRpYURldmljZUZhaWxlZER1ZVRvU2h1dGRvd24iLCJNZWRpYURldmljZUtpbGxTd2l0Y2hPbiIsIlRhYkNhcHR1cmVFcnJvciIsIlNjcmVlbkNhcHR1cmVFcnJvciIsIkRldmljZUNhcHR1cmVFcnJvciIsImNvbnN0cmFpbnQiLCJjb25zdHJhaW50TmFtZSIsImdldFVzZXJNZWRpYV8iLCJvblN1Y2Nlc3MiLCJvbkVycm9yIiwiZ2V0VXNlck1lZGlhIiwib3JpZ0dldFVzZXJNZWRpYSIsImNzIiwic3RyZWFtIiwiZ2V0QXVkaW9UcmFja3MiLCJnZXRWaWRlb1RyYWNrcyIsImdldFRyYWNrcyIsInN0b3AiLCJET01FeGNlcHRpb24iLCJzaGltTWVkaWFTdHJlYW0iLCJNZWRpYVN0cmVhbSIsIndlYmtpdE1lZGlhU3RyZWFtIiwic2hpbU9uVHJhY2skMSIsIl9vbnRyYWNrIiwib3JpZ1NldFJlbW90ZURlc2NyaXB0aW9uIiwic2V0UmVtb3RlRGVzY3JpcHRpb24iLCJfb250cmFja3BvbHkiLCJ0ZSIsImdldFJlY2VpdmVycyIsImV2ZW50IiwiRXZlbnQiLCJ0cmFuc2NlaXZlciIsInN0cmVhbXMiLCJkaXNwYXRjaEV2ZW50Iiwic2hpbUdldFNlbmRlcnNXaXRoRHRtZiIsInNoaW1TZW5kZXJXaXRoRHRtZiIsInBjIiwiZHRtZiIsIl9kdG1mIiwiY3JlYXRlRFRNRlNlbmRlciIsIl9wYyIsImdldFNlbmRlcnMiLCJfc2VuZGVycyIsIm9yaWdBZGRUcmFjayIsImFkZFRyYWNrIiwic2VuZGVyIiwib3JpZ1JlbW92ZVRyYWNrIiwicmVtb3ZlVHJhY2siLCJpZHgiLCJzcGxpY2UiLCJvcmlnQWRkU3RyZWFtIiwiYWRkU3RyZWFtIiwib3JpZ1JlbW92ZVN0cmVhbSIsInJlbW92ZVN0cmVhbSIsIlJUQ1J0cFNlbmRlciIsIm9yaWdHZXRTZW5kZXJzIiwic2VuZGVycyIsInNoaW1TZW5kZXJSZWNlaXZlckdldFN0YXRzIiwiUlRDUnRwUmVjZWl2ZXIiLCJnZXRTdGF0cyIsIm9yaWdHZXRSZWNlaXZlcnMiLCJyZWNlaXZlcnMiLCJzcmNFbGVtZW50Iiwib3JpZ0dldFN0YXRzIiwiTWVkaWFTdHJlYW1UcmFjayIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrV2l0aE5hdGl2ZSIsImdldExvY2FsU3RyZWFtcyIsIl9zaGltbWVkTG9jYWxTdHJlYW1zIiwic3RyZWFtSWQiLCJhbHJlYWR5RXhpc3RzIiwiZXhpc3RpbmdTZW5kZXJzIiwibmV3U2VuZGVycyIsIm5ld1NlbmRlciIsInNoaW1BZGRUcmFja1JlbW92ZVRyYWNrIiwib3JpZ0dldExvY2FsU3RyZWFtcyIsIm5hdGl2ZVN0cmVhbXMiLCJfcmV2ZXJzZVN0cmVhbXMiLCJfc3RyZWFtcyIsIm5ld1N0cmVhbSIsInNpZ25hbGluZ1N0YXRlIiwib2xkU3RyZWFtIiwicmVwbGFjZUludGVybmFsU3RyZWFtSWQiLCJkZXNjcmlwdGlvbiIsInNkcCIsImludGVybmFsSWQiLCJleHRlcm5hbFN0cmVhbSIsImludGVybmFsU3RyZWFtIiwiUmVnRXhwIiwiUlRDU2Vzc2lvbkRlc2NyaXB0aW9uIiwicmVwbGFjZUV4dGVybmFsU3RyZWFtSWQiLCJuYXRpdmVNZXRob2QiLCJtZXRob2RPYmoiLCJpc0xlZ2FjeUNhbGwiLCJkZXNjIiwib3JpZ1NldExvY2FsRGVzY3JpcHRpb24iLCJzZXRMb2NhbERlc2NyaXB0aW9uIiwib3JpZ0xvY2FsRGVzY3JpcHRpb24iLCJpc0xvY2FsIiwic3RyZWFtaWQiLCJoYXNUcmFjayIsInNoaW1QZWVyQ29ubmVjdGlvbiQxIiwiUlRDSWNlQ2FuZGlkYXRlIiwiZml4TmVnb3RpYXRpb25OZWVkZWQiLCJnZXRDb25maWd1cmF0aW9uIiwic2RwU2VtYW50aWNzIiwiY2hyb21lU2hpbSIsIl9fcHJvdG9fXyIsInNoaW1HZXRVc2VyTWVkaWEiLCJzaGltT25UcmFjayIsInNoaW1QZWVyQ29ubmVjdGlvbiIsInNoaW1HZXRVc2VyTWVkaWEkMSIsIm5hdGl2ZUdldFVzZXJNZWRpYSIsImdldFNldHRpbmdzIiwibmF0aXZlR2V0U2V0dGluZ3MiLCJhcHBseUNvbnN0cmFpbnRzIiwibmF0aXZlQXBwbHlDb25zdHJhaW50cyIsInNoaW1HZXREaXNwbGF5TWVkaWEiLCJwcmVmZXJyZWRNZWRpYVNvdXJjZSIsImdldERpc3BsYXlNZWRpYSIsImNvZGUiLCJtZWRpYVNvdXJjZSIsIlJUQ1RyYWNrRXZlbnQiLCJtb3pSVENQZWVyQ29ubmVjdGlvbiIsIm1vZGVyblN0YXRzVHlwZXMiLCJpbmJvdW5kcnRwIiwib3V0Ym91bmRydHAiLCJjYW5kaWRhdGVwYWlyIiwibG9jYWxjYW5kaWRhdGUiLCJyZW1vdGVjYW5kaWRhdGUiLCJuYXRpdmVHZXRTdGF0cyIsInNlbGVjdG9yIiwib25TdWNjIiwib25FcnIiLCJzdGF0Iiwic2hpbVNlbmRlckdldFN0YXRzIiwic2hpbVJlY2VpdmVyR2V0U3RhdHMiLCJzaGltUmVtb3ZlU3RyZWFtIiwic2hpbVJUQ0RhdGFDaGFubmVsIiwiRGF0YUNoYW5uZWwiLCJSVENEYXRhQ2hhbm5lbCIsInNoaW1BZGRUcmFuc2NlaXZlciIsIm9yaWdBZGRUcmFuc2NlaXZlciIsImFkZFRyYW5zY2VpdmVyIiwic2V0UGFyYW1ldGVyc1Byb21pc2VzIiwic2VuZEVuY29kaW5ncyIsInNob3VsZFBlcmZvcm1DaGVjayIsImVuY29kaW5nUGFyYW0iLCJyaWRSZWdleCIsInJpZCIsInBhcnNlRmxvYXQiLCJzY2FsZVJlc29sdXRpb25Eb3duQnkiLCJtYXhGcmFtZXJhdGUiLCJwYXJhbXMiLCJnZXRQYXJhbWV0ZXJzIiwiZW5jb2RpbmdzIiwic2V0UGFyYW1ldGVycyIsImNhdGNoIiwic2hpbUdldFBhcmFtZXRlcnMiLCJvcmlnR2V0UGFyYW1ldGVycyIsInNoaW1DcmVhdGVPZmZlciIsIm9yaWdDcmVhdGVPZmZlciIsImNyZWF0ZU9mZmVyIiwiZmluYWxseSIsInNoaW1DcmVhdGVBbnN3ZXIiLCJvcmlnQ3JlYXRlQW5zd2VyIiwiY3JlYXRlQW5zd2VyIiwiZmlyZWZveFNoaW0iLCJzaGltTG9jYWxTdHJlYW1zQVBJIiwiX2xvY2FsU3RyZWFtcyIsIl9hZGRUcmFjayIsIl9sZW4iLCJfa2V5IiwidHJhY2tzIiwic2hpbVJlbW90ZVN0cmVhbXNBUEkiLCJnZXRSZW1vdGVTdHJlYW1zIiwiX3JlbW90ZVN0cmVhbXMiLCJfb25hZGRzdHJlYW0iLCJfb25hZGRzdHJlYW1wb2x5Iiwic2hpbUNhbGxiYWNrc0FQSSIsImFkZEljZUNhbmRpZGF0ZSIsInN1Y2Nlc3NDYWxsYmFjayIsImZhaWx1cmVDYWxsYmFjayIsInByb21pc2UiLCJ3aXRoQ2FsbGJhY2siLCJjYW5kaWRhdGUiLCJfZ2V0VXNlck1lZGlhIiwic2hpbUNvbnN0cmFpbnRzIiwiZXJyY2IiLCJzaGltUlRDSWNlU2VydmVyVXJscyIsIk9yaWdQZWVyQ29ubmVjdGlvbiIsInBjQ29uZmlnIiwicGNDb25zdHJhaW50cyIsImljZVNlcnZlcnMiLCJuZXdJY2VTZXJ2ZXJzIiwic2VydmVyIiwidXJscyIsInVybCIsImdlbmVyYXRlQ2VydGlmaWNhdGUiLCJzaGltVHJhY2tFdmVudFRyYW5zY2VpdmVyIiwic2hpbUNyZWF0ZU9mZmVyTGVnYWN5Iiwib2ZmZXJPcHRpb25zIiwib2ZmZXJUb1JlY2VpdmVBdWRpbyIsImF1ZGlvVHJhbnNjZWl2ZXIiLCJnZXRUcmFuc2NlaXZlcnMiLCJkaXJlY3Rpb24iLCJzZXREaXJlY3Rpb24iLCJvZmZlclRvUmVjZWl2ZVZpZGVvIiwidmlkZW9UcmFuc2NlaXZlciIsInNoaW1BdWRpb0NvbnRleHQiLCJBdWRpb0NvbnRleHQiLCJ3ZWJraXRBdWRpb0NvbnRleHQiLCJzYWZhcmlTaGltIiwic2RwJDEiLCJoYXNSZXF1aXJlZFNkcCIsInJlcXVpcmVTZHAiLCJTRFBVdGlscyIsImdlbmVyYXRlSWRlbnRpZmllciIsImxvY2FsQ05hbWUiLCJzcGxpdExpbmVzIiwiYmxvYiIsImxpbmUiLCJzcGxpdFNlY3Rpb25zIiwicGFydHMiLCJwYXJ0IiwiZ2V0RGVzY3JpcHRpb24iLCJzZWN0aW9ucyIsImdldE1lZGlhU2VjdGlvbnMiLCJtYXRjaFByZWZpeCIsInBhcnNlQ2FuZGlkYXRlIiwiZm91bmRhdGlvbiIsImNvbXBvbmVudCIsInByb3RvY29sIiwicHJpb3JpdHkiLCJpcCIsImFkZHJlc3MiLCJwb3J0IiwicmVsYXRlZEFkZHJlc3MiLCJyZWxhdGVkUG9ydCIsInRjcFR5cGUiLCJ1ZnJhZyIsInVzZXJuYW1lRnJhZ21lbnQiLCJ3cml0ZUNhbmRpZGF0ZSIsInBhcnNlSWNlT3B0aW9ucyIsInBhcnNlUnRwTWFwIiwicGFyc2VkIiwicGF5bG9hZFR5cGUiLCJjbG9ja1JhdGUiLCJjaGFubmVscyIsIm51bUNoYW5uZWxzIiwid3JpdGVSdHBNYXAiLCJjb2RlYyIsInB0IiwicHJlZmVycmVkUGF5bG9hZFR5cGUiLCJwYXJzZUV4dG1hcCIsInVyaSIsImF0dHJpYnV0ZXMiLCJ3cml0ZUV4dG1hcCIsImhlYWRlckV4dGVuc2lvbiIsInByZWZlcnJlZElkIiwicGFyc2VGbXRwIiwia3YiLCJqIiwid3JpdGVGbXRwIiwicGFyYW1ldGVycyIsInBhcmFtIiwicGFyc2VSdGNwRmIiLCJwYXJhbWV0ZXIiLCJ3cml0ZVJ0Y3BGYiIsImxpbmVzIiwicnRjcEZlZWRiYWNrIiwiZmIiLCJwYXJzZVNzcmNNZWRpYSIsInNwIiwic3NyYyIsImNvbG9uIiwiYXR0cmlidXRlIiwicGFyc2VTc3JjR3JvdXAiLCJzZW1hbnRpY3MiLCJzc3JjcyIsImdldE1pZCIsIm1lZGlhU2VjdGlvbiIsInBhcnNlRmluZ2VycHJpbnQiLCJhbGdvcml0aG0iLCJnZXREdGxzUGFyYW1ldGVycyIsInNlc3Npb25wYXJ0Iiwicm9sZSIsImZpbmdlcnByaW50cyIsIndyaXRlRHRsc1BhcmFtZXRlcnMiLCJzZXR1cFR5cGUiLCJmcCIsInBhcnNlQ3J5cHRvTGluZSIsImNyeXB0b1N1aXRlIiwia2V5UGFyYW1zIiwic2Vzc2lvblBhcmFtcyIsIndyaXRlQ3J5cHRvTGluZSIsIndyaXRlQ3J5cHRvS2V5UGFyYW1zIiwicGFyc2VDcnlwdG9LZXlQYXJhbXMiLCJrZXlNZXRob2QiLCJrZXlTYWx0IiwibGlmZVRpbWUiLCJta2lWYWx1ZSIsIm1raUxlbmd0aCIsImdldENyeXB0b1BhcmFtZXRlcnMiLCJnZXRJY2VQYXJhbWV0ZXJzIiwicHdkIiwicGFzc3dvcmQiLCJ3cml0ZUljZVBhcmFtZXRlcnMiLCJpY2VMaXRlIiwicGFyc2VSdHBQYXJhbWV0ZXJzIiwiY29kZWNzIiwiaGVhZGVyRXh0ZW5zaW9ucyIsImZlY01lY2hhbmlzbXMiLCJydGNwIiwibWxpbmUiLCJwcm9maWxlIiwicnRwbWFwbGluZSIsImZtdHBzIiwid2lsZGNhcmRSdGNwRmIiLCJkdXBsaWNhdGUiLCJleGlzdGluZ0ZlZWRiYWNrIiwid3JpdGVSdHBEZXNjcmlwdGlvbiIsImNhcHMiLCJtYXhwdGltZSIsInBhcnNlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzIiwiZW5jb2RpbmdQYXJhbWV0ZXJzIiwiaGFzUmVkIiwiaGFzVWxwZmVjIiwicHJpbWFyeVNzcmMiLCJzZWNvbmRhcnlTc3JjIiwiZmxvd3MiLCJhcHQiLCJlbmNQYXJhbSIsImNvZGVjUGF5bG9hZFR5cGUiLCJydHgiLCJmZWMiLCJtZWNoYW5pc20iLCJiYW5kd2lkdGgiLCJtYXhCaXRyYXRlIiwicGFyc2VSdGNwUGFyYW1ldGVycyIsInJ0Y3BQYXJhbWV0ZXJzIiwicmVtb3RlU3NyYyIsImNuYW1lIiwicnNpemUiLCJyZWR1Y2VkU2l6ZSIsImNvbXBvdW5kIiwibXV4Iiwid3JpdGVSdGNwUGFyYW1ldGVycyIsInBhcnNlTXNpZCIsInNwZWMiLCJwbGFuQiIsIm1zaWRQYXJ0cyIsInBhcnNlU2N0cERlc2NyaXB0aW9uIiwicGFyc2VNTGluZSIsIm1heFNpemVMaW5lIiwibWF4TWVzc2FnZVNpemUiLCJzY3RwUG9ydCIsImZtdCIsInNjdHBNYXBMaW5lcyIsIndyaXRlU2N0cERlc2NyaXB0aW9uIiwibWVkaWEiLCJzY3RwIiwib3V0cHV0IiwiZ2VuZXJhdGVTZXNzaW9uSWQiLCJzdWJzdHIiLCJ3cml0ZVNlc3Npb25Cb2lsZXJwbGF0ZSIsInNlc3NJZCIsInNlc3NWZXIiLCJzZXNzVXNlciIsInNlc3Npb25JZCIsInVzZXIiLCJnZXREaXJlY3Rpb24iLCJnZXRLaW5kIiwiaXNSZWplY3RlZCIsInBhcnNlT0xpbmUiLCJ1c2VybmFtZSIsInNlc3Npb25WZXJzaW9uIiwibmV0VHlwZSIsImFkZHJlc3NUeXBlIiwiaXNWYWxpZFNEUCIsInNkcEV4cG9ydHMiLCJzaGltUlRDSWNlQ2FuZGlkYXRlIiwiTmF0aXZlUlRDSWNlQ2FuZGlkYXRlIiwibmF0aXZlQ2FuZGlkYXRlIiwicGFyc2VkQ2FuZGlkYXRlIiwic2RwTWlkIiwic2RwTUxpbmVJbmRleCIsInNoaW1SVENJY2VDYW5kaWRhdGVSZWxheVByb3RvY29sIiwicmVsYXlQcm90b2NvbCIsInNoaW1NYXhNZXNzYWdlU2l6ZSIsIl9zY3RwIiwic2N0cEluRGVzY3JpcHRpb24iLCJtTGluZSIsImdldFJlbW90ZUZpcmVmb3hWZXJzaW9uIiwiZ2V0Q2FuU2VuZE1heE1lc3NhZ2VTaXplIiwicmVtb3RlSXNGaXJlZm94IiwiY2FuU2VuZE1heE1lc3NhZ2VTaXplIiwiZ2V0TWF4TWVzc2FnZVNpemUiLCJpc0ZpcmVmb3giLCJjYW5TZW5kTU1TIiwicmVtb3RlTU1TIiwic2hpbVNlbmRUaHJvd1R5cGVFcnJvciIsIndyYXBEY1NlbmQiLCJkYyIsIm9yaWdEYXRhQ2hhbm5lbFNlbmQiLCJzZW5kIiwicmVhZHlTdGF0ZSIsIm9yaWdDcmVhdGVEYXRhQ2hhbm5lbCIsImNyZWF0ZURhdGFDaGFubmVsIiwiZGF0YUNoYW5uZWwiLCJjaGFubmVsIiwic2hpbUNvbm5lY3Rpb25TdGF0ZSIsImNvbXBsZXRlZCIsImNoZWNraW5nIiwiaWNlQ29ubmVjdGlvblN0YXRlIiwiX29uY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib3JpZ01ldGhvZCIsIl9jb25uZWN0aW9uc3RhdGVjaGFuZ2Vwb2x5IiwiX2xhc3RDb25uZWN0aW9uU3RhdGUiLCJjb25uZWN0aW9uU3RhdGUiLCJuZXdFdmVudCIsInJlbW92ZUV4dG1hcEFsbG93TWl4ZWQiLCJuYXRpdmVTUkQiLCJzaGltQWRkSWNlQ2FuZGlkYXRlTnVsbE9yRW1wdHkiLCJuYXRpdmVBZGRJY2VDYW5kaWRhdGUiLCJzaGltUGFyYW1ldGVybGVzc1NldExvY2FsRGVzY3JpcHRpb24iLCJuYXRpdmVTZXRMb2NhbERlc2NyaXB0aW9uIiwiY29tbW9uU2hpbSIsImFkYXB0ZXJGYWN0b3J5Iiwic2hpbUNocm9tZSIsInNoaW1GaXJlZm94Iiwic2hpbVNhZmFyaSIsImFkYXB0ZXIiLCJicm93c2VyU2hpbSIsIkVOQ1JZUFRJT05fQUxHT1JJVEhNIiwiREVDUllQVElPTl9GQUlMVVJFX1RPTEVSQU5DRSIsIkUyRUVfRkxBRyIsIlNBTFQiLCJLRVlfUFJPVklERVJfREVGQVVMVFMiLCJzaGFyZWRLZXkiLCJyYXRjaGV0U2FsdCIsInJhdGNoZXRXaW5kb3dTaXplIiwiZmFpbHVyZVRvbGVyYW5jZSIsImtleXJpbmdTaXplIiwiYWxsb3dLZXlFeHRyYWN0aW9uIiwiS2V5UHJvdmlkZXJFdmVudCIsIktleUhhbmRsZXJFdmVudCIsIkVuY3J5cHRpb25FdmVudCIsIkNyeXB0b3JFdmVudCIsImlzRTJFRVN1cHBvcnRlZCIsImlzSW5zZXJ0YWJsZVN0cmVhbVN1cHBvcnRlZCIsImlzU2NyaXB0VHJhbnNmb3JtU3VwcG9ydGVkIiwiUlRDUnRwU2NyaXB0VHJhbnNmb3JtIiwiY3JlYXRlRW5jb2RlZFN0cmVhbXMiLCJpc1ZpZGVvRnJhbWUiLCJmcmFtZSIsImltcG9ydEtleSIsImtleUJ5dGVzXzEiLCJrZXlCeXRlcyIsInVzYWdlIiwiZXh0cmFjdGFibGUiLCJjcnlwdG8iLCJzdWJ0bGUiLCJjcmVhdGVLZXlNYXRlcmlhbEZyb21TdHJpbmciLCJrZXlNYXRlcmlhbCIsImNyZWF0ZUtleU1hdGVyaWFsRnJvbUJ1ZmZlciIsImNyeXB0b0J1ZmZlciIsImdldEFsZ29PcHRpb25zIiwiYWxnb3JpdGhtTmFtZSIsInNhbHQiLCJlbmNvZGVkU2FsdCIsImhhc2giLCJpdGVyYXRpb25zIiwiZGVyaXZlS2V5cyIsIm1hdGVyaWFsIiwiYWxnb3JpdGhtT3B0aW9ucyIsImVuY3J5cHRpb25LZXkiLCJkZXJpdmVLZXkiLCJjcmVhdGVFMkVFS2V5IiwiZ2V0UmFuZG9tVmFsdWVzIiwicmF0Y2hldCIsImRlcml2ZUJpdHMiLCJuZWVkc1Jic3BVbmVzY2FwaW5nIiwiZnJhbWVEYXRhIiwicGFyc2VSYnNwIiwiZGF0YU91dCIsImtaZXJvc0luU3RhcnRTZXF1ZW5jZSIsImtFbXVsYXRpb25CeXRlIiwid3JpdGVSYnNwIiwiZGF0YV9pbiIsIm51bUNvbnNlY3V0aXZlWmVyb3MiLCJCYXNlS2V5UHJvdmlkZXIiLCJvbktleVJhdGNoZXRlZCIsImtleUluZGV4Iiwia2V5SW5mb01hcCIsIktleVJhdGNoZXRlZCIsIm9uU2V0RW5jcnlwdGlvbktleSIsInBhcnRpY2lwYW50SWRlbnRpdHkiLCJrZXlJbmZvIiwiU2V0S2V5IiwiZ2V0S2V5cyIsImZyb20iLCJnZXRPcHRpb25zIiwicmF0Y2hldEtleSIsIlJhdGNoZXRSZXF1ZXN0IiwiRXh0ZXJuYWxFMkVFS2V5UHJvdmlkZXIiLCJvcHRzIiwic2V0S2V5IiwiZGVyaXZlZEtleSIsIkxpdmVraXRFcnJvciIsIkNvbm5lY3Rpb25FcnJvclJlYXNvbiIsIkNvbm5lY3Rpb25FcnJvciIsInJlYXNvbiIsInN0YXR1cyIsInJlYXNvbk5hbWUiLCJEZXZpY2VVbnN1cHBvcnRlZEVycm9yIiwiVHJhY2tJbnZhbGlkRXJyb3IiLCJVbnN1cHBvcnRlZFNlcnZlciIsIlVuZXhwZWN0ZWRDb25uZWN0aW9uU3RhdGUiLCJOZWdvdGlhdGlvbkVycm9yIiwiUHVibGlzaERhdGFFcnJvciIsIlB1Ymxpc2hUcmFja0Vycm9yIiwiU2lnbmFsUmVxdWVzdEVycm9yIiwiTWVkaWFEZXZpY2VGYWlsdXJlIiwiZ2V0RmFpbHVyZSIsIk5vdEZvdW5kIiwiUGVybWlzc2lvbkRlbmllZCIsIkRldmljZUluVXNlIiwiT3RoZXIiLCJDcnlwdG9yRXJyb3JSZWFzb24iLCJDcnlwdG9yRXJyb3IiLCJJbnRlcm5hbEVycm9yIiwiUm9vbUV2ZW50IiwiUGFydGljaXBhbnRFdmVudCIsIkVuZ2luZUV2ZW50IiwiVHJhY2tFdmVudCIsImNsb25lRGVlcCIsInN0cnVjdHVyZWRDbG9uZSIsImNvbW1vblZlcnNpb25JZGVudGlmaWVyIiwiZ2V0QnJvd3NlciIsImZvcmNlIiwidWEiLCJicm93c2Vyc0xpc3QiLCJfcmVmIiwiZGVzY3JpYmUiLCJnZXRNYXRjaCIsIm9zIiwib3NWZXJzaW9uIiwiZ2V0T1NWZXJzaW9uIiwiZXhwIiwidmVyc2lvbiQxIiwicHJvdG9jb2xWZXJzaW9uIiwiQ3JpdGljYWxUaW1lcnMiLCJzZXRUaW1lb3V0Iiwic2V0SW50ZXJ2YWwiLCJjbGVhclRpbWVvdXQiLCJjbGVhckludGVydmFsIiwiQkFDS0dST1VORF9SRUFDVElPTl9ERUxBWSIsInJlY3ljbGVkRWxlbWVudHMiLCJWaWRlb1F1YWxpdHkiLCJUcmFjayIsIm1lZGlhVHJhY2siLCJsb2dnZXJPcHRpb25zIiwiYXR0YWNoZWRFbGVtZW50cyIsImlzTXV0ZWQiLCJzdHJlYW1TdGF0ZSIsIkFjdGl2ZSIsImlzSW5CYWNrZ3JvdW5kIiwiX2N1cnJlbnRCaXRyYXRlIiwiYXBwVmlzaWJpbGl0eUNoYW5nZWRMaXN0ZW5lciIsImJhY2tncm91bmRUaW1lb3V0IiwidmlzaWJpbGl0eVN0YXRlIiwiaGFuZGxlQXBwVmlzaWJpbGl0eUNoYW5nZWQiLCJsb2dnZXJDb250ZXh0Q2IiLCJfbWVkaWFTdHJlYW1UcmFjayIsIl9tZWRpYVN0cmVhbUlEIiwiU291cmNlIiwiVW5rbm93biIsImxvZ0NvbnRleHQiLCJnZXRMb2dDb250ZXh0RnJvbVRyYWNrIiwiY3VycmVudEJpdHJhdGUiLCJtZWRpYVN0cmVhbVRyYWNrIiwibWVkaWFTdHJlYW1JRCIsImF0dGFjaCIsImVsZW1lbnQiLCJlbGVtZW50VHlwZSIsIktpbmQiLCJWaWRlbyIsImFkZEFwcFZpc2liaWxpdHlMaXN0ZW5lciIsInBhcmVudEVsZW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiYXR0YWNoVG9FbGVtZW50IiwiYWxsTWVkaWFTdHJlYW1UcmFja3MiLCJzcmNPYmplY3QiLCJoYXNBdWRpbyIsInRyIiwicGxheSIsIkF1ZGlvUGxheWJhY2tTdGFydGVkIiwiVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJBdWRpb1BsYXliYWNrRmFpbGVkIiwiVmlkZW9QbGF5YmFja0ZhaWxlZCIsIm11dGVkIiwiRWxlbWVudEF0dGFjaGVkIiwiZGV0YWNoIiwiZGV0YWNoVHJhY2siLCJyZWN5Y2xlRWxlbWVudCIsIkVsZW1lbnREZXRhY2hlZCIsImRldGFjaGVkIiwiZWxtIiwicmVtb3ZlQXBwVmlzaWJpbGl0eUxpc3RlbmVyIiwic3RvcE1vbml0b3IiLCJlbmFibGUiLCJlbmFibGVkIiwiZGlzYWJsZSIsIm1vbml0b3JJbnRlcnZhbCIsInRpbWVTeW5jSGFuZGxlIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJ1cGRhdGVMb2dnZXJPcHRpb25zIiwiSFRNTEF1ZGlvRWxlbWVudCIsInNob3VsZENhY2hlIiwicGF1c2UiLCJlbCIsImlzV2ViIiwibWVkaWFTdHJlYW0iLCJleGlzdGluZ1RyYWNrcyIsImV0IiwiaXNTYWZhcmkiLCJIVE1MVmlkZW9FbGVtZW50IiwiYXV0b3BsYXkiLCJwbGF5c0lubGluZSIsImlzRmlyZUZveCIsIlN0cmVhbVN0YXRlJDEiLCJraW5kVG9Qcm90byIsIkF1ZGlvIiwiQVVESU8iLCJWSURFTyIsIkRBVEEiLCJraW5kRnJvbVByb3RvIiwic291cmNlVG9Qcm90byIsIkNhbWVyYSIsIkNBTUVSQSIsIk1pY3JvcGhvbmUiLCJNSUNST1BIT05FIiwiU2NyZWVuU2hhcmUiLCJTQ1JFRU5fU0hBUkUiLCJTY3JlZW5TaGFyZUF1ZGlvIiwiU0NSRUVOX1NIQVJFX0FVRElPIiwiVU5LTk9XTiIsInNvdXJjZUZyb21Qcm90byIsInN0cmVhbVN0YXRlRnJvbVByb3RvIiwiQUNUSVZFIiwiUEFVU0VEIiwiUGF1c2VkIiwiVmlkZW9QcmVzZXQiLCJ3aWR0aE9yT3B0aW9ucyIsImhlaWdodCIsIndpZHRoIiwiYXNwZWN0UmF0aW8iLCJlbmNvZGluZyIsInJlc29sdXRpb24iLCJmcmFtZVJhdGUiLCJiYWNrdXBDb2RlY3MiLCJ2aWRlb0NvZGVjcyIsImlzQmFja3VwQ29kZWMiLCJiYWNrdXAiLCJCYWNrdXBDb2RlY1BvbGljeSIsIkF1ZGlvUHJlc2V0cyIsInRlbGVwaG9uZSIsInNwZWVjaCIsIm11c2ljIiwibXVzaWNTdGVyZW8iLCJtdXNpY0hpZ2hRdWFsaXR5IiwibXVzaWNIaWdoUXVhbGl0eVN0ZXJlbyIsIlZpZGVvUHJlc2V0cyIsImg5MCIsImgxODAiLCJoMjE2IiwiaDM2MCIsImg1NDAiLCJoNzIwIiwiaDEwODAiLCJoMTQ0MCIsImgyMTYwIiwiVmlkZW9QcmVzZXRzNDMiLCJoMTIwIiwiaDI0MCIsImg0ODAiLCJTY3JlZW5TaGFyZVByZXNldHMiLCJoMzYwZnBzMyIsImgzNjBmcHMxNSIsImg3MjBmcHM1IiwiaDcyMGZwczE1IiwiaDcyMGZwczMwIiwiaDEwODBmcHMxNSIsImgxMDgwZnBzMzAiLCJvcmlnaW5hbCIsInNlcGFyYXRvciIsImRkRXh0ZW5zaW9uVVJJIiwidW5wYWNrU3RyZWFtSWQiLCJzbGVlcCIsImR1cmF0aW9uIiwic3VwcG9ydHNUcmFuc2NlaXZlciIsInN1cHBvcnRzQWRkVHJhY2siLCJzdXBwb3J0c0FkYXB0aXZlU3RyZWFtIiwiUmVzaXplT2JzZXJ2ZXIiLCJJbnRlcnNlY3Rpb25PYnNlcnZlciIsInN1cHBvcnRzRHluYWNhc3QiLCJzdXBwb3J0c0FWMSIsImNhcGFiaWxpdGllcyIsImdldENhcGFiaWxpdGllcyIsImhhc0FWMSIsIm1pbWVUeXBlIiwic3VwcG9ydHNWUDkiLCJjb21wYXJlVmVyc2lvbnMiLCJoYXNWUDkiLCJpc1NWQ0NvZGVjIiwic3VwcG9ydHNTZXRTaW5rSWQiLCJpc0Jyb3dzZXJTdXBwb3J0ZWQiLCJpc1NhZmFyaTE3IiwiaXNNb2JpbGUiLCJtb2JpbGUiLCJpc0UyRUVTaW11bGNhc3RTdXBwb3J0ZWQiLCJzdXBwb3J0ZWRTYWZhcmlWZXJzaW9uIiwiaXNSZWFjdE5hdGl2ZSIsInByb2R1Y3QiLCJpc0Nsb3VkIiwic2VydmVyVXJsIiwiaG9zdG5hbWUiLCJnZXRMS1JlYWN0TmF0aXZlSW5mbyIsImdsb2JhbCIsIkxpdmVLaXRSZWFjdE5hdGl2ZUdsb2JhbCIsImdldFJlYWN0TmF0aXZlT3MiLCJwbGF0Zm9ybSIsImdldERldmljZVBpeGVsUmF0aW8iLCJkZXZpY2VQaXhlbFJhdGlvIiwidjEiLCJ2MiIsInBhcnRzMSIsInBhcnRzMiIsInAxIiwicDIiLCJyb0Rpc3BhdGNoQ2FsbGJhY2siLCJlbnRyeSIsImhhbmRsZVJlc2l6ZSIsImlvRGlzcGF0Y2hDYWxsYmFjayIsImhhbmRsZVZpc2liaWxpdHlDaGFuZ2VkIiwicmVzaXplT2JzZXJ2ZXIiLCJnZXRSZXNpemVPYnNlcnZlciIsImludGVyc2VjdGlvbk9ic2VydmVyIiwiZ2V0SW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJyb290TWFyZ2luIiwiZ2V0Q2xpZW50SW5mbyIsInNkayIsIkpTIiwiZW1wdHlWaWRlb1N0cmVhbVRyYWNrIiwiZ2V0RW1wdHlWaWRlb1N0cmVhbVRyYWNrIiwiY3JlYXRlRHVtbXlWaWRlb1N0cmVhbVRyYWNrIiwicGFpbnRDb250ZW50IiwiY2FudmFzIiwiY3R4IiwiZ2V0Q29udGV4dCIsImZpbGxSZWN0IiwiYmVnaW5QYXRoIiwiYXJjIiwiUEkiLCJjbG9zZVBhdGgiLCJmaWxsU3R5bGUiLCJmaWxsIiwiZHVtbXlTdHJlYW0iLCJjYXB0dXJlU3RyZWFtIiwiZHVtbXlUcmFjayIsImVtcHR5QXVkaW9TdHJlYW1UcmFjayIsImdldEVtcHR5QXVkaW9TdHJlYW1UcmFjayIsIm9zY2lsbGF0b3IiLCJjcmVhdGVPc2NpbGxhdG9yIiwiZ2FpbiIsImNyZWF0ZUdhaW4iLCJzZXRWYWx1ZUF0VGltZSIsImRzdCIsImNyZWF0ZU1lZGlhU3RyZWFtRGVzdGluYXRpb24iLCJjb25uZWN0IiwiRnV0dXJlIiwiZnV0dXJlQmFzZSIsIm9uRmluYWxseSIsImNyZWF0ZUF1ZGlvQW5hbHlzZXIiLCJjbG9uZVRyYWNrIiwiZmZ0U2l6ZSIsInNtb290aGluZ1RpbWVDb25zdGFudCIsIm1pbkRlY2liZWxzIiwibWF4RGVjaWJlbHMiLCJhdWRpb0NvbnRleHQiLCJnZXROZXdBdWRpb0NvbnRleHQiLCJzdHJlYW1UcmFjayIsIm1lZGlhU3RyZWFtU291cmNlIiwiY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2UiLCJhbmFseXNlciIsImNyZWF0ZUFuYWx5c2VyIiwiZGF0YUFycmF5IiwiZnJlcXVlbmN5QmluQ291bnQiLCJjYWxjdWxhdGVWb2x1bWUiLCJnZXRCeXRlRnJlcXVlbmN5RGF0YSIsInN1bSIsImFtcGxpdHVkZSIsInBvdyIsInZvbHVtZSIsInNxcnQiLCJjbGVhbnVwIiwiY2xvc2UiLCJpc1ZpZGVvQ29kZWMiLCJtYXliZUNvZGVjIiwidW53cmFwQ29uc3RyYWludCIsInRvV2Vic29ja2V0VXJsIiwidG9IdHRwVXJsIiwiZXh0cmFjdFRyYW5zY3JpcHRpb25TZWdtZW50cyIsInRyYW5zY3JpcHRpb24iLCJmaXJzdFJlY2VpdmVkVGltZXNNYXAiLCJzZWdtZW50cyIsInRleHQiLCJsYW5ndWFnZSIsInN0YXJ0VGltZSIsImVuZFRpbWUiLCJmaW5hbCIsImZpcnN0UmVjZWl2ZWRUaW1lIiwibGFzdFJlY2VpdmVkVGltZSIsImV4dHJhY3RDaGF0TWVzc2FnZSIsInRpbWVzdGFtcCIsImVkaXRUaW1lc3RhbXAiLCJnZXREaXNjb25uZWN0UmVhc29uRnJvbUNvbm5lY3Rpb25FcnJvciIsIkNhbmNlbGxlZCIsIkNMSUVOVF9JTklUSUFURUQiLCJOb3RBbGxvd2VkIiwiVVNFUl9SRUpFQ1RFRCIsIlNlcnZlclVucmVhY2hhYmxlIiwiSk9JTl9GQUlMVVJFIiwiVU5LTk9XTl9SRUFTT04iLCJiaWdJbnRUb051bWJlciIsIm51bWJlclRvQmlnSW50IiwiaXNMb2NhbFRyYWNrIiwiaXNBdWRpb1RyYWNrIiwiaXNWaWRlb1RyYWNrIiwiaXNMb2NhbFZpZGVvVHJhY2siLCJpc0xvY2FsQXVkaW9UcmFjayIsImlzUmVtb3RlVHJhY2siLCJpc1JlbW90ZVB1YiIsInB1YiIsImlzUmVtb3RlVmlkZW9UcmFjayIsImlzTG9jYWxQYXJ0aWNpcGFudCIsImlzUmVtb3RlUGFydGljaXBhbnQiLCJzcGxpdFV0ZjgiLCJlbmNvZGVkIiwibWVyZ2VEZWZhdWx0T3B0aW9ucyIsImF1ZGlvRGVmYXVsdHMiLCJ2aWRlb0RlZmF1bHRzIiwib3B0aW9uc1dpdGhvdXRQcm9jZXNzb3IiLCJhdWRpb1Byb2Nlc3NvciIsInZpZGVvUHJvY2Vzc29yIiwiZXh0cmFjdFByb2Nlc3NvcnNGcm9tT3B0aW9ucyIsImRlZmF1bHRBdWRpb1Byb2Nlc3NvciIsInByb2Nlc3NvciIsImRlZmF1bHRWaWRlb1Byb2Nlc3NvciIsImNsb25lZE9wdGlvbnMiLCJtZXJnZU9iamVjdFdpdGhvdXRPdmVyd3JpdGluZyIsIm1haW5PYmplY3QiLCJvYmplY3RUb01lcmdlIiwiY29uc3RyYWludHNGb3JPcHRpb25zIiwidmlkZW9PcHRpb25zIiwiZGV0ZWN0U2lsZW5jZSIsInRyYWNrXzEiLCJ0aW1lT2Zmc2V0IiwiYnVmZmVyTGVuZ3RoIiwiZ2V0Qnl0ZVRpbWVEb21haW5EYXRhIiwic29tZU5vaXNlIiwic2FtcGxlIiwibGF0ZW5jeUhpbnQiLCJib2R5IiwiaGFuZGxlUmVzdW1lIiwicmVzdW1lIiwic291cmNlVG9LaW5kIiwic2NyZWVuQ2FwdHVyZVRvRGlzcGxheU1lZGlhU3RyZWFtT3B0aW9ucyIsInZpZGVvQ29uc3RyYWludHMiLCJjb250cm9sbGVyIiwic2VsZkJyb3dzZXJTdXJmYWNlIiwic3VyZmFjZVN3aXRjaGluZyIsInN5c3RlbUF1ZGlvIiwicHJlZmVyQ3VycmVudFRhYiIsIm1pbWVUeXBlVG9WaWRlb0NvZGVjU3RyaW5nIiwiZ2V0VHJhY2tQdWJsaWNhdGlvbkluZm8iLCJpbmZvcyIsImNpZCIsInRyYWNrSW5mbyIsInRyYWNrSUQiLCJzaWQiLCJzdHJlYW1JRCIsInN0cmVhbVRyYWNrSUQiLCJ0cmFja1NpZCIsImlzRW5hYmxlZCIsInRyYWNrTmFtZSIsImVuY3J5cHRlZCIsImlzRW5jcnlwdGVkIiwic3VwcG9ydHNTeW5jaHJvbml6YXRpb25Tb3VyY2VzIiwiZGlmZkF0dHJpYnV0ZXMiLCJvbGRWYWx1ZXMiLCJuZXdWYWx1ZXMiLCJhbGxLZXlzIiwiZGlmZiIsIm5ld09wdGlvbnMiLCJnZXRUcmFja1NvdXJjZUZyb21Qcm90byIsIkUyRUVNYW5hZ2VyIiwib25Xb3JrZXJNZXNzYWdlIiwiZXYiLCJFbmNyeXB0aW9uRXJyb3IiLCJrZXlQcm92aWRlciIsInBvc3RLZXkiLCJlbmNyeXB0aW9uRW5hYmxlZCIsInJvb20iLCJsb2NhbFBhcnRpY2lwYW50IiwiaWRlbnRpdHkiLCJQYXJ0aWNpcGFudEVuY3J5cHRpb25TdGF0dXNDaGFuZ2VkIiwicGFydGljaXBhbnQiLCJnZXRQYXJ0aWNpcGFudEJ5SWRlbnRpdHkiLCJvbldvcmtlckVycm9yIiwid29ya2VyIiwic2V0dXAiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwia2V5UHJvdmlkZXJPcHRpb25zIiwib25tZXNzYWdlIiwib25lcnJvciIsInBvc3RNZXNzYWdlIiwic2V0UGFydGljaXBhbnRDcnlwdG9yRW5hYmxlZCIsInBvc3RFbmFibGUiLCJzZXRTaWZUcmFpbGVyIiwidHJhaWxlciIsInBvc3RTaWZUcmFpbGVyIiwic2V0dXBFbmdpbmUiLCJlbmdpbmUiLCJSVFBWaWRlb01hcFVwZGF0ZSIsInJ0cE1hcCIsInBvc3RSVFBNYXAiLCJUcmFja1B1Ymxpc2hlZCIsImVuY3J5cHRpb24iLCJOT05FIiwiQ29ubmVjdGlvblN0YXRlQ2hhbmdlZCIsIkNvbm5lY3Rpb25TdGF0ZSIsIkNvbm5lY3RlZCIsInJlbW90ZVBhcnRpY2lwYW50cyIsInRyYWNrUHVibGljYXRpb25zIiwiVHJhY2tVbnN1YnNjcmliZWQiLCJzZXR1cEUyRUVSZWNlaXZlciIsIlNpZ25hbENvbm5lY3RlZCIsImlzRTJFRUVuYWJsZWQiLCJMb2NhbFRyYWNrUHVibGlzaGVkIiwicHVibGljYXRpb24iLCJzZXR1cEUyRUVTZW5kZXIiLCJwYXJ0aWNpcGFudElkIiwicG9zdFJhdGNoZXRSZXF1ZXN0IiwiaXNQdWJsaXNoZXIiLCJlbmFibGVNc2ciLCJSZWZlcmVuY2VFcnJvciIsInJlbW90ZUlkIiwiaGFuZGxlUmVjZWl2ZXIiLCJoYW5kbGVTZW5kZXIiLCJ0cmFuc2Zvcm0iLCJ3cml0YWJsZVN0cmVhbSIsInJlYWRhYmxlIiwicmVhZGFibGVTdHJlYW0iLCJyZWNlaXZlclN0cmVhbXMiLCJzZW5kZXJTdHJlYW1zIiwiZGVmYXVsdElkIiwiRGV2aWNlTWFuYWdlciIsIl9wcmV2aW91c0RldmljZXMiLCJnZXRJbnN0YW5jZSIsImluc3RhbmNlIiwicHJldmlvdXNEZXZpY2VzIiwiZ2V0RGV2aWNlcyIsImtpbmRfMSIsIl90aGlzIiwicmVxdWVzdFBlcm1pc3Npb25zIiwidXNlck1lZGlhUHJvbWlzZU1hcCIsImhhc0RldmljZUluVXNlIiwiaXNEdW1teURldmljZU9yRW1wdHkiLCJkZXZpY2UiLCJub0xhYmVsIiwiaXNSZWxldmFudCIsInBlcm1pc3Npb25zVG9BY3F1aXJlIiwibm9ybWFsaXplRGV2aWNlSWQiLCJncm91cElkIiwiZGVmYXVsdERldmljZSIsIm1lZGlhRGV2aWNlS2luZHMiLCJRdWV1ZVRhc2tTdGF0dXMiLCJBc3luY1F1ZXVlIiwicGVuZGluZ1Rhc2tzIiwidGFza011dGV4IiwibmV4dFRhc2tJbmRleCIsInJ1biIsInRhc2siLCJ0YXNrSW5mbyIsImVucXVldWVkQXQiLCJXQUlUSU5HIiwidW5sb2NrIiwiZXhlY3V0ZWRBdCIsIlJVTk5JTkciLCJDT01QTEVURUQiLCJmbHVzaCIsInNuYXBzaG90IiwiY3JlYXRlUnRjVXJsIiwic2VhcmNoUGFyYW1zIiwidXJsT2JqIiwiVVJMIiwiYXBwZW5kVXJsUGF0aCIsImNyZWF0ZVZhbGlkYXRlVXJsIiwicnRjV3NVcmwiLCJlbnN1cmVUcmFpbGluZ1NsYXNoIiwicGF0aCIsInBhdGhuYW1lIiwicGFzc1Rocm91Z2hRdWV1ZVNpZ25hbHMiLCJjYW5QYXNzVGhyb3VnaFF1ZXVlIiwiY2FuUGFzcyIsIlNpZ25hbENvbm5lY3Rpb25TdGF0ZSIsIlNpZ25hbENsaWVudCIsImN1cnJlbnRTdGF0ZSIsImlzRGlzY29ubmVjdGVkIiwiRElTQ09OTkVDVElORyIsIkRJU0NPTk5FQ1RFRCIsImlzRXN0YWJsaXNoaW5nQ29ubmVjdGlvbiIsIkNPTk5FQ1RJTkciLCJSRUNPTk5FQ1RJTkciLCJnZXROZXh0UmVxdWVzdElkIiwiX3JlcXVlc3RJZCIsInVzZUpTT04iLCJydHQiLCJyZXNldENhbGxiYWNrcyIsIm9uQW5zd2VyIiwib25MZWF2ZSIsIm9uTG9jYWxUcmFja1B1Ymxpc2hlZCIsIm9uTG9jYWxUcmFja1VucHVibGlzaGVkIiwib25OZWdvdGlhdGVSZXF1ZXN0ZWQiLCJvbk9mZmVyIiwib25SZW1vdGVNdXRlQ2hhbmdlZCIsIm9uU3Vic2NyaWJlZFF1YWxpdHlVcGRhdGUiLCJvblRva2VuUmVmcmVzaCIsIm9uVHJpY2tsZSIsIm9uQ2xvc2UiLCJTaWduYWwiLCJyZXF1ZXN0UXVldWUiLCJxdWV1ZWRSZXF1ZXN0cyIsImNsb3NpbmdMb2NrIiwiY29ubmVjdGlvbkxvY2siLCJ0b2tlbiIsImFib3J0U2lnbmFsIiwicmVzIiwicmVjb25uZWN0IiwiY2xlYXJQaW5nSW50ZXJ2YWwiLCJyZWNvbm5lY3RSZWFzb24iLCJjb25uZWN0T3B0aW9ucyIsImNsaWVudEluZm8iLCJjcmVhdGVDb25uZWN0aW9uUGFyYW1zIiwicnRjVXJsIiwidmFsaWRhdGVVcmwiLCJhYm9ydEhhbmRsZXIiLCJ3c1RpbWVvdXQiLCJ3ZWJzb2NrZXRUaW1lb3V0IiwiYWJvcnRlZCIsInJlZGFjdGVkVXJsIiwid3MiLCJXZWJTb2NrZXQiLCJiaW5hcnlUeXBlIiwib25vcGVuIiwiQ09OTkVDVEVEIiwicmVzcCIsImZldGNoIiwidG9GaXhlZCIsImhhbmRsZVdTRXJyb3IiLCJzaG91bGRQcm9jZXNzTWVzc2FnZSIsInBpbmdUaW1lb3V0RHVyYXRpb24iLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbER1cmF0aW9uIiwicGluZ0ludGVydmFsIiwidGltZW91dCIsImludGVydmFsIiwic3RhcnRQaW5nSW50ZXJ2YWwiLCJzaWduYWxMYXRlbmN5IiwiaGFuZGxlU2lnbmFsUmVzcG9uc2UiLCJvbmNsb3NlIiwid2FzQ2xlYW4iLCJoYW5kbGVPbkNsb3NlIiwidXBkYXRlU3RhdGUiLCJjbG9zZVByb21pc2UiLCJDTE9TSU5HIiwicmFjZSIsInNlbmRPZmZlciIsIm9mZmVyIiwib2ZmZXJTZHAiLCJzZW5kUmVxdWVzdCIsInRvUHJvdG9TZXNzaW9uRGVzY3JpcHRpb24iLCJzZW5kQW5zd2VyIiwiYW5zd2VyIiwiYW5zd2VyU2RwIiwic2VuZEljZUNhbmRpZGF0ZSIsImNhbmRpZGF0ZUluaXQiLCJzZW5kTXV0ZVRyYWNrIiwic2VuZEFkZFRyYWNrIiwic2VuZFVwZGF0ZUxvY2FsTWV0YWRhdGEiLCJtZXRhZGF0YV8xIiwibmFtZV8xIiwibWV0YWRhdGEiLCJfdGhpczIiLCJyZXF1ZXN0SWQiLCJzZW5kVXBkYXRlVHJhY2tTZXR0aW5ncyIsInNldHRpbmdzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvbiIsInN1YiIsInNlbmRTeW5jU3RhdGUiLCJzeW5jIiwic2VuZFVwZGF0ZVZpZGVvTGF5ZXJzIiwibGF5ZXJzIiwic2VuZFVwZGF0ZVN1YnNjcmlwdGlvblBlcm1pc3Npb25zIiwiYWxsUGFydGljaXBhbnRzIiwidHJhY2tQZXJtaXNzaW9ucyIsInNlbmRTaW11bGF0ZVNjZW5hcmlvIiwic2NlbmFyaW8iLCJzZW5kUGluZyIsInNlbmRVcGRhdGVMb2NhbEF1ZGlvVHJhY2siLCJmZWF0dXJlcyIsInNlbmRMZWF2ZSIsImFjdGlvbiIsIkRJU0NPTk5FQ1QiLCJtZXNzYWdlXzEiLCJfdGhpczMiLCJmcm9tUXVldWUiLCJjYW5RdWV1ZSIsIk9QRU4iLCJwaW5nSGFuZGxlZCIsInNkIiwiZnJvbVByb3RvU2Vzc2lvbkRlc2NyaXB0aW9uIiwib25QYXJ0aWNpcGFudFVwZGF0ZSIsInBhcnRpY2lwYW50cyIsIm9uU3BlYWtlcnNDaGFuZ2VkIiwic3BlYWtlcnMiLCJvblJvb21VcGRhdGUiLCJvbkNvbm5lY3Rpb25RdWFsaXR5Iiwib25TdHJlYW1TdGF0ZVVwZGF0ZSIsIm9uU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsIm9uU3Vic2NyaXB0aW9uRXJyb3IiLCJsYXN0UGluZ1RpbWVzdGFtcCIsInJlc2V0UGluZ1RpbWVvdXQiLCJvblJlcXVlc3RSZXNwb25zZSIsIm9uTG9jYWxUcmFja1N1YnNjcmliZWQiLCJtc2dDYXNlIiwic2V0UmVjb25uZWN0ZWQiLCJvbkNsb3NlQ2FsbGJhY2siLCJjbGVhclBpbmdUaW1lb3V0IiwidG9VVENTdHJpbmciLCJyc2QiLCJVUkxTZWFyY2hQYXJhbXMiLCJhdXRvU3Vic2NyaWJlIiwiZGV2aWNlTW9kZWwiLCJicm93c2VyVmVyc2lvbiIsImFkYXB0aXZlU3RyZWFtIiwiY29ubmVjdGlvbiIsImxpYiIsInBhcnNlciIsImdyYW1tYXIiLCJoYXNSZXF1aXJlZEdyYW1tYXIiLCJyZXF1aXJlR3JhbW1hciIsImdyYW1tYXIkMSIsInJlZyIsInUiLCJyYXRlIiwic3VidHlwZSIsImNvbmZpZyIsInNlc3Npb25Db25maWciLCJzdHIiLCJyYWRkciIsInRjcHR5cGUiLCJnZW5lcmF0aW9uIiwiZGlyMiIsImNsa3NyY0V4dCIsIm1lZGlhQ2xvY2tWYWx1ZSIsInJhdGVOdW1lcmF0b3IiLCJyYXRlRGVub21pbmF0b3IiLCJvYmpzIiwiaGFzUmVxdWlyZWRQYXJzZXIiLCJyZXF1aXJlUGFyc2VyIiwidG9JbnRJZkludCIsImF0dGFjaFByb3BlcnRpZXMiLCJyYXdOYW1lIiwicGFyc2VSZWciLCJjb250ZW50IiwibmVlZHNCbGFuayIsImtleUxvY2F0aW9uIiwidmFsaWRMaW5lIiwic2Vzc2lvbiIsInJ0cCIsImZtdHAiLCJwYXJhbVJlZHVjZXIiLCJhY2MiLCJwYXJzZVBhcmFtcyIsInBhcnNlRm10cENvbmZpZyIsInBhcnNlUGF5bG9hZHMiLCJwYXJzZVJlbW90ZUNhbmRpZGF0ZXMiLCJjYW5kaWRhdGVzIiwicGFyc2VJbWFnZUF0dHJpYnV0ZXMiLCJwYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QiLCJzY2lkIiwicGF1c2VkIiwiaGFzUmVxdWlyZWRXcml0ZXIiLCJyZXF1aXJlV3JpdGVyIiwiZm9ybWF0UmVnRXhwIiwiZm9ybWF0U3RyIiwibWFrZUxpbmUiLCJkZWZhdWx0T3V0ZXJPcmRlciIsImRlZmF1bHRJbm5lck9yZGVyIiwicGF5bG9hZHMiLCJvdXRlck9yZGVyIiwiaW5uZXJPcmRlciIsImhhc1JlcXVpcmVkTGliIiwicmVxdWlyZUxpYiIsIndyaXRlIiwibGliRXhwb3J0cyIsImlzSW1tZWRpYXRlIiwiY2FsbGJhY2siLCJtYXhXYWl0IiwiY2FuY2VsIiwic3RhcnRCaXRyYXRlRm9yU1ZDIiwiZGVib3VuY2VJbnRlcnZhbCIsIlBDRXZlbnRzIiwiTmVnb3RpYXRpb25TdGFydGVkIiwiTmVnb3RpYXRpb25Db21wbGV0ZSIsIlJUUFZpZGVvUGF5bG9hZFR5cGVzIiwiUENUcmFuc3BvcnQiLCJjcmVhdGVQQyIsImRkRXh0SUQiLCJwZW5kaW5nQ2FuZGlkYXRlcyIsInJlc3RhcnRpbmdJY2UiLCJyZW5lZ290aWF0ZSIsInRyYWNrQml0cmF0ZXMiLCJyZW1vdGVTdGVyZW9NaWRzIiwicmVtb3RlTmFja01pZHMiLCJuZWdvdGlhdGUiLCJjcmVhdGVBbmRTZW5kT2ZmZXIiLCJvbmNvbm5lY3Rpb25zdGF0ZWNoYW5nZSIsIm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlIiwib25pY2VnYXRoZXJpbmdzdGF0ZWNoYW5nZSIsIm9uZGF0YWNoYW5uZWwiLCJvbm5lZ290aWF0aW9ubmVlZGVkIiwib25zaWduYWxpbmdzdGF0ZWNoYW5nZSIsIm9uaWNlY2FuZGlkYXRlIiwib250cmFjayIsIm9uSWNlQ2FuZGlkYXRlIiwib25pY2VjYW5kaWRhdGVlcnJvciIsIm9uSWNlQ2FuZGlkYXRlRXJyb3IiLCJvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uU2lnbmFsaW5nU3RhdGVjaGFuZ2UiLCJvbkNvbm5lY3Rpb25TdGF0ZUNoYW5nZSIsIm9uRGF0YUNoYW5uZWwiLCJvblRyYWNrIiwiaXNJQ0VDb25uZWN0ZWQiLCJyZW1vdGVEZXNjcmlwdGlvbiIsIm11bmdlZFNEUCIsInN0ZXJlb01pZHMiLCJuYWNrTWlkcyIsImV4dHJhY3RTdGVyZW9BbmROYWNrQXVkaW9Gcm9tT2ZmZXIiLCJzZHBQYXJzZWQiLCJ0cmFja2JyIiwiY29kZWNQYXlsb2FkIiwicGF5bG9hZCIsImZtdHBGb3VuZCIsImF0dHIiLCJtYXhiciIsInNldE11bmdlZFNEUCIsImljZVJlc3RhcnQiLCJjdXJyZW50U0QiLCJlbnN1cmVJUEFkZHJNYXRjaFZlcnNpb24iLCJlbnN1cmVBdWRpb05hY2tBbmRTdGVyZW8iLCJtc2lkIiwiZW5zdXJlVmlkZW9EREV4dGVuc2lvbkZvclNWQyIsInN0YXJ0Qml0cmF0ZSIsInJvdW5kIiwiY3JlYXRlQW5kU2V0QW5zd2VyIiwiZGF0YUNoYW5uZWxEaWN0IiwidHJhbnNjZWl2ZXJJbml0Iiwic2V0VHJhY2tDb2RlY0JpdHJhdGUiLCJzZXRDb25maWd1cmF0aW9uIiwicnRjQ29uZmlnIiwiY2FuUmVtb3ZlVHJhY2siLCJnZXRDb25uZWN0aW9uU3RhdGUiLCJnZXRJQ0VDb25uZWN0aW9uU3RhdGUiLCJnZXRTaWduYWxsaW5nU3RhdGUiLCJnZXRMb2NhbERlc2NyaXB0aW9uIiwibG9jYWxEZXNjcmlwdGlvbiIsImdldFJlbW90ZURlc2NyaXB0aW9uIiwiZ2V0Q29ubmVjdGVkQWRkcmVzcyIsInNlbGVjdGVkQ2FuZGlkYXRlUGFpcklkIiwiY2FuZGlkYXRlUGFpcnMiLCJzZWxlY3RlZCIsInNlbGVjdGVkSUQiLCJyZW1vdGVDYW5kaWRhdGVJZCIsIm11bmdlZCIsInJlbW90ZSIsIm9yaWdpbmFsU2RwIiwicmVtb3RlU2RwIiwiZGRGb3VuZCIsIm1heElEIiwib3B1c1BheWxvYWQiLCJydGNwRmIiLCJpc1Y2IiwiZGVmYXVsdFZpZGVvQ29kZWMiLCJwdWJsaXNoRGVmYXVsdHMiLCJhdWRpb1ByZXNldCIsImR0eCIsInJlZCIsImZvcmNlU3RlcmVvIiwic2ltdWxjYXN0Iiwic2NyZWVuU2hhcmVFbmNvZGluZyIsInN0b3BNaWNUcmFja09uTXV0ZSIsInZpZGVvQ29kZWMiLCJiYWNrdXBDb2RlYyIsImF1dG9HYWluQ29udHJvbCIsImVjaG9DYW5jZWxsYXRpb24iLCJub2lzZVN1cHByZXNzaW9uIiwidm9pY2VJc29sYXRpb24iLCJyb29tT3B0aW9uRGVmYXVsdHMiLCJkeW5hY2FzdCIsInN0b3BMb2NhbFRyYWNrT25VbnB1Ymxpc2giLCJyZWNvbm5lY3RQb2xpY3kiLCJkaXNjb25uZWN0T25QYWdlTGVhdmUiLCJ3ZWJBdWRpb01peCIsInJvb21Db25uZWN0T3B0aW9uRGVmYXVsdHMiLCJtYXhSZXRyaWVzIiwicGVlckNvbm5lY3Rpb25UaW1lb3V0IiwiUENUcmFuc3BvcnRTdGF0ZSIsIlBDVHJhbnNwb3J0TWFuYWdlciIsIm5lZWRzUHVibGlzaGVyIiwiaXNQdWJsaXNoZXJDb25uZWN0aW9uUmVxdWlyZWQiLCJuZWVkc1N1YnNjcmliZXIiLCJpc1N1YnNjcmliZXJDb25uZWN0aW9uUmVxdWlyZWQiLCJzdWJzY3JpYmVyUHJpbWFyeSIsInByZXZpb3VzU3RhdGUiLCJjb25uZWN0aW9uU3RhdGVzIiwicmVxdWlyZWRUcmFuc3BvcnRzIiwic3QiLCJGQUlMRUQiLCJDTE9TRUQiLCJORVciLCJvblN0YXRlQ2hhbmdlIiwicHVibGlzaGVyIiwic3Vic2NyaWJlciIsIlBDTWFuYWdlciIsIlBVQkxJU0hFUiIsIlNVQlNDUklCRVIiLCJvblB1Ymxpc2hlck9mZmVyIiwicmVtb3RlT2ZmZXJMb2NrIiwicmVxdWlyZVB1Ymxpc2hlciIsInJlcXVpcmUiLCJyZXF1aXJlU3Vic2NyaWJlciIsImNyZWF0ZUFuZFNlbmRQdWJsaXNoZXJPZmZlciIsInNldFB1Ymxpc2hlckFuc3dlciIsInRyaWdnZXJJY2VSZXN0YXJ0IiwiY3JlYXRlU3Vic2NyaWJlckFuc3dlckZyb21PZmZlciIsIlJUQ1NkcFR5cGUiLCJ1cGRhdGVDb25maWd1cmF0aW9uIiwiZW5zdXJlUENUcmFuc3BvcnRDb25uZWN0aW9uIiwiYWJvcnRDb250cm9sbGVyIiwidHJhbnNwb3J0IiwiZW5zdXJlVHJhbnNwb3J0Q29ubmVjdGVkIiwibmVnb3RpYXRpb25UaW1lb3V0Iiwic2lnbmFsIiwiYWRkUHVibGlzaGVyVHJhbnNjZWl2ZXIiLCJhZGRQdWJsaXNoZXJUcmFjayIsImNyZWF0ZVB1Ymxpc2hlckRhdGFDaGFubmVsIiwidHJhbnNwb3J0cyIsInBjVHJhbnNwb3J0XzEiLCJhYm9ydENvbnRyb2xsZXJfMSIsInBjVHJhbnNwb3J0IiwiY29ubmVjdFRpbWVvdXQiLCJScGNFcnJvciIsInRydW5jYXRlQnl0ZXMiLCJNQVhfTUVTU0FHRV9CWVRFUyIsIk1BWF9EQVRBX0JZVEVTIiwiZnJvbVByb3RvIiwidG9Qcm90byIsImJ1aWx0SW4iLCJFcnJvckNvZGUiLCJFcnJvck1lc3NhZ2UiLCJBUFBMSUNBVElPTl9FUlJPUiIsIkNPTk5FQ1RJT05fVElNRU9VVCIsIlJFU1BPTlNFX1RJTUVPVVQiLCJSRUNJUElFTlRfRElTQ09OTkVDVEVEIiwiUkVTUE9OU0VfUEFZTE9BRF9UT09fTEFSR0UiLCJTRU5EX0ZBSUxFRCIsIlVOU1VQUE9SVEVEX01FVEhPRCIsIlJFQ0lQSUVOVF9OT1RfRk9VTkQiLCJSRVFVRVNUX1BBWUxPQURfVE9PX0xBUkdFIiwiVU5TVVBQT1JURURfU0VSVkVSIiwiVU5TVVBQT1JURURfVkVSU0lPTiIsIk1BWF9QQVlMT0FEX0JZVEVTIiwiZW5jb2RlciIsIm1heEJ5dGVzIiwibW9uaXRvckZyZXF1ZW5jeSIsImNvbXB1dGVCaXRyYXRlIiwiY3VycmVudFN0YXRzIiwicHJldlN0YXRzIiwiYnl0ZXNOb3ciLCJieXRlc1ByZXYiLCJieXRlc1JlY2VpdmVkIiwiYnl0ZXNTZW50IiwiZGVmYXVsdERpbWVuc2lvbnNUaW1lb3V0IiwiTG9jYWxUcmFjayIsIl9zZW5kZXIiLCJfY29uc3RyYWludHMiLCJ1c2VyUHJvdmlkZWRUcmFjayIsIm1hbnVhbGx5U3RvcHBlZCIsIl9pc1Vwc3RyZWFtUGF1c2VkIiwiaGFuZGxlVHJhY2tNdXRlRXZlbnQiLCJkZWJvdW5jZWRUcmFja011dGVIYW5kbGVyIiwicGF1c2VVcHN0cmVhbSIsImhhbmRsZVRyYWNrVW5tdXRlRXZlbnQiLCJyZXN1bWVVcHN0cmVhbSIsImhhbmRsZUVuZGVkIiwicmVhY3F1aXJlVHJhY2siLCJFbmRlZCIsInByb3ZpZGVkQnlVc2VyIiwibXV0ZUxvY2siLCJwYXVzZVVwc3RyZWFtTG9jayIsInByb2Nlc3NvckxvY2siLCJyZXN0YXJ0TG9jayIsInNldE1lZGlhU3RyZWFtVHJhY2siLCJnZXRDb25zdHJhaW50cyIsImRpbWVuc2lvbnMiLCJpc1Vwc3RyZWFtUGF1c2VkIiwiaXNVc2VyUHJvdmlkZWQiLCJwcm9jZXNzZWRUcmFjayIsImdldFNvdXJjZVRyYWNrU2V0dGluZ3MiLCJuZXdUcmFjayIsInByb2Nlc3NvckVsZW1lbnQiLCJyZXN0YXJ0IiwicmVwbGFjZVRyYWNrIiwid2FpdEZvckRpbWVuc2lvbnMiLCJzdGFydGVkIiwiZGltcyIsInNldERldmljZUlkIiwicmVzdGFydFRyYWNrIiwiZ2V0RGV2aWNlSWQiLCJub3JtYWxpemUiLCJtdXRlIiwic2V0VHJhY2tNdXRlZCIsInVubXV0ZSIsInVzZXJQcm92aWRlZE9yT3B0aW9ucyIsInN0b3BQcm9jZXNzb3IiLCJvdGhlckNvbnN0cmFpbnRzIiwic3RyZWFtQ29uc3RyYWludHMiLCJSZXN0YXJ0ZWQiLCJNdXRlZCIsIlVubXV0ZWQiLCJuZWVkc1JlQWNxdWlzaXRpb24iLCJfc3VwZXIiLCJkZXN0cm95IiwiVXBzdHJlYW1QYXVzZWQiLCJVcHN0cmVhbVJlc3VtZWQiLCJnZXRSVENTdGF0c1JlcG9ydCIsInN0YXRzUmVwb3J0Iiwic2V0UHJvY2Vzc29yIiwicHJvY2Vzc29yXzEiLCJzaG93UHJvY2Vzc2VkU3RyZWFtTG9jYWxseSIsInByb2Nlc3Nvck9wdGlvbnMiLCJUcmFja1Byb2Nlc3NvclVwZGF0ZSIsImdldFByb2Nlc3NvciIsIl90aGlzNCIsImtlZXBFbGVtZW50IiwicmVtb3ZlIiwiTG9jYWxBdWRpb1RyYWNrIiwiZW5oYW5jZWROb2lzZUNhbmNlbGxhdGlvbiIsImlzS3Jpc3BOb2lzZUZpbHRlckVuYWJsZWQiLCJzdG9wT25NdXRlIiwibW9uaXRvclNlbmRlciIsImdldFNlbmRlclN0YXRzIiwiaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckVuYWJsZSIsIkF1ZGlvVHJhY2tGZWF0dXJlVXBkYXRlIiwiVEZfRU5IQU5DRURfTk9JU0VfQ0FOQ0VMTEFUSU9OIiwiaGFuZGxlS3Jpc3BOb2lzZUZpbHRlckRpc2FibGUiLCJjaGVja0ZvclNpbGVuY2UiLCJkZXZpY2VIYXNDaGFuZ2VkIiwic3RhcnRNb25pdG9yIiwic2V0QXVkaW9Db250ZXh0IiwiYXVkaW9TdGF0cyIsInBhY2tldHNTZW50IiwicGFja2V0c0xvc3QiLCJyb3VuZFRyaXBUaW1lIiwiaml0dGVyIiwidHJhY2tJc1NpbGVudCIsIkF1ZGlvU2lsZW5jZURldGVjdGVkIiwibWVkaWFUcmFja1RvTG9jYWxUcmFjayIsIkxvY2FsVmlkZW9UcmFjayIsInByZXNldHMxNjkiLCJwcmVzZXRzNDMiLCJwcmVzZXRzU2NyZWVuU2hhcmUiLCJkZWZhdWx0U2ltdWxjYXN0UHJlc2V0czE2OSIsImRlZmF1bHRTaW11bGNhc3RQcmVzZXRzNDMiLCJjb21wdXRlRGVmYXVsdFNjcmVlblNoYXJlU2ltdWxjYXN0UHJlc2V0cyIsImZyb21QcmVzZXQiLCJmcHMiLCJ2aWRlb1JpZHMiLCJjb21wdXRlVmlkZW9FbmNvZGluZ3MiLCJpc1NjcmVlblNoYXJlIiwidmlkZW9FbmNvZGluZyIsInVzZVNpbXVsY2FzdCIsInNjYWxhYmlsaXR5TW9kZSIsImRldGVybWluZUFwcHJvcHJpYXRlRW5jb2RpbmciLCJzb3VyY2VGcmFtZXJhdGUiLCJzbSIsIlNjYWxhYmlsaXR5TW9kZSIsInNwYXRpYWwiLCJiaXRyYXRlc1JhdGlvIiwic3VmZml4IiwibmV0d29ya1ByaW9yaXR5IiwicHJlc2V0cyIsInNvcnRQcmVzZXRzIiwic2NyZWVuU2hhcmVTaW11bGNhc3RMYXllcnMiLCJkZWZhdWx0U2ltdWxjYXN0TGF5ZXJzIiwidmlkZW9TaW11bGNhc3RMYXllcnMiLCJtaWRQcmVzZXQiLCJsb3dQcmVzZXQiLCJlbmNvZGluZ3NGcm9tUHJlc2V0cyIsImNvbXB1dGVUcmFja0JhY2t1cEVuY29kaW5ncyIsInNlcnZlclJlcXVlc3RlZCIsInByZXNldHNGb3JSZXNvbHV0aW9uIiwicHJlc2V0IiwiYXNwZWN0IiwiYWJzIiwiY2FuU2V0UHJpb3JpdHkiLCJ0b3BGcmFtZXJhdGUiLCJub3RpZnlPbmNlIiwiYUVuYyIsImJFbmMiLCJyZXN1bHRzIiwidGVtcG9yYWwiLCJnZXREZWZhdWx0RGVncmFkYXRpb25QcmVmZXJlbmNlIiwicmVmcmVzaFN1YnNjcmliZWRDb2RlY0FmdGVyTmV3Q29kZWMiLCJkZWdyYWRhdGlvblByZWZlcmVuY2UiLCJzZXREZWdyYWRhdGlvblByZWZlcmVuY2UiLCJzaW11bGNhc3RDb2RlY3MiLCJzdGF0c01hcCIsInRvdGFsQml0cmF0ZSIsInNlbmRlckxvY2siLCJpc1NpbXVsY2FzdCIsInNpZ25hbENsaWVudCIsImVfMSIsIl9nIiwic2MiLCJlXzFfMSIsInJldHVybiIsImVfMiIsImVfMl8xIiwiaXRlbXMiLCJ2cyIsImZyYW1lSGVpZ2h0IiwiZnJhbWVXaWR0aCIsImZyYW1lc1BlclNlY29uZCIsImZyYW1lc1NlbnQiLCJmaXJDb3VudCIsInBsaUNvdW50IiwibmFja0NvdW50IiwicXVhbGl0eUxpbWl0YXRpb25SZWFzb24iLCJxdWFsaXR5TGltaXRhdGlvbkR1cmF0aW9ucyIsInF1YWxpdHlMaW1pdGF0aW9uUmVzb2x1dGlvbkNoYW5nZXMiLCJyZXRyYW5zbWl0dGVkUGFja2V0c1NlbnQiLCJ0YXJnZXRCaXRyYXRlIiwic2V0UHVibGlzaGluZ1F1YWxpdHkiLCJtYXhRdWFsaXR5IiwicXVhbGl0aWVzIiwicSIsIkxPVyIsIkhJR0giLCJxdWFsaXR5Iiwic2V0UHVibGlzaGluZ0xheWVycyIsImVfMyIsImVfM18xIiwiZV80IiwiX2giLCJlXzRfMSIsInByZWZlcmVuY2UiLCJhZGRTaW11bGNhc3RUcmFjayIsInNpbXVsY2FzdENvZGVjSW5mbyIsInNldFNpbXVsY2FzdFRyYWNrU2VuZGVyIiwic3Vic2NyaWJlZENvZGVjcyIsInNldFB1Ymxpc2hpbmdDb2RlY3MiLCJjb2RlY3NfMSIsImNvZGVjc18xXzEiLCJlXzUiLCJjdXJyZW50Q29kZWMiLCJuZXdDb2RlY3MiLCJzZXRQdWJsaXNoaW5nTGF5ZXJzRm9yU2VuZGVyIiwiZV81XzEiLCJzZW5kZXJFbmNvZGluZ3MiLCJoYXNDaGFuZ2VkIiwiY2xvc2FibGVTcGF0aWFsIiwibW9kZSIsIk9GRiIsImFjdGl2ZSIsIm9yaWdpbmFsTW9kZSIsInZpZGVvUXVhbGl0eUZvclJpZCIsInN1YnNjcmliZWRRdWFsaXR5IiwibWF4RnJhbWVSYXRlIiwiTUVESVVNIiwidmlkZW9MYXllcnNGcm9tRW5jb2RpbmdzIiwic3ZjIiwiYml0cmF0ZSIsImVuY29kaW5nU00iLCJyZXNSYXRpbyIsInNjYWxlIiwibG9zc3lEYXRhQ2hhbm5lbCIsInJlbGlhYmxlRGF0YUNoYW5uZWwiLCJtaW5SZWNvbm5lY3RXYWl0IiwibGVhdmVSZWNvbm5lY3QiLCJQQ1N0YXRlIiwiUlRDRW5naW5lIiwiaXNDbG9zZWQiLCJfaXNDbG9zZWQiLCJwZW5kaW5nUmVjb25uZWN0IiwicmVjb25uZWN0VGltZW91dCIsImZ1bGxSZWNvbm5lY3RPbk5leHQiLCJwY1N0YXRlIiwiTmV3IiwicGVuZGluZ1RyYWNrUmVzb2x2ZXJzIiwicmVjb25uZWN0QXR0ZW1wdHMiLCJyZWNvbm5lY3RTdGFydCIsImF0dGVtcHRpbmdSZWNvbm5lY3QiLCJqb2luQXR0ZW1wdHMiLCJtYXhKb2luQXR0ZW1wdHMiLCJzaG91bGRGYWlsTmV4dCIsImhhbmRsZURhdGFDaGFubmVsIiwicmVsaWFibGVEQ1N1YiIsImxvc3N5RENTdWIiLCJoYW5kbGVEYXRhTWVzc2FnZSIsImRhdGFQcm9jZXNzTG9jayIsIkJsb2IiLCJhcnJheUJ1ZmZlciIsImRwIiwiQWN0aXZlU3BlYWtlcnNVcGRhdGUiLCJhcHBseVVzZXJEYXRhQ29tcGF0IiwiRGF0YVBhY2tldFJlY2VpdmVkIiwiaGFuZGxlRGF0YUVycm9yIiwiY3VycmVudFRhcmdldCIsImNoYW5uZWxLaW5kIiwibWF4UmV0cmFuc21pdHMiLCJFcnJvckV2ZW50IiwiaGFuZGxlQnVmZmVyZWRBbW91bnRMb3ciLCJMT1NTWSIsIlJFTElBQkxFIiwidXBkYXRlQW5kRW1pdERDQnVmZmVyU3RhdHVzIiwiaGFuZGxlRGlzY29ubmVjdCIsImRpc2Nvbm5lY3RSZWFzb24iLCJkaXNjb25uZWN0IiwiRGlzY29ubmVjdGVkIiwiZGVsYXkiLCJnZXROZXh0UmV0cnlEZWxheSIsImVsYXBzZWRNcyIsImNsZWFyUmVjb25uZWN0VGltZW91dCIsInJlZ2lvblVybFByb3ZpZGVyIiwidXBkYXRlVG9rZW4iLCJhdHRlbXB0UmVjb25uZWN0Iiwid2FpdEZvclJlc3RhcnRlZCIsIm9uUmVzdGFydGVkIiwib25EaXNjb25uZWN0ZWQiLCJpc0J1ZmZlclN0YXR1c0xvdyIsImRjQnVmZmVyU3RhdHVzIiwiRENCdWZmZXJTdGF0dXNDaGFuZ2VkIiwiZGF0YUNoYW5uZWxGb3JLaW5kIiwiYnVmZmVyZWRBbW91bnQiLCJidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCIsImhhbmRsZUJyb3dzZXJPbkxpbmUiLCJjbGllbnQiLCJSUl9TSUdOQUxfRElTQ09OTkVDVEVEIiwiRW5naW5lIiwiZXhwU2lnbmFsTGF0ZW5jeSIsInJlZ2lzdGVyT25MaW5lTGlzdGVuZXIiLCJ1cGRhdGVzIiwidXBkYXRlIiwiU3RyZWFtU3RhdGVDaGFuZ2VkIiwicmVzcG9uc2UiLCJTaWduYWxSZXF1ZXN0UmVzcG9uc2UiLCJsYXRlc3RKb2luUmVzcG9uc2UiLCJyb29tSUQiLCJwSUQiLCJzaWduYWxPcHRzIiwic2V0dXBTaWduYWxDbGllbnRDYWxsYmFja3MiLCJqb2luUmVzcG9uc2UiLCJwY01hbmFnZXIiLCJjb25maWd1cmUiLCJmYXN0UHVibGlzaCIsImNsaWVudENvbmZpZ3VyYXRpb24iLCJDbG9zaW5nIiwiZGVyZWdpc3Rlck9uTGluZUxpc3RlbmVyIiwiY2xlYXJQZW5kaW5nUmVjb25uZWN0IiwiY2xlYW51cFBlZXJDb25uZWN0aW9ucyIsImNsZWFudXBDbGllbnQiLCJkY0NsZWFudXAiLCJvbmJ1ZmZlcmVkYW1vdW50bG93Iiwib25jbG9zaW5nIiwibG9zc3lEQyIsInJlbGlhYmxlREMiLCJwdWJsaWNhdGlvblRpbWVvdXQiLCJ1cGRhdGVNdXRlU3RhdHVzIiwiZGF0YVN1YnNjcmliZXJSZWFkeVN0YXRlIiwiZ2V0Q29ubmVjdGVkU2VydmVyQWRkcmVzcyIsInNldFJlZ2lvblVybFByb3ZpZGVyIiwicHJvdmlkZXIiLCJwYXJ0aWNpcGFudFNpZCIsIm1ha2VSVENDb25maWd1cmF0aW9uIiwiVHJhbnNwb3J0c0NyZWF0ZWQiLCJwdWJsaXNoZXJTdGF0ZSIsInN1YnNjcmliZXJTdGF0ZSIsInB1Ymxpc2hlckNvbm5lY3Rpb25Qcm9taXNlIiwic2hvdWxkRW1pdCIsIlJSX1NVQlNDUklCRVJfRkFJTEVEIiwiUlJfUFVCTElTSEVSX0ZBSUxFRCIsImlzU2lnbmFsU2V2ZXJlZCIsImlzUENTZXZlcmVkIiwiT2ZmbGluZSIsIk1lZGlhVHJhY2tBZGRlZCIsInN1cHBvcnRPcHRpb25hbERhdGFjaGFubmVsIiwic2VydmVySW5mbyIsImNyZWF0ZURhdGFDaGFubmVscyIsIkxvY2FsVHJhY2tVbnB1Ymxpc2hlZCIsIkxvY2FsVHJhY2tTdWJzY3JpYmVkIiwiUmVtb3RlTXV0ZSIsImxlYXZlIiwicmVnaW9ucyIsInNldFNlcnZlclJlcG9ydGVkUmVnaW9ucyIsIlJFQ09OTkVDVCIsIlJFU1VNRSIsInNlcnZlclJlc3BvbnNlIiwiZTJlZUVuYWJsZWQiLCJlbmNvZGVkSW5zZXJ0YWJsZVN0cmVhbXMiLCJydGNJY2VTZXJ2ZXJzIiwiaWNlU2VydmVyIiwicnRjSWNlU2VydmVyIiwiY3JlZGVudGlhbCIsImZvcmNlUmVsYXkiLCJFTkFCTEVEIiwiaWNlVHJhbnNwb3J0UG9saWN5IiwiY29udGludWFsR2F0aGVyaW5nUG9saWN5Iiwib3JkZXJlZCIsImNyZWF0ZVNlbmRlciIsImNyZWF0ZVRyYW5zY2VpdmVyUlRDUnRwU2VuZGVyIiwiY3JlYXRlUlRDUnRwU2VuZGVyIiwiY3JlYXRlU2ltdWxjYXN0U2VuZGVyIiwic2ltdWxjYXN0VHJhY2siLCJjcmVhdGVTaW11bGNhc3RUcmFuc2NlaXZlclNlbmRlciIsInJlc3VtZUNvbm5lY3Rpb24iLCJESVNBQkxFRCIsInJlc3RhcnRDb25uZWN0aW9uIiwicmVjb3ZlcmFibGUiLCJTaWduYWxSZWNvbm5lY3RFcnJvciIsIlJSX1VOS05PV04iLCJyZWdpb25VcmwiLCJSZXN0YXJ0aW5nIiwiU2lnbmFsUmVzdGFydGVkIiwid2FpdEZvclBDUmVjb25uZWN0ZWQiLCJyZXNldEF0dGVtcHRzIiwibmV4dFJlZ2lvblVybCIsImdldE5leHRCZXN0UmVnaW9uVXJsIiwiUmVzdW1pbmciLCJTaWduYWxSZXN1bWVkIiwiUmVzdW1lZCIsIndhaXRGb3JQQ0luaXRpYWxDb25uZWN0aW9uIiwiUmVjb25uZWN0aW5nIiwicHVibGlzaFJwY1Jlc3BvbnNlIiwiZGVzdGluYXRpb25JZGVudGl0eSIsInBhY2tldCIsImRlc3RpbmF0aW9uSWRlbnRpdGllcyIsInNlbmREYXRhUGFja2V0IiwicHVibGlzaFJwY0FjayIsImVuc3VyZVB1Ymxpc2hlckNvbm5lY3RlZCIsIndhaXRGb3JCdWZmZXJTdGF0dXNMb3ciLCJvbkNsb3NpbmciLCJlbnN1cmVEYXRhVHJhbnNwb3J0Q29ubmVjdGVkIiwidHJhbnNwb3J0TmFtZSIsIm5lZWROZWdvdGlhdGlvbiIsInRhcmdldENoYW5uZWwiLCJ2ZXJpZnlUcmFuc3BvcnQiLCJBYm9ydENvbnRyb2xsZXIiLCJoYW5kbGVDbG9zZWQiLCJhYm9ydCIsInJ0cFR5cGVzIiwicmVtb3RlVHJhY2tzIiwibG9jYWxUcmFja3MiLCJwcmV2aW91c0Fuc3dlciIsInByZXZpb3VzT2ZmZXIiLCJ0cmFja1NpZHMiLCJ0cmFja1NpZHNEaXNhYmxlZCIsImlzRGVzaXJlZCIsInN1YnNjcmlwdGlvbiIsInN1YnNjcmliZSIsInBhcnRpY2lwYW50VHJhY2tzIiwicHVibGlzaFRyYWNrcyIsImRhdGFDaGFubmVscyIsImRhdGFDaGFubmVsc0luZm8iLCJmYWlsTmV4dCIsImdldEluZm8iLCJuZXdPYmoiLCJvbGRPYmoiLCJSZWdpb25VcmxQcm92aWRlciIsImxhc3RVcGRhdGVBdCIsInNldHRpbmdzQ2FjaGVUaW1lIiwiYXR0ZW1wdGVkUmVnaW9ucyIsImdldFNlcnZlclVybCIsInJlZ2lvblNldHRpbmdzIiwiZmV0Y2hSZWdpb25TZXR0aW5ncyIsInJlZ2lvbnNMZWZ0IiwicmVnaW9uIiwiYXR0ZW1wdGVkIiwibmV4dFJlZ2lvbiIsInJlZ2lvblNldHRpbmdzUmVzcG9uc2UiLCJnZXRDbG91ZENvbmZpZ1VybCIsImhlYWRlcnMiLCJhdXRob3JpemF0aW9uIiwic3RhdHVzVGV4dCIsImhvc3QiLCJCYXNlU3RyZWFtUmVhZGVyIiwiX2luZm8iLCJ0b3RhbEJ5dGVTaXplIiwiQnl0ZVN0cmVhbVJlYWRlciIsImhhbmRsZUNodW5rUmVjZWl2ZWQiLCJjdXJyZW50UHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwiZ2V0UmVhZGVyIiwicmVsZWFzZUxvY2siLCJyZWFkQWxsIiwiYWRkIiwiVGV4dFN0cmVhbVJlYWRlciIsInRvdGFsQ2h1bmtDb3VudCIsInJlY2VpdmVkQ2h1bmtzIiwiY2h1bmtJbmRleCIsInByZXZpb3VzQ2h1bmtBdEluZGV4IiwiZGVjb2RlciIsImZpbmFsU3RyaW5nIiwiQmFzZVN0cmVhbVdyaXRlciIsImRlZmF1bHRXcml0ZXIiLCJnZXRXcml0ZXIiLCJUZXh0U3RyZWFtV3JpdGVyIiwiQnl0ZVN0cmVhbVdyaXRlciIsIlJlbW90ZVRyYWNrIiwic2V0TXV0ZWQiLCJzZXRNZWRpYVN0cmVhbSIsIm9uUmVtb3ZlVHJhY2siLCJwbGF5b3V0RGVsYXlIaW50Iiwic2V0UGxheW91dERlbGF5IiwiZGVsYXlJblNlY29uZHMiLCJnZXRQbGF5b3V0RGVsYXkiLCJtb25pdG9yUmVjZWl2ZXIiLCJyZWdpc3RlclRpbWVTeW5jVXBkYXRlIiwibG9vcCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInNvdXJjZXMiLCJnZXRTeW5jaHJvbml6YXRpb25Tb3VyY2VzIiwicnRwVGltZXN0YW1wIiwiVGltZVN5bmNVcGRhdGUiLCJSZW1vdGVBdWRpb1RyYWNrIiwiYXVkaW9PdXRwdXQiLCJnZXRSZWNlaXZlclN0YXRzIiwid2ViQXVkaW9QbHVnaW5Ob2RlcyIsInNpbmtJZCIsInNldFZvbHVtZSIsImdhaW5Ob2RlIiwic2V0VGFyZ2V0QXRUaW1lIiwiX3NldFZvbHVtZSIsImVsZW1lbnRWb2x1bWUiLCJnZXRWb2x1bWUiLCJoaWdoZXN0Vm9sdW1lIiwic2V0U2lua0lkIiwibmVlZHNOZXdXZWJBdWRpb0Nvbm5lY3Rpb24iLCJjb25uZWN0V2ViQXVkaW8iLCJkaXNjb25uZWN0V2ViQXVkaW8iLCJzZXRXZWJBdWRpb1BsdWdpbnMiLCJub2RlcyIsInNvdXJjZU5vZGUiLCJsYXN0Tm9kZSIsIm5vZGUiLCJkZXN0aW5hdGlvbiIsInJlY2VpdmVyU3RhdHMiLCJjb25jZWFsZWRTYW1wbGVzIiwiY29uY2VhbG1lbnRFdmVudHMiLCJzaWxlbnRDb25jZWFsZWRTYW1wbGVzIiwic2lsZW50Q29uY2VhbG1lbnRFdmVudHMiLCJ0b3RhbEF1ZGlvRW5lcmd5IiwidG90YWxTYW1wbGVzRHVyYXRpb24iLCJSRUFDVElPTl9ERUxBWSIsIlJlbW90ZVZpZGVvVHJhY2siLCJhZGFwdGl2ZVN0cmVhbVNldHRpbmdzIiwiZWxlbWVudEluZm9zIiwiZGVib3VuY2VkSGFuZGxlUmVzaXplIiwidXBkYXRlRGltZW5zaW9ucyIsImlzQWRhcHRpdmVTdHJlYW0iLCJlbGVtZW50SW5mbyIsIkhUTUxFbGVtZW50SW5mbyIsIm9ic2VydmVFbGVtZW50SW5mbyIsInVwZGF0ZVZpc2liaWxpdHkiLCJvYnNlcnZlIiwic3RvcE9ic2VydmluZ0VsZW1lbnRJbmZvIiwic3RvcEVsZW1lbnRJbmZvcyIsInN0b3BPYnNlcnZpbmciLCJkZXRhY2hlZEVsZW1lbnRzIiwic3RvcE9ic2VydmluZ0VsZW1lbnQiLCJnZXREZWNvZGVySW1wbGVtZW50YXRpb24iLCJkZWNvZGVySW1wbGVtZW50YXRpb24iLCJjb2RlY0lEIiwiY29kZWNJZCIsImZyYW1lc0RlY29kZWQiLCJmcmFtZXNEcm9wcGVkIiwiZnJhbWVzUmVjZWl2ZWQiLCJwYWNrZXRzUmVjZWl2ZWQiLCJsYXN0VmlzaWJpbGl0eUNoYW5nZSIsInZpc2liaWxpdHlDaGFuZ2VkQXQiLCJiYWNrZ3JvdW5kUGF1c2UiLCJwYXVzZVZpZGVvSW5CYWNrZ3JvdW5kIiwiaXNQaVBNb2RlIiwicGljdHVyZUluUGljdHVyZSIsImlzVmlzaWJsZSIsInZpc2libGUiLCJsYXN0VmlzaWJsZSIsIlZpc2liaWxpdHlDaGFuZ2VkIiwibWF4V2lkdGgiLCJtYXhIZWlnaHQiLCJwaXhlbERlbnNpdHkiLCJnZXRQaXhlbERlbnNpdHkiLCJjdXJyZW50RWxlbWVudFdpZHRoIiwiY3VycmVudEVsZW1lbnRIZWlnaHQiLCJsYXN0RGltZW5zaW9ucyIsIlZpZGVvRGltZW5zaW9uc0NoYW5nZWQiLCJpc1BpUCIsImlzSW50ZXJzZWN0aW5nIiwib25WaXNpYmlsaXR5Q2hhbmdlZCIsImlzRWxlbWVudEluUGlQIiwib25FbnRlclBpUCIsImRvY3VtZW50UGljdHVyZUluUGljdHVyZSIsIm9uTGVhdmVQaVAiLCJpc0VsZW1lbnRJblZpZXdwb3J0IiwiY2xpZW50V2lkdGgiLCJjbGllbnRIZWlnaHQiLCJ1bm9ic2VydmUiLCJwaWN0dXJlSW5QaWN0dXJlRWxlbWVudCIsIndpbiIsInZpZXdwb3J0V2luZG93IiwidG9wIiwib2Zmc2V0VG9wIiwibGVmdCIsIm9mZnNldExlZnQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldEhlaWdodCIsImhpZGRlbiIsImRpc3BsYXkiLCJnZXRDb21wdXRlZFN0eWxlIiwib2Zmc2V0UGFyZW50IiwicGFnZVlPZmZzZXQiLCJpbm5lckhlaWdodCIsInBhZ2VYT2Zmc2V0IiwiaW5uZXJXaWR0aCIsIlRyYWNrUHVibGljYXRpb24iLCJtZXRhZGF0YU11dGVkIiwiaGFuZGxlTXV0ZWQiLCJoYW5kbGVVbm11dGVkIiwiUHVibGljYXRpb24iLCJzZXRUcmFjayIsImlzU3Vic2NyaWJlZCIsImF1ZGlvVHJhY2siLCJ2aWRlb1RyYWNrIiwidXBkYXRlSW5mbyIsInNpbXVsY2FzdGVkIiwiU3Vic2NyaXB0aW9uU3RhdHVzIiwiUGVybWlzc2lvblN0YXR1cyIsIkxvY2FsVHJhY2tQdWJsaWNhdGlvbiIsInRpIiwiaGFuZGxlVHJhY2tFbmRlZCIsImdldFRyYWNrRmVhdHVyZXMiLCJURl9BVVRPX0dBSU5fQ09OVFJPTCIsIlRGX0VDSE9fQ0FOQ0VMTEFUSU9OIiwiVEZfTk9JU0VfU1VQUFJFU1NJT04iLCJjaGFubmVsQ291bnQiLCJURl9TVEVSRU8iLCJURl9OT19EVFgiLCJjcmVhdGVMb2NhbFRyYWNrcyIsImF0dGVtcHRFeGFjdE1hdGNoIiwiaW50ZXJuYWxPcHRpb25zIiwicmV0cnlBdWRpb09wdGlvbnMiLCJyZXRyeVZpZGVvT3B0aW9ucyIsIm1lZGlhUHJvbWlzZSIsImlzQXVkaW8iLCJ0cmFja09wdGlvbnMiLCJ0cmFja0NvbnN0cmFpbnRzIiwiY29uT3JCb29sIiwibmV3RGV2aWNlSWQiLCJjcmVhdGVMb2NhbFZpZGVvVHJhY2siLCJjcmVhdGVMb2NhbEF1ZGlvVHJhY2siLCJjcmVhdGVMb2NhbFNjcmVlblRyYWNrcyIsInNjcmVlblZpZGVvIiwic2NyZWVuQXVkaW8iLCJDb25uZWN0aW9uUXVhbGl0eSIsInF1YWxpdHlGcm9tUHJvdG8iLCJFWENFTExFTlQiLCJFeGNlbGxlbnQiLCJHT09EIiwiR29vZCIsIlBPT1IiLCJQb29yIiwiTE9TVCIsIkxvc3QiLCJQYXJ0aWNpcGFudCIsImlzQWdlbnQiLCJwZXJtaXNzaW9ucyIsImFnZW50IiwiQUdFTlQiLCJfa2luZCIsIl9hdHRyaWJ1dGVzIiwiU1RBTkRBUkQiLCJhdWRpb0xldmVsIiwiaXNTcGVha2luZyIsIl9jb25uZWN0aW9uUXVhbGl0eSIsImF1ZGlvVHJhY2tQdWJsaWNhdGlvbnMiLCJ2aWRlb1RyYWNrUHVibGljYXRpb25zIiwiZ2V0VHJhY2tQdWJsaWNhdGlvbnMiLCJnZXRUcmFja1B1YmxpY2F0aW9uIiwiZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5TmFtZSIsImNvbm5lY3Rpb25RdWFsaXR5IiwiaXNDYW1lcmFFbmFibGVkIiwiaXNNaWNyb3Bob25lRW5hYmxlZCIsImlzU2NyZWVuU2hhcmVFbmFibGVkIiwiam9pbmVkQXQiLCJwYXJ0aWNpcGFudEluZm8iLCJfc2V0TmFtZSIsIl9zZXRNZXRhZGF0YSIsIl9zZXRBdHRyaWJ1dGVzIiwicGVybWlzc2lvbiIsInNldFBlcm1pc3Npb25zIiwibWQiLCJjaGFuZ2VkIiwicHJldk1ldGFkYXRhIiwiUGFydGljaXBhbnRNZXRhZGF0YUNoYW5nZWQiLCJQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkIiwiQXR0cmlidXRlc0NoYW5nZWQiLCJwcmV2UGVybWlzc2lvbnMiLCJjYW5QdWJsaXNoIiwiY2FuU3Vic2NyaWJlIiwiY2FuUHVibGlzaERhdGEiLCJyZWNvcmRlciIsImNhblB1Ymxpc2hTb3VyY2VzIiwiY2FuU3Vic2NyaWJlTWV0cmljcyIsIlBhcnRpY2lwYW50UGVybWlzc2lvbnNDaGFuZ2VkIiwic2V0SXNTcGVha2luZyIsInNwZWFraW5nIiwibGFzdFNwb2tlQXQiLCJJc1NwZWFraW5nQ2hhbmdlZCIsInNldENvbm5lY3Rpb25RdWFsaXR5IiwicHJldlF1YWxpdHkiLCJDb25uZWN0aW9uUXVhbGl0eUNoYW5nZWQiLCJhZGRUcmFja1B1YmxpY2F0aW9uIiwiVHJhY2tNdXRlZCIsIlRyYWNrVW5tdXRlZCIsInRyYWNrUGVybWlzc2lvblRvUHJvdG8iLCJwZXJtcyIsImFsbFRyYWNrcyIsImFsbG93QWxsIiwiYWxsb3dlZFRyYWNrU2lkcyIsIlNUUkVBTV9DSFVOS19TSVpFIiwiTG9jYWxQYXJ0aWNpcGFudCIsInJvb21ScGNIYW5kbGVycyIsInBlbmRpbmdQdWJsaXNoaW5nIiwicGVuZGluZ1B1Ymxpc2hQcm9taXNlcyIsInBhcnRpY2lwYW50VHJhY2tQZXJtaXNzaW9ucyIsImFsbFBhcnRpY2lwYW50c0FsbG93ZWRUb1N1YnNjcmliZSIsImVuY3J5cHRpb25UeXBlIiwiZW5hYmxlZFB1Ymxpc2hWaWRlb0NvZGVjcyIsInBlbmRpbmdBY2tzIiwicGVuZGluZ1Jlc3BvbnNlcyIsImhhbmRsZVJlY29ubmVjdGluZyIsInJlY29ubmVjdEZ1dHVyZSIsImhhbmRsZVJlY29ubmVjdGVkIiwidXBkYXRlVHJhY2tTdWJzY3JpcHRpb25QZXJtaXNzaW9ucyIsImhhbmRsZURpc2Nvbm5lY3RlZCIsImhhbmRsZVNpZ25hbFJlcXVlc3RSZXNwb25zZSIsInRhcmdldFJlcXVlc3QiLCJwZW5kaW5nU2lnbmFsUmVxdWVzdHMiLCJPSyIsImhhbmRsZURhdGFQYWNrZXQiLCJycGNSZXNwb25zZSIsImhhbmRsZUluY29taW5nUnBjUmVzcG9uc2UiLCJycGNBY2siLCJoYW5kbGVJbmNvbWluZ1JwY0FjayIsImFsbFBhcnRpY2lwYW50c0FsbG93ZWQiLCJvblRyYWNrVW5tdXRlZCIsIm9uVHJhY2tNdXRlZCIsIm9uVHJhY2tVcHN0cmVhbVBhdXNlZCIsIm9uVHJhY2tVcHN0cmVhbVJlc3VtZWQiLCJvblRyYWNrRmVhdHVyZVVwZGF0ZSIsImhhbmRsZVN1YnNjcmliZWRRdWFsaXR5VXBkYXRlIiwicm9vbU9wdGlvbnMiLCJuZXdDb2RlY3NfMSIsIm5ld0NvZGVjc18xXzEiLCJwdWJsaXNoQWRkaXRpb25hbENvZGVjRm9yVHJhY2siLCJzdWJzY3JpYmVkUXVhbGl0aWVzIiwiaGFuZGxlTG9jYWxUcmFja1VucHVibGlzaGVkIiwidW5wdWJsaXNoZWQiLCJ1bnB1Ymxpc2hUcmFjayIsImN1cnJlbnRQZXJtaXNzaW9ucyIsInF1ZXJ5Iiwib25jaGFuZ2UiLCJhY3RpdmVEZXZpY2VNYXAiLCJycGNIYW5kbGVycyIsImxhc3RDYW1lcmFFcnJvciIsImNhbWVyYUVycm9yIiwibGFzdE1pY3JvcGhvbmVFcnJvciIsIm1pY3JvcGhvbmVFcnJvciIsInNldE1ldGFkYXRhIiwicmVxdWVzdE1ldGFkYXRhVXBkYXRlIiwic2V0TmFtZSIsInNldEF0dHJpYnV0ZXMiLCJwZXJmb3JtYW5jZSIsIl9yZWYyIiwic2V0Q2FtZXJhRW5hYmxlZCIsInB1Ymxpc2hPcHRpb25zIiwic2V0VHJhY2tFbmFibGVkIiwic2V0TWljcm9waG9uZUVuYWJsZWQiLCJzZXRTY3JlZW5TaGFyZUVuYWJsZWQiLCJzZXRFMkVFRW5hYmxlZCIsIkdDTSIsInJlcHVibGlzaEFsbFRyYWNrcyIsInJlcHVibGlzaFByb21pc2UiLCJwZW5kaW5nVHJhY2siLCJ3YWl0Rm9yUGVuZGluZ1B1YmxpY2F0aW9uT2ZTb3VyY2UiLCJjcmVhdGVUcmFja3MiLCJjcmVhdGVTY3JlZW5UcmFja3MiLCJNZWRpYURldmljZXNFcnJvciIsInB1Ymxpc2hQcm9taXNlcyIsImxvY2FsVHJhY2siLCJwdWJsaXNoVHJhY2siLCJwdWJsaXNoZWRUcmFja3MiLCJzY3JlZW5BdWRpb1RyYWNrIiwiZW5hYmxlQ2FtZXJhQW5kTWljcm9waG9uZSIsIm1lcmdlZE9wdGlvbnNXaXRoUHJvY2Vzc29ycyIsImF1ZGlvQ2FwdHVyZURlZmF1bHRzIiwidmlkZW9DYXB0dXJlRGVmYXVsdHMiLCJBdWRpb1N0cmVhbUFjcXVpcmVkIiwiY29udGVudEhpbnQiLCJwdWJsaXNoT3JSZXB1Ymxpc2hUcmFjayIsIm9wdGlvbnNfMSIsImlzUmVwdWJsaXNoIiwiZGVmYXVsdENvbnN0cmFpbnRzIiwiZGV2aWNlS2luZCIsImV4aXN0aW5nUHVibGljYXRpb24iLCJpc1N0ZXJlb0lucHV0IiwiaXNTdGVyZW8iLCJlMmVlIiwicHVibGlzaFByb21pc2UiLCJvblNpZ25hbENvbm5lY3RlZCIsInB1Ymxpc2giLCJoYXNQZXJtaXNzaW9uc1RvUHVibGlzaCIsIl9qIiwiX2siLCJleGlzdGluZ1RyYWNrT2ZTb3VyY2UiLCJwdWJsaXNoZWRUcmFjayIsIm1pbWUiLCJkaXNhYmxlRHR4Iiwic3RlcmVvIiwiZGlzYWJsZVJlZCIsImJhY2t1cENvZGVjUG9saWN5IiwiZGVmYXVsdFJlcyIsInRyYWNrVHJhbnNjZWl2ZXIiLCJyZXRzIiwicHJpbWFyeUNvZGVjTWltZSIsInVwZGF0ZWRDb2RlYyIsInN0b3BPblVucHVibGlzaCIsImdldFB1YmxpY2F0aW9uRm9yVHJhY2siLCJwdWJMb2dDb250ZXh0IiwibmVnb3RpYXRpb25OZWVkZWQiLCJ0cmFja1NlbmRlciIsImNsZWFyIiwidW5wdWJsaXNoVHJhY2tzIiwicmVzdGFydFRyYWNrcyIsImxvY2FsUHVicyIsInB1Ymxpc2hEYXRhIiwiZGF0YV8xIiwicmVsaWFibGUiLCJ0b3BpYyIsInB1Ymxpc2hEdG1mIiwiZGlnaXQiLCJzZW5kQ2hhdE1lc3NhZ2UiLCJyYW5kb21VVUlEIiwiYXR0YWNoZWRGaWxlcyIsImF0dGFjaG1lbnRzIiwiZWRpdENoYXRNZXNzYWdlIiwiZWRpdFRleHQiLCJvcmlnaW5hbE1lc3NhZ2UiLCJzZW5kVGV4dCIsInRleHRJbkJ5dGVzIiwidG90YWxUZXh0TGVuZ3RoIiwiZmlsZUlkcyIsInByb2dyZXNzZXMiLCJoYW5kbGVQcm9ncmVzcyIsInByb2dyZXNzIiwidG90YWxQcm9ncmVzcyIsInN0cmVhbVRleHQiLCJ0b3RhbFNpemUiLCJhdHRhY2hlZFN0cmVhbUlkcyIsImZpbGUiLCJfc2VuZEZpbGUiLCJoZWFkZXIiLCJ0b3RhbExlbmd0aCIsImNvbnRlbnRIZWFkZXIiLCJyZXBseVRvU3RyZWFtSWQiLCJvcGVyYXRpb25UeXBlIiwiVVBEQVRFIiwiQ1JFQVRFIiwiY2h1bmtJZCIsImxvY2FsUCIsIldyaXRhYmxlU3RyZWFtIiwidGV4dEJ5dGVDaHVuayIsImNodW5rUGFja2V0IiwidHJhaWxlclBhY2tldCIsIm9uRW5naW5lQ2xvc2UiLCJzZW5kRmlsZSIsInN0cmVhbUJ5dGVzIiwid3JpdGVNdXRleCIsInN1YkNodW5rIiwiYnl0ZVdyaXRlciIsInBlcmZvcm1ScGMiLCJfcmVmMyIsIl90aGlzNSIsInJlc3BvbnNlVGltZW91dCIsIm1heFJvdW5kVHJpcExhdGVuY3kiLCJwdWJsaXNoUnBjUmVxdWVzdCIsImFja1RpbWVvdXRJZCIsInJlc3BvbnNlVGltZW91dElkIiwicmVzcG9uc2VQYXlsb2FkIiwicmVzcG9uc2VFcnJvciIsInJlZ2lzdGVyUnBjTWV0aG9kIiwidW5yZWdpc3RlclJwY01ldGhvZCIsInNldFRyYWNrU3Vic2NyaXB0aW9uUGVybWlzc2lvbnMiLCJyZXNwb25zZVRpbWVvdXRNcyIsImhhbmRsZVBhcnRpY2lwYW50RGlzY29ubmVjdGVkIiwicGVuZGluZ0lkZW50aXR5Iiwic2V0RW5hYmxlZFB1Ymxpc2hDb2RlY3MiLCJtdXRlZE9uU2VydmVyIiwid2FpdEZvclBlbmRpbmdUaW1lb3V0IiwicHVibGlzaFByb21pc2VFbnRyeSIsIl9yZWY0IiwiUmVtb3RlVHJhY2tQdWJsaWNhdGlvbiIsImFsbG93ZWQiLCJkaXNhYmxlZCIsImN1cnJlbnRWaWRlb1F1YWxpdHkiLCJoYW5kbGVWaXNpYmlsaXR5Q2hhbmdlIiwiZW1pdFRyYWNrVXBkYXRlIiwiaGFuZGxlVmlkZW9EaW1lbnNpb25zQ2hhbmdlIiwidmlkZW9EaW1lbnNpb25zIiwic3Vic2NyaWJlZCIsInNldFN1YnNjcmliZWQiLCJwcmV2U3RhdHVzIiwic3Vic2NyaXB0aW9uU3RhdHVzIiwicHJldlBlcm1pc3Npb24iLCJwZXJtaXNzaW9uU3RhdHVzIiwiZW1pdFN1YnNjcmlwdGlvblVwZGF0ZUlmQ2hhbmdlZCIsImVtaXRQZXJtaXNzaW9uVXBkYXRlSWZDaGFuZ2VkIiwiVW5zdWJzY3JpYmVkIiwiRGVzaXJlZCIsIlN1YnNjcmliZWQiLCJBbGxvd2VkIiwic2V0RW5hYmxlZCIsImlzTWFudWFsT3BlcmF0aW9uQWxsb3dlZCIsInNldFZpZGVvUXVhbGl0eSIsInNldFZpZGVvRGltZW5zaW9ucyIsInNldFZpZGVvRlBTIiwidmlkZW9RdWFsaXR5IiwicHJldlRyYWNrIiwic2V0QWxsb3dlZCIsInNldFN1YnNjcmlwdGlvbkVycm9yIiwiU3Vic2NyaXB0aW9uRmFpbGVkIiwicHJldk1ldGFkYXRhTXV0ZWQiLCJwcmV2aW91c1N0YXR1cyIsImN1cnJlbnRTdGF0dXMiLCJTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkIiwicHJldmlvdXNQZXJtaXNzaW9uU3RhdHVzIiwiY3VycmVudFBlcm1pc3Npb25TdGF0dXMiLCJTdWJzY3JpcHRpb25QZXJtaXNzaW9uQ2hhbmdlZCIsIlVwZGF0ZVNldHRpbmdzIiwiUmVtb3RlUGFydGljaXBhbnQiLCJmcm9tUGFydGljaXBhbnRJbmZvIiwicGkiLCJycElEIiwicmVtb3RlUGFydGljaXBhbnQiLCJ2b2x1bWVNYXAiLCJUcmFja1N1YnNjcmlwdGlvblBlcm1pc3Npb25DaGFuZ2VkIiwiVHJhY2tTdWJzY3JpcHRpb25TdGF0dXNDaGFuZ2VkIiwicHJldmlvdXNUcmFjayIsIlRyYWNrU3Vic2NyaXB0aW9uRmFpbGVkIiwiYXVkaW9QdWJsaWNhdGlvbiIsImFkZFN1YnNjcmliZWRNZWRpYVRyYWNrIiwidHJpZXNMZWZ0IiwiZ2V0VHJhY2tQdWJsaWNhdGlvbkJ5U2lkIiwiaXNWaWRlbyIsImhhc01ldGFkYXRhIiwidmFsaWRUcmFja3MiLCJuZXdUcmFja3MiLCJvbGRUcmFjayIsInNlbmRVbnB1Ymxpc2giLCJUcmFja1VucHVibGlzaGVkIiwic2V0QXVkaW9PdXRwdXQiLCJwcm9taXNlcyIsImNvbm5lY3Rpb25SZWNvbmNpbGVGcmVxdWVuY3kiLCJSb29tIiwiYWN0aXZlU3BlYWtlcnMiLCJhdWRpb0VuYWJsZWQiLCJpc1ZpZGVvUGxheWJhY2tCbG9ja2VkIiwiYnVmZmVyZWRFdmVudHMiLCJpc1Jlc3VtaW5nIiwiYnl0ZVN0cmVhbUNvbnRyb2xsZXJzIiwidGV4dFN0cmVhbUNvbnRyb2xsZXJzIiwiYnl0ZVN0cmVhbUhhbmRsZXJzIiwidGV4dFN0cmVhbUhhbmRsZXJzIiwidW5sb2NrRGlzY29ubmVjdCIsImRpc2Nvbm5lY3RMb2NrIiwiY29ubmVjdEZ1dHVyZSIsInNldEFuZEVtaXRDb25uZWN0aW9uU3RhdGUiLCJDb25uZWN0aW5nIiwiY29ubmVjdEZuIiwiYXR0ZW1wdENvbm5lY3Rpb24iLCJuZXh0VXJsIiwicmVjcmVhdGVFbmdpbmUiLCJjbGVhckNvbm5lY3Rpb25GdXR1cmVzIiwiY29ubmVjdFNpZ25hbCIsImUyZWVNYW5hZ2VyIiwic2VydmVyVmVyc2lvbiIsInNlcnZlclJlZ2lvbiIsInJvb21TaWQiLCJhcHBseUpvaW5SZXNwb25zZSIsImVuYWJsZWRQdWJsaXNoQ29kZWNzIiwic2lmVHJhaWxlciIsImhhbmRsZVBhcnRpY2lwYW50VXBkYXRlcyIsIm90aGVyUGFydGljaXBhbnRzIiwiaGFuZGxlUm9vbVVwZGF0ZSIsIm1heWJlQ3JlYXRlRW5naW5lIiwiYWNxdWlyZUF1ZGlvQ29udGV4dCIsImNvbm5PcHRpb25zIiwic2V0dXBMb2NhbFBhcnRpY2lwYW50RXZlbnRzIiwicmVzdWx0aW5nRXJyb3IiLCJvblBhZ2VMZWF2ZSIsInJlZ2lzdGVyQ29ubmVjdGlvblJlY29uY2lsZSIsImFyZ3NfMSIsInN0b3BUcmFja3MiLCJzdGFydEF1ZGlvIiwiZWxlbWVudHMiLCJhdWRpb0lkIiwiZHVtbXlBdWRpb0VsIiwiZ2V0RWxlbWVudEJ5SWQiLCJhcHBlbmQiLCJoYW5kbGVBdWRpb1BsYXliYWNrU3RhcnRlZCIsImhhbmRsZUF1ZGlvUGxheWJhY2tGYWlsZWQiLCJzdGFydFZpZGVvIiwiaGFuZGxlVmlkZW9QbGF5YmFja1N0YXJ0ZWQiLCJoYW5kbGVWaWRlb1BsYXliYWNrRmFpbGVkIiwiaGFuZGxlUmVzdGFydGluZyIsImNsZWFyQ29ubmVjdGlvblJlY29uY2lsZSIsImhhbmRsZVNpZ25hbFJlc3RhcnRlZCIsIlJlY29ubmVjdGVkIiwiZW1pdEJ1ZmZlcmVkRXZlbnRzIiwicGFydGljaXBhbnRJbmZvcyIsInNpZFRvSWRlbnRpdHkiLCJnZXRPckNyZWF0ZVBhcnRpY2lwYW50IiwiaGFuZGxlQWN0aXZlU3BlYWtlcnNVcGRhdGUiLCJzZWVuU2lkcyIsInNwZWFrZXIiLCJnZXRSZW1vdGVQYXJ0aWNpcGFudEJ5U2lkIiwiZW1pdFdoZW5Db25uZWN0ZWQiLCJBY3RpdmVTcGVha2Vyc0NoYW5nZWQiLCJoYW5kbGVTcGVha2Vyc0NoYW5nZWQiLCJzcGVha2VyVXBkYXRlcyIsImxhc3RTcGVha2VycyIsImhhbmRsZVN0cmVhbVN0YXRlVXBkYXRlIiwic3RyZWFtU3RhdGVVcGRhdGUiLCJzdHJlYW1TdGF0ZXMiLCJuZXdTdHJlYW1TdGF0ZSIsIlRyYWNrU3RyZWFtU3RhdGVDaGFuZ2VkIiwiaGFuZGxlU3Vic2NyaXB0aW9uUGVybWlzc2lvblVwZGF0ZSIsImhhbmRsZVN1YnNjcmlwdGlvbkVycm9yIiwiaGFuZGxlVXNlclBhY2tldCIsImhhbmRsZVRyYW5zY3JpcHRpb24iLCJoYW5kbGVTaXBEdG1mIiwiaGFuZGxlQ2hhdE1lc3NhZ2UiLCJoYW5kbGVNZXRyaWNzIiwiaGFuZGxlU3RyZWFtSGVhZGVyIiwiaGFuZGxlU3RyZWFtQ2h1bmsiLCJoYW5kbGVTdHJlYW1UcmFpbGVyIiwicnBjIiwiaGFuZGxlSW5jb21pbmdScGNSZXF1ZXN0IiwidXNlclBhY2tldCIsIkRhdGFSZWNlaXZlZCIsIlNpcERUTUZSZWNlaXZlZCIsImJ1ZmZlcmVkU2VnbWVudHMiLCJfcmVtb3RlUGFydGljaXBhbnQiLCJ0cmFuc2NyaWJlZFBhcnRpY2lwYW50SWRlbnRpdHkiLCJ0cmFuc2NyaXB0aW9uUmVjZWl2ZWRUaW1lcyIsIlRyYW5zY3JpcHRpb25SZWNlaXZlZCIsImNoYXRNZXNzYWdlIiwibWV0cmljcyIsIk1ldHJpY3NSZWNlaXZlZCIsImNhblBsYXliYWNrQXVkaW8iLCJBdWRpb1BsYXliYWNrU3RhdHVzQ2hhbmdlZCIsIlZpZGVvUGxheWJhY2tTdGF0dXNDaGFuZ2VkIiwiaGFuZGxlRGV2aWNlQ2hhbmdlIiwiYXZhaWxhYmxlRGV2aWNlcyIsImF2YWlsYWJsZURldmljZSIsInByZXZpb3VzRGV2aWNlIiwiZ2V0QWN0aXZlRGV2aWNlIiwiQWN0aXZlRGV2aWNlQ2hhbmdlZCIsImtpbmRzIiwiZGV2aWNlc09mS2luZCIsImFjdGl2ZURldmljZSIsInN3aXRjaEFjdGl2ZURldmljZSIsImRldmljZUluZm8iLCJNZWRpYURldmljZXNDaGFuZ2VkIiwib2xkUm9vbSIsInJvb21JbmZvIiwiUm9vbU1ldGFkYXRhQ2hhbmdlZCIsImFjdGl2ZVJlY29yZGluZyIsIlJlY29yZGluZ1N0YXR1c0NoYW5nZWQiLCJoYW5kbGVDb25uZWN0aW9uUXVhbGl0eVVwZGF0ZSIsIm9uTG9jYWxQYXJ0aWNpcGFudE1ldGFkYXRhQ2hhbmdlZCIsIm9uTG9jYWxQYXJ0aWNpcGFudE5hbWVDaGFuZ2VkIiwib25Mb2NhbEF0dHJpYnV0ZXNDaGFuZ2VkIiwiY2hhbmdlZEF0dHJpYnV0ZXMiLCJQYXJ0aWNpcGFudEF0dHJpYnV0ZXNDaGFuZ2VkIiwib25Mb2NhbFRyYWNrTXV0ZWQiLCJvbkxvY2FsVHJhY2tVbm11dGVkIiwib25UcmFja1Byb2Nlc3NvclVwZGF0ZSIsIm9uUHVibGlzaCIsIm9uTG9jYWxUcmFja1Jlc3RhcnRlZCIsIkxvY2FsQXVkaW9TaWxlbmNlRGV0ZWN0ZWQiLCJvbkxvY2FsQ29ubmVjdGlvblF1YWxpdHlDaGFuZ2VkIiwib25NZWRpYURldmljZXNFcnJvciIsIm9uTG9jYWxQYXJ0aWNpcGFudFBlcm1pc3Npb25zQ2hhbmdlZCIsIm9uTG9jYWxDaGF0TWVzc2FnZVNlbnQiLCJzZXR1cEUyRUUiLCJjbGVhbnVwUmVnaXN0cnkiLCJyZWdpc3RlciIsInJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIiLCJ1bnJlZ2lzdGVyVGV4dFN0cmVhbUhhbmRsZXIiLCJyZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyIiwidW5yZWdpc3RlckJ5dGVTdHJlYW1IYW5kbGVyIiwiY2FsbGVySWRlbnRpdHkiLCJpc1JlY29yZGluZyIsImdldFNpZCIsIm51bVBhcnRpY2lwYW50cyIsIm51bVB1Ymxpc2hlcnMiLCJvblRyYWNrQWRkZWQiLCJTaWduYWxSZWNvbm5lY3RpbmciLCJ1cGRhdGVTdWJzY3JpcHRpb25zIiwic3Vic2NyaWJlZFNpZCIsInRyYWNrUHVibGljYXRpb24iLCJnZXRMb2NhbERldmljZXMiLCJwcmVwYXJlQ29ubmVjdGlvbiIsInNpbXVsYXRlU2NlbmFyaW8iLCJwb3N0QWN0aW9uIiwiY2FuUGxheWJhY2tWaWRlbyIsImRldmljZUlkXzEiLCJzdWNjZXNzIiwibmVlZHNVcGRhdGVXaXRob3V0VHJhY2tzIiwiZGV2aWNlQ29uc3RyYWludCIsInByZXZEZXZpY2VJZCIsInJlY29ubmVjdGVkSGFuZGxlciIsInNob3VsZFN0b3BUcmFja3MiLCJQYXJ0aWNpcGFudERpc2Nvbm5lY3RlZCIsInN0cmVhbUhlYWRlciIsInN0cmVhbUhhbmRsZXJDYWxsYmFjayIsInN0cmVhbUNvbnRyb2xsZXIiLCJSZWFkYWJsZVN0cmVhbSIsImZpbGVCdWZmZXIiLCJlbnF1ZXVlIiwidGV4dEJ1ZmZlciIsIm5ld0NvbnRleHRJc1J1bm5pbmciLCJjcmVhdGVQYXJ0aWNpcGFudCIsImV4aXN0aW5nUGFydGljaXBhbnQiLCJ3YXNVcGRhdGVkIiwiUGFydGljaXBhbnRDb25uZWN0ZWQiLCJjb25zZWN1dGl2ZUZhaWx1cmVzIiwiY29ubmVjdGlvblJlY29uY2lsZUludGVydmFsIiwibnVtRmFpbHVyZXMiLCJjbG9zZWQiLCJ0cmFuc3BvcnRzQ29ubmVjdGVkIiwiU1RBVEVfTUlTTUFUQ0giLCJfbGVuMiIsIl9rZXkyIiwic2ltdWxhdGVQYXJ0aWNpcGFudHMiLCJ1c2VSZWFsVHJhY2tzIiwicGFydGljaXBhbnRPcHRpb25zIiwiYXNwZWN0UmF0aW9zIiwiZW1wdHlUaW1lb3V0IiwibWF4UGFydGljaXBhbnRzIiwiY3JlYXRpb25UaW1lIiwidHVyblBhc3N3b3JkIiwiZW5hYmxlZENvZGVjcyIsImNhbVB1YiIsImF1ZGlvUHViIiwiZHVtbXlWaWRlbyIsIl9sZW4zIiwiX2tleTMiLCJtaW5pbWl6ZWRBcmdzIiwibWFwQXJncyIsIkZpbmFsaXphdGlvblJlZ2lzdHJ5IiwiQ2hlY2tTdGF0dXMiLCJDaGVja2VyIiwiSURMRSIsImxvZ3MiLCJvbkNvbXBsZXRlIiwic2V0U3RhdHVzIiwicGVyZm9ybSIsImVycm9yc0FzV2FybmluZ3MiLCJhcHBlbmRXYXJuaW5nIiwiYXBwZW5kRXJyb3IiLCJTS0lQUEVEIiwiaXNTdWNjZXNzIiwiU1VDQ0VTUyIsInN3aXRjaFByb3RvY29sIiwiaGFzUmVjb25uZWN0aW5nIiwiaGFzUmVjb25uZWN0ZWQiLCJhcHBlbmRNZXNzYWdlIiwiQ2xvdWRSZWdpb25DaGVjayIsInJlZ2lvblByb3ZpZGVyIiwicmVnaW9uU3RhdHMiLCJzZWVuVXJscyIsImNoZWNrQ2xvdWRSZWdpb24iLCJiZXN0UmVnaW9uIiwiYmVzdFN0YXRzIiwiY2h1bmtTaXplIiwibnVtQ2h1bmtzIiwiY2h1bmtEYXRhIiwibm9taW5hdGVkIiwiY3VycmVudFJvdW5kVHJpcFRpbWUiLCJURVNUX0RVUkFUSU9OIiwiQ29ubmVjdGlvblByb3RvY29sQ2hlY2siLCJ1ZHBTdGF0cyIsImNoZWNrQ29ubmVjdGlvblByb3RvY29sIiwidGNwU3RhdHMiLCJiaXRyYXRlVG90YWwiLCJydHRUb3RhbCIsImppdHRlclRvdGFsIiwiY3B1IiwiaHVlIiwiYW5pbWF0ZSIsInByb3RvY29sU3RhdHMiLCJQdWJsaXNoQXVkaW9DaGVjayIsIm51bVBhY2tldHMiLCJtZWRpYVR5cGUiLCJQdWJsaXNoVmlkZW9DaGVjayIsImNoZWNrRm9yVmlkZW8iLCJvbnBsYXkiLCJ2aWRlb1dpZHRoIiwidmlkZW9IZWlnaHQiLCJkcmF3SW1hZ2UiLCJpbWFnZURhdGEiLCJnZXRJbWFnZURhdGEiLCJpc0FsbEJsYWNrIiwiUmVjb25uZWN0Q2hlY2siLCJyZWNvbm5lY3RpbmdUcmlnZ2VyZWQiLCJyZWNvbm5lY3RlZCIsInJlY29ubmVjdFJlc29sdmVyIiwiVFVSTkNoZWNrIiwiam9pblJlcyIsImhhc1RMUyIsImhhc1RVUk4iLCJoYXNTVFVOIiwiV2ViUlRDQ2hlY2siLCJoYXNUY3AiLCJoYXNJcHY0VWRwIiwicHJldlRyaWNrbGUiLCJpc0lQUHJpdmF0ZSIsIlJUQ1BlZXJDb25uZWN0aW9uSWNlRXJyb3JFdmVudCIsImVycm9yQ29kZSIsImVycm9yVGV4dCIsInNlY29uZCIsIldlYlNvY2tldENoZWNrIiwiZWRpdGlvbiIsIkNsb3VkIiwiQ29ubmVjdGlvbkNoZWNrIiwiY2hlY2tSZXN1bHRzIiwiZ2V0TmV4dENoZWNrSWQiLCJuZXh0SWQiLCJ1cGRhdGVDaGVjayIsImNoZWNrSWQiLCJnZXRSZXN1bHRzIiwiY3JlYXRlQW5kUnVuQ2hlY2siLCJjaGVjayIsImhhbmRsZVVwZGF0ZSIsImNoZWNrV2Vic29ja2V0IiwiY2hlY2tXZWJSVEMiLCJjaGVja1RVUk4iLCJjaGVja1JlY29ubmVjdCIsImNoZWNrUHVibGlzaEF1ZGlvIiwiY2hlY2tQdWJsaXNoVmlkZW8iLCJmYWNpbmdNb2RlRnJvbUxvY2FsVHJhY2siLCJ0cmFja1NldHRpbmdzIiwiZGVmYXVsdEZhY2luZ01vZGUiLCJjb25maWRlbmNlIiwicmF3RmFjaW5nTW9kZSIsImlzRmFjaW5nTW9kZVZhbHVlIiwibGFiZWxBbmFseXNpc1Jlc3VsdCIsImZhY2luZ01vZGVGcm9tRGV2aWNlTGFiZWwiLCJrbm93bkRldmljZUxhYmVscyIsImtub3duRGV2aWNlTGFiZWxTZWN0aW9ucyIsImRldmljZUxhYmVsIiwic2VjdGlvbiIsImFsbG93ZWRWYWx1ZXMiLCJNdXRleCIsIlBhcnRpY2lwYW50S2luZCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/livekit-client/dist/livekit-client.esm.mjs\n");

/***/ })

};
;