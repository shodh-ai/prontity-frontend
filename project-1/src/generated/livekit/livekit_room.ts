// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.28.3
// source: livekit_room.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { RoomAgentDispatch } from "./livekit_agent_dispatch";
import { AutoParticipantEgress, AutoTrackEgress, RoomCompositeEgressRequest } from "./livekit_egress";
import {
  DataPacket_Kind,
  dataPacket_KindFromJSON,
  dataPacket_KindToJSON,
  ParticipantInfo,
  ParticipantPermission,
  ParticipantTracks,
  Room,
  TrackInfo,
} from "./livekit_models";

export const protobufPackage = "livekit";

export interface CreateRoomRequest {
  /** name of the room */
  name: string;
  /** configuration to use for this room parameters. Setting parameters below override the config defaults. */
  roomPreset: string;
  /** number of seconds to keep the room open if no one joins */
  emptyTimeout: number;
  /** number of seconds to keep the room open after everyone leaves */
  departureTimeout: number;
  /** limit number of participants that can be in a room */
  maxParticipants: number;
  /** override the node room is allocated to, for debugging */
  nodeId: string;
  /** metadata of room */
  metadata: string;
  /** auto-egress configurations */
  egress:
    | RoomEgress
    | undefined;
  /** playout delay of subscriber */
  minPlayoutDelay: number;
  maxPlayoutDelay: number;
  /**
   * improves A/V sync when playout_delay set to a value larger than 200ms. It will disables transceiver re-use
   * so not recommended for rooms with frequent subscription changes
   */
  syncStreams: boolean;
  /** replay */
  replayEnabled: boolean;
  /** Define agents that should be dispatched to this room */
  agents: RoomAgentDispatch[];
}

export interface RoomEgress {
  room: RoomCompositeEgressRequest | undefined;
  participant: AutoParticipantEgress | undefined;
  tracks: AutoTrackEgress | undefined;
}

export interface RoomAgent {
  dispatches: RoomAgentDispatch[];
}

export interface ListRoomsRequest {
  /** when set, will only return rooms with name match */
  names: string[];
}

export interface ListRoomsResponse {
  rooms: Room[];
}

export interface DeleteRoomRequest {
  /** name of the room */
  room: string;
}

export interface DeleteRoomResponse {
}

export interface ListParticipantsRequest {
  /** name of the room */
  room: string;
}

export interface ListParticipantsResponse {
  participants: ParticipantInfo[];
}

export interface RoomParticipantIdentity {
  /** name of the room */
  room: string;
  /** identity of the participant */
  identity: string;
}

export interface RemoveParticipantResponse {
}

export interface MuteRoomTrackRequest {
  /** name of the room */
  room: string;
  identity: string;
  /** sid of the track to mute */
  trackSid: string;
  /** set to true to mute, false to unmute */
  muted: boolean;
}

export interface MuteRoomTrackResponse {
  track: TrackInfo | undefined;
}

export interface UpdateParticipantRequest {
  room: string;
  identity: string;
  /** metadata to update. skipping updates if left empty */
  metadata: string;
  /** set to update the participant's permissions */
  permission:
    | ParticipantPermission
    | undefined;
  /** display name to update */
  name: string;
  /**
   * attributes to update. it only updates attributes that have been set
   * to delete attributes, set the value to an empty string
   */
  attributes: { [key: string]: string };
}

export interface UpdateParticipantRequest_AttributesEntry {
  key: string;
  value: string;
}

export interface UpdateSubscriptionsRequest {
  room: string;
  identity: string;
  /** list of sids of tracks */
  trackSids: string[];
  /** set to true to subscribe, false to unsubscribe from tracks */
  subscribe: boolean;
  /** list of participants and their tracks */
  participantTracks: ParticipantTracks[];
}

/** empty for now */
export interface UpdateSubscriptionsResponse {
}

export interface SendDataRequest {
  room: string;
  data: Uint8Array;
  kind: DataPacket_Kind;
  /**
   * mark deprecated
   *
   * @deprecated
   */
  destinationSids: string[];
  /** when set, only forward to these identities */
  destinationIdentities: string[];
  topic?:
    | string
    | undefined;
  /** added by SDK to enable de-duping of messages, for INTERNAL USE ONLY */
  nonce: Uint8Array;
}

/**  */
export interface SendDataResponse {
}

export interface UpdateRoomMetadataRequest {
  room: string;
  /** metadata to update. skipping updates if left empty */
  metadata: string;
}

export interface RoomConfiguration {
  /** Used as ID, must be unique */
  name: string;
  /** number of seconds to keep the room open if no one joins */
  emptyTimeout: number;
  /** number of seconds to keep the room open after everyone leaves */
  departureTimeout: number;
  /** limit number of participants that can be in a room, excluding Egress and Ingress participants */
  maxParticipants: number;
  /** egress */
  egress:
    | RoomEgress
    | undefined;
  /** playout delay of subscriber */
  minPlayoutDelay: number;
  maxPlayoutDelay: number;
  /**
   * improves A/V sync when playout_delay set to a value larger than 200ms. It will disables transceiver re-use
   * so not recommended for rooms with frequent subscription changes
   */
  syncStreams: boolean;
  /** Define agents that should be dispatched to this room */
  agents: RoomAgentDispatch[];
}

export interface ForwardParticipantRequest {
  /** room to forward participant from */
  room: string;
  /** identity of the participant to forward */
  identity: string;
  /** room to forward participant to */
  destinationRoom: string;
}

export interface ForwardParticipantResponse {
}

export interface MoveParticipantRequest {
  /** room to move participant from */
  room: string;
  /** identity of the participant to move to */
  identity: string;
  /** room to move participant to */
  destinationRoom: string;
}

export interface MoveParticipantResponse {
}

function createBaseCreateRoomRequest(): CreateRoomRequest {
  return {
    name: "",
    roomPreset: "",
    emptyTimeout: 0,
    departureTimeout: 0,
    maxParticipants: 0,
    nodeId: "",
    metadata: "",
    egress: undefined,
    minPlayoutDelay: 0,
    maxPlayoutDelay: 0,
    syncStreams: false,
    replayEnabled: false,
    agents: [],
  };
}

export const CreateRoomRequest: MessageFns<CreateRoomRequest> = {
  encode(message: CreateRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.roomPreset !== "") {
      writer.uint32(98).string(message.roomPreset);
    }
    if (message.emptyTimeout !== 0) {
      writer.uint32(16).uint32(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      writer.uint32(80).uint32(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer.uint32(24).uint32(message.maxParticipants);
    }
    if (message.nodeId !== "") {
      writer.uint32(34).string(message.nodeId);
    }
    if (message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    if (message.egress !== undefined) {
      RoomEgress.encode(message.egress, writer.uint32(50).fork()).join();
    }
    if (message.minPlayoutDelay !== 0) {
      writer.uint32(56).uint32(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      writer.uint32(64).uint32(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      writer.uint32(72).bool(message.syncStreams);
    }
    if (message.replayEnabled !== false) {
      writer.uint32(104).bool(message.replayEnabled);
    }
    for (const v of message.agents) {
      RoomAgentDispatch.encode(v!, writer.uint32(114).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.roomPreset = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emptyTimeout = reader.uint32();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.departureTimeout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.maxParticipants = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.nodeId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.egress = RoomEgress.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.minPlayoutDelay = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxPlayoutDelay = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.syncStreams = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.replayEnabled = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.agents.push(RoomAgentDispatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRoomRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      roomPreset: isSet(object.roomPreset) ? globalThis.String(object.roomPreset) : "",
      emptyTimeout: isSet(object.emptyTimeout) ? globalThis.Number(object.emptyTimeout) : 0,
      departureTimeout: isSet(object.departureTimeout) ? globalThis.Number(object.departureTimeout) : 0,
      maxParticipants: isSet(object.maxParticipants) ? globalThis.Number(object.maxParticipants) : 0,
      nodeId: isSet(object.nodeId) ? globalThis.String(object.nodeId) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      egress: isSet(object.egress) ? RoomEgress.fromJSON(object.egress) : undefined,
      minPlayoutDelay: isSet(object.minPlayoutDelay) ? globalThis.Number(object.minPlayoutDelay) : 0,
      maxPlayoutDelay: isSet(object.maxPlayoutDelay) ? globalThis.Number(object.maxPlayoutDelay) : 0,
      syncStreams: isSet(object.syncStreams) ? globalThis.Boolean(object.syncStreams) : false,
      replayEnabled: isSet(object.replayEnabled) ? globalThis.Boolean(object.replayEnabled) : false,
      agents: globalThis.Array.isArray(object?.agents)
        ? object.agents.map((e: any) => RoomAgentDispatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: CreateRoomRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.roomPreset !== "") {
      obj.roomPreset = message.roomPreset;
    }
    if (message.emptyTimeout !== 0) {
      obj.emptyTimeout = Math.round(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      obj.departureTimeout = Math.round(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      obj.maxParticipants = Math.round(message.maxParticipants);
    }
    if (message.nodeId !== "") {
      obj.nodeId = message.nodeId;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.egress !== undefined) {
      obj.egress = RoomEgress.toJSON(message.egress);
    }
    if (message.minPlayoutDelay !== 0) {
      obj.minPlayoutDelay = Math.round(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      obj.maxPlayoutDelay = Math.round(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      obj.syncStreams = message.syncStreams;
    }
    if (message.replayEnabled !== false) {
      obj.replayEnabled = message.replayEnabled;
    }
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => RoomAgentDispatch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<CreateRoomRequest>): CreateRoomRequest {
    return CreateRoomRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateRoomRequest>): CreateRoomRequest {
    const message = createBaseCreateRoomRequest();
    message.name = object.name ?? "";
    message.roomPreset = object.roomPreset ?? "";
    message.emptyTimeout = object.emptyTimeout ?? 0;
    message.departureTimeout = object.departureTimeout ?? 0;
    message.maxParticipants = object.maxParticipants ?? 0;
    message.nodeId = object.nodeId ?? "";
    message.metadata = object.metadata ?? "";
    message.egress = (object.egress !== undefined && object.egress !== null)
      ? RoomEgress.fromPartial(object.egress)
      : undefined;
    message.minPlayoutDelay = object.minPlayoutDelay ?? 0;
    message.maxPlayoutDelay = object.maxPlayoutDelay ?? 0;
    message.syncStreams = object.syncStreams ?? false;
    message.replayEnabled = object.replayEnabled ?? false;
    message.agents = object.agents?.map((e) => RoomAgentDispatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoomEgress(): RoomEgress {
  return { room: undefined, participant: undefined, tracks: undefined };
}

export const RoomEgress: MessageFns<RoomEgress> = {
  encode(message: RoomEgress, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== undefined) {
      RoomCompositeEgressRequest.encode(message.room, writer.uint32(10).fork()).join();
    }
    if (message.participant !== undefined) {
      AutoParticipantEgress.encode(message.participant, writer.uint32(26).fork()).join();
    }
    if (message.tracks !== undefined) {
      AutoTrackEgress.encode(message.tracks, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomEgress {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomEgress();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = RoomCompositeEgressRequest.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participant = AutoParticipantEgress.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tracks = AutoTrackEgress.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomEgress {
    return {
      room: isSet(object.room) ? RoomCompositeEgressRequest.fromJSON(object.room) : undefined,
      participant: isSet(object.participant) ? AutoParticipantEgress.fromJSON(object.participant) : undefined,
      tracks: isSet(object.tracks) ? AutoTrackEgress.fromJSON(object.tracks) : undefined,
    };
  },

  toJSON(message: RoomEgress): unknown {
    const obj: any = {};
    if (message.room !== undefined) {
      obj.room = RoomCompositeEgressRequest.toJSON(message.room);
    }
    if (message.participant !== undefined) {
      obj.participant = AutoParticipantEgress.toJSON(message.participant);
    }
    if (message.tracks !== undefined) {
      obj.tracks = AutoTrackEgress.toJSON(message.tracks);
    }
    return obj;
  },

  create(base?: DeepPartial<RoomEgress>): RoomEgress {
    return RoomEgress.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomEgress>): RoomEgress {
    const message = createBaseRoomEgress();
    message.room = (object.room !== undefined && object.room !== null)
      ? RoomCompositeEgressRequest.fromPartial(object.room)
      : undefined;
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? AutoParticipantEgress.fromPartial(object.participant)
      : undefined;
    message.tracks = (object.tracks !== undefined && object.tracks !== null)
      ? AutoTrackEgress.fromPartial(object.tracks)
      : undefined;
    return message;
  },
};

function createBaseRoomAgent(): RoomAgent {
  return { dispatches: [] };
}

export const RoomAgent: MessageFns<RoomAgent> = {
  encode(message: RoomAgent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.dispatches) {
      RoomAgentDispatch.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomAgent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomAgent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dispatches.push(RoomAgentDispatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomAgent {
    return {
      dispatches: globalThis.Array.isArray(object?.dispatches)
        ? object.dispatches.map((e: any) => RoomAgentDispatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RoomAgent): unknown {
    const obj: any = {};
    if (message.dispatches?.length) {
      obj.dispatches = message.dispatches.map((e) => RoomAgentDispatch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RoomAgent>): RoomAgent {
    return RoomAgent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomAgent>): RoomAgent {
    const message = createBaseRoomAgent();
    message.dispatches = object.dispatches?.map((e) => RoomAgentDispatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRoomsRequest(): ListRoomsRequest {
  return { names: [] };
}

export const ListRoomsRequest: MessageFns<ListRoomsRequest> = {
  encode(message: ListRoomsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.names) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoomsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoomsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.names.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoomsRequest {
    return { names: globalThis.Array.isArray(object?.names) ? object.names.map((e: any) => globalThis.String(e)) : [] };
  },

  toJSON(message: ListRoomsRequest): unknown {
    const obj: any = {};
    if (message.names?.length) {
      obj.names = message.names;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRoomsRequest>): ListRoomsRequest {
    return ListRoomsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRoomsRequest>): ListRoomsRequest {
    const message = createBaseListRoomsRequest();
    message.names = object.names?.map((e) => e) || [];
    return message;
  },
};

function createBaseListRoomsResponse(): ListRoomsResponse {
  return { rooms: [] };
}

export const ListRoomsResponse: MessageFns<ListRoomsResponse> = {
  encode(message: ListRoomsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.rooms) {
      Room.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRoomsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRoomsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rooms.push(Room.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRoomsResponse {
    return { rooms: globalThis.Array.isArray(object?.rooms) ? object.rooms.map((e: any) => Room.fromJSON(e)) : [] };
  },

  toJSON(message: ListRoomsResponse): unknown {
    const obj: any = {};
    if (message.rooms?.length) {
      obj.rooms = message.rooms.map((e) => Room.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListRoomsResponse>): ListRoomsResponse {
    return ListRoomsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRoomsResponse>): ListRoomsResponse {
    const message = createBaseListRoomsResponse();
    message.rooms = object.rooms?.map((e) => Room.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteRoomRequest(): DeleteRoomRequest {
  return { room: "" };
}

export const DeleteRoomRequest: MessageFns<DeleteRoomRequest> = {
  encode(message: DeleteRoomRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoomRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoomRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRoomRequest {
    return { room: isSet(object.room) ? globalThis.String(object.room) : "" };
  },

  toJSON(message: DeleteRoomRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteRoomRequest>): DeleteRoomRequest {
    return DeleteRoomRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteRoomRequest>): DeleteRoomRequest {
    const message = createBaseDeleteRoomRequest();
    message.room = object.room ?? "";
    return message;
  },
};

function createBaseDeleteRoomResponse(): DeleteRoomResponse {
  return {};
}

export const DeleteRoomResponse: MessageFns<DeleteRoomResponse> = {
  encode(_: DeleteRoomResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRoomResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRoomResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DeleteRoomResponse {
    return {};
  },

  toJSON(_: DeleteRoomResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DeleteRoomResponse>): DeleteRoomResponse {
    return DeleteRoomResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DeleteRoomResponse>): DeleteRoomResponse {
    const message = createBaseDeleteRoomResponse();
    return message;
  },
};

function createBaseListParticipantsRequest(): ListParticipantsRequest {
  return { room: "" };
}

export const ListParticipantsRequest: MessageFns<ListParticipantsRequest> = {
  encode(message: ListParticipantsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsRequest {
    return { room: isSet(object.room) ? globalThis.String(object.room) : "" };
  },

  toJSON(message: ListParticipantsRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    return ListParticipantsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsRequest>): ListParticipantsRequest {
    const message = createBaseListParticipantsRequest();
    message.room = object.room ?? "";
    return message;
  },
};

function createBaseListParticipantsResponse(): ListParticipantsResponse {
  return { participants: [] };
}

export const ListParticipantsResponse: MessageFns<ListParticipantsResponse> = {
  encode(message: ListParticipantsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      ParticipantInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListParticipantsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListParticipantsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participants.push(ParticipantInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListParticipantsResponse {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => ParticipantInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListParticipantsResponse): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => ParticipantInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    return ListParticipantsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListParticipantsResponse>): ListParticipantsResponse {
    const message = createBaseListParticipantsResponse();
    message.participants = object.participants?.map((e) => ParticipantInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoomParticipantIdentity(): RoomParticipantIdentity {
  return { room: "", identity: "" };
}

export const RoomParticipantIdentity: MessageFns<RoomParticipantIdentity> = {
  encode(message: RoomParticipantIdentity, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomParticipantIdentity {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomParticipantIdentity();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomParticipantIdentity {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
    };
  },

  toJSON(message: RoomParticipantIdentity): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    return obj;
  },

  create(base?: DeepPartial<RoomParticipantIdentity>): RoomParticipantIdentity {
    return RoomParticipantIdentity.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomParticipantIdentity>): RoomParticipantIdentity {
    const message = createBaseRoomParticipantIdentity();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    return message;
  },
};

function createBaseRemoveParticipantResponse(): RemoveParticipantResponse {
  return {};
}

export const RemoveParticipantResponse: MessageFns<RemoveParticipantResponse> = {
  encode(_: RemoveParticipantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoveParticipantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoveParticipantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoveParticipantResponse {
    return {};
  },

  toJSON(_: RemoveParticipantResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoveParticipantResponse>): RemoveParticipantResponse {
    return RemoveParticipantResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoveParticipantResponse>): RemoveParticipantResponse {
    const message = createBaseRemoveParticipantResponse();
    return message;
  },
};

function createBaseMuteRoomTrackRequest(): MuteRoomTrackRequest {
  return { room: "", identity: "", trackSid: "", muted: false };
}

export const MuteRoomTrackRequest: MessageFns<MuteRoomTrackRequest> = {
  encode(message: MuteRoomTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    if (message.trackSid !== "") {
      writer.uint32(26).string(message.trackSid);
    }
    if (message.muted !== false) {
      writer.uint32(32).bool(message.muted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteRoomTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteRoomTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.muted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteRoomTrackRequest {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      muted: isSet(object.muted) ? globalThis.Boolean(object.muted) : false,
    };
  },

  toJSON(message: MuteRoomTrackRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.muted !== false) {
      obj.muted = message.muted;
    }
    return obj;
  },

  create(base?: DeepPartial<MuteRoomTrackRequest>): MuteRoomTrackRequest {
    return MuteRoomTrackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MuteRoomTrackRequest>): MuteRoomTrackRequest {
    const message = createBaseMuteRoomTrackRequest();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    message.trackSid = object.trackSid ?? "";
    message.muted = object.muted ?? false;
    return message;
  },
};

function createBaseMuteRoomTrackResponse(): MuteRoomTrackResponse {
  return { track: undefined };
}

export const MuteRoomTrackResponse: MessageFns<MuteRoomTrackResponse> = {
  encode(message: MuteRoomTrackResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.track !== undefined) {
      TrackInfo.encode(message.track, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteRoomTrackResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteRoomTrackResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.track = TrackInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteRoomTrackResponse {
    return { track: isSet(object.track) ? TrackInfo.fromJSON(object.track) : undefined };
  },

  toJSON(message: MuteRoomTrackResponse): unknown {
    const obj: any = {};
    if (message.track !== undefined) {
      obj.track = TrackInfo.toJSON(message.track);
    }
    return obj;
  },

  create(base?: DeepPartial<MuteRoomTrackResponse>): MuteRoomTrackResponse {
    return MuteRoomTrackResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MuteRoomTrackResponse>): MuteRoomTrackResponse {
    const message = createBaseMuteRoomTrackResponse();
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackInfo.fromPartial(object.track)
      : undefined;
    return message;
  },
};

function createBaseUpdateParticipantRequest(): UpdateParticipantRequest {
  return { room: "", identity: "", metadata: "", permission: undefined, name: "", attributes: {} };
}

export const UpdateParticipantRequest: MessageFns<UpdateParticipantRequest> = {
  encode(message: UpdateParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    if (message.metadata !== "") {
      writer.uint32(26).string(message.metadata);
    }
    if (message.permission !== undefined) {
      ParticipantPermission.encode(message.permission, writer.uint32(34).fork()).join();
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      UpdateParticipantRequest_AttributesEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.permission = ParticipantPermission.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = UpdateParticipantRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.attributes[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantRequest {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      permission: isSet(object.permission) ? ParticipantPermission.fromJSON(object.permission) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UpdateParticipantRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.permission !== undefined) {
      obj.permission = ParticipantPermission.toJSON(message.permission);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateParticipantRequest>): UpdateParticipantRequest {
    return UpdateParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateParticipantRequest>): UpdateParticipantRequest {
    const message = createBaseUpdateParticipantRequest();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    message.metadata = object.metadata ?? "";
    message.permission = (object.permission !== undefined && object.permission !== null)
      ? ParticipantPermission.fromPartial(object.permission)
      : undefined;
    message.name = object.name ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseUpdateParticipantRequest_AttributesEntry(): UpdateParticipantRequest_AttributesEntry {
  return { key: "", value: "" };
}

export const UpdateParticipantRequest_AttributesEntry: MessageFns<UpdateParticipantRequest_AttributesEntry> = {
  encode(message: UpdateParticipantRequest_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantRequest_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateParticipantRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateParticipantRequest_AttributesEntry>): UpdateParticipantRequest_AttributesEntry {
    return UpdateParticipantRequest_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateParticipantRequest_AttributesEntry>): UpdateParticipantRequest_AttributesEntry {
    const message = createBaseUpdateParticipantRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdateSubscriptionsRequest(): UpdateSubscriptionsRequest {
  return { room: "", identity: "", trackSids: [], subscribe: false, participantTracks: [] };
}

export const UpdateSubscriptionsRequest: MessageFns<UpdateSubscriptionsRequest> = {
  encode(message: UpdateSubscriptionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    for (const v of message.trackSids) {
      writer.uint32(26).string(v!);
    }
    if (message.subscribe !== false) {
      writer.uint32(32).bool(message.subscribe);
    }
    for (const v of message.participantTracks) {
      ParticipantTracks.encode(v!, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscriptionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trackSids.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.subscribe = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.participantTracks.push(ParticipantTracks.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscriptionsRequest {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      trackSids: globalThis.Array.isArray(object?.trackSids)
        ? object.trackSids.map((e: any) => globalThis.String(e))
        : [],
      subscribe: isSet(object.subscribe) ? globalThis.Boolean(object.subscribe) : false,
      participantTracks: globalThis.Array.isArray(object?.participantTracks)
        ? object.participantTracks.map((e: any) => ParticipantTracks.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateSubscriptionsRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.trackSids?.length) {
      obj.trackSids = message.trackSids;
    }
    if (message.subscribe !== false) {
      obj.subscribe = message.subscribe;
    }
    if (message.participantTracks?.length) {
      obj.participantTracks = message.participantTracks.map((e) => ParticipantTracks.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSubscriptionsRequest>): UpdateSubscriptionsRequest {
    return UpdateSubscriptionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSubscriptionsRequest>): UpdateSubscriptionsRequest {
    const message = createBaseUpdateSubscriptionsRequest();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    message.trackSids = object.trackSids?.map((e) => e) || [];
    message.subscribe = object.subscribe ?? false;
    message.participantTracks = object.participantTracks?.map((e) => ParticipantTracks.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateSubscriptionsResponse(): UpdateSubscriptionsResponse {
  return {};
}

export const UpdateSubscriptionsResponse: MessageFns<UpdateSubscriptionsResponse> = {
  encode(_: UpdateSubscriptionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscriptionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscriptionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): UpdateSubscriptionsResponse {
    return {};
  },

  toJSON(_: UpdateSubscriptionsResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<UpdateSubscriptionsResponse>): UpdateSubscriptionsResponse {
    return UpdateSubscriptionsResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<UpdateSubscriptionsResponse>): UpdateSubscriptionsResponse {
    const message = createBaseUpdateSubscriptionsResponse();
    return message;
  },
};

function createBaseSendDataRequest(): SendDataRequest {
  return {
    room: "",
    data: new Uint8Array(0),
    kind: 0,
    destinationSids: [],
    destinationIdentities: [],
    topic: undefined,
    nonce: new Uint8Array(0),
  };
}

export const SendDataRequest: MessageFns<SendDataRequest> = {
  encode(message: SendDataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data);
    }
    if (message.kind !== 0) {
      writer.uint32(24).int32(message.kind);
    }
    for (const v of message.destinationSids) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.destinationIdentities) {
      writer.uint32(50).string(v!);
    }
    if (message.topic !== undefined) {
      writer.uint32(42).string(message.topic);
    }
    if (message.nonce.length !== 0) {
      writer.uint32(58).bytes(message.nonce);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendDataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendDataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.data = reader.bytes();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.destinationSids.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.destinationIdentities.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.topic = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.nonce = reader.bytes();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendDataRequest {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array(0),
      kind: isSet(object.kind) ? dataPacket_KindFromJSON(object.kind) : 0,
      destinationSids: globalThis.Array.isArray(object?.destinationSids)
        ? object.destinationSids.map((e: any) => globalThis.String(e))
        : [],
      destinationIdentities: globalThis.Array.isArray(object?.destinationIdentities)
        ? object.destinationIdentities.map((e: any) => globalThis.String(e))
        : [],
      topic: isSet(object.topic) ? globalThis.String(object.topic) : undefined,
      nonce: isSet(object.nonce) ? bytesFromBase64(object.nonce) : new Uint8Array(0),
    };
  },

  toJSON(message: SendDataRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data);
    }
    if (message.kind !== 0) {
      obj.kind = dataPacket_KindToJSON(message.kind);
    }
    if (message.destinationSids?.length) {
      obj.destinationSids = message.destinationSids;
    }
    if (message.destinationIdentities?.length) {
      obj.destinationIdentities = message.destinationIdentities;
    }
    if (message.topic !== undefined) {
      obj.topic = message.topic;
    }
    if (message.nonce.length !== 0) {
      obj.nonce = base64FromBytes(message.nonce);
    }
    return obj;
  },

  create(base?: DeepPartial<SendDataRequest>): SendDataRequest {
    return SendDataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendDataRequest>): SendDataRequest {
    const message = createBaseSendDataRequest();
    message.room = object.room ?? "";
    message.data = object.data ?? new Uint8Array(0);
    message.kind = object.kind ?? 0;
    message.destinationSids = object.destinationSids?.map((e) => e) || [];
    message.destinationIdentities = object.destinationIdentities?.map((e) => e) || [];
    message.topic = object.topic ?? undefined;
    message.nonce = object.nonce ?? new Uint8Array(0);
    return message;
  },
};

function createBaseSendDataResponse(): SendDataResponse {
  return {};
}

export const SendDataResponse: MessageFns<SendDataResponse> = {
  encode(_: SendDataResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendDataResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendDataResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): SendDataResponse {
    return {};
  },

  toJSON(_: SendDataResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<SendDataResponse>): SendDataResponse {
    return SendDataResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<SendDataResponse>): SendDataResponse {
    const message = createBaseSendDataResponse();
    return message;
  },
};

function createBaseUpdateRoomMetadataRequest(): UpdateRoomMetadataRequest {
  return { room: "", metadata: "" };
}

export const UpdateRoomMetadataRequest: MessageFns<UpdateRoomMetadataRequest> = {
  encode(message: UpdateRoomMetadataRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.metadata !== "") {
      writer.uint32(18).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRoomMetadataRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRoomMetadataRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRoomMetadataRequest {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
    };
  },

  toJSON(message: UpdateRoomMetadataRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateRoomMetadataRequest>): UpdateRoomMetadataRequest {
    return UpdateRoomMetadataRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateRoomMetadataRequest>): UpdateRoomMetadataRequest {
    const message = createBaseUpdateRoomMetadataRequest();
    message.room = object.room ?? "";
    message.metadata = object.metadata ?? "";
    return message;
  },
};

function createBaseRoomConfiguration(): RoomConfiguration {
  return {
    name: "",
    emptyTimeout: 0,
    departureTimeout: 0,
    maxParticipants: 0,
    egress: undefined,
    minPlayoutDelay: 0,
    maxPlayoutDelay: 0,
    syncStreams: false,
    agents: [],
  };
}

export const RoomConfiguration: MessageFns<RoomConfiguration> = {
  encode(message: RoomConfiguration, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.emptyTimeout !== 0) {
      writer.uint32(16).uint32(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      writer.uint32(24).uint32(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      writer.uint32(32).uint32(message.maxParticipants);
    }
    if (message.egress !== undefined) {
      RoomEgress.encode(message.egress, writer.uint32(42).fork()).join();
    }
    if (message.minPlayoutDelay !== 0) {
      writer.uint32(56).uint32(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      writer.uint32(64).uint32(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      writer.uint32(72).bool(message.syncStreams);
    }
    for (const v of message.agents) {
      RoomAgentDispatch.encode(v!, writer.uint32(82).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomConfiguration {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomConfiguration();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.emptyTimeout = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.departureTimeout = reader.uint32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.maxParticipants = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.egress = RoomEgress.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.minPlayoutDelay = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.maxPlayoutDelay = reader.uint32();
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.syncStreams = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.agents.push(RoomAgentDispatch.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomConfiguration {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      emptyTimeout: isSet(object.emptyTimeout) ? globalThis.Number(object.emptyTimeout) : 0,
      departureTimeout: isSet(object.departureTimeout) ? globalThis.Number(object.departureTimeout) : 0,
      maxParticipants: isSet(object.maxParticipants) ? globalThis.Number(object.maxParticipants) : 0,
      egress: isSet(object.egress) ? RoomEgress.fromJSON(object.egress) : undefined,
      minPlayoutDelay: isSet(object.minPlayoutDelay) ? globalThis.Number(object.minPlayoutDelay) : 0,
      maxPlayoutDelay: isSet(object.maxPlayoutDelay) ? globalThis.Number(object.maxPlayoutDelay) : 0,
      syncStreams: isSet(object.syncStreams) ? globalThis.Boolean(object.syncStreams) : false,
      agents: globalThis.Array.isArray(object?.agents)
        ? object.agents.map((e: any) => RoomAgentDispatch.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RoomConfiguration): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.emptyTimeout !== 0) {
      obj.emptyTimeout = Math.round(message.emptyTimeout);
    }
    if (message.departureTimeout !== 0) {
      obj.departureTimeout = Math.round(message.departureTimeout);
    }
    if (message.maxParticipants !== 0) {
      obj.maxParticipants = Math.round(message.maxParticipants);
    }
    if (message.egress !== undefined) {
      obj.egress = RoomEgress.toJSON(message.egress);
    }
    if (message.minPlayoutDelay !== 0) {
      obj.minPlayoutDelay = Math.round(message.minPlayoutDelay);
    }
    if (message.maxPlayoutDelay !== 0) {
      obj.maxPlayoutDelay = Math.round(message.maxPlayoutDelay);
    }
    if (message.syncStreams !== false) {
      obj.syncStreams = message.syncStreams;
    }
    if (message.agents?.length) {
      obj.agents = message.agents.map((e) => RoomAgentDispatch.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RoomConfiguration>): RoomConfiguration {
    return RoomConfiguration.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomConfiguration>): RoomConfiguration {
    const message = createBaseRoomConfiguration();
    message.name = object.name ?? "";
    message.emptyTimeout = object.emptyTimeout ?? 0;
    message.departureTimeout = object.departureTimeout ?? 0;
    message.maxParticipants = object.maxParticipants ?? 0;
    message.egress = (object.egress !== undefined && object.egress !== null)
      ? RoomEgress.fromPartial(object.egress)
      : undefined;
    message.minPlayoutDelay = object.minPlayoutDelay ?? 0;
    message.maxPlayoutDelay = object.maxPlayoutDelay ?? 0;
    message.syncStreams = object.syncStreams ?? false;
    message.agents = object.agents?.map((e) => RoomAgentDispatch.fromPartial(e)) || [];
    return message;
  },
};

function createBaseForwardParticipantRequest(): ForwardParticipantRequest {
  return { room: "", identity: "", destinationRoom: "" };
}

export const ForwardParticipantRequest: MessageFns<ForwardParticipantRequest> = {
  encode(message: ForwardParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    if (message.destinationRoom !== "") {
      writer.uint32(26).string(message.destinationRoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationRoom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ForwardParticipantRequest {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      destinationRoom: isSet(object.destinationRoom) ? globalThis.String(object.destinationRoom) : "",
    };
  },

  toJSON(message: ForwardParticipantRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.destinationRoom !== "") {
      obj.destinationRoom = message.destinationRoom;
    }
    return obj;
  },

  create(base?: DeepPartial<ForwardParticipantRequest>): ForwardParticipantRequest {
    return ForwardParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ForwardParticipantRequest>): ForwardParticipantRequest {
    const message = createBaseForwardParticipantRequest();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    message.destinationRoom = object.destinationRoom ?? "";
    return message;
  },
};

function createBaseForwardParticipantResponse(): ForwardParticipantResponse {
  return {};
}

export const ForwardParticipantResponse: MessageFns<ForwardParticipantResponse> = {
  encode(_: ForwardParticipantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ForwardParticipantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseForwardParticipantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ForwardParticipantResponse {
    return {};
  },

  toJSON(_: ForwardParticipantResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ForwardParticipantResponse>): ForwardParticipantResponse {
    return ForwardParticipantResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ForwardParticipantResponse>): ForwardParticipantResponse {
    const message = createBaseForwardParticipantResponse();
    return message;
  },
};

function createBaseMoveParticipantRequest(): MoveParticipantRequest {
  return { room: "", identity: "", destinationRoom: "" };
}

export const MoveParticipantRequest: MessageFns<MoveParticipantRequest> = {
  encode(message: MoveParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== "") {
      writer.uint32(10).string(message.room);
    }
    if (message.identity !== "") {
      writer.uint32(18).string(message.identity);
    }
    if (message.destinationRoom !== "") {
      writer.uint32(26).string(message.destinationRoom);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.identity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.destinationRoom = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MoveParticipantRequest {
    return {
      room: isSet(object.room) ? globalThis.String(object.room) : "",
      identity: isSet(object.identity) ? globalThis.String(object.identity) : "",
      destinationRoom: isSet(object.destinationRoom) ? globalThis.String(object.destinationRoom) : "",
    };
  },

  toJSON(message: MoveParticipantRequest): unknown {
    const obj: any = {};
    if (message.room !== "") {
      obj.room = message.room;
    }
    if (message.identity !== "") {
      obj.identity = message.identity;
    }
    if (message.destinationRoom !== "") {
      obj.destinationRoom = message.destinationRoom;
    }
    return obj;
  },

  create(base?: DeepPartial<MoveParticipantRequest>): MoveParticipantRequest {
    return MoveParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MoveParticipantRequest>): MoveParticipantRequest {
    const message = createBaseMoveParticipantRequest();
    message.room = object.room ?? "";
    message.identity = object.identity ?? "";
    message.destinationRoom = object.destinationRoom ?? "";
    return message;
  },
};

function createBaseMoveParticipantResponse(): MoveParticipantResponse {
  return {};
}

export const MoveParticipantResponse: MessageFns<MoveParticipantResponse> = {
  encode(_: MoveParticipantResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MoveParticipantResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMoveParticipantResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MoveParticipantResponse {
    return {};
  },

  toJSON(_: MoveParticipantResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<MoveParticipantResponse>): MoveParticipantResponse {
    return MoveParticipantResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<MoveParticipantResponse>): MoveParticipantResponse {
    const message = createBaseMoveParticipantResponse();
    return message;
  },
};

/**
 * Room service that can be performed on any node
 * they are Twirp-based HTTP req/responses
 */
export type RoomServiceDefinition = typeof RoomServiceDefinition;
export const RoomServiceDefinition = {
  name: "RoomService",
  fullName: "livekit.RoomService",
  methods: {
    /**
     * Creates a room with settings. Requires `roomCreate` permission.
     * This method is optional; rooms are automatically created when clients connect to them for the first time.
     */
    createRoom: {
      name: "CreateRoom",
      requestType: CreateRoomRequest,
      requestStream: false,
      responseType: Room,
      responseStream: false,
      options: {},
    },
    /** List rooms that are active on the server. Requires `roomList` permission. */
    listRooms: {
      name: "ListRooms",
      requestType: ListRoomsRequest,
      requestStream: false,
      responseType: ListRoomsResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Deletes an existing room by name or id. Requires `roomCreate` permission.
     * DeleteRoom will disconnect all participants that are currently in the room.
     */
    deleteRoom: {
      name: "DeleteRoom",
      requestType: DeleteRoomRequest,
      requestStream: false,
      responseType: DeleteRoomResponse,
      responseStream: false,
      options: {},
    },
    /** Lists participants in a room, Requires `roomAdmin` */
    listParticipants: {
      name: "ListParticipants",
      requestType: ListParticipantsRequest,
      requestStream: false,
      responseType: ListParticipantsResponse,
      responseStream: false,
      options: {},
    },
    /** Get information on a specific participant, Requires `roomAdmin` */
    getParticipant: {
      name: "GetParticipant",
      requestType: RoomParticipantIdentity,
      requestStream: false,
      responseType: ParticipantInfo,
      responseStream: false,
      options: {},
    },
    /** Removes a participant from room. Requires `roomAdmin` */
    removeParticipant: {
      name: "RemoveParticipant",
      requestType: RoomParticipantIdentity,
      requestStream: false,
      responseType: RemoveParticipantResponse,
      responseStream: false,
      options: {},
    },
    /** Mute/unmute a participant's track, Requires `roomAdmin` */
    mutePublishedTrack: {
      name: "MutePublishedTrack",
      requestType: MuteRoomTrackRequest,
      requestStream: false,
      responseType: MuteRoomTrackResponse,
      responseStream: false,
      options: {},
    },
    /** Update participant metadata, will cause updates to be broadcasted to everyone in the room. Requires `roomAdmin` */
    updateParticipant: {
      name: "UpdateParticipant",
      requestType: UpdateParticipantRequest,
      requestStream: false,
      responseType: ParticipantInfo,
      responseStream: false,
      options: {},
    },
    /** Subscribes or unsubscribe a participant from tracks. Requires `roomAdmin` */
    updateSubscriptions: {
      name: "UpdateSubscriptions",
      requestType: UpdateSubscriptionsRequest,
      requestStream: false,
      responseType: UpdateSubscriptionsResponse,
      responseStream: false,
      options: {},
    },
    /** Send data over data channel to participants in a room, Requires `roomAdmin` */
    sendData: {
      name: "SendData",
      requestType: SendDataRequest,
      requestStream: false,
      responseType: SendDataResponse,
      responseStream: false,
      options: {},
    },
    /** Update room metadata, will cause updates to be broadcasted to everyone in the room, Requires `roomAdmin` */
    updateRoomMetadata: {
      name: "UpdateRoomMetadata",
      requestType: UpdateRoomMetadataRequest,
      requestStream: false,
      responseType: Room,
      responseStream: false,
      options: {},
    },
    /**
     * Cloud-only
     * a connected participant's track(s) to another room. Requires `roomAdmin` and `destinationRoom`. The forwarding will
     * stop when the participant leaves the room or `RemoveParticipant` has been called in the destination room.
     * A participant can be forwarded to multiple rooms. The destination room will be created if it does not exist.
     */
    forwardParticipant: {
      name: "ForwardParticipant",
      requestType: ForwardParticipantRequest,
      requestStream: false,
      responseType: ForwardParticipantResponse,
      responseStream: false,
      options: {},
    },
    /**
     * Cloud-only
     * Move a connected participant to a different room. Requires `roomAdmin` and `destinationRoom`.
     * The participant will be removed from the current room and added to the destination room.
     * From the other observers' perspective, the participant would've disconnected from the previous room and joined the new one.
     */
    moveParticipant: {
      name: "MoveParticipant",
      requestType: MoveParticipantRequest,
      requestStream: false,
      responseType: MoveParticipantResponse,
      responseStream: false,
      options: {},
    },
  },
} as const;

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
