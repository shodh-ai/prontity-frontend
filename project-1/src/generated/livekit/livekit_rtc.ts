// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.28.3
// source: livekit_rtc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  AudioTrackFeature,
  audioTrackFeatureFromJSON,
  audioTrackFeatureToJSON,
  BackupCodecPolicy,
  backupCodecPolicyFromJSON,
  backupCodecPolicyToJSON,
  ClientConfiguration,
  Codec,
  ConnectionQuality,
  connectionQualityFromJSON,
  connectionQualityToJSON,
  DisconnectReason,
  disconnectReasonFromJSON,
  disconnectReasonToJSON,
  Encryption_Type,
  encryption_TypeFromJSON,
  encryption_TypeToJSON,
  ParticipantInfo,
  ParticipantTracks,
  Room,
  ServerInfo,
  SpeakerInfo,
  SubscriptionError,
  subscriptionErrorFromJSON,
  subscriptionErrorToJSON,
  TrackInfo,
  TrackSource,
  trackSourceFromJSON,
  trackSourceToJSON,
  TrackType,
  trackTypeFromJSON,
  trackTypeToJSON,
  VideoLayer,
  VideoQuality,
  videoQualityFromJSON,
  videoQualityToJSON,
} from "./livekit_models";

export const protobufPackage = "livekit";

export enum SignalTarget {
  PUBLISHER = 0,
  SUBSCRIBER = 1,
  UNRECOGNIZED = -1,
}

export function signalTargetFromJSON(object: any): SignalTarget {
  switch (object) {
    case 0:
    case "PUBLISHER":
      return SignalTarget.PUBLISHER;
    case 1:
    case "SUBSCRIBER":
      return SignalTarget.SUBSCRIBER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SignalTarget.UNRECOGNIZED;
  }
}

export function signalTargetToJSON(object: SignalTarget): string {
  switch (object) {
    case SignalTarget.PUBLISHER:
      return "PUBLISHER";
    case SignalTarget.SUBSCRIBER:
      return "SUBSCRIBER";
    case SignalTarget.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum StreamState {
  ACTIVE = 0,
  PAUSED = 1,
  UNRECOGNIZED = -1,
}

export function streamStateFromJSON(object: any): StreamState {
  switch (object) {
    case 0:
    case "ACTIVE":
      return StreamState.ACTIVE;
    case 1:
    case "PAUSED":
      return StreamState.PAUSED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return StreamState.UNRECOGNIZED;
  }
}

export function streamStateToJSON(object: StreamState): string {
  switch (object) {
    case StreamState.ACTIVE:
      return "ACTIVE";
    case StreamState.PAUSED:
      return "PAUSED";
    case StreamState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum CandidateProtocol {
  UDP = 0,
  TCP = 1,
  TLS = 2,
  UNRECOGNIZED = -1,
}

export function candidateProtocolFromJSON(object: any): CandidateProtocol {
  switch (object) {
    case 0:
    case "UDP":
      return CandidateProtocol.UDP;
    case 1:
    case "TCP":
      return CandidateProtocol.TCP;
    case 2:
    case "TLS":
      return CandidateProtocol.TLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return CandidateProtocol.UNRECOGNIZED;
  }
}

export function candidateProtocolToJSON(object: CandidateProtocol): string {
  switch (object) {
    case CandidateProtocol.UDP:
      return "UDP";
    case CandidateProtocol.TCP:
      return "TCP";
    case CandidateProtocol.TLS:
      return "TLS";
    case CandidateProtocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface SignalRequest {
  message?:
    | //
    /** initial join exchange, for publisher */
    { $case: "offer"; offer: SessionDescription }
    | //
    /** participant answering publisher offer */
    { $case: "answer"; answer: SessionDescription }
    | { $case: "trickle"; trickle: TrickleRequest }
    | { $case: "addTrack"; addTrack: AddTrackRequest }
    | //
    /** mute the participant's published tracks */
    { $case: "mute"; mute: MuteTrackRequest }
    | //
    /** Subscribe or unsubscribe from tracks */
    { $case: "subscription"; subscription: UpdateSubscription }
    | //
    /** Update settings of subscribed tracks */
    { $case: "trackSetting"; trackSetting: UpdateTrackSettings }
    | //
    /** Immediately terminate session */
    { $case: "leave"; leave: LeaveRequest }
    | //
    /** Update published video layers */
    { $case: "updateLayers"; updateLayers: UpdateVideoLayers }
    | //
    /** Update subscriber permissions */
    { $case: "subscriptionPermission"; subscriptionPermission: SubscriptionPermission }
    | //
    /** sync client's subscribe state to server during reconnect */
    { $case: "syncState"; syncState: SyncState }
    | //
    /** Simulate conditions, for client validations */
    { $case: "simulate"; simulate: SimulateScenario }
    | //
    /** client triggered ping to server */
    { $case: "ping"; ping: string }
    | //
    /**
     * update a participant's own metadata, name, or attributes
     * requires canUpdateOwnParticipantMetadata permission
     */
    { $case: "updateMetadata"; updateMetadata: UpdateParticipantMetadata }
    | { $case: "pingReq"; pingReq: Ping }
    | //
    /** Update local audio track settings */
    { $case: "updateAudioTrack"; updateAudioTrack: UpdateLocalAudioTrack }
    | //
    /** Update local video track settings */
    { $case: "updateVideoTrack"; updateVideoTrack: UpdateLocalVideoTrack }
    | undefined;
}

export interface SignalResponse {
  message?:
    | //
    /** sent when join is accepted */
    { $case: "join"; join: JoinResponse }
    | //
    /** sent when server answers publisher */
    { $case: "answer"; answer: SessionDescription }
    | //
    /** sent when server is sending subscriber an offer */
    { $case: "offer"; offer: SessionDescription }
    | //
    /** sent when an ICE candidate is available */
    { $case: "trickle"; trickle: TrickleRequest }
    | //
    /** sent when participants in the room has changed */
    { $case: "update"; update: ParticipantUpdate }
    | //
    /** sent to the participant when their track has been published */
    { $case: "trackPublished"; trackPublished: TrackPublishedResponse }
    | //
    /** Immediately terminate session */
    { $case: "leave"; leave: LeaveRequest }
    | //
    /** server initiated mute */
    { $case: "mute"; mute: MuteTrackRequest }
    | //
    /** indicates changes to speaker status, including when they've gone to not speaking */
    { $case: "speakersChanged"; speakersChanged: SpeakersChanged }
    | //
    /** sent when metadata of the room has changed */
    { $case: "roomUpdate"; roomUpdate: RoomUpdate }
    | //
    /** when connection quality changed */
    { $case: "connectionQuality"; connectionQuality: ConnectionQualityUpdate }
    | //
    /**
     * when streamed tracks state changed, used to notify when any of the streams were paused due to
     * congestion
     */
    { $case: "streamStateUpdate"; streamStateUpdate: StreamStateUpdate }
    | //
    /** when max subscribe quality changed, used by dynamic broadcasting to disable unused layers */
    { $case: "subscribedQualityUpdate"; subscribedQualityUpdate: SubscribedQualityUpdate }
    | //
    /** when subscription permission changed */
    { $case: "subscriptionPermissionUpdate"; subscriptionPermissionUpdate: SubscriptionPermissionUpdate }
    | //
    /** update the token the client was using, to prevent an active client from using an expired token */
    { $case: "refreshToken"; refreshToken: string }
    | //
    /** server initiated track unpublish */
    { $case: "trackUnpublished"; trackUnpublished: TrackUnpublishedResponse }
    | //
    /** respond to ping */
    { $case: "pong"; pong: string }
    | //
    /** sent when client reconnects */
    { $case: "reconnect"; reconnect: ReconnectResponse }
    | //
    /** respond to Ping */
    { $case: "pongResp"; pongResp: Pong }
    | //
    /** Subscription response, client should not expect any media from this subscription if it fails */
    { $case: "subscriptionResponse"; subscriptionResponse: SubscriptionResponse }
    | //
    /** Response relating to user inititated requests that carry a `request_id` */
    { $case: "requestResponse"; requestResponse: RequestResponse }
    | //
    /** notify to the publisher when a published track has been subscribed for the first time */
    { $case: "trackSubscribed"; trackSubscribed: TrackSubscribed }
    | //
    /** notify to the participant when they have been moved to a new room */
    { $case: "roomMoved"; roomMoved: RoomMovedResponse }
    | undefined;
}

export interface SimulcastCodec {
  codec: string;
  cid: string;
}

export interface AddTrackRequest {
  /** client ID of track, to match it when RTC track is received */
  cid: string;
  name: string;
  type: TrackType;
  /** to be deprecated in favor of layers */
  width: number;
  height: number;
  /** true to add track and initialize to muted */
  muted: boolean;
  /**
   * true if DTX (Discontinuous Transmission) is disabled for audio
   *
   * @deprecated
   */
  disableDtx: boolean;
  source: TrackSource;
  layers: VideoLayer[];
  simulcastCodecs: SimulcastCodec[];
  /** server ID of track, publish new codec to exist track */
  sid: string;
  /**
   * deprecated in favor of audio_features
   *
   * @deprecated
   */
  stereo: boolean;
  /** true if RED (Redundant Encoding) is disabled for audio */
  disableRed: boolean;
  encryption: Encryption_Type;
  /**
   * which stream the track belongs to, used to group tracks together.
   * if not specified, server will infer it from track source to bundle camera/microphone, screenshare/audio together
   */
  stream: string;
  backupCodecPolicy: BackupCodecPolicy;
  audioFeatures: AudioTrackFeature[];
}

export interface TrickleRequest {
  candidateInit: string;
  target: SignalTarget;
  final: boolean;
}

export interface MuteTrackRequest {
  sid: string;
  muted: boolean;
}

export interface JoinResponse {
  room: Room | undefined;
  participant: ParticipantInfo | undefined;
  otherParticipants: ParticipantInfo[];
  /** deprecated. use server_info.version instead. */
  serverVersion: string;
  iceServers: ICEServer[];
  /** use subscriber as the primary PeerConnection */
  subscriberPrimary: boolean;
  /**
   * when the current server isn't available, return alternate url to retry connection
   * when this is set, the other fields will be largely empty
   */
  alternativeUrl: string;
  clientConfiguration:
    | ClientConfiguration
    | undefined;
  /** deprecated. use server_info.region instead. */
  serverRegion: string;
  pingTimeout: number;
  pingInterval: number;
  serverInfo:
    | ServerInfo
    | undefined;
  /** Server-Injected-Frame byte trailer, used to identify unencrypted frames when e2ee is enabled */
  sifTrailer: Uint8Array;
  enabledPublishCodecs: Codec[];
  /** when set, client should attempt to establish publish peer connection when joining room to speed up publishing */
  fastPublish: boolean;
}

export interface ReconnectResponse {
  iceServers: ICEServer[];
  clientConfiguration: ClientConfiguration | undefined;
  serverInfo: ServerInfo | undefined;
}

export interface TrackPublishedResponse {
  cid: string;
  track: TrackInfo | undefined;
}

export interface TrackUnpublishedResponse {
  trackSid: string;
}

export interface SessionDescription {
  /** "answer" | "offer" | "pranswer" | "rollback" */
  type: string;
  sdp: string;
}

export interface ParticipantUpdate {
  participants: ParticipantInfo[];
}

export interface UpdateSubscription {
  trackSids: string[];
  subscribe: boolean;
  participantTracks: ParticipantTracks[];
}

export interface UpdateTrackSettings {
  trackSids: string[];
  /** when true, the track is placed in a paused state, with no new data returned */
  disabled: boolean;
  /** deprecated in favor of width & height */
  quality: VideoQuality;
  /** for video, width to receive */
  width: number;
  /** for video, height to receive */
  height: number;
  fps: number;
  /**
   * subscription priority. 1 being the highest (0 is unset)
   * when unset, server sill assign priority based on the order of subscription
   * server will use priority in the following ways:
   * 1. when subscribed tracks exceed per-participant subscription limit, server will
   *    pause the lowest priority tracks
   * 2. when the network is congested, server will assign available bandwidth to
   *    higher priority tracks first. lowest priority tracks can be paused
   */
  priority: number;
}

export interface UpdateLocalAudioTrack {
  trackSid: string;
  features: AudioTrackFeature[];
}

export interface UpdateLocalVideoTrack {
  trackSid: string;
  width: number;
  height: number;
}

export interface LeaveRequest {
  /**
   * sent when server initiates the disconnect due to server-restart
   * indicates clients should attempt full-reconnect sequence
   * NOTE: `can_reconnect` obsoleted by `action` starting in protocol version 13
   */
  canReconnect: boolean;
  reason: DisconnectReason;
  action: LeaveRequest_Action;
  regions: RegionSettings | undefined;
}

/** indicates action clients should take on receiving this message */
export enum LeaveRequest_Action {
  /** DISCONNECT - should disconnect */
  DISCONNECT = 0,
  /** RESUME - should attempt a resume with `reconnect=1` in join URL */
  RESUME = 1,
  /** RECONNECT - should attempt a reconnect, i. e. no `reconnect=1` */
  RECONNECT = 2,
  UNRECOGNIZED = -1,
}

export function leaveRequest_ActionFromJSON(object: any): LeaveRequest_Action {
  switch (object) {
    case 0:
    case "DISCONNECT":
      return LeaveRequest_Action.DISCONNECT;
    case 1:
    case "RESUME":
      return LeaveRequest_Action.RESUME;
    case 2:
    case "RECONNECT":
      return LeaveRequest_Action.RECONNECT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return LeaveRequest_Action.UNRECOGNIZED;
  }
}

export function leaveRequest_ActionToJSON(object: LeaveRequest_Action): string {
  switch (object) {
    case LeaveRequest_Action.DISCONNECT:
      return "DISCONNECT";
    case LeaveRequest_Action.RESUME:
      return "RESUME";
    case LeaveRequest_Action.RECONNECT:
      return "RECONNECT";
    case LeaveRequest_Action.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * message to indicate published video track dimensions are changing
 *
 * @deprecated
 */
export interface UpdateVideoLayers {
  trackSid: string;
  layers: VideoLayer[];
}

export interface UpdateParticipantMetadata {
  metadata: string;
  name: string;
  /**
   * attributes to update. it only updates attributes that have been set
   * to delete attributes, set the value to an empty string
   */
  attributes: { [key: string]: string };
  requestId: number;
}

export interface UpdateParticipantMetadata_AttributesEntry {
  key: string;
  value: string;
}

export interface ICEServer {
  urls: string[];
  username: string;
  credential: string;
}

export interface SpeakersChanged {
  speakers: SpeakerInfo[];
}

export interface RoomUpdate {
  room: Room | undefined;
}

export interface ConnectionQualityInfo {
  participantSid: string;
  quality: ConnectionQuality;
  score: number;
}

export interface ConnectionQualityUpdate {
  updates: ConnectionQualityInfo[];
}

export interface StreamStateInfo {
  participantSid: string;
  trackSid: string;
  state: StreamState;
}

export interface StreamStateUpdate {
  streamStates: StreamStateInfo[];
}

export interface SubscribedQuality {
  quality: VideoQuality;
  enabled: boolean;
}

export interface SubscribedCodec {
  codec: string;
  qualities: SubscribedQuality[];
}

export interface SubscribedQualityUpdate {
  trackSid: string;
  /** @deprecated */
  subscribedQualities: SubscribedQuality[];
  subscribedCodecs: SubscribedCodec[];
}

export interface TrackPermission {
  /** permission could be granted either by participant sid or identity */
  participantSid: string;
  allTracks: boolean;
  trackSids: string[];
  participantIdentity: string;
}

export interface SubscriptionPermission {
  allParticipants: boolean;
  trackPermissions: TrackPermission[];
}

export interface SubscriptionPermissionUpdate {
  participantSid: string;
  trackSid: string;
  allowed: boolean;
}

export interface RoomMovedResponse {
  /** information about the new room */
  room:
    | Room
    | undefined;
  /** new reconnect token that can be used to reconnect to the new room */
  token: string;
  participant: ParticipantInfo | undefined;
  otherParticipants: ParticipantInfo[];
}

export interface SyncState {
  /** last subscribe answer before reconnecting */
  answer: SessionDescription | undefined;
  subscription: UpdateSubscription | undefined;
  publishTracks: TrackPublishedResponse[];
  dataChannels: DataChannelInfo[];
  /** last received server side offer before reconnecting */
  offer: SessionDescription | undefined;
  trackSidsDisabled: string[];
}

export interface DataChannelInfo {
  label: string;
  id: number;
  target: SignalTarget;
}

export interface SimulateScenario {
  scenario?:
    | //
    /** simulate N seconds of speaker activity */
    { $case: "speakerUpdate"; speakerUpdate: number }
    | //
    /** simulate local node failure */
    { $case: "nodeFailure"; nodeFailure: boolean }
    | //
    /** simulate migration */
    { $case: "migration"; migration: boolean }
    | //
    /** server to send leave */
    { $case: "serverLeave"; serverLeave: boolean }
    | //
    /** switch candidate protocol to tcp */
    { $case: "switchCandidateProtocol"; switchCandidateProtocol: CandidateProtocol }
    | //
    /**
     * maximum bandwidth for subscribers, in bps
     * when zero, clears artificial bandwidth limit
     */
    { $case: "subscriberBandwidth"; subscriberBandwidth: string }
    | //
    /** disconnect signal on resume */
    { $case: "disconnectSignalOnResume"; disconnectSignalOnResume: boolean }
    | //
    /** disconnect signal on resume before sending any messages from server */
    { $case: "disconnectSignalOnResumeNoMessages"; disconnectSignalOnResumeNoMessages: boolean }
    | //
    /** full reconnect leave request */
    { $case: "leaveRequestFullReconnect"; leaveRequestFullReconnect: boolean }
    | undefined;
}

export interface Ping {
  timestamp: string;
  /** rtt in milliseconds calculated by client */
  rtt: string;
}

export interface Pong {
  /** timestamp field of last received ping request */
  lastPingTimestamp: string;
  timestamp: string;
}

export interface RegionSettings {
  regions: RegionInfo[];
}

export interface RegionInfo {
  region: string;
  url: string;
  distance: string;
}

export interface SubscriptionResponse {
  trackSid: string;
  err: SubscriptionError;
}

export interface RequestResponse {
  requestId: number;
  reason: RequestResponse_Reason;
  message: string;
}

export enum RequestResponse_Reason {
  OK = 0,
  NOT_FOUND = 1,
  NOT_ALLOWED = 2,
  LIMIT_EXCEEDED = 3,
  UNRECOGNIZED = -1,
}

export function requestResponse_ReasonFromJSON(object: any): RequestResponse_Reason {
  switch (object) {
    case 0:
    case "OK":
      return RequestResponse_Reason.OK;
    case 1:
    case "NOT_FOUND":
      return RequestResponse_Reason.NOT_FOUND;
    case 2:
    case "NOT_ALLOWED":
      return RequestResponse_Reason.NOT_ALLOWED;
    case 3:
    case "LIMIT_EXCEEDED":
      return RequestResponse_Reason.LIMIT_EXCEEDED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RequestResponse_Reason.UNRECOGNIZED;
  }
}

export function requestResponse_ReasonToJSON(object: RequestResponse_Reason): string {
  switch (object) {
    case RequestResponse_Reason.OK:
      return "OK";
    case RequestResponse_Reason.NOT_FOUND:
      return "NOT_FOUND";
    case RequestResponse_Reason.NOT_ALLOWED:
      return "NOT_ALLOWED";
    case RequestResponse_Reason.LIMIT_EXCEEDED:
      return "LIMIT_EXCEEDED";
    case RequestResponse_Reason.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface TrackSubscribed {
  trackSid: string;
}

function createBaseSignalRequest(): SignalRequest {
  return { message: undefined };
}

export const SignalRequest: MessageFns<SignalRequest> = {
  encode(message: SignalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "offer":
        SessionDescription.encode(message.message.offer, writer.uint32(10).fork()).join();
        break;
      case "answer":
        SessionDescription.encode(message.message.answer, writer.uint32(18).fork()).join();
        break;
      case "trickle":
        TrickleRequest.encode(message.message.trickle, writer.uint32(26).fork()).join();
        break;
      case "addTrack":
        AddTrackRequest.encode(message.message.addTrack, writer.uint32(34).fork()).join();
        break;
      case "mute":
        MuteTrackRequest.encode(message.message.mute, writer.uint32(42).fork()).join();
        break;
      case "subscription":
        UpdateSubscription.encode(message.message.subscription, writer.uint32(50).fork()).join();
        break;
      case "trackSetting":
        UpdateTrackSettings.encode(message.message.trackSetting, writer.uint32(58).fork()).join();
        break;
      case "leave":
        LeaveRequest.encode(message.message.leave, writer.uint32(66).fork()).join();
        break;
      case "updateLayers":
        UpdateVideoLayers.encode(message.message.updateLayers, writer.uint32(82).fork()).join();
        break;
      case "subscriptionPermission":
        SubscriptionPermission.encode(message.message.subscriptionPermission, writer.uint32(90).fork()).join();
        break;
      case "syncState":
        SyncState.encode(message.message.syncState, writer.uint32(98).fork()).join();
        break;
      case "simulate":
        SimulateScenario.encode(message.message.simulate, writer.uint32(106).fork()).join();
        break;
      case "ping":
        writer.uint32(112).int64(message.message.ping);
        break;
      case "updateMetadata":
        UpdateParticipantMetadata.encode(message.message.updateMetadata, writer.uint32(122).fork()).join();
        break;
      case "pingReq":
        Ping.encode(message.message.pingReq, writer.uint32(130).fork()).join();
        break;
      case "updateAudioTrack":
        UpdateLocalAudioTrack.encode(message.message.updateAudioTrack, writer.uint32(138).fork()).join();
        break;
      case "updateVideoTrack":
        UpdateLocalVideoTrack.encode(message.message.updateVideoTrack, writer.uint32(146).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "offer", offer: SessionDescription.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = { $case: "answer", answer: SessionDescription.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = { $case: "trickle", trickle: TrickleRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = { $case: "addTrack", addTrack: AddTrackRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = { $case: "mute", mute: MuteTrackRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = { $case: "subscription", subscription: UpdateSubscription.decode(reader, reader.uint32()) };
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.message = {
            $case: "trackSetting",
            trackSetting: UpdateTrackSettings.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.message = { $case: "leave", leave: LeaveRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.message = { $case: "updateLayers", updateLayers: UpdateVideoLayers.decode(reader, reader.uint32()) };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.message = {
            $case: "subscriptionPermission",
            subscriptionPermission: SubscriptionPermission.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.message = { $case: "syncState", syncState: SyncState.decode(reader, reader.uint32()) };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.message = { $case: "simulate", simulate: SimulateScenario.decode(reader, reader.uint32()) };
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.message = { $case: "ping", ping: reader.int64().toString() };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.message = {
            $case: "updateMetadata",
            updateMetadata: UpdateParticipantMetadata.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.message = { $case: "pingReq", pingReq: Ping.decode(reader, reader.uint32()) };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.message = {
            $case: "updateAudioTrack",
            updateAudioTrack: UpdateLocalAudioTrack.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          message.message = {
            $case: "updateVideoTrack",
            updateVideoTrack: UpdateLocalVideoTrack.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalRequest {
    return {
      message: isSet(object.offer)
        ? { $case: "offer", offer: SessionDescription.fromJSON(object.offer) }
        : isSet(object.answer)
        ? { $case: "answer", answer: SessionDescription.fromJSON(object.answer) }
        : isSet(object.trickle)
        ? { $case: "trickle", trickle: TrickleRequest.fromJSON(object.trickle) }
        : isSet(object.addTrack)
        ? { $case: "addTrack", addTrack: AddTrackRequest.fromJSON(object.addTrack) }
        : isSet(object.mute)
        ? { $case: "mute", mute: MuteTrackRequest.fromJSON(object.mute) }
        : isSet(object.subscription)
        ? { $case: "subscription", subscription: UpdateSubscription.fromJSON(object.subscription) }
        : isSet(object.trackSetting)
        ? { $case: "trackSetting", trackSetting: UpdateTrackSettings.fromJSON(object.trackSetting) }
        : isSet(object.leave)
        ? { $case: "leave", leave: LeaveRequest.fromJSON(object.leave) }
        : isSet(object.updateLayers)
        ? { $case: "updateLayers", updateLayers: UpdateVideoLayers.fromJSON(object.updateLayers) }
        : isSet(object.subscriptionPermission)
        ? {
          $case: "subscriptionPermission",
          subscriptionPermission: SubscriptionPermission.fromJSON(object.subscriptionPermission),
        }
        : isSet(object.syncState)
        ? { $case: "syncState", syncState: SyncState.fromJSON(object.syncState) }
        : isSet(object.simulate)
        ? { $case: "simulate", simulate: SimulateScenario.fromJSON(object.simulate) }
        : isSet(object.ping)
        ? { $case: "ping", ping: globalThis.String(object.ping) }
        : isSet(object.updateMetadata)
        ? { $case: "updateMetadata", updateMetadata: UpdateParticipantMetadata.fromJSON(object.updateMetadata) }
        : isSet(object.pingReq)
        ? { $case: "pingReq", pingReq: Ping.fromJSON(object.pingReq) }
        : isSet(object.updateAudioTrack)
        ? { $case: "updateAudioTrack", updateAudioTrack: UpdateLocalAudioTrack.fromJSON(object.updateAudioTrack) }
        : isSet(object.updateVideoTrack)
        ? { $case: "updateVideoTrack", updateVideoTrack: UpdateLocalVideoTrack.fromJSON(object.updateVideoTrack) }
        : undefined,
    };
  },

  toJSON(message: SignalRequest): unknown {
    const obj: any = {};
    if (message.message?.$case === "offer") {
      obj.offer = SessionDescription.toJSON(message.message.offer);
    } else if (message.message?.$case === "answer") {
      obj.answer = SessionDescription.toJSON(message.message.answer);
    } else if (message.message?.$case === "trickle") {
      obj.trickle = TrickleRequest.toJSON(message.message.trickle);
    } else if (message.message?.$case === "addTrack") {
      obj.addTrack = AddTrackRequest.toJSON(message.message.addTrack);
    } else if (message.message?.$case === "mute") {
      obj.mute = MuteTrackRequest.toJSON(message.message.mute);
    } else if (message.message?.$case === "subscription") {
      obj.subscription = UpdateSubscription.toJSON(message.message.subscription);
    } else if (message.message?.$case === "trackSetting") {
      obj.trackSetting = UpdateTrackSettings.toJSON(message.message.trackSetting);
    } else if (message.message?.$case === "leave") {
      obj.leave = LeaveRequest.toJSON(message.message.leave);
    } else if (message.message?.$case === "updateLayers") {
      obj.updateLayers = UpdateVideoLayers.toJSON(message.message.updateLayers);
    } else if (message.message?.$case === "subscriptionPermission") {
      obj.subscriptionPermission = SubscriptionPermission.toJSON(message.message.subscriptionPermission);
    } else if (message.message?.$case === "syncState") {
      obj.syncState = SyncState.toJSON(message.message.syncState);
    } else if (message.message?.$case === "simulate") {
      obj.simulate = SimulateScenario.toJSON(message.message.simulate);
    } else if (message.message?.$case === "ping") {
      obj.ping = message.message.ping;
    } else if (message.message?.$case === "updateMetadata") {
      obj.updateMetadata = UpdateParticipantMetadata.toJSON(message.message.updateMetadata);
    } else if (message.message?.$case === "pingReq") {
      obj.pingReq = Ping.toJSON(message.message.pingReq);
    } else if (message.message?.$case === "updateAudioTrack") {
      obj.updateAudioTrack = UpdateLocalAudioTrack.toJSON(message.message.updateAudioTrack);
    } else if (message.message?.$case === "updateVideoTrack") {
      obj.updateVideoTrack = UpdateLocalVideoTrack.toJSON(message.message.updateVideoTrack);
    }
    return obj;
  },

  create(base?: DeepPartial<SignalRequest>): SignalRequest {
    return SignalRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignalRequest>): SignalRequest {
    const message = createBaseSignalRequest();
    switch (object.message?.$case) {
      case "offer": {
        if (object.message?.offer !== undefined && object.message?.offer !== null) {
          message.message = { $case: "offer", offer: SessionDescription.fromPartial(object.message.offer) };
        }
        break;
      }
      case "answer": {
        if (object.message?.answer !== undefined && object.message?.answer !== null) {
          message.message = { $case: "answer", answer: SessionDescription.fromPartial(object.message.answer) };
        }
        break;
      }
      case "trickle": {
        if (object.message?.trickle !== undefined && object.message?.trickle !== null) {
          message.message = { $case: "trickle", trickle: TrickleRequest.fromPartial(object.message.trickle) };
        }
        break;
      }
      case "addTrack": {
        if (object.message?.addTrack !== undefined && object.message?.addTrack !== null) {
          message.message = { $case: "addTrack", addTrack: AddTrackRequest.fromPartial(object.message.addTrack) };
        }
        break;
      }
      case "mute": {
        if (object.message?.mute !== undefined && object.message?.mute !== null) {
          message.message = { $case: "mute", mute: MuteTrackRequest.fromPartial(object.message.mute) };
        }
        break;
      }
      case "subscription": {
        if (object.message?.subscription !== undefined && object.message?.subscription !== null) {
          message.message = {
            $case: "subscription",
            subscription: UpdateSubscription.fromPartial(object.message.subscription),
          };
        }
        break;
      }
      case "trackSetting": {
        if (object.message?.trackSetting !== undefined && object.message?.trackSetting !== null) {
          message.message = {
            $case: "trackSetting",
            trackSetting: UpdateTrackSettings.fromPartial(object.message.trackSetting),
          };
        }
        break;
      }
      case "leave": {
        if (object.message?.leave !== undefined && object.message?.leave !== null) {
          message.message = { $case: "leave", leave: LeaveRequest.fromPartial(object.message.leave) };
        }
        break;
      }
      case "updateLayers": {
        if (object.message?.updateLayers !== undefined && object.message?.updateLayers !== null) {
          message.message = {
            $case: "updateLayers",
            updateLayers: UpdateVideoLayers.fromPartial(object.message.updateLayers),
          };
        }
        break;
      }
      case "subscriptionPermission": {
        if (object.message?.subscriptionPermission !== undefined && object.message?.subscriptionPermission !== null) {
          message.message = {
            $case: "subscriptionPermission",
            subscriptionPermission: SubscriptionPermission.fromPartial(object.message.subscriptionPermission),
          };
        }
        break;
      }
      case "syncState": {
        if (object.message?.syncState !== undefined && object.message?.syncState !== null) {
          message.message = { $case: "syncState", syncState: SyncState.fromPartial(object.message.syncState) };
        }
        break;
      }
      case "simulate": {
        if (object.message?.simulate !== undefined && object.message?.simulate !== null) {
          message.message = { $case: "simulate", simulate: SimulateScenario.fromPartial(object.message.simulate) };
        }
        break;
      }
      case "ping": {
        if (object.message?.ping !== undefined && object.message?.ping !== null) {
          message.message = { $case: "ping", ping: object.message.ping };
        }
        break;
      }
      case "updateMetadata": {
        if (object.message?.updateMetadata !== undefined && object.message?.updateMetadata !== null) {
          message.message = {
            $case: "updateMetadata",
            updateMetadata: UpdateParticipantMetadata.fromPartial(object.message.updateMetadata),
          };
        }
        break;
      }
      case "pingReq": {
        if (object.message?.pingReq !== undefined && object.message?.pingReq !== null) {
          message.message = { $case: "pingReq", pingReq: Ping.fromPartial(object.message.pingReq) };
        }
        break;
      }
      case "updateAudioTrack": {
        if (object.message?.updateAudioTrack !== undefined && object.message?.updateAudioTrack !== null) {
          message.message = {
            $case: "updateAudioTrack",
            updateAudioTrack: UpdateLocalAudioTrack.fromPartial(object.message.updateAudioTrack),
          };
        }
        break;
      }
      case "updateVideoTrack": {
        if (object.message?.updateVideoTrack !== undefined && object.message?.updateVideoTrack !== null) {
          message.message = {
            $case: "updateVideoTrack",
            updateVideoTrack: UpdateLocalVideoTrack.fromPartial(object.message.updateVideoTrack),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSignalResponse(): SignalResponse {
  return { message: undefined };
}

export const SignalResponse: MessageFns<SignalResponse> = {
  encode(message: SignalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.message?.$case) {
      case "join":
        JoinResponse.encode(message.message.join, writer.uint32(10).fork()).join();
        break;
      case "answer":
        SessionDescription.encode(message.message.answer, writer.uint32(18).fork()).join();
        break;
      case "offer":
        SessionDescription.encode(message.message.offer, writer.uint32(26).fork()).join();
        break;
      case "trickle":
        TrickleRequest.encode(message.message.trickle, writer.uint32(34).fork()).join();
        break;
      case "update":
        ParticipantUpdate.encode(message.message.update, writer.uint32(42).fork()).join();
        break;
      case "trackPublished":
        TrackPublishedResponse.encode(message.message.trackPublished, writer.uint32(50).fork()).join();
        break;
      case "leave":
        LeaveRequest.encode(message.message.leave, writer.uint32(66).fork()).join();
        break;
      case "mute":
        MuteTrackRequest.encode(message.message.mute, writer.uint32(74).fork()).join();
        break;
      case "speakersChanged":
        SpeakersChanged.encode(message.message.speakersChanged, writer.uint32(82).fork()).join();
        break;
      case "roomUpdate":
        RoomUpdate.encode(message.message.roomUpdate, writer.uint32(90).fork()).join();
        break;
      case "connectionQuality":
        ConnectionQualityUpdate.encode(message.message.connectionQuality, writer.uint32(98).fork()).join();
        break;
      case "streamStateUpdate":
        StreamStateUpdate.encode(message.message.streamStateUpdate, writer.uint32(106).fork()).join();
        break;
      case "subscribedQualityUpdate":
        SubscribedQualityUpdate.encode(message.message.subscribedQualityUpdate, writer.uint32(114).fork()).join();
        break;
      case "subscriptionPermissionUpdate":
        SubscriptionPermissionUpdate.encode(message.message.subscriptionPermissionUpdate, writer.uint32(122).fork())
          .join();
        break;
      case "refreshToken":
        writer.uint32(130).string(message.message.refreshToken);
        break;
      case "trackUnpublished":
        TrackUnpublishedResponse.encode(message.message.trackUnpublished, writer.uint32(138).fork()).join();
        break;
      case "pong":
        writer.uint32(144).int64(message.message.pong);
        break;
      case "reconnect":
        ReconnectResponse.encode(message.message.reconnect, writer.uint32(154).fork()).join();
        break;
      case "pongResp":
        Pong.encode(message.message.pongResp, writer.uint32(162).fork()).join();
        break;
      case "subscriptionResponse":
        SubscriptionResponse.encode(message.message.subscriptionResponse, writer.uint32(170).fork()).join();
        break;
      case "requestResponse":
        RequestResponse.encode(message.message.requestResponse, writer.uint32(178).fork()).join();
        break;
      case "trackSubscribed":
        TrackSubscribed.encode(message.message.trackSubscribed, writer.uint32(186).fork()).join();
        break;
      case "roomMoved":
        RoomMovedResponse.encode(message.message.roomMoved, writer.uint32(194).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = { $case: "join", join: JoinResponse.decode(reader, reader.uint32()) };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = { $case: "answer", answer: SessionDescription.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = { $case: "offer", offer: SessionDescription.decode(reader, reader.uint32()) };
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.message = { $case: "trickle", trickle: TrickleRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = { $case: "update", update: ParticipantUpdate.decode(reader, reader.uint32()) };
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.message = {
            $case: "trackPublished",
            trackPublished: TrackPublishedResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.message = { $case: "leave", leave: LeaveRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.message = { $case: "mute", mute: MuteTrackRequest.decode(reader, reader.uint32()) };
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.message = {
            $case: "speakersChanged",
            speakersChanged: SpeakersChanged.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.message = { $case: "roomUpdate", roomUpdate: RoomUpdate.decode(reader, reader.uint32()) };
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.message = {
            $case: "connectionQuality",
            connectionQuality: ConnectionQualityUpdate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.message = {
            $case: "streamStateUpdate",
            streamStateUpdate: StreamStateUpdate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.message = {
            $case: "subscribedQualityUpdate",
            subscribedQualityUpdate: SubscribedQualityUpdate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.message = {
            $case: "subscriptionPermissionUpdate",
            subscriptionPermissionUpdate: SubscriptionPermissionUpdate.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.message = { $case: "refreshToken", refreshToken: reader.string() };
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.message = {
            $case: "trackUnpublished",
            trackUnpublished: TrackUnpublishedResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.message = { $case: "pong", pong: reader.int64().toString() };
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.message = { $case: "reconnect", reconnect: ReconnectResponse.decode(reader, reader.uint32()) };
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.message = { $case: "pongResp", pongResp: Pong.decode(reader, reader.uint32()) };
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.message = {
            $case: "subscriptionResponse",
            subscriptionResponse: SubscriptionResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 22: {
          if (tag !== 178) {
            break;
          }

          message.message = {
            $case: "requestResponse",
            requestResponse: RequestResponse.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 23: {
          if (tag !== 186) {
            break;
          }

          message.message = {
            $case: "trackSubscribed",
            trackSubscribed: TrackSubscribed.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 24: {
          if (tag !== 194) {
            break;
          }

          message.message = { $case: "roomMoved", roomMoved: RoomMovedResponse.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalResponse {
    return {
      message: isSet(object.join)
        ? { $case: "join", join: JoinResponse.fromJSON(object.join) }
        : isSet(object.answer)
        ? { $case: "answer", answer: SessionDescription.fromJSON(object.answer) }
        : isSet(object.offer)
        ? { $case: "offer", offer: SessionDescription.fromJSON(object.offer) }
        : isSet(object.trickle)
        ? { $case: "trickle", trickle: TrickleRequest.fromJSON(object.trickle) }
        : isSet(object.update)
        ? { $case: "update", update: ParticipantUpdate.fromJSON(object.update) }
        : isSet(object.trackPublished)
        ? { $case: "trackPublished", trackPublished: TrackPublishedResponse.fromJSON(object.trackPublished) }
        : isSet(object.leave)
        ? { $case: "leave", leave: LeaveRequest.fromJSON(object.leave) }
        : isSet(object.mute)
        ? { $case: "mute", mute: MuteTrackRequest.fromJSON(object.mute) }
        : isSet(object.speakersChanged)
        ? { $case: "speakersChanged", speakersChanged: SpeakersChanged.fromJSON(object.speakersChanged) }
        : isSet(object.roomUpdate)
        ? { $case: "roomUpdate", roomUpdate: RoomUpdate.fromJSON(object.roomUpdate) }
        : isSet(object.connectionQuality)
        ? { $case: "connectionQuality", connectionQuality: ConnectionQualityUpdate.fromJSON(object.connectionQuality) }
        : isSet(object.streamStateUpdate)
        ? { $case: "streamStateUpdate", streamStateUpdate: StreamStateUpdate.fromJSON(object.streamStateUpdate) }
        : isSet(object.subscribedQualityUpdate)
        ? {
          $case: "subscribedQualityUpdate",
          subscribedQualityUpdate: SubscribedQualityUpdate.fromJSON(object.subscribedQualityUpdate),
        }
        : isSet(object.subscriptionPermissionUpdate)
        ? {
          $case: "subscriptionPermissionUpdate",
          subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromJSON(object.subscriptionPermissionUpdate),
        }
        : isSet(object.refreshToken)
        ? { $case: "refreshToken", refreshToken: globalThis.String(object.refreshToken) }
        : isSet(object.trackUnpublished)
        ? { $case: "trackUnpublished", trackUnpublished: TrackUnpublishedResponse.fromJSON(object.trackUnpublished) }
        : isSet(object.pong)
        ? { $case: "pong", pong: globalThis.String(object.pong) }
        : isSet(object.reconnect)
        ? { $case: "reconnect", reconnect: ReconnectResponse.fromJSON(object.reconnect) }
        : isSet(object.pongResp)
        ? { $case: "pongResp", pongResp: Pong.fromJSON(object.pongResp) }
        : isSet(object.subscriptionResponse)
        ? {
          $case: "subscriptionResponse",
          subscriptionResponse: SubscriptionResponse.fromJSON(object.subscriptionResponse),
        }
        : isSet(object.requestResponse)
        ? { $case: "requestResponse", requestResponse: RequestResponse.fromJSON(object.requestResponse) }
        : isSet(object.trackSubscribed)
        ? { $case: "trackSubscribed", trackSubscribed: TrackSubscribed.fromJSON(object.trackSubscribed) }
        : isSet(object.roomMoved)
        ? { $case: "roomMoved", roomMoved: RoomMovedResponse.fromJSON(object.roomMoved) }
        : undefined,
    };
  },

  toJSON(message: SignalResponse): unknown {
    const obj: any = {};
    if (message.message?.$case === "join") {
      obj.join = JoinResponse.toJSON(message.message.join);
    } else if (message.message?.$case === "answer") {
      obj.answer = SessionDescription.toJSON(message.message.answer);
    } else if (message.message?.$case === "offer") {
      obj.offer = SessionDescription.toJSON(message.message.offer);
    } else if (message.message?.$case === "trickle") {
      obj.trickle = TrickleRequest.toJSON(message.message.trickle);
    } else if (message.message?.$case === "update") {
      obj.update = ParticipantUpdate.toJSON(message.message.update);
    } else if (message.message?.$case === "trackPublished") {
      obj.trackPublished = TrackPublishedResponse.toJSON(message.message.trackPublished);
    } else if (message.message?.$case === "leave") {
      obj.leave = LeaveRequest.toJSON(message.message.leave);
    } else if (message.message?.$case === "mute") {
      obj.mute = MuteTrackRequest.toJSON(message.message.mute);
    } else if (message.message?.$case === "speakersChanged") {
      obj.speakersChanged = SpeakersChanged.toJSON(message.message.speakersChanged);
    } else if (message.message?.$case === "roomUpdate") {
      obj.roomUpdate = RoomUpdate.toJSON(message.message.roomUpdate);
    } else if (message.message?.$case === "connectionQuality") {
      obj.connectionQuality = ConnectionQualityUpdate.toJSON(message.message.connectionQuality);
    } else if (message.message?.$case === "streamStateUpdate") {
      obj.streamStateUpdate = StreamStateUpdate.toJSON(message.message.streamStateUpdate);
    } else if (message.message?.$case === "subscribedQualityUpdate") {
      obj.subscribedQualityUpdate = SubscribedQualityUpdate.toJSON(message.message.subscribedQualityUpdate);
    } else if (message.message?.$case === "subscriptionPermissionUpdate") {
      obj.subscriptionPermissionUpdate = SubscriptionPermissionUpdate.toJSON(
        message.message.subscriptionPermissionUpdate,
      );
    } else if (message.message?.$case === "refreshToken") {
      obj.refreshToken = message.message.refreshToken;
    } else if (message.message?.$case === "trackUnpublished") {
      obj.trackUnpublished = TrackUnpublishedResponse.toJSON(message.message.trackUnpublished);
    } else if (message.message?.$case === "pong") {
      obj.pong = message.message.pong;
    } else if (message.message?.$case === "reconnect") {
      obj.reconnect = ReconnectResponse.toJSON(message.message.reconnect);
    } else if (message.message?.$case === "pongResp") {
      obj.pongResp = Pong.toJSON(message.message.pongResp);
    } else if (message.message?.$case === "subscriptionResponse") {
      obj.subscriptionResponse = SubscriptionResponse.toJSON(message.message.subscriptionResponse);
    } else if (message.message?.$case === "requestResponse") {
      obj.requestResponse = RequestResponse.toJSON(message.message.requestResponse);
    } else if (message.message?.$case === "trackSubscribed") {
      obj.trackSubscribed = TrackSubscribed.toJSON(message.message.trackSubscribed);
    } else if (message.message?.$case === "roomMoved") {
      obj.roomMoved = RoomMovedResponse.toJSON(message.message.roomMoved);
    }
    return obj;
  },

  create(base?: DeepPartial<SignalResponse>): SignalResponse {
    return SignalResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SignalResponse>): SignalResponse {
    const message = createBaseSignalResponse();
    switch (object.message?.$case) {
      case "join": {
        if (object.message?.join !== undefined && object.message?.join !== null) {
          message.message = { $case: "join", join: JoinResponse.fromPartial(object.message.join) };
        }
        break;
      }
      case "answer": {
        if (object.message?.answer !== undefined && object.message?.answer !== null) {
          message.message = { $case: "answer", answer: SessionDescription.fromPartial(object.message.answer) };
        }
        break;
      }
      case "offer": {
        if (object.message?.offer !== undefined && object.message?.offer !== null) {
          message.message = { $case: "offer", offer: SessionDescription.fromPartial(object.message.offer) };
        }
        break;
      }
      case "trickle": {
        if (object.message?.trickle !== undefined && object.message?.trickle !== null) {
          message.message = { $case: "trickle", trickle: TrickleRequest.fromPartial(object.message.trickle) };
        }
        break;
      }
      case "update": {
        if (object.message?.update !== undefined && object.message?.update !== null) {
          message.message = { $case: "update", update: ParticipantUpdate.fromPartial(object.message.update) };
        }
        break;
      }
      case "trackPublished": {
        if (object.message?.trackPublished !== undefined && object.message?.trackPublished !== null) {
          message.message = {
            $case: "trackPublished",
            trackPublished: TrackPublishedResponse.fromPartial(object.message.trackPublished),
          };
        }
        break;
      }
      case "leave": {
        if (object.message?.leave !== undefined && object.message?.leave !== null) {
          message.message = { $case: "leave", leave: LeaveRequest.fromPartial(object.message.leave) };
        }
        break;
      }
      case "mute": {
        if (object.message?.mute !== undefined && object.message?.mute !== null) {
          message.message = { $case: "mute", mute: MuteTrackRequest.fromPartial(object.message.mute) };
        }
        break;
      }
      case "speakersChanged": {
        if (object.message?.speakersChanged !== undefined && object.message?.speakersChanged !== null) {
          message.message = {
            $case: "speakersChanged",
            speakersChanged: SpeakersChanged.fromPartial(object.message.speakersChanged),
          };
        }
        break;
      }
      case "roomUpdate": {
        if (object.message?.roomUpdate !== undefined && object.message?.roomUpdate !== null) {
          message.message = { $case: "roomUpdate", roomUpdate: RoomUpdate.fromPartial(object.message.roomUpdate) };
        }
        break;
      }
      case "connectionQuality": {
        if (object.message?.connectionQuality !== undefined && object.message?.connectionQuality !== null) {
          message.message = {
            $case: "connectionQuality",
            connectionQuality: ConnectionQualityUpdate.fromPartial(object.message.connectionQuality),
          };
        }
        break;
      }
      case "streamStateUpdate": {
        if (object.message?.streamStateUpdate !== undefined && object.message?.streamStateUpdate !== null) {
          message.message = {
            $case: "streamStateUpdate",
            streamStateUpdate: StreamStateUpdate.fromPartial(object.message.streamStateUpdate),
          };
        }
        break;
      }
      case "subscribedQualityUpdate": {
        if (object.message?.subscribedQualityUpdate !== undefined && object.message?.subscribedQualityUpdate !== null) {
          message.message = {
            $case: "subscribedQualityUpdate",
            subscribedQualityUpdate: SubscribedQualityUpdate.fromPartial(object.message.subscribedQualityUpdate),
          };
        }
        break;
      }
      case "subscriptionPermissionUpdate": {
        if (
          object.message?.subscriptionPermissionUpdate !== undefined &&
          object.message?.subscriptionPermissionUpdate !== null
        ) {
          message.message = {
            $case: "subscriptionPermissionUpdate",
            subscriptionPermissionUpdate: SubscriptionPermissionUpdate.fromPartial(
              object.message.subscriptionPermissionUpdate,
            ),
          };
        }
        break;
      }
      case "refreshToken": {
        if (object.message?.refreshToken !== undefined && object.message?.refreshToken !== null) {
          message.message = { $case: "refreshToken", refreshToken: object.message.refreshToken };
        }
        break;
      }
      case "trackUnpublished": {
        if (object.message?.trackUnpublished !== undefined && object.message?.trackUnpublished !== null) {
          message.message = {
            $case: "trackUnpublished",
            trackUnpublished: TrackUnpublishedResponse.fromPartial(object.message.trackUnpublished),
          };
        }
        break;
      }
      case "pong": {
        if (object.message?.pong !== undefined && object.message?.pong !== null) {
          message.message = { $case: "pong", pong: object.message.pong };
        }
        break;
      }
      case "reconnect": {
        if (object.message?.reconnect !== undefined && object.message?.reconnect !== null) {
          message.message = { $case: "reconnect", reconnect: ReconnectResponse.fromPartial(object.message.reconnect) };
        }
        break;
      }
      case "pongResp": {
        if (object.message?.pongResp !== undefined && object.message?.pongResp !== null) {
          message.message = { $case: "pongResp", pongResp: Pong.fromPartial(object.message.pongResp) };
        }
        break;
      }
      case "subscriptionResponse": {
        if (object.message?.subscriptionResponse !== undefined && object.message?.subscriptionResponse !== null) {
          message.message = {
            $case: "subscriptionResponse",
            subscriptionResponse: SubscriptionResponse.fromPartial(object.message.subscriptionResponse),
          };
        }
        break;
      }
      case "requestResponse": {
        if (object.message?.requestResponse !== undefined && object.message?.requestResponse !== null) {
          message.message = {
            $case: "requestResponse",
            requestResponse: RequestResponse.fromPartial(object.message.requestResponse),
          };
        }
        break;
      }
      case "trackSubscribed": {
        if (object.message?.trackSubscribed !== undefined && object.message?.trackSubscribed !== null) {
          message.message = {
            $case: "trackSubscribed",
            trackSubscribed: TrackSubscribed.fromPartial(object.message.trackSubscribed),
          };
        }
        break;
      }
      case "roomMoved": {
        if (object.message?.roomMoved !== undefined && object.message?.roomMoved !== null) {
          message.message = { $case: "roomMoved", roomMoved: RoomMovedResponse.fromPartial(object.message.roomMoved) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSimulcastCodec(): SimulcastCodec {
  return { codec: "", cid: "" };
}

export const SimulcastCodec: MessageFns<SimulcastCodec> = {
  encode(message: SimulcastCodec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    if (message.cid !== "") {
      writer.uint32(18).string(message.cid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimulcastCodec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulcastCodec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.cid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulcastCodec {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
    };
  },

  toJSON(message: SimulcastCodec): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    return obj;
  },

  create(base?: DeepPartial<SimulcastCodec>): SimulcastCodec {
    return SimulcastCodec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SimulcastCodec>): SimulcastCodec {
    const message = createBaseSimulcastCodec();
    message.codec = object.codec ?? "";
    message.cid = object.cid ?? "";
    return message;
  },
};

function createBaseAddTrackRequest(): AddTrackRequest {
  return {
    cid: "",
    name: "",
    type: 0,
    width: 0,
    height: 0,
    muted: false,
    disableDtx: false,
    source: 0,
    layers: [],
    simulcastCodecs: [],
    sid: "",
    stereo: false,
    disableRed: false,
    encryption: 0,
    stream: "",
    backupCodecPolicy: 0,
    audioFeatures: [],
  };
}

export const AddTrackRequest: MessageFns<AddTrackRequest> = {
  encode(message: AddTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cid !== "") {
      writer.uint32(10).string(message.cid);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.width !== 0) {
      writer.uint32(32).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(40).uint32(message.height);
    }
    if (message.muted !== false) {
      writer.uint32(48).bool(message.muted);
    }
    if (message.disableDtx !== false) {
      writer.uint32(56).bool(message.disableDtx);
    }
    if (message.source !== 0) {
      writer.uint32(64).int32(message.source);
    }
    for (const v of message.layers) {
      VideoLayer.encode(v!, writer.uint32(74).fork()).join();
    }
    for (const v of message.simulcastCodecs) {
      SimulcastCodec.encode(v!, writer.uint32(82).fork()).join();
    }
    if (message.sid !== "") {
      writer.uint32(90).string(message.sid);
    }
    if (message.stereo !== false) {
      writer.uint32(96).bool(message.stereo);
    }
    if (message.disableRed !== false) {
      writer.uint32(104).bool(message.disableRed);
    }
    if (message.encryption !== 0) {
      writer.uint32(112).int32(message.encryption);
    }
    if (message.stream !== "") {
      writer.uint32(122).string(message.stream);
    }
    if (message.backupCodecPolicy !== 0) {
      writer.uint32(128).int32(message.backupCodecPolicy);
    }
    writer.uint32(138).fork();
    for (const v of message.audioFeatures) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.muted = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.disableDtx = reader.bool();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.source = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.layers.push(VideoLayer.decode(reader, reader.uint32()));
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.simulcastCodecs.push(SimulcastCodec.decode(reader, reader.uint32()));
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.sid = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.stereo = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.disableRed = reader.bool();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.encryption = reader.int32() as any;
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.stream = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.backupCodecPolicy = reader.int32() as any;
          continue;
        }
        case 17: {
          if (tag === 136) {
            message.audioFeatures.push(reader.int32() as any);

            continue;
          }

          if (tag === 138) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.audioFeatures.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddTrackRequest {
    return {
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      type: isSet(object.type) ? trackTypeFromJSON(object.type) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      muted: isSet(object.muted) ? globalThis.Boolean(object.muted) : false,
      disableDtx: isSet(object.disableDtx) ? globalThis.Boolean(object.disableDtx) : false,
      source: isSet(object.source) ? trackSourceFromJSON(object.source) : 0,
      layers: globalThis.Array.isArray(object?.layers) ? object.layers.map((e: any) => VideoLayer.fromJSON(e)) : [],
      simulcastCodecs: globalThis.Array.isArray(object?.simulcastCodecs)
        ? object.simulcastCodecs.map((e: any) => SimulcastCodec.fromJSON(e))
        : [],
      sid: isSet(object.sid) ? globalThis.String(object.sid) : "",
      stereo: isSet(object.stereo) ? globalThis.Boolean(object.stereo) : false,
      disableRed: isSet(object.disableRed) ? globalThis.Boolean(object.disableRed) : false,
      encryption: isSet(object.encryption) ? encryption_TypeFromJSON(object.encryption) : 0,
      stream: isSet(object.stream) ? globalThis.String(object.stream) : "",
      backupCodecPolicy: isSet(object.backupCodecPolicy) ? backupCodecPolicyFromJSON(object.backupCodecPolicy) : 0,
      audioFeatures: globalThis.Array.isArray(object?.audioFeatures)
        ? object.audioFeatures.map((e: any) => audioTrackFeatureFromJSON(e))
        : [],
    };
  },

  toJSON(message: AddTrackRequest): unknown {
    const obj: any = {};
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.type !== 0) {
      obj.type = trackTypeToJSON(message.type);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.muted !== false) {
      obj.muted = message.muted;
    }
    if (message.disableDtx !== false) {
      obj.disableDtx = message.disableDtx;
    }
    if (message.source !== 0) {
      obj.source = trackSourceToJSON(message.source);
    }
    if (message.layers?.length) {
      obj.layers = message.layers.map((e) => VideoLayer.toJSON(e));
    }
    if (message.simulcastCodecs?.length) {
      obj.simulcastCodecs = message.simulcastCodecs.map((e) => SimulcastCodec.toJSON(e));
    }
    if (message.sid !== "") {
      obj.sid = message.sid;
    }
    if (message.stereo !== false) {
      obj.stereo = message.stereo;
    }
    if (message.disableRed !== false) {
      obj.disableRed = message.disableRed;
    }
    if (message.encryption !== 0) {
      obj.encryption = encryption_TypeToJSON(message.encryption);
    }
    if (message.stream !== "") {
      obj.stream = message.stream;
    }
    if (message.backupCodecPolicy !== 0) {
      obj.backupCodecPolicy = backupCodecPolicyToJSON(message.backupCodecPolicy);
    }
    if (message.audioFeatures?.length) {
      obj.audioFeatures = message.audioFeatures.map((e) => audioTrackFeatureToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<AddTrackRequest>): AddTrackRequest {
    return AddTrackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AddTrackRequest>): AddTrackRequest {
    const message = createBaseAddTrackRequest();
    message.cid = object.cid ?? "";
    message.name = object.name ?? "";
    message.type = object.type ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.muted = object.muted ?? false;
    message.disableDtx = object.disableDtx ?? false;
    message.source = object.source ?? 0;
    message.layers = object.layers?.map((e) => VideoLayer.fromPartial(e)) || [];
    message.simulcastCodecs = object.simulcastCodecs?.map((e) => SimulcastCodec.fromPartial(e)) || [];
    message.sid = object.sid ?? "";
    message.stereo = object.stereo ?? false;
    message.disableRed = object.disableRed ?? false;
    message.encryption = object.encryption ?? 0;
    message.stream = object.stream ?? "";
    message.backupCodecPolicy = object.backupCodecPolicy ?? 0;
    message.audioFeatures = object.audioFeatures?.map((e) => e) || [];
    return message;
  },
};

function createBaseTrickleRequest(): TrickleRequest {
  return { candidateInit: "", target: 0, final: false };
}

export const TrickleRequest: MessageFns<TrickleRequest> = {
  encode(message: TrickleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.candidateInit !== "") {
      writer.uint32(10).string(message.candidateInit);
    }
    if (message.target !== 0) {
      writer.uint32(16).int32(message.target);
    }
    if (message.final !== false) {
      writer.uint32(24).bool(message.final);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrickleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrickleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.candidateInit = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.final = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrickleRequest {
    return {
      candidateInit: isSet(object.candidateInit) ? globalThis.String(object.candidateInit) : "",
      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0,
      final: isSet(object.final) ? globalThis.Boolean(object.final) : false,
    };
  },

  toJSON(message: TrickleRequest): unknown {
    const obj: any = {};
    if (message.candidateInit !== "") {
      obj.candidateInit = message.candidateInit;
    }
    if (message.target !== 0) {
      obj.target = signalTargetToJSON(message.target);
    }
    if (message.final !== false) {
      obj.final = message.final;
    }
    return obj;
  },

  create(base?: DeepPartial<TrickleRequest>): TrickleRequest {
    return TrickleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrickleRequest>): TrickleRequest {
    const message = createBaseTrickleRequest();
    message.candidateInit = object.candidateInit ?? "";
    message.target = object.target ?? 0;
    message.final = object.final ?? false;
    return message;
  },
};

function createBaseMuteTrackRequest(): MuteTrackRequest {
  return { sid: "", muted: false };
}

export const MuteTrackRequest: MessageFns<MuteTrackRequest> = {
  encode(message: MuteTrackRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sid !== "") {
      writer.uint32(10).string(message.sid);
    }
    if (message.muted !== false) {
      writer.uint32(16).bool(message.muted);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MuteTrackRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMuteTrackRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.muted = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MuteTrackRequest {
    return {
      sid: isSet(object.sid) ? globalThis.String(object.sid) : "",
      muted: isSet(object.muted) ? globalThis.Boolean(object.muted) : false,
    };
  },

  toJSON(message: MuteTrackRequest): unknown {
    const obj: any = {};
    if (message.sid !== "") {
      obj.sid = message.sid;
    }
    if (message.muted !== false) {
      obj.muted = message.muted;
    }
    return obj;
  },

  create(base?: DeepPartial<MuteTrackRequest>): MuteTrackRequest {
    return MuteTrackRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<MuteTrackRequest>): MuteTrackRequest {
    const message = createBaseMuteTrackRequest();
    message.sid = object.sid ?? "";
    message.muted = object.muted ?? false;
    return message;
  },
};

function createBaseJoinResponse(): JoinResponse {
  return {
    room: undefined,
    participant: undefined,
    otherParticipants: [],
    serverVersion: "",
    iceServers: [],
    subscriberPrimary: false,
    alternativeUrl: "",
    clientConfiguration: undefined,
    serverRegion: "",
    pingTimeout: 0,
    pingInterval: 0,
    serverInfo: undefined,
    sifTrailer: new Uint8Array(0),
    enabledPublishCodecs: [],
    fastPublish: false,
  };
}

export const JoinResponse: MessageFns<JoinResponse> = {
  encode(message: JoinResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== undefined) {
      Room.encode(message.room, writer.uint32(10).fork()).join();
    }
    if (message.participant !== undefined) {
      ParticipantInfo.encode(message.participant, writer.uint32(18).fork()).join();
    }
    for (const v of message.otherParticipants) {
      ParticipantInfo.encode(v!, writer.uint32(26).fork()).join();
    }
    if (message.serverVersion !== "") {
      writer.uint32(34).string(message.serverVersion);
    }
    for (const v of message.iceServers) {
      ICEServer.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.subscriberPrimary !== false) {
      writer.uint32(48).bool(message.subscriberPrimary);
    }
    if (message.alternativeUrl !== "") {
      writer.uint32(58).string(message.alternativeUrl);
    }
    if (message.clientConfiguration !== undefined) {
      ClientConfiguration.encode(message.clientConfiguration, writer.uint32(66).fork()).join();
    }
    if (message.serverRegion !== "") {
      writer.uint32(74).string(message.serverRegion);
    }
    if (message.pingTimeout !== 0) {
      writer.uint32(80).int32(message.pingTimeout);
    }
    if (message.pingInterval !== 0) {
      writer.uint32(88).int32(message.pingInterval);
    }
    if (message.serverInfo !== undefined) {
      ServerInfo.encode(message.serverInfo, writer.uint32(98).fork()).join();
    }
    if (message.sifTrailer.length !== 0) {
      writer.uint32(106).bytes(message.sifTrailer);
    }
    for (const v of message.enabledPublishCodecs) {
      Codec.encode(v!, writer.uint32(114).fork()).join();
    }
    if (message.fastPublish !== false) {
      writer.uint32(120).bool(message.fastPublish);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): JoinResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseJoinResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = Room.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participant = ParticipantInfo.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.otherParticipants.push(ParticipantInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.serverVersion = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.iceServers.push(ICEServer.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.subscriberPrimary = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.alternativeUrl = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.clientConfiguration = ClientConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.serverRegion = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.pingTimeout = reader.int32();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.pingInterval = reader.int32();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.serverInfo = ServerInfo.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.sifTrailer = reader.bytes();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.enabledPublishCodecs.push(Codec.decode(reader, reader.uint32()));
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.fastPublish = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): JoinResponse {
    return {
      room: isSet(object.room) ? Room.fromJSON(object.room) : undefined,
      participant: isSet(object.participant) ? ParticipantInfo.fromJSON(object.participant) : undefined,
      otherParticipants: globalThis.Array.isArray(object?.otherParticipants)
        ? object.otherParticipants.map((e: any) => ParticipantInfo.fromJSON(e))
        : [],
      serverVersion: isSet(object.serverVersion) ? globalThis.String(object.serverVersion) : "",
      iceServers: globalThis.Array.isArray(object?.iceServers)
        ? object.iceServers.map((e: any) => ICEServer.fromJSON(e))
        : [],
      subscriberPrimary: isSet(object.subscriberPrimary) ? globalThis.Boolean(object.subscriberPrimary) : false,
      alternativeUrl: isSet(object.alternativeUrl) ? globalThis.String(object.alternativeUrl) : "",
      clientConfiguration: isSet(object.clientConfiguration)
        ? ClientConfiguration.fromJSON(object.clientConfiguration)
        : undefined,
      serverRegion: isSet(object.serverRegion) ? globalThis.String(object.serverRegion) : "",
      pingTimeout: isSet(object.pingTimeout) ? globalThis.Number(object.pingTimeout) : 0,
      pingInterval: isSet(object.pingInterval) ? globalThis.Number(object.pingInterval) : 0,
      serverInfo: isSet(object.serverInfo) ? ServerInfo.fromJSON(object.serverInfo) : undefined,
      sifTrailer: isSet(object.sifTrailer) ? bytesFromBase64(object.sifTrailer) : new Uint8Array(0),
      enabledPublishCodecs: globalThis.Array.isArray(object?.enabledPublishCodecs)
        ? object.enabledPublishCodecs.map((e: any) => Codec.fromJSON(e))
        : [],
      fastPublish: isSet(object.fastPublish) ? globalThis.Boolean(object.fastPublish) : false,
    };
  },

  toJSON(message: JoinResponse): unknown {
    const obj: any = {};
    if (message.room !== undefined) {
      obj.room = Room.toJSON(message.room);
    }
    if (message.participant !== undefined) {
      obj.participant = ParticipantInfo.toJSON(message.participant);
    }
    if (message.otherParticipants?.length) {
      obj.otherParticipants = message.otherParticipants.map((e) => ParticipantInfo.toJSON(e));
    }
    if (message.serverVersion !== "") {
      obj.serverVersion = message.serverVersion;
    }
    if (message.iceServers?.length) {
      obj.iceServers = message.iceServers.map((e) => ICEServer.toJSON(e));
    }
    if (message.subscriberPrimary !== false) {
      obj.subscriberPrimary = message.subscriberPrimary;
    }
    if (message.alternativeUrl !== "") {
      obj.alternativeUrl = message.alternativeUrl;
    }
    if (message.clientConfiguration !== undefined) {
      obj.clientConfiguration = ClientConfiguration.toJSON(message.clientConfiguration);
    }
    if (message.serverRegion !== "") {
      obj.serverRegion = message.serverRegion;
    }
    if (message.pingTimeout !== 0) {
      obj.pingTimeout = Math.round(message.pingTimeout);
    }
    if (message.pingInterval !== 0) {
      obj.pingInterval = Math.round(message.pingInterval);
    }
    if (message.serverInfo !== undefined) {
      obj.serverInfo = ServerInfo.toJSON(message.serverInfo);
    }
    if (message.sifTrailer.length !== 0) {
      obj.sifTrailer = base64FromBytes(message.sifTrailer);
    }
    if (message.enabledPublishCodecs?.length) {
      obj.enabledPublishCodecs = message.enabledPublishCodecs.map((e) => Codec.toJSON(e));
    }
    if (message.fastPublish !== false) {
      obj.fastPublish = message.fastPublish;
    }
    return obj;
  },

  create(base?: DeepPartial<JoinResponse>): JoinResponse {
    return JoinResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<JoinResponse>): JoinResponse {
    const message = createBaseJoinResponse();
    message.room = (object.room !== undefined && object.room !== null) ? Room.fromPartial(object.room) : undefined;
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? ParticipantInfo.fromPartial(object.participant)
      : undefined;
    message.otherParticipants = object.otherParticipants?.map((e) => ParticipantInfo.fromPartial(e)) || [];
    message.serverVersion = object.serverVersion ?? "";
    message.iceServers = object.iceServers?.map((e) => ICEServer.fromPartial(e)) || [];
    message.subscriberPrimary = object.subscriberPrimary ?? false;
    message.alternativeUrl = object.alternativeUrl ?? "";
    message.clientConfiguration = (object.clientConfiguration !== undefined && object.clientConfiguration !== null)
      ? ClientConfiguration.fromPartial(object.clientConfiguration)
      : undefined;
    message.serverRegion = object.serverRegion ?? "";
    message.pingTimeout = object.pingTimeout ?? 0;
    message.pingInterval = object.pingInterval ?? 0;
    message.serverInfo = (object.serverInfo !== undefined && object.serverInfo !== null)
      ? ServerInfo.fromPartial(object.serverInfo)
      : undefined;
    message.sifTrailer = object.sifTrailer ?? new Uint8Array(0);
    message.enabledPublishCodecs = object.enabledPublishCodecs?.map((e) => Codec.fromPartial(e)) || [];
    message.fastPublish = object.fastPublish ?? false;
    return message;
  },
};

function createBaseReconnectResponse(): ReconnectResponse {
  return { iceServers: [], clientConfiguration: undefined, serverInfo: undefined };
}

export const ReconnectResponse: MessageFns<ReconnectResponse> = {
  encode(message: ReconnectResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.iceServers) {
      ICEServer.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.clientConfiguration !== undefined) {
      ClientConfiguration.encode(message.clientConfiguration, writer.uint32(18).fork()).join();
    }
    if (message.serverInfo !== undefined) {
      ServerInfo.encode(message.serverInfo, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReconnectResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReconnectResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.iceServers.push(ICEServer.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.clientConfiguration = ClientConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.serverInfo = ServerInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReconnectResponse {
    return {
      iceServers: globalThis.Array.isArray(object?.iceServers)
        ? object.iceServers.map((e: any) => ICEServer.fromJSON(e))
        : [],
      clientConfiguration: isSet(object.clientConfiguration)
        ? ClientConfiguration.fromJSON(object.clientConfiguration)
        : undefined,
      serverInfo: isSet(object.serverInfo) ? ServerInfo.fromJSON(object.serverInfo) : undefined,
    };
  },

  toJSON(message: ReconnectResponse): unknown {
    const obj: any = {};
    if (message.iceServers?.length) {
      obj.iceServers = message.iceServers.map((e) => ICEServer.toJSON(e));
    }
    if (message.clientConfiguration !== undefined) {
      obj.clientConfiguration = ClientConfiguration.toJSON(message.clientConfiguration);
    }
    if (message.serverInfo !== undefined) {
      obj.serverInfo = ServerInfo.toJSON(message.serverInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<ReconnectResponse>): ReconnectResponse {
    return ReconnectResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ReconnectResponse>): ReconnectResponse {
    const message = createBaseReconnectResponse();
    message.iceServers = object.iceServers?.map((e) => ICEServer.fromPartial(e)) || [];
    message.clientConfiguration = (object.clientConfiguration !== undefined && object.clientConfiguration !== null)
      ? ClientConfiguration.fromPartial(object.clientConfiguration)
      : undefined;
    message.serverInfo = (object.serverInfo !== undefined && object.serverInfo !== null)
      ? ServerInfo.fromPartial(object.serverInfo)
      : undefined;
    return message;
  },
};

function createBaseTrackPublishedResponse(): TrackPublishedResponse {
  return { cid: "", track: undefined };
}

export const TrackPublishedResponse: MessageFns<TrackPublishedResponse> = {
  encode(message: TrackPublishedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.cid !== "") {
      writer.uint32(10).string(message.cid);
    }
    if (message.track !== undefined) {
      TrackInfo.encode(message.track, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackPublishedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackPublishedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.cid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.track = TrackInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackPublishedResponse {
    return {
      cid: isSet(object.cid) ? globalThis.String(object.cid) : "",
      track: isSet(object.track) ? TrackInfo.fromJSON(object.track) : undefined,
    };
  },

  toJSON(message: TrackPublishedResponse): unknown {
    const obj: any = {};
    if (message.cid !== "") {
      obj.cid = message.cid;
    }
    if (message.track !== undefined) {
      obj.track = TrackInfo.toJSON(message.track);
    }
    return obj;
  },

  create(base?: DeepPartial<TrackPublishedResponse>): TrackPublishedResponse {
    return TrackPublishedResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackPublishedResponse>): TrackPublishedResponse {
    const message = createBaseTrackPublishedResponse();
    message.cid = object.cid ?? "";
    message.track = (object.track !== undefined && object.track !== null)
      ? TrackInfo.fromPartial(object.track)
      : undefined;
    return message;
  },
};

function createBaseTrackUnpublishedResponse(): TrackUnpublishedResponse {
  return { trackSid: "" };
}

export const TrackUnpublishedResponse: MessageFns<TrackUnpublishedResponse> = {
  encode(message: TrackUnpublishedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackSid !== "") {
      writer.uint32(10).string(message.trackSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackUnpublishedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackUnpublishedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackUnpublishedResponse {
    return { trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "" };
  },

  toJSON(message: TrackUnpublishedResponse): unknown {
    const obj: any = {};
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    return obj;
  },

  create(base?: DeepPartial<TrackUnpublishedResponse>): TrackUnpublishedResponse {
    return TrackUnpublishedResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackUnpublishedResponse>): TrackUnpublishedResponse {
    const message = createBaseTrackUnpublishedResponse();
    message.trackSid = object.trackSid ?? "";
    return message;
  },
};

function createBaseSessionDescription(): SessionDescription {
  return { type: "", sdp: "" };
}

export const SessionDescription: MessageFns<SessionDescription> = {
  encode(message: SessionDescription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.sdp !== "") {
      writer.uint32(18).string(message.sdp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionDescription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionDescription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sdp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionDescription {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      sdp: isSet(object.sdp) ? globalThis.String(object.sdp) : "",
    };
  },

  toJSON(message: SessionDescription): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.sdp !== "") {
      obj.sdp = message.sdp;
    }
    return obj;
  },

  create(base?: DeepPartial<SessionDescription>): SessionDescription {
    return SessionDescription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionDescription>): SessionDescription {
    const message = createBaseSessionDescription();
    message.type = object.type ?? "";
    message.sdp = object.sdp ?? "";
    return message;
  },
};

function createBaseParticipantUpdate(): ParticipantUpdate {
  return { participants: [] };
}

export const ParticipantUpdate: MessageFns<ParticipantUpdate> = {
  encode(message: ParticipantUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.participants) {
      ParticipantInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ParticipantUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseParticipantUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participants.push(ParticipantInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ParticipantUpdate {
    return {
      participants: globalThis.Array.isArray(object?.participants)
        ? object.participants.map((e: any) => ParticipantInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ParticipantUpdate): unknown {
    const obj: any = {};
    if (message.participants?.length) {
      obj.participants = message.participants.map((e) => ParticipantInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ParticipantUpdate>): ParticipantUpdate {
    return ParticipantUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ParticipantUpdate>): ParticipantUpdate {
    const message = createBaseParticipantUpdate();
    message.participants = object.participants?.map((e) => ParticipantInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateSubscription(): UpdateSubscription {
  return { trackSids: [], subscribe: false, participantTracks: [] };
}

export const UpdateSubscription: MessageFns<UpdateSubscription> = {
  encode(message: UpdateSubscription, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trackSids) {
      writer.uint32(10).string(v!);
    }
    if (message.subscribe !== false) {
      writer.uint32(16).bool(message.subscribe);
    }
    for (const v of message.participantTracks) {
      ParticipantTracks.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSubscription {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSubscription();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSids.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.subscribe = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participantTracks.push(ParticipantTracks.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSubscription {
    return {
      trackSids: globalThis.Array.isArray(object?.trackSids)
        ? object.trackSids.map((e: any) => globalThis.String(e))
        : [],
      subscribe: isSet(object.subscribe) ? globalThis.Boolean(object.subscribe) : false,
      participantTracks: globalThis.Array.isArray(object?.participantTracks)
        ? object.participantTracks.map((e: any) => ParticipantTracks.fromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateSubscription): unknown {
    const obj: any = {};
    if (message.trackSids?.length) {
      obj.trackSids = message.trackSids;
    }
    if (message.subscribe !== false) {
      obj.subscribe = message.subscribe;
    }
    if (message.participantTracks?.length) {
      obj.participantTracks = message.participantTracks.map((e) => ParticipantTracks.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSubscription>): UpdateSubscription {
    return UpdateSubscription.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSubscription>): UpdateSubscription {
    const message = createBaseUpdateSubscription();
    message.trackSids = object.trackSids?.map((e) => e) || [];
    message.subscribe = object.subscribe ?? false;
    message.participantTracks = object.participantTracks?.map((e) => ParticipantTracks.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateTrackSettings(): UpdateTrackSettings {
  return { trackSids: [], disabled: false, quality: 0, width: 0, height: 0, fps: 0, priority: 0 };
}

export const UpdateTrackSettings: MessageFns<UpdateTrackSettings> = {
  encode(message: UpdateTrackSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.trackSids) {
      writer.uint32(10).string(v!);
    }
    if (message.disabled !== false) {
      writer.uint32(24).bool(message.disabled);
    }
    if (message.quality !== 0) {
      writer.uint32(32).int32(message.quality);
    }
    if (message.width !== 0) {
      writer.uint32(40).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(48).uint32(message.height);
    }
    if (message.fps !== 0) {
      writer.uint32(56).uint32(message.fps);
    }
    if (message.priority !== 0) {
      writer.uint32(64).uint32(message.priority);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateTrackSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateTrackSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSids.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.disabled = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.quality = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.fps = reader.uint32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.priority = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateTrackSettings {
    return {
      trackSids: globalThis.Array.isArray(object?.trackSids)
        ? object.trackSids.map((e: any) => globalThis.String(e))
        : [],
      disabled: isSet(object.disabled) ? globalThis.Boolean(object.disabled) : false,
      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
      fps: isSet(object.fps) ? globalThis.Number(object.fps) : 0,
      priority: isSet(object.priority) ? globalThis.Number(object.priority) : 0,
    };
  },

  toJSON(message: UpdateTrackSettings): unknown {
    const obj: any = {};
    if (message.trackSids?.length) {
      obj.trackSids = message.trackSids;
    }
    if (message.disabled !== false) {
      obj.disabled = message.disabled;
    }
    if (message.quality !== 0) {
      obj.quality = videoQualityToJSON(message.quality);
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    if (message.fps !== 0) {
      obj.fps = Math.round(message.fps);
    }
    if (message.priority !== 0) {
      obj.priority = Math.round(message.priority);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateTrackSettings>): UpdateTrackSettings {
    return UpdateTrackSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateTrackSettings>): UpdateTrackSettings {
    const message = createBaseUpdateTrackSettings();
    message.trackSids = object.trackSids?.map((e) => e) || [];
    message.disabled = object.disabled ?? false;
    message.quality = object.quality ?? 0;
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    message.fps = object.fps ?? 0;
    message.priority = object.priority ?? 0;
    return message;
  },
};

function createBaseUpdateLocalAudioTrack(): UpdateLocalAudioTrack {
  return { trackSid: "", features: [] };
}

export const UpdateLocalAudioTrack: MessageFns<UpdateLocalAudioTrack> = {
  encode(message: UpdateLocalAudioTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackSid !== "") {
      writer.uint32(10).string(message.trackSid);
    }
    writer.uint32(18).fork();
    for (const v of message.features) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLocalAudioTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLocalAudioTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.features.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.features.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLocalAudioTrack {
    return {
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      features: globalThis.Array.isArray(object?.features)
        ? object.features.map((e: any) => audioTrackFeatureFromJSON(e))
        : [],
    };
  },

  toJSON(message: UpdateLocalAudioTrack): unknown {
    const obj: any = {};
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.features?.length) {
      obj.features = message.features.map((e) => audioTrackFeatureToJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateLocalAudioTrack>): UpdateLocalAudioTrack {
    return UpdateLocalAudioTrack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateLocalAudioTrack>): UpdateLocalAudioTrack {
    const message = createBaseUpdateLocalAudioTrack();
    message.trackSid = object.trackSid ?? "";
    message.features = object.features?.map((e) => e) || [];
    return message;
  },
};

function createBaseUpdateLocalVideoTrack(): UpdateLocalVideoTrack {
  return { trackSid: "", width: 0, height: 0 };
}

export const UpdateLocalVideoTrack: MessageFns<UpdateLocalVideoTrack> = {
  encode(message: UpdateLocalVideoTrack, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackSid !== "") {
      writer.uint32(10).string(message.trackSid);
    }
    if (message.width !== 0) {
      writer.uint32(16).uint32(message.width);
    }
    if (message.height !== 0) {
      writer.uint32(24).uint32(message.height);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateLocalVideoTrack {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateLocalVideoTrack();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.width = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.height = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateLocalVideoTrack {
    return {
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      width: isSet(object.width) ? globalThis.Number(object.width) : 0,
      height: isSet(object.height) ? globalThis.Number(object.height) : 0,
    };
  },

  toJSON(message: UpdateLocalVideoTrack): unknown {
    const obj: any = {};
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.width !== 0) {
      obj.width = Math.round(message.width);
    }
    if (message.height !== 0) {
      obj.height = Math.round(message.height);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateLocalVideoTrack>): UpdateLocalVideoTrack {
    return UpdateLocalVideoTrack.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateLocalVideoTrack>): UpdateLocalVideoTrack {
    const message = createBaseUpdateLocalVideoTrack();
    message.trackSid = object.trackSid ?? "";
    message.width = object.width ?? 0;
    message.height = object.height ?? 0;
    return message;
  },
};

function createBaseLeaveRequest(): LeaveRequest {
  return { canReconnect: false, reason: 0, action: 0, regions: undefined };
}

export const LeaveRequest: MessageFns<LeaveRequest> = {
  encode(message: LeaveRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.canReconnect !== false) {
      writer.uint32(8).bool(message.canReconnect);
    }
    if (message.reason !== 0) {
      writer.uint32(16).int32(message.reason);
    }
    if (message.action !== 0) {
      writer.uint32(24).int32(message.action);
    }
    if (message.regions !== undefined) {
      RegionSettings.encode(message.regions, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LeaveRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLeaveRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.canReconnect = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.action = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.regions = RegionSettings.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LeaveRequest {
    return {
      canReconnect: isSet(object.canReconnect) ? globalThis.Boolean(object.canReconnect) : false,
      reason: isSet(object.reason) ? disconnectReasonFromJSON(object.reason) : 0,
      action: isSet(object.action) ? leaveRequest_ActionFromJSON(object.action) : 0,
      regions: isSet(object.regions) ? RegionSettings.fromJSON(object.regions) : undefined,
    };
  },

  toJSON(message: LeaveRequest): unknown {
    const obj: any = {};
    if (message.canReconnect !== false) {
      obj.canReconnect = message.canReconnect;
    }
    if (message.reason !== 0) {
      obj.reason = disconnectReasonToJSON(message.reason);
    }
    if (message.action !== 0) {
      obj.action = leaveRequest_ActionToJSON(message.action);
    }
    if (message.regions !== undefined) {
      obj.regions = RegionSettings.toJSON(message.regions);
    }
    return obj;
  },

  create(base?: DeepPartial<LeaveRequest>): LeaveRequest {
    return LeaveRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LeaveRequest>): LeaveRequest {
    const message = createBaseLeaveRequest();
    message.canReconnect = object.canReconnect ?? false;
    message.reason = object.reason ?? 0;
    message.action = object.action ?? 0;
    message.regions = (object.regions !== undefined && object.regions !== null)
      ? RegionSettings.fromPartial(object.regions)
      : undefined;
    return message;
  },
};

function createBaseUpdateVideoLayers(): UpdateVideoLayers {
  return { trackSid: "", layers: [] };
}

export const UpdateVideoLayers: MessageFns<UpdateVideoLayers> = {
  encode(message: UpdateVideoLayers, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackSid !== "") {
      writer.uint32(10).string(message.trackSid);
    }
    for (const v of message.layers) {
      VideoLayer.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateVideoLayers {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateVideoLayers();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.layers.push(VideoLayer.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateVideoLayers {
    return {
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      layers: globalThis.Array.isArray(object?.layers) ? object.layers.map((e: any) => VideoLayer.fromJSON(e)) : [],
    };
  },

  toJSON(message: UpdateVideoLayers): unknown {
    const obj: any = {};
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.layers?.length) {
      obj.layers = message.layers.map((e) => VideoLayer.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateVideoLayers>): UpdateVideoLayers {
    return UpdateVideoLayers.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateVideoLayers>): UpdateVideoLayers {
    const message = createBaseUpdateVideoLayers();
    message.trackSid = object.trackSid ?? "";
    message.layers = object.layers?.map((e) => VideoLayer.fromPartial(e)) || [];
    return message;
  },
};

function createBaseUpdateParticipantMetadata(): UpdateParticipantMetadata {
  return { metadata: "", name: "", attributes: {}, requestId: 0 };
}

export const UpdateParticipantMetadata: MessageFns<UpdateParticipantMetadata> = {
  encode(message: UpdateParticipantMetadata, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metadata !== "") {
      writer.uint32(10).string(message.metadata);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      UpdateParticipantMetadata_AttributesEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.requestId !== 0) {
      writer.uint32(32).uint32(message.requestId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantMetadata {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantMetadata();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = UpdateParticipantMetadata_AttributesEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.attributes[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantMetadata {
    return {
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
    };
  },

  toJSON(message: UpdateParticipantMetadata): unknown {
    const obj: any = {};
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateParticipantMetadata>): UpdateParticipantMetadata {
    return UpdateParticipantMetadata.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateParticipantMetadata>): UpdateParticipantMetadata {
    const message = createBaseUpdateParticipantMetadata();
    message.metadata = object.metadata ?? "";
    message.name = object.name ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.requestId = object.requestId ?? 0;
    return message;
  },
};

function createBaseUpdateParticipantMetadata_AttributesEntry(): UpdateParticipantMetadata_AttributesEntry {
  return { key: "", value: "" };
}

export const UpdateParticipantMetadata_AttributesEntry: MessageFns<UpdateParticipantMetadata_AttributesEntry> = {
  encode(message: UpdateParticipantMetadata_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateParticipantMetadata_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateParticipantMetadata_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateParticipantMetadata_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: UpdateParticipantMetadata_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateParticipantMetadata_AttributesEntry>): UpdateParticipantMetadata_AttributesEntry {
    return UpdateParticipantMetadata_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<UpdateParticipantMetadata_AttributesEntry>,
  ): UpdateParticipantMetadata_AttributesEntry {
    const message = createBaseUpdateParticipantMetadata_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseICEServer(): ICEServer {
  return { urls: [], username: "", credential: "" };
}

export const ICEServer: MessageFns<ICEServer> = {
  encode(message: ICEServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.urls) {
      writer.uint32(10).string(v!);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.credential !== "") {
      writer.uint32(26).string(message.credential);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ICEServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseICEServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.urls.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.credential = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ICEServer {
    return {
      urls: globalThis.Array.isArray(object?.urls) ? object.urls.map((e: any) => globalThis.String(e)) : [],
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      credential: isSet(object.credential) ? globalThis.String(object.credential) : "",
    };
  },

  toJSON(message: ICEServer): unknown {
    const obj: any = {};
    if (message.urls?.length) {
      obj.urls = message.urls;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.credential !== "") {
      obj.credential = message.credential;
    }
    return obj;
  },

  create(base?: DeepPartial<ICEServer>): ICEServer {
    return ICEServer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ICEServer>): ICEServer {
    const message = createBaseICEServer();
    message.urls = object.urls?.map((e) => e) || [];
    message.username = object.username ?? "";
    message.credential = object.credential ?? "";
    return message;
  },
};

function createBaseSpeakersChanged(): SpeakersChanged {
  return { speakers: [] };
}

export const SpeakersChanged: MessageFns<SpeakersChanged> = {
  encode(message: SpeakersChanged, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.speakers) {
      SpeakerInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SpeakersChanged {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSpeakersChanged();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.speakers.push(SpeakerInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SpeakersChanged {
    return {
      speakers: globalThis.Array.isArray(object?.speakers)
        ? object.speakers.map((e: any) => SpeakerInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SpeakersChanged): unknown {
    const obj: any = {};
    if (message.speakers?.length) {
      obj.speakers = message.speakers.map((e) => SpeakerInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SpeakersChanged>): SpeakersChanged {
    return SpeakersChanged.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SpeakersChanged>): SpeakersChanged {
    const message = createBaseSpeakersChanged();
    message.speakers = object.speakers?.map((e) => SpeakerInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRoomUpdate(): RoomUpdate {
  return { room: undefined };
}

export const RoomUpdate: MessageFns<RoomUpdate> = {
  encode(message: RoomUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== undefined) {
      Room.encode(message.room, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = Room.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomUpdate {
    return { room: isSet(object.room) ? Room.fromJSON(object.room) : undefined };
  },

  toJSON(message: RoomUpdate): unknown {
    const obj: any = {};
    if (message.room !== undefined) {
      obj.room = Room.toJSON(message.room);
    }
    return obj;
  },

  create(base?: DeepPartial<RoomUpdate>): RoomUpdate {
    return RoomUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomUpdate>): RoomUpdate {
    const message = createBaseRoomUpdate();
    message.room = (object.room !== undefined && object.room !== null) ? Room.fromPartial(object.room) : undefined;
    return message;
  },
};

function createBaseConnectionQualityInfo(): ConnectionQualityInfo {
  return { participantSid: "", quality: 0, score: 0 };
}

export const ConnectionQualityInfo: MessageFns<ConnectionQualityInfo> = {
  encode(message: ConnectionQualityInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participantSid !== "") {
      writer.uint32(10).string(message.participantSid);
    }
    if (message.quality !== 0) {
      writer.uint32(16).int32(message.quality);
    }
    if (message.score !== 0) {
      writer.uint32(29).float(message.score);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionQualityInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionQualityInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participantSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quality = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 29) {
            break;
          }

          message.score = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionQualityInfo {
    return {
      participantSid: isSet(object.participantSid) ? globalThis.String(object.participantSid) : "",
      quality: isSet(object.quality) ? connectionQualityFromJSON(object.quality) : 0,
      score: isSet(object.score) ? globalThis.Number(object.score) : 0,
    };
  },

  toJSON(message: ConnectionQualityInfo): unknown {
    const obj: any = {};
    if (message.participantSid !== "") {
      obj.participantSid = message.participantSid;
    }
    if (message.quality !== 0) {
      obj.quality = connectionQualityToJSON(message.quality);
    }
    if (message.score !== 0) {
      obj.score = message.score;
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionQualityInfo>): ConnectionQualityInfo {
    return ConnectionQualityInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionQualityInfo>): ConnectionQualityInfo {
    const message = createBaseConnectionQualityInfo();
    message.participantSid = object.participantSid ?? "";
    message.quality = object.quality ?? 0;
    message.score = object.score ?? 0;
    return message;
  },
};

function createBaseConnectionQualityUpdate(): ConnectionQualityUpdate {
  return { updates: [] };
}

export const ConnectionQualityUpdate: MessageFns<ConnectionQualityUpdate> = {
  encode(message: ConnectionQualityUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.updates) {
      ConnectionQualityInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConnectionQualityUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConnectionQualityUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.updates.push(ConnectionQualityInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConnectionQualityUpdate {
    return {
      updates: globalThis.Array.isArray(object?.updates)
        ? object.updates.map((e: any) => ConnectionQualityInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ConnectionQualityUpdate): unknown {
    const obj: any = {};
    if (message.updates?.length) {
      obj.updates = message.updates.map((e) => ConnectionQualityInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ConnectionQualityUpdate>): ConnectionQualityUpdate {
    return ConnectionQualityUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ConnectionQualityUpdate>): ConnectionQualityUpdate {
    const message = createBaseConnectionQualityUpdate();
    message.updates = object.updates?.map((e) => ConnectionQualityInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStreamStateInfo(): StreamStateInfo {
  return { participantSid: "", trackSid: "", state: 0 };
}

export const StreamStateInfo: MessageFns<StreamStateInfo> = {
  encode(message: StreamStateInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participantSid !== "") {
      writer.uint32(10).string(message.participantSid);
    }
    if (message.trackSid !== "") {
      writer.uint32(18).string(message.trackSid);
    }
    if (message.state !== 0) {
      writer.uint32(24).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamStateInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStateInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participantSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStateInfo {
    return {
      participantSid: isSet(object.participantSid) ? globalThis.String(object.participantSid) : "",
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      state: isSet(object.state) ? streamStateFromJSON(object.state) : 0,
    };
  },

  toJSON(message: StreamStateInfo): unknown {
    const obj: any = {};
    if (message.participantSid !== "") {
      obj.participantSid = message.participantSid;
    }
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.state !== 0) {
      obj.state = streamStateToJSON(message.state);
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStateInfo>): StreamStateInfo {
    return StreamStateInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStateInfo>): StreamStateInfo {
    const message = createBaseStreamStateInfo();
    message.participantSid = object.participantSid ?? "";
    message.trackSid = object.trackSid ?? "";
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseStreamStateUpdate(): StreamStateUpdate {
  return { streamStates: [] };
}

export const StreamStateUpdate: MessageFns<StreamStateUpdate> = {
  encode(message: StreamStateUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.streamStates) {
      StreamStateInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamStateUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamStateUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.streamStates.push(StreamStateInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamStateUpdate {
    return {
      streamStates: globalThis.Array.isArray(object?.streamStates)
        ? object.streamStates.map((e: any) => StreamStateInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: StreamStateUpdate): unknown {
    const obj: any = {};
    if (message.streamStates?.length) {
      obj.streamStates = message.streamStates.map((e) => StreamStateInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<StreamStateUpdate>): StreamStateUpdate {
    return StreamStateUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamStateUpdate>): StreamStateUpdate {
    const message = createBaseStreamStateUpdate();
    message.streamStates = object.streamStates?.map((e) => StreamStateInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubscribedQuality(): SubscribedQuality {
  return { quality: 0, enabled: false };
}

export const SubscribedQuality: MessageFns<SubscribedQuality> = {
  encode(message: SubscribedQuality, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.quality !== 0) {
      writer.uint32(8).int32(message.quality);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribedQuality {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribedQuality();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.quality = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribedQuality {
    return {
      quality: isSet(object.quality) ? videoQualityFromJSON(object.quality) : 0,
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
    };
  },

  toJSON(message: SubscribedQuality): unknown {
    const obj: any = {};
    if (message.quality !== 0) {
      obj.quality = videoQualityToJSON(message.quality);
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribedQuality>): SubscribedQuality {
    return SubscribedQuality.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribedQuality>): SubscribedQuality {
    const message = createBaseSubscribedQuality();
    message.quality = object.quality ?? 0;
    message.enabled = object.enabled ?? false;
    return message;
  },
};

function createBaseSubscribedCodec(): SubscribedCodec {
  return { codec: "", qualities: [] };
}

export const SubscribedCodec: MessageFns<SubscribedCodec> = {
  encode(message: SubscribedCodec, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.codec !== "") {
      writer.uint32(10).string(message.codec);
    }
    for (const v of message.qualities) {
      SubscribedQuality.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribedCodec {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribedCodec();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.codec = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.qualities.push(SubscribedQuality.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribedCodec {
    return {
      codec: isSet(object.codec) ? globalThis.String(object.codec) : "",
      qualities: globalThis.Array.isArray(object?.qualities)
        ? object.qualities.map((e: any) => SubscribedQuality.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubscribedCodec): unknown {
    const obj: any = {};
    if (message.codec !== "") {
      obj.codec = message.codec;
    }
    if (message.qualities?.length) {
      obj.qualities = message.qualities.map((e) => SubscribedQuality.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribedCodec>): SubscribedCodec {
    return SubscribedCodec.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribedCodec>): SubscribedCodec {
    const message = createBaseSubscribedCodec();
    message.codec = object.codec ?? "";
    message.qualities = object.qualities?.map((e) => SubscribedQuality.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubscribedQualityUpdate(): SubscribedQualityUpdate {
  return { trackSid: "", subscribedQualities: [], subscribedCodecs: [] };
}

export const SubscribedQualityUpdate: MessageFns<SubscribedQualityUpdate> = {
  encode(message: SubscribedQualityUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackSid !== "") {
      writer.uint32(10).string(message.trackSid);
    }
    for (const v of message.subscribedQualities) {
      SubscribedQuality.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.subscribedCodecs) {
      SubscribedCodec.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscribedQualityUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscribedQualityUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscribedQualities.push(SubscribedQuality.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.subscribedCodecs.push(SubscribedCodec.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscribedQualityUpdate {
    return {
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      subscribedQualities: globalThis.Array.isArray(object?.subscribedQualities)
        ? object.subscribedQualities.map((e: any) => SubscribedQuality.fromJSON(e))
        : [],
      subscribedCodecs: globalThis.Array.isArray(object?.subscribedCodecs)
        ? object.subscribedCodecs.map((e: any) => SubscribedCodec.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubscribedQualityUpdate): unknown {
    const obj: any = {};
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.subscribedQualities?.length) {
      obj.subscribedQualities = message.subscribedQualities.map((e) => SubscribedQuality.toJSON(e));
    }
    if (message.subscribedCodecs?.length) {
      obj.subscribedCodecs = message.subscribedCodecs.map((e) => SubscribedCodec.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SubscribedQualityUpdate>): SubscribedQualityUpdate {
    return SubscribedQualityUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscribedQualityUpdate>): SubscribedQualityUpdate {
    const message = createBaseSubscribedQualityUpdate();
    message.trackSid = object.trackSid ?? "";
    message.subscribedQualities = object.subscribedQualities?.map((e) => SubscribedQuality.fromPartial(e)) || [];
    message.subscribedCodecs = object.subscribedCodecs?.map((e) => SubscribedCodec.fromPartial(e)) || [];
    return message;
  },
};

function createBaseTrackPermission(): TrackPermission {
  return { participantSid: "", allTracks: false, trackSids: [], participantIdentity: "" };
}

export const TrackPermission: MessageFns<TrackPermission> = {
  encode(message: TrackPermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participantSid !== "") {
      writer.uint32(10).string(message.participantSid);
    }
    if (message.allTracks !== false) {
      writer.uint32(16).bool(message.allTracks);
    }
    for (const v of message.trackSids) {
      writer.uint32(26).string(v!);
    }
    if (message.participantIdentity !== "") {
      writer.uint32(34).string(message.participantIdentity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackPermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participantSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.allTracks = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trackSids.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackPermission {
    return {
      participantSid: isSet(object.participantSid) ? globalThis.String(object.participantSid) : "",
      allTracks: isSet(object.allTracks) ? globalThis.Boolean(object.allTracks) : false,
      trackSids: globalThis.Array.isArray(object?.trackSids)
        ? object.trackSids.map((e: any) => globalThis.String(e))
        : [],
      participantIdentity: isSet(object.participantIdentity) ? globalThis.String(object.participantIdentity) : "",
    };
  },

  toJSON(message: TrackPermission): unknown {
    const obj: any = {};
    if (message.participantSid !== "") {
      obj.participantSid = message.participantSid;
    }
    if (message.allTracks !== false) {
      obj.allTracks = message.allTracks;
    }
    if (message.trackSids?.length) {
      obj.trackSids = message.trackSids;
    }
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    return obj;
  },

  create(base?: DeepPartial<TrackPermission>): TrackPermission {
    return TrackPermission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackPermission>): TrackPermission {
    const message = createBaseTrackPermission();
    message.participantSid = object.participantSid ?? "";
    message.allTracks = object.allTracks ?? false;
    message.trackSids = object.trackSids?.map((e) => e) || [];
    message.participantIdentity = object.participantIdentity ?? "";
    return message;
  },
};

function createBaseSubscriptionPermission(): SubscriptionPermission {
  return { allParticipants: false, trackPermissions: [] };
}

export const SubscriptionPermission: MessageFns<SubscriptionPermission> = {
  encode(message: SubscriptionPermission, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.allParticipants !== false) {
      writer.uint32(8).bool(message.allParticipants);
    }
    for (const v of message.trackPermissions) {
      TrackPermission.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionPermission {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionPermission();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.allParticipants = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackPermissions.push(TrackPermission.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionPermission {
    return {
      allParticipants: isSet(object.allParticipants) ? globalThis.Boolean(object.allParticipants) : false,
      trackPermissions: globalThis.Array.isArray(object?.trackPermissions)
        ? object.trackPermissions.map((e: any) => TrackPermission.fromJSON(e))
        : [],
    };
  },

  toJSON(message: SubscriptionPermission): unknown {
    const obj: any = {};
    if (message.allParticipants !== false) {
      obj.allParticipants = message.allParticipants;
    }
    if (message.trackPermissions?.length) {
      obj.trackPermissions = message.trackPermissions.map((e) => TrackPermission.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<SubscriptionPermission>): SubscriptionPermission {
    return SubscriptionPermission.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptionPermission>): SubscriptionPermission {
    const message = createBaseSubscriptionPermission();
    message.allParticipants = object.allParticipants ?? false;
    message.trackPermissions = object.trackPermissions?.map((e) => TrackPermission.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSubscriptionPermissionUpdate(): SubscriptionPermissionUpdate {
  return { participantSid: "", trackSid: "", allowed: false };
}

export const SubscriptionPermissionUpdate: MessageFns<SubscriptionPermissionUpdate> = {
  encode(message: SubscriptionPermissionUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participantSid !== "") {
      writer.uint32(10).string(message.participantSid);
    }
    if (message.trackSid !== "") {
      writer.uint32(18).string(message.trackSid);
    }
    if (message.allowed !== false) {
      writer.uint32(24).bool(message.allowed);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionPermissionUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionPermissionUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participantSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.allowed = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionPermissionUpdate {
    return {
      participantSid: isSet(object.participantSid) ? globalThis.String(object.participantSid) : "",
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      allowed: isSet(object.allowed) ? globalThis.Boolean(object.allowed) : false,
    };
  },

  toJSON(message: SubscriptionPermissionUpdate): unknown {
    const obj: any = {};
    if (message.participantSid !== "") {
      obj.participantSid = message.participantSid;
    }
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.allowed !== false) {
      obj.allowed = message.allowed;
    }
    return obj;
  },

  create(base?: DeepPartial<SubscriptionPermissionUpdate>): SubscriptionPermissionUpdate {
    return SubscriptionPermissionUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptionPermissionUpdate>): SubscriptionPermissionUpdate {
    const message = createBaseSubscriptionPermissionUpdate();
    message.participantSid = object.participantSid ?? "";
    message.trackSid = object.trackSid ?? "";
    message.allowed = object.allowed ?? false;
    return message;
  },
};

function createBaseRoomMovedResponse(): RoomMovedResponse {
  return { room: undefined, token: "", participant: undefined, otherParticipants: [] };
}

export const RoomMovedResponse: MessageFns<RoomMovedResponse> = {
  encode(message: RoomMovedResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.room !== undefined) {
      Room.encode(message.room, writer.uint32(10).fork()).join();
    }
    if (message.token !== "") {
      writer.uint32(18).string(message.token);
    }
    if (message.participant !== undefined) {
      ParticipantInfo.encode(message.participant, writer.uint32(26).fork()).join();
    }
    for (const v of message.otherParticipants) {
      ParticipantInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RoomMovedResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRoomMovedResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.room = Room.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.participant = ParticipantInfo.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.otherParticipants.push(ParticipantInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RoomMovedResponse {
    return {
      room: isSet(object.room) ? Room.fromJSON(object.room) : undefined,
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      participant: isSet(object.participant) ? ParticipantInfo.fromJSON(object.participant) : undefined,
      otherParticipants: globalThis.Array.isArray(object?.otherParticipants)
        ? object.otherParticipants.map((e: any) => ParticipantInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RoomMovedResponse): unknown {
    const obj: any = {};
    if (message.room !== undefined) {
      obj.room = Room.toJSON(message.room);
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.participant !== undefined) {
      obj.participant = ParticipantInfo.toJSON(message.participant);
    }
    if (message.otherParticipants?.length) {
      obj.otherParticipants = message.otherParticipants.map((e) => ParticipantInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RoomMovedResponse>): RoomMovedResponse {
    return RoomMovedResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RoomMovedResponse>): RoomMovedResponse {
    const message = createBaseRoomMovedResponse();
    message.room = (object.room !== undefined && object.room !== null) ? Room.fromPartial(object.room) : undefined;
    message.token = object.token ?? "";
    message.participant = (object.participant !== undefined && object.participant !== null)
      ? ParticipantInfo.fromPartial(object.participant)
      : undefined;
    message.otherParticipants = object.otherParticipants?.map((e) => ParticipantInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseSyncState(): SyncState {
  return {
    answer: undefined,
    subscription: undefined,
    publishTracks: [],
    dataChannels: [],
    offer: undefined,
    trackSidsDisabled: [],
  };
}

export const SyncState: MessageFns<SyncState> = {
  encode(message: SyncState, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.answer !== undefined) {
      SessionDescription.encode(message.answer, writer.uint32(10).fork()).join();
    }
    if (message.subscription !== undefined) {
      UpdateSubscription.encode(message.subscription, writer.uint32(18).fork()).join();
    }
    for (const v of message.publishTracks) {
      TrackPublishedResponse.encode(v!, writer.uint32(26).fork()).join();
    }
    for (const v of message.dataChannels) {
      DataChannelInfo.encode(v!, writer.uint32(34).fork()).join();
    }
    if (message.offer !== undefined) {
      SessionDescription.encode(message.offer, writer.uint32(42).fork()).join();
    }
    for (const v of message.trackSidsDisabled) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SyncState {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSyncState();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.answer = SessionDescription.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.subscription = UpdateSubscription.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.publishTracks.push(TrackPublishedResponse.decode(reader, reader.uint32()));
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.dataChannels.push(DataChannelInfo.decode(reader, reader.uint32()));
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.offer = SessionDescription.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.trackSidsDisabled.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SyncState {
    return {
      answer: isSet(object.answer) ? SessionDescription.fromJSON(object.answer) : undefined,
      subscription: isSet(object.subscription) ? UpdateSubscription.fromJSON(object.subscription) : undefined,
      publishTracks: globalThis.Array.isArray(object?.publishTracks)
        ? object.publishTracks.map((e: any) => TrackPublishedResponse.fromJSON(e))
        : [],
      dataChannels: globalThis.Array.isArray(object?.dataChannels)
        ? object.dataChannels.map((e: any) => DataChannelInfo.fromJSON(e))
        : [],
      offer: isSet(object.offer) ? SessionDescription.fromJSON(object.offer) : undefined,
      trackSidsDisabled: globalThis.Array.isArray(object?.trackSidsDisabled)
        ? object.trackSidsDisabled.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SyncState): unknown {
    const obj: any = {};
    if (message.answer !== undefined) {
      obj.answer = SessionDescription.toJSON(message.answer);
    }
    if (message.subscription !== undefined) {
      obj.subscription = UpdateSubscription.toJSON(message.subscription);
    }
    if (message.publishTracks?.length) {
      obj.publishTracks = message.publishTracks.map((e) => TrackPublishedResponse.toJSON(e));
    }
    if (message.dataChannels?.length) {
      obj.dataChannels = message.dataChannels.map((e) => DataChannelInfo.toJSON(e));
    }
    if (message.offer !== undefined) {
      obj.offer = SessionDescription.toJSON(message.offer);
    }
    if (message.trackSidsDisabled?.length) {
      obj.trackSidsDisabled = message.trackSidsDisabled;
    }
    return obj;
  },

  create(base?: DeepPartial<SyncState>): SyncState {
    return SyncState.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SyncState>): SyncState {
    const message = createBaseSyncState();
    message.answer = (object.answer !== undefined && object.answer !== null)
      ? SessionDescription.fromPartial(object.answer)
      : undefined;
    message.subscription = (object.subscription !== undefined && object.subscription !== null)
      ? UpdateSubscription.fromPartial(object.subscription)
      : undefined;
    message.publishTracks = object.publishTracks?.map((e) => TrackPublishedResponse.fromPartial(e)) || [];
    message.dataChannels = object.dataChannels?.map((e) => DataChannelInfo.fromPartial(e)) || [];
    message.offer = (object.offer !== undefined && object.offer !== null)
      ? SessionDescription.fromPartial(object.offer)
      : undefined;
    message.trackSidsDisabled = object.trackSidsDisabled?.map((e) => e) || [];
    return message;
  },
};

function createBaseDataChannelInfo(): DataChannelInfo {
  return { label: "", id: 0, target: 0 };
}

export const DataChannelInfo: MessageFns<DataChannelInfo> = {
  encode(message: DataChannelInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.id !== 0) {
      writer.uint32(16).uint32(message.id);
    }
    if (message.target !== 0) {
      writer.uint32(24).int32(message.target);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataChannelInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataChannelInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.id = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.target = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataChannelInfo {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      target: isSet(object.target) ? signalTargetFromJSON(object.target) : 0,
    };
  },

  toJSON(message: DataChannelInfo): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.target !== 0) {
      obj.target = signalTargetToJSON(message.target);
    }
    return obj;
  },

  create(base?: DeepPartial<DataChannelInfo>): DataChannelInfo {
    return DataChannelInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DataChannelInfo>): DataChannelInfo {
    const message = createBaseDataChannelInfo();
    message.label = object.label ?? "";
    message.id = object.id ?? 0;
    message.target = object.target ?? 0;
    return message;
  },
};

function createBaseSimulateScenario(): SimulateScenario {
  return { scenario: undefined };
}

export const SimulateScenario: MessageFns<SimulateScenario> = {
  encode(message: SimulateScenario, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.scenario?.$case) {
      case "speakerUpdate":
        writer.uint32(8).int32(message.scenario.speakerUpdate);
        break;
      case "nodeFailure":
        writer.uint32(16).bool(message.scenario.nodeFailure);
        break;
      case "migration":
        writer.uint32(24).bool(message.scenario.migration);
        break;
      case "serverLeave":
        writer.uint32(32).bool(message.scenario.serverLeave);
        break;
      case "switchCandidateProtocol":
        writer.uint32(40).int32(message.scenario.switchCandidateProtocol);
        break;
      case "subscriberBandwidth":
        writer.uint32(48).int64(message.scenario.subscriberBandwidth);
        break;
      case "disconnectSignalOnResume":
        writer.uint32(56).bool(message.scenario.disconnectSignalOnResume);
        break;
      case "disconnectSignalOnResumeNoMessages":
        writer.uint32(64).bool(message.scenario.disconnectSignalOnResumeNoMessages);
        break;
      case "leaveRequestFullReconnect":
        writer.uint32(72).bool(message.scenario.leaveRequestFullReconnect);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SimulateScenario {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSimulateScenario();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.scenario = { $case: "speakerUpdate", speakerUpdate: reader.int32() };
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.scenario = { $case: "nodeFailure", nodeFailure: reader.bool() };
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.scenario = { $case: "migration", migration: reader.bool() };
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.scenario = { $case: "serverLeave", serverLeave: reader.bool() };
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.scenario = { $case: "switchCandidateProtocol", switchCandidateProtocol: reader.int32() as any };
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.scenario = { $case: "subscriberBandwidth", subscriberBandwidth: reader.int64().toString() };
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.scenario = { $case: "disconnectSignalOnResume", disconnectSignalOnResume: reader.bool() };
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.scenario = {
            $case: "disconnectSignalOnResumeNoMessages",
            disconnectSignalOnResumeNoMessages: reader.bool(),
          };
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.scenario = { $case: "leaveRequestFullReconnect", leaveRequestFullReconnect: reader.bool() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SimulateScenario {
    return {
      scenario: isSet(object.speakerUpdate)
        ? { $case: "speakerUpdate", speakerUpdate: globalThis.Number(object.speakerUpdate) }
        : isSet(object.nodeFailure)
        ? { $case: "nodeFailure", nodeFailure: globalThis.Boolean(object.nodeFailure) }
        : isSet(object.migration)
        ? { $case: "migration", migration: globalThis.Boolean(object.migration) }
        : isSet(object.serverLeave)
        ? { $case: "serverLeave", serverLeave: globalThis.Boolean(object.serverLeave) }
        : isSet(object.switchCandidateProtocol)
        ? {
          $case: "switchCandidateProtocol",
          switchCandidateProtocol: candidateProtocolFromJSON(object.switchCandidateProtocol),
        }
        : isSet(object.subscriberBandwidth)
        ? { $case: "subscriberBandwidth", subscriberBandwidth: globalThis.String(object.subscriberBandwidth) }
        : isSet(object.disconnectSignalOnResume)
        ? {
          $case: "disconnectSignalOnResume",
          disconnectSignalOnResume: globalThis.Boolean(object.disconnectSignalOnResume),
        }
        : isSet(object.disconnectSignalOnResumeNoMessages)
        ? {
          $case: "disconnectSignalOnResumeNoMessages",
          disconnectSignalOnResumeNoMessages: globalThis.Boolean(object.disconnectSignalOnResumeNoMessages),
        }
        : isSet(object.leaveRequestFullReconnect)
        ? {
          $case: "leaveRequestFullReconnect",
          leaveRequestFullReconnect: globalThis.Boolean(object.leaveRequestFullReconnect),
        }
        : undefined,
    };
  },

  toJSON(message: SimulateScenario): unknown {
    const obj: any = {};
    if (message.scenario?.$case === "speakerUpdate") {
      obj.speakerUpdate = Math.round(message.scenario.speakerUpdate);
    } else if (message.scenario?.$case === "nodeFailure") {
      obj.nodeFailure = message.scenario.nodeFailure;
    } else if (message.scenario?.$case === "migration") {
      obj.migration = message.scenario.migration;
    } else if (message.scenario?.$case === "serverLeave") {
      obj.serverLeave = message.scenario.serverLeave;
    } else if (message.scenario?.$case === "switchCandidateProtocol") {
      obj.switchCandidateProtocol = candidateProtocolToJSON(message.scenario.switchCandidateProtocol);
    } else if (message.scenario?.$case === "subscriberBandwidth") {
      obj.subscriberBandwidth = message.scenario.subscriberBandwidth;
    } else if (message.scenario?.$case === "disconnectSignalOnResume") {
      obj.disconnectSignalOnResume = message.scenario.disconnectSignalOnResume;
    } else if (message.scenario?.$case === "disconnectSignalOnResumeNoMessages") {
      obj.disconnectSignalOnResumeNoMessages = message.scenario.disconnectSignalOnResumeNoMessages;
    } else if (message.scenario?.$case === "leaveRequestFullReconnect") {
      obj.leaveRequestFullReconnect = message.scenario.leaveRequestFullReconnect;
    }
    return obj;
  },

  create(base?: DeepPartial<SimulateScenario>): SimulateScenario {
    return SimulateScenario.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SimulateScenario>): SimulateScenario {
    const message = createBaseSimulateScenario();
    switch (object.scenario?.$case) {
      case "speakerUpdate": {
        if (object.scenario?.speakerUpdate !== undefined && object.scenario?.speakerUpdate !== null) {
          message.scenario = { $case: "speakerUpdate", speakerUpdate: object.scenario.speakerUpdate };
        }
        break;
      }
      case "nodeFailure": {
        if (object.scenario?.nodeFailure !== undefined && object.scenario?.nodeFailure !== null) {
          message.scenario = { $case: "nodeFailure", nodeFailure: object.scenario.nodeFailure };
        }
        break;
      }
      case "migration": {
        if (object.scenario?.migration !== undefined && object.scenario?.migration !== null) {
          message.scenario = { $case: "migration", migration: object.scenario.migration };
        }
        break;
      }
      case "serverLeave": {
        if (object.scenario?.serverLeave !== undefined && object.scenario?.serverLeave !== null) {
          message.scenario = { $case: "serverLeave", serverLeave: object.scenario.serverLeave };
        }
        break;
      }
      case "switchCandidateProtocol": {
        if (
          object.scenario?.switchCandidateProtocol !== undefined && object.scenario?.switchCandidateProtocol !== null
        ) {
          message.scenario = {
            $case: "switchCandidateProtocol",
            switchCandidateProtocol: object.scenario.switchCandidateProtocol,
          };
        }
        break;
      }
      case "subscriberBandwidth": {
        if (object.scenario?.subscriberBandwidth !== undefined && object.scenario?.subscriberBandwidth !== null) {
          message.scenario = { $case: "subscriberBandwidth", subscriberBandwidth: object.scenario.subscriberBandwidth };
        }
        break;
      }
      case "disconnectSignalOnResume": {
        if (
          object.scenario?.disconnectSignalOnResume !== undefined && object.scenario?.disconnectSignalOnResume !== null
        ) {
          message.scenario = {
            $case: "disconnectSignalOnResume",
            disconnectSignalOnResume: object.scenario.disconnectSignalOnResume,
          };
        }
        break;
      }
      case "disconnectSignalOnResumeNoMessages": {
        if (
          object.scenario?.disconnectSignalOnResumeNoMessages !== undefined &&
          object.scenario?.disconnectSignalOnResumeNoMessages !== null
        ) {
          message.scenario = {
            $case: "disconnectSignalOnResumeNoMessages",
            disconnectSignalOnResumeNoMessages: object.scenario.disconnectSignalOnResumeNoMessages,
          };
        }
        break;
      }
      case "leaveRequestFullReconnect": {
        if (
          object.scenario?.leaveRequestFullReconnect !== undefined &&
          object.scenario?.leaveRequestFullReconnect !== null
        ) {
          message.scenario = {
            $case: "leaveRequestFullReconnect",
            leaveRequestFullReconnect: object.scenario.leaveRequestFullReconnect,
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBasePing(): Ping {
  return { timestamp: "0", rtt: "0" };
}

export const Ping: MessageFns<Ping> = {
  encode(message: Ping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "0") {
      writer.uint32(8).int64(message.timestamp);
    }
    if (message.rtt !== "0") {
      writer.uint32(16).int64(message.rtt);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.rtt = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ping {
    return {
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
      rtt: isSet(object.rtt) ? globalThis.String(object.rtt) : "0",
    };
  },

  toJSON(message: Ping): unknown {
    const obj: any = {};
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    if (message.rtt !== "0") {
      obj.rtt = message.rtt;
    }
    return obj;
  },

  create(base?: DeepPartial<Ping>): Ping {
    return Ping.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Ping>): Ping {
    const message = createBasePing();
    message.timestamp = object.timestamp ?? "0";
    message.rtt = object.rtt ?? "0";
    return message;
  },
};

function createBasePong(): Pong {
  return { lastPingTimestamp: "0", timestamp: "0" };
}

export const Pong: MessageFns<Pong> = {
  encode(message: Pong, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.lastPingTimestamp !== "0") {
      writer.uint32(8).int64(message.lastPingTimestamp);
    }
    if (message.timestamp !== "0") {
      writer.uint32(16).int64(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pong {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.lastPingTimestamp = reader.int64().toString();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.timestamp = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pong {
    return {
      lastPingTimestamp: isSet(object.lastPingTimestamp) ? globalThis.String(object.lastPingTimestamp) : "0",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "0",
    };
  },

  toJSON(message: Pong): unknown {
    const obj: any = {};
    if (message.lastPingTimestamp !== "0") {
      obj.lastPingTimestamp = message.lastPingTimestamp;
    }
    if (message.timestamp !== "0") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create(base?: DeepPartial<Pong>): Pong {
    return Pong.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Pong>): Pong {
    const message = createBasePong();
    message.lastPingTimestamp = object.lastPingTimestamp ?? "0";
    message.timestamp = object.timestamp ?? "0";
    return message;
  },
};

function createBaseRegionSettings(): RegionSettings {
  return { regions: [] };
}

export const RegionSettings: MessageFns<RegionSettings> = {
  encode(message: RegionSettings, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.regions) {
      RegionInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegionSettings {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegionSettings();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.regions.push(RegionInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegionSettings {
    return {
      regions: globalThis.Array.isArray(object?.regions) ? object.regions.map((e: any) => RegionInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: RegionSettings): unknown {
    const obj: any = {};
    if (message.regions?.length) {
      obj.regions = message.regions.map((e) => RegionInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<RegionSettings>): RegionSettings {
    return RegionSettings.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegionSettings>): RegionSettings {
    const message = createBaseRegionSettings();
    message.regions = object.regions?.map((e) => RegionInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRegionInfo(): RegionInfo {
  return { region: "", url: "", distance: "0" };
}

export const RegionInfo: MessageFns<RegionInfo> = {
  encode(message: RegionInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.region !== "") {
      writer.uint32(10).string(message.region);
    }
    if (message.url !== "") {
      writer.uint32(18).string(message.url);
    }
    if (message.distance !== "0") {
      writer.uint32(24).int64(message.distance);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegionInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegionInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.url = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.distance = reader.int64().toString();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegionInfo {
    return {
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      url: isSet(object.url) ? globalThis.String(object.url) : "",
      distance: isSet(object.distance) ? globalThis.String(object.distance) : "0",
    };
  },

  toJSON(message: RegionInfo): unknown {
    const obj: any = {};
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.url !== "") {
      obj.url = message.url;
    }
    if (message.distance !== "0") {
      obj.distance = message.distance;
    }
    return obj;
  },

  create(base?: DeepPartial<RegionInfo>): RegionInfo {
    return RegionInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RegionInfo>): RegionInfo {
    const message = createBaseRegionInfo();
    message.region = object.region ?? "";
    message.url = object.url ?? "";
    message.distance = object.distance ?? "0";
    return message;
  },
};

function createBaseSubscriptionResponse(): SubscriptionResponse {
  return { trackSid: "", err: 0 };
}

export const SubscriptionResponse: MessageFns<SubscriptionResponse> = {
  encode(message: SubscriptionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackSid !== "") {
      writer.uint32(10).string(message.trackSid);
    }
    if (message.err !== 0) {
      writer.uint32(16).int32(message.err);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SubscriptionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSubscriptionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.err = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SubscriptionResponse {
    return {
      trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "",
      err: isSet(object.err) ? subscriptionErrorFromJSON(object.err) : 0,
    };
  },

  toJSON(message: SubscriptionResponse): unknown {
    const obj: any = {};
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    if (message.err !== 0) {
      obj.err = subscriptionErrorToJSON(message.err);
    }
    return obj;
  },

  create(base?: DeepPartial<SubscriptionResponse>): SubscriptionResponse {
    return SubscriptionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SubscriptionResponse>): SubscriptionResponse {
    const message = createBaseSubscriptionResponse();
    message.trackSid = object.trackSid ?? "";
    message.err = object.err ?? 0;
    return message;
  },
};

function createBaseRequestResponse(): RequestResponse {
  return { requestId: 0, reason: 0, message: "" };
}

export const RequestResponse: MessageFns<RequestResponse> = {
  encode(message: RequestResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== 0) {
      writer.uint32(8).uint32(message.requestId);
    }
    if (message.reason !== 0) {
      writer.uint32(16).int32(message.reason);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RequestResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRequestResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.requestId = reader.uint32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.reason = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RequestResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.Number(object.requestId) : 0,
      reason: isSet(object.reason) ? requestResponse_ReasonFromJSON(object.reason) : 0,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: RequestResponse): unknown {
    const obj: any = {};
    if (message.requestId !== 0) {
      obj.requestId = Math.round(message.requestId);
    }
    if (message.reason !== 0) {
      obj.reason = requestResponse_ReasonToJSON(message.reason);
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<RequestResponse>): RequestResponse {
    return RequestResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RequestResponse>): RequestResponse {
    const message = createBaseRequestResponse();
    message.requestId = object.requestId ?? 0;
    message.reason = object.reason ?? 0;
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseTrackSubscribed(): TrackSubscribed {
  return { trackSid: "" };
}

export const TrackSubscribed: MessageFns<TrackSubscribed> = {
  encode(message: TrackSubscribed, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trackSid !== "") {
      writer.uint32(10).string(message.trackSid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TrackSubscribed {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTrackSubscribed();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trackSid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TrackSubscribed {
    return { trackSid: isSet(object.trackSid) ? globalThis.String(object.trackSid) : "" };
  },

  toJSON(message: TrackSubscribed): unknown {
    const obj: any = {};
    if (message.trackSid !== "") {
      obj.trackSid = message.trackSid;
    }
    return obj;
  },

  create(base?: DeepPartial<TrackSubscribed>): TrackSubscribed {
    return TrackSubscribed.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TrackSubscribed>): TrackSubscribed {
    const message = createBaseTrackSubscribed();
    message.trackSid = object.trackSid ?? "";
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
