// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.28.3
// source: livekit_sip.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Duration } from "./google/protobuf/duration";
import { Empty } from "./google/protobuf/empty";
import {
  DisconnectReason,
  disconnectReasonFromJSON,
  disconnectReasonToJSON,
  ListUpdate,
  Pagination,
} from "./livekit_models";
import { RoomConfiguration } from "./livekit_room";

export const protobufPackage = "livekit";

export enum SIPStatusCode {
  SIP_STATUS_UNKNOWN = 0,
  SIP_STATUS_TRYING = 100,
  SIP_STATUS_RINGING = 180,
  SIP_STATUS_CALL_IS_FORWARDED = 181,
  SIP_STATUS_QUEUED = 182,
  SIP_STATUS_SESSION_PROGRESS = 183,
  SIP_STATUS_OK = 200,
  SIP_STATUS_ACCEPTED = 202,
  SIP_STATUS_MOVED_PERMANENTLY = 301,
  SIP_STATUS_MOVED_TEMPORARILY = 302,
  SIP_STATUS_USE_PROXY = 305,
  SIP_STATUS_BAD_REQUEST = 400,
  SIP_STATUS_UNAUTHORIZED = 401,
  SIP_STATUS_PAYMENT_REQUIRED = 402,
  SIP_STATUS_FORBIDDEN = 403,
  SIP_STATUS_NOTFOUND = 404,
  SIP_STATUS_METHOD_NOT_ALLOWED = 405,
  SIP_STATUS_NOT_ACCEPTABLE = 406,
  SIP_STATUS_PROXY_AUTH_REQUIRED = 407,
  SIP_STATUS_REQUEST_TIMEOUT = 408,
  SIP_STATUS_CONFLICT = 409,
  SIP_STATUS_GONE = 410,
  SIP_STATUS_REQUEST_ENTITY_TOO_LARGE = 413,
  SIP_STATUS_REQUEST_URI_TOO_LONG = 414,
  SIP_STATUS_UNSUPPORTED_MEDIA_TYPE = 415,
  SIP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE = 416,
  SIP_STATUS_BAD_EXTENSION = 420,
  SIP_STATUS_EXTENSION_REQUIRED = 421,
  SIP_STATUS_INTERVAL_TOO_BRIEF = 423,
  SIP_STATUS_TEMPORARILY_UNAVAILABLE = 480,
  SIP_STATUS_CALL_TRANSACTION_DOES_NOT_EXISTS = 481,
  SIP_STATUS_LOOP_DETECTED = 482,
  SIP_STATUS_TOO_MANY_HOPS = 483,
  SIP_STATUS_ADDRESS_INCOMPLETE = 484,
  SIP_STATUS_AMBIGUOUS = 485,
  SIP_STATUS_BUSY_HERE = 486,
  SIP_STATUS_REQUEST_TERMINATED = 487,
  SIP_STATUS_NOT_ACCEPTABLE_HERE = 488,
  SIP_STATUS_INTERNAL_SERVER_ERROR = 500,
  SIP_STATUS_NOT_IMPLEMENTED = 501,
  SIP_STATUS_BAD_GATEWAY = 502,
  SIP_STATUS_SERVICE_UNAVAILABLE = 503,
  SIP_STATUS_GATEWAY_TIMEOUT = 504,
  SIP_STATUS_VERSION_NOT_SUPPORTED = 505,
  SIP_STATUS_MESSAGE_TOO_LARGE = 513,
  SIP_STATUS_GLOBAL_BUSY_EVERYWHERE = 600,
  SIP_STATUS_GLOBAL_DECLINE = 603,
  SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE = 604,
  SIP_STATUS_GLOBAL_NOT_ACCEPTABLE = 606,
  UNRECOGNIZED = -1,
}

export function sIPStatusCodeFromJSON(object: any): SIPStatusCode {
  switch (object) {
    case 0:
    case "SIP_STATUS_UNKNOWN":
      return SIPStatusCode.SIP_STATUS_UNKNOWN;
    case 100:
    case "SIP_STATUS_TRYING":
      return SIPStatusCode.SIP_STATUS_TRYING;
    case 180:
    case "SIP_STATUS_RINGING":
      return SIPStatusCode.SIP_STATUS_RINGING;
    case 181:
    case "SIP_STATUS_CALL_IS_FORWARDED":
      return SIPStatusCode.SIP_STATUS_CALL_IS_FORWARDED;
    case 182:
    case "SIP_STATUS_QUEUED":
      return SIPStatusCode.SIP_STATUS_QUEUED;
    case 183:
    case "SIP_STATUS_SESSION_PROGRESS":
      return SIPStatusCode.SIP_STATUS_SESSION_PROGRESS;
    case 200:
    case "SIP_STATUS_OK":
      return SIPStatusCode.SIP_STATUS_OK;
    case 202:
    case "SIP_STATUS_ACCEPTED":
      return SIPStatusCode.SIP_STATUS_ACCEPTED;
    case 301:
    case "SIP_STATUS_MOVED_PERMANENTLY":
      return SIPStatusCode.SIP_STATUS_MOVED_PERMANENTLY;
    case 302:
    case "SIP_STATUS_MOVED_TEMPORARILY":
      return SIPStatusCode.SIP_STATUS_MOVED_TEMPORARILY;
    case 305:
    case "SIP_STATUS_USE_PROXY":
      return SIPStatusCode.SIP_STATUS_USE_PROXY;
    case 400:
    case "SIP_STATUS_BAD_REQUEST":
      return SIPStatusCode.SIP_STATUS_BAD_REQUEST;
    case 401:
    case "SIP_STATUS_UNAUTHORIZED":
      return SIPStatusCode.SIP_STATUS_UNAUTHORIZED;
    case 402:
    case "SIP_STATUS_PAYMENT_REQUIRED":
      return SIPStatusCode.SIP_STATUS_PAYMENT_REQUIRED;
    case 403:
    case "SIP_STATUS_FORBIDDEN":
      return SIPStatusCode.SIP_STATUS_FORBIDDEN;
    case 404:
    case "SIP_STATUS_NOTFOUND":
      return SIPStatusCode.SIP_STATUS_NOTFOUND;
    case 405:
    case "SIP_STATUS_METHOD_NOT_ALLOWED":
      return SIPStatusCode.SIP_STATUS_METHOD_NOT_ALLOWED;
    case 406:
    case "SIP_STATUS_NOT_ACCEPTABLE":
      return SIPStatusCode.SIP_STATUS_NOT_ACCEPTABLE;
    case 407:
    case "SIP_STATUS_PROXY_AUTH_REQUIRED":
      return SIPStatusCode.SIP_STATUS_PROXY_AUTH_REQUIRED;
    case 408:
    case "SIP_STATUS_REQUEST_TIMEOUT":
      return SIPStatusCode.SIP_STATUS_REQUEST_TIMEOUT;
    case 409:
    case "SIP_STATUS_CONFLICT":
      return SIPStatusCode.SIP_STATUS_CONFLICT;
    case 410:
    case "SIP_STATUS_GONE":
      return SIPStatusCode.SIP_STATUS_GONE;
    case 413:
    case "SIP_STATUS_REQUEST_ENTITY_TOO_LARGE":
      return SIPStatusCode.SIP_STATUS_REQUEST_ENTITY_TOO_LARGE;
    case 414:
    case "SIP_STATUS_REQUEST_URI_TOO_LONG":
      return SIPStatusCode.SIP_STATUS_REQUEST_URI_TOO_LONG;
    case 415:
    case "SIP_STATUS_UNSUPPORTED_MEDIA_TYPE":
      return SIPStatusCode.SIP_STATUS_UNSUPPORTED_MEDIA_TYPE;
    case 416:
    case "SIP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE":
      return SIPStatusCode.SIP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE;
    case 420:
    case "SIP_STATUS_BAD_EXTENSION":
      return SIPStatusCode.SIP_STATUS_BAD_EXTENSION;
    case 421:
    case "SIP_STATUS_EXTENSION_REQUIRED":
      return SIPStatusCode.SIP_STATUS_EXTENSION_REQUIRED;
    case 423:
    case "SIP_STATUS_INTERVAL_TOO_BRIEF":
      return SIPStatusCode.SIP_STATUS_INTERVAL_TOO_BRIEF;
    case 480:
    case "SIP_STATUS_TEMPORARILY_UNAVAILABLE":
      return SIPStatusCode.SIP_STATUS_TEMPORARILY_UNAVAILABLE;
    case 481:
    case "SIP_STATUS_CALL_TRANSACTION_DOES_NOT_EXISTS":
      return SIPStatusCode.SIP_STATUS_CALL_TRANSACTION_DOES_NOT_EXISTS;
    case 482:
    case "SIP_STATUS_LOOP_DETECTED":
      return SIPStatusCode.SIP_STATUS_LOOP_DETECTED;
    case 483:
    case "SIP_STATUS_TOO_MANY_HOPS":
      return SIPStatusCode.SIP_STATUS_TOO_MANY_HOPS;
    case 484:
    case "SIP_STATUS_ADDRESS_INCOMPLETE":
      return SIPStatusCode.SIP_STATUS_ADDRESS_INCOMPLETE;
    case 485:
    case "SIP_STATUS_AMBIGUOUS":
      return SIPStatusCode.SIP_STATUS_AMBIGUOUS;
    case 486:
    case "SIP_STATUS_BUSY_HERE":
      return SIPStatusCode.SIP_STATUS_BUSY_HERE;
    case 487:
    case "SIP_STATUS_REQUEST_TERMINATED":
      return SIPStatusCode.SIP_STATUS_REQUEST_TERMINATED;
    case 488:
    case "SIP_STATUS_NOT_ACCEPTABLE_HERE":
      return SIPStatusCode.SIP_STATUS_NOT_ACCEPTABLE_HERE;
    case 500:
    case "SIP_STATUS_INTERNAL_SERVER_ERROR":
      return SIPStatusCode.SIP_STATUS_INTERNAL_SERVER_ERROR;
    case 501:
    case "SIP_STATUS_NOT_IMPLEMENTED":
      return SIPStatusCode.SIP_STATUS_NOT_IMPLEMENTED;
    case 502:
    case "SIP_STATUS_BAD_GATEWAY":
      return SIPStatusCode.SIP_STATUS_BAD_GATEWAY;
    case 503:
    case "SIP_STATUS_SERVICE_UNAVAILABLE":
      return SIPStatusCode.SIP_STATUS_SERVICE_UNAVAILABLE;
    case 504:
    case "SIP_STATUS_GATEWAY_TIMEOUT":
      return SIPStatusCode.SIP_STATUS_GATEWAY_TIMEOUT;
    case 505:
    case "SIP_STATUS_VERSION_NOT_SUPPORTED":
      return SIPStatusCode.SIP_STATUS_VERSION_NOT_SUPPORTED;
    case 513:
    case "SIP_STATUS_MESSAGE_TOO_LARGE":
      return SIPStatusCode.SIP_STATUS_MESSAGE_TOO_LARGE;
    case 600:
    case "SIP_STATUS_GLOBAL_BUSY_EVERYWHERE":
      return SIPStatusCode.SIP_STATUS_GLOBAL_BUSY_EVERYWHERE;
    case 603:
    case "SIP_STATUS_GLOBAL_DECLINE":
      return SIPStatusCode.SIP_STATUS_GLOBAL_DECLINE;
    case 604:
    case "SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE":
      return SIPStatusCode.SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE;
    case 606:
    case "SIP_STATUS_GLOBAL_NOT_ACCEPTABLE":
      return SIPStatusCode.SIP_STATUS_GLOBAL_NOT_ACCEPTABLE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPStatusCode.UNRECOGNIZED;
  }
}

export function sIPStatusCodeToJSON(object: SIPStatusCode): string {
  switch (object) {
    case SIPStatusCode.SIP_STATUS_UNKNOWN:
      return "SIP_STATUS_UNKNOWN";
    case SIPStatusCode.SIP_STATUS_TRYING:
      return "SIP_STATUS_TRYING";
    case SIPStatusCode.SIP_STATUS_RINGING:
      return "SIP_STATUS_RINGING";
    case SIPStatusCode.SIP_STATUS_CALL_IS_FORWARDED:
      return "SIP_STATUS_CALL_IS_FORWARDED";
    case SIPStatusCode.SIP_STATUS_QUEUED:
      return "SIP_STATUS_QUEUED";
    case SIPStatusCode.SIP_STATUS_SESSION_PROGRESS:
      return "SIP_STATUS_SESSION_PROGRESS";
    case SIPStatusCode.SIP_STATUS_OK:
      return "SIP_STATUS_OK";
    case SIPStatusCode.SIP_STATUS_ACCEPTED:
      return "SIP_STATUS_ACCEPTED";
    case SIPStatusCode.SIP_STATUS_MOVED_PERMANENTLY:
      return "SIP_STATUS_MOVED_PERMANENTLY";
    case SIPStatusCode.SIP_STATUS_MOVED_TEMPORARILY:
      return "SIP_STATUS_MOVED_TEMPORARILY";
    case SIPStatusCode.SIP_STATUS_USE_PROXY:
      return "SIP_STATUS_USE_PROXY";
    case SIPStatusCode.SIP_STATUS_BAD_REQUEST:
      return "SIP_STATUS_BAD_REQUEST";
    case SIPStatusCode.SIP_STATUS_UNAUTHORIZED:
      return "SIP_STATUS_UNAUTHORIZED";
    case SIPStatusCode.SIP_STATUS_PAYMENT_REQUIRED:
      return "SIP_STATUS_PAYMENT_REQUIRED";
    case SIPStatusCode.SIP_STATUS_FORBIDDEN:
      return "SIP_STATUS_FORBIDDEN";
    case SIPStatusCode.SIP_STATUS_NOTFOUND:
      return "SIP_STATUS_NOTFOUND";
    case SIPStatusCode.SIP_STATUS_METHOD_NOT_ALLOWED:
      return "SIP_STATUS_METHOD_NOT_ALLOWED";
    case SIPStatusCode.SIP_STATUS_NOT_ACCEPTABLE:
      return "SIP_STATUS_NOT_ACCEPTABLE";
    case SIPStatusCode.SIP_STATUS_PROXY_AUTH_REQUIRED:
      return "SIP_STATUS_PROXY_AUTH_REQUIRED";
    case SIPStatusCode.SIP_STATUS_REQUEST_TIMEOUT:
      return "SIP_STATUS_REQUEST_TIMEOUT";
    case SIPStatusCode.SIP_STATUS_CONFLICT:
      return "SIP_STATUS_CONFLICT";
    case SIPStatusCode.SIP_STATUS_GONE:
      return "SIP_STATUS_GONE";
    case SIPStatusCode.SIP_STATUS_REQUEST_ENTITY_TOO_LARGE:
      return "SIP_STATUS_REQUEST_ENTITY_TOO_LARGE";
    case SIPStatusCode.SIP_STATUS_REQUEST_URI_TOO_LONG:
      return "SIP_STATUS_REQUEST_URI_TOO_LONG";
    case SIPStatusCode.SIP_STATUS_UNSUPPORTED_MEDIA_TYPE:
      return "SIP_STATUS_UNSUPPORTED_MEDIA_TYPE";
    case SIPStatusCode.SIP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE:
      return "SIP_STATUS_REQUESTED_RANGE_NOT_SATISFIABLE";
    case SIPStatusCode.SIP_STATUS_BAD_EXTENSION:
      return "SIP_STATUS_BAD_EXTENSION";
    case SIPStatusCode.SIP_STATUS_EXTENSION_REQUIRED:
      return "SIP_STATUS_EXTENSION_REQUIRED";
    case SIPStatusCode.SIP_STATUS_INTERVAL_TOO_BRIEF:
      return "SIP_STATUS_INTERVAL_TOO_BRIEF";
    case SIPStatusCode.SIP_STATUS_TEMPORARILY_UNAVAILABLE:
      return "SIP_STATUS_TEMPORARILY_UNAVAILABLE";
    case SIPStatusCode.SIP_STATUS_CALL_TRANSACTION_DOES_NOT_EXISTS:
      return "SIP_STATUS_CALL_TRANSACTION_DOES_NOT_EXISTS";
    case SIPStatusCode.SIP_STATUS_LOOP_DETECTED:
      return "SIP_STATUS_LOOP_DETECTED";
    case SIPStatusCode.SIP_STATUS_TOO_MANY_HOPS:
      return "SIP_STATUS_TOO_MANY_HOPS";
    case SIPStatusCode.SIP_STATUS_ADDRESS_INCOMPLETE:
      return "SIP_STATUS_ADDRESS_INCOMPLETE";
    case SIPStatusCode.SIP_STATUS_AMBIGUOUS:
      return "SIP_STATUS_AMBIGUOUS";
    case SIPStatusCode.SIP_STATUS_BUSY_HERE:
      return "SIP_STATUS_BUSY_HERE";
    case SIPStatusCode.SIP_STATUS_REQUEST_TERMINATED:
      return "SIP_STATUS_REQUEST_TERMINATED";
    case SIPStatusCode.SIP_STATUS_NOT_ACCEPTABLE_HERE:
      return "SIP_STATUS_NOT_ACCEPTABLE_HERE";
    case SIPStatusCode.SIP_STATUS_INTERNAL_SERVER_ERROR:
      return "SIP_STATUS_INTERNAL_SERVER_ERROR";
    case SIPStatusCode.SIP_STATUS_NOT_IMPLEMENTED:
      return "SIP_STATUS_NOT_IMPLEMENTED";
    case SIPStatusCode.SIP_STATUS_BAD_GATEWAY:
      return "SIP_STATUS_BAD_GATEWAY";
    case SIPStatusCode.SIP_STATUS_SERVICE_UNAVAILABLE:
      return "SIP_STATUS_SERVICE_UNAVAILABLE";
    case SIPStatusCode.SIP_STATUS_GATEWAY_TIMEOUT:
      return "SIP_STATUS_GATEWAY_TIMEOUT";
    case SIPStatusCode.SIP_STATUS_VERSION_NOT_SUPPORTED:
      return "SIP_STATUS_VERSION_NOT_SUPPORTED";
    case SIPStatusCode.SIP_STATUS_MESSAGE_TOO_LARGE:
      return "SIP_STATUS_MESSAGE_TOO_LARGE";
    case SIPStatusCode.SIP_STATUS_GLOBAL_BUSY_EVERYWHERE:
      return "SIP_STATUS_GLOBAL_BUSY_EVERYWHERE";
    case SIPStatusCode.SIP_STATUS_GLOBAL_DECLINE:
      return "SIP_STATUS_GLOBAL_DECLINE";
    case SIPStatusCode.SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE:
      return "SIP_STATUS_GLOBAL_DOES_NOT_EXIST_ANYWHERE";
    case SIPStatusCode.SIP_STATUS_GLOBAL_NOT_ACCEPTABLE:
      return "SIP_STATUS_GLOBAL_NOT_ACCEPTABLE";
    case SIPStatusCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SIPTransport {
  SIP_TRANSPORT_AUTO = 0,
  SIP_TRANSPORT_UDP = 1,
  SIP_TRANSPORT_TCP = 2,
  SIP_TRANSPORT_TLS = 3,
  UNRECOGNIZED = -1,
}

export function sIPTransportFromJSON(object: any): SIPTransport {
  switch (object) {
    case 0:
    case "SIP_TRANSPORT_AUTO":
      return SIPTransport.SIP_TRANSPORT_AUTO;
    case 1:
    case "SIP_TRANSPORT_UDP":
      return SIPTransport.SIP_TRANSPORT_UDP;
    case 2:
    case "SIP_TRANSPORT_TCP":
      return SIPTransport.SIP_TRANSPORT_TCP;
    case 3:
    case "SIP_TRANSPORT_TLS":
      return SIPTransport.SIP_TRANSPORT_TLS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPTransport.UNRECOGNIZED;
  }
}

export function sIPTransportToJSON(object: SIPTransport): string {
  switch (object) {
    case SIPTransport.SIP_TRANSPORT_AUTO:
      return "SIP_TRANSPORT_AUTO";
    case SIPTransport.SIP_TRANSPORT_UDP:
      return "SIP_TRANSPORT_UDP";
    case SIPTransport.SIP_TRANSPORT_TCP:
      return "SIP_TRANSPORT_TCP";
    case SIPTransport.SIP_TRANSPORT_TLS:
      return "SIP_TRANSPORT_TLS";
    case SIPTransport.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SIPHeaderOptions {
  /** SIP_NO_HEADERS - do not map any headers, except ones mapped explicitly */
  SIP_NO_HEADERS = 0,
  /** SIP_X_HEADERS - map all X-* headers to sip.h.x-* attributes */
  SIP_X_HEADERS = 1,
  /** SIP_ALL_HEADERS - map all headers to sip.h.* attributes */
  SIP_ALL_HEADERS = 2,
  UNRECOGNIZED = -1,
}

export function sIPHeaderOptionsFromJSON(object: any): SIPHeaderOptions {
  switch (object) {
    case 0:
    case "SIP_NO_HEADERS":
      return SIPHeaderOptions.SIP_NO_HEADERS;
    case 1:
    case "SIP_X_HEADERS":
      return SIPHeaderOptions.SIP_X_HEADERS;
    case 2:
    case "SIP_ALL_HEADERS":
      return SIPHeaderOptions.SIP_ALL_HEADERS;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPHeaderOptions.UNRECOGNIZED;
  }
}

export function sIPHeaderOptionsToJSON(object: SIPHeaderOptions): string {
  switch (object) {
    case SIPHeaderOptions.SIP_NO_HEADERS:
      return "SIP_NO_HEADERS";
    case SIPHeaderOptions.SIP_X_HEADERS:
      return "SIP_X_HEADERS";
    case SIPHeaderOptions.SIP_ALL_HEADERS:
      return "SIP_ALL_HEADERS";
    case SIPHeaderOptions.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SIPMediaEncryption {
  /** SIP_MEDIA_ENCRYPT_DISABLE - do not enable encryption */
  SIP_MEDIA_ENCRYPT_DISABLE = 0,
  /** SIP_MEDIA_ENCRYPT_ALLOW - use encryption if available */
  SIP_MEDIA_ENCRYPT_ALLOW = 1,
  /** SIP_MEDIA_ENCRYPT_REQUIRE - require encryption */
  SIP_MEDIA_ENCRYPT_REQUIRE = 2,
  UNRECOGNIZED = -1,
}

export function sIPMediaEncryptionFromJSON(object: any): SIPMediaEncryption {
  switch (object) {
    case 0:
    case "SIP_MEDIA_ENCRYPT_DISABLE":
      return SIPMediaEncryption.SIP_MEDIA_ENCRYPT_DISABLE;
    case 1:
    case "SIP_MEDIA_ENCRYPT_ALLOW":
      return SIPMediaEncryption.SIP_MEDIA_ENCRYPT_ALLOW;
    case 2:
    case "SIP_MEDIA_ENCRYPT_REQUIRE":
      return SIPMediaEncryption.SIP_MEDIA_ENCRYPT_REQUIRE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPMediaEncryption.UNRECOGNIZED;
  }
}

export function sIPMediaEncryptionToJSON(object: SIPMediaEncryption): string {
  switch (object) {
    case SIPMediaEncryption.SIP_MEDIA_ENCRYPT_DISABLE:
      return "SIP_MEDIA_ENCRYPT_DISABLE";
    case SIPMediaEncryption.SIP_MEDIA_ENCRYPT_ALLOW:
      return "SIP_MEDIA_ENCRYPT_ALLOW";
    case SIPMediaEncryption.SIP_MEDIA_ENCRYPT_REQUIRE:
      return "SIP_MEDIA_ENCRYPT_REQUIRE";
    case SIPMediaEncryption.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SIPCallStatus {
  /** SCS_CALL_INCOMING - Incoming call is being handled by the SIP service. The SIP participant hasn't joined a LiveKit room yet */
  SCS_CALL_INCOMING = 0,
  /** SCS_PARTICIPANT_JOINED - SIP participant for outgoing call has been created. The SIP outgoing call is being established */
  SCS_PARTICIPANT_JOINED = 1,
  /** SCS_ACTIVE - Call is ongoing. SIP participant is active in the LiveKit room */
  SCS_ACTIVE = 2,
  /** SCS_DISCONNECTED - Call has ended */
  SCS_DISCONNECTED = 3,
  /** SCS_ERROR - Call has ended or never succeeded because of an error */
  SCS_ERROR = 4,
  UNRECOGNIZED = -1,
}

export function sIPCallStatusFromJSON(object: any): SIPCallStatus {
  switch (object) {
    case 0:
    case "SCS_CALL_INCOMING":
      return SIPCallStatus.SCS_CALL_INCOMING;
    case 1:
    case "SCS_PARTICIPANT_JOINED":
      return SIPCallStatus.SCS_PARTICIPANT_JOINED;
    case 2:
    case "SCS_ACTIVE":
      return SIPCallStatus.SCS_ACTIVE;
    case 3:
    case "SCS_DISCONNECTED":
      return SIPCallStatus.SCS_DISCONNECTED;
    case 4:
    case "SCS_ERROR":
      return SIPCallStatus.SCS_ERROR;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPCallStatus.UNRECOGNIZED;
  }
}

export function sIPCallStatusToJSON(object: SIPCallStatus): string {
  switch (object) {
    case SIPCallStatus.SCS_CALL_INCOMING:
      return "SCS_CALL_INCOMING";
    case SIPCallStatus.SCS_PARTICIPANT_JOINED:
      return "SCS_PARTICIPANT_JOINED";
    case SIPCallStatus.SCS_ACTIVE:
      return "SCS_ACTIVE";
    case SIPCallStatus.SCS_DISCONNECTED:
      return "SCS_DISCONNECTED";
    case SIPCallStatus.SCS_ERROR:
      return "SCS_ERROR";
    case SIPCallStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SIPTransferStatus {
  STS_TRANSFER_ONGOING = 0,
  STS_TRANSFER_FAILED = 1,
  STS_TRANSFER_SUCCESSFUL = 2,
  UNRECOGNIZED = -1,
}

export function sIPTransferStatusFromJSON(object: any): SIPTransferStatus {
  switch (object) {
    case 0:
    case "STS_TRANSFER_ONGOING":
      return SIPTransferStatus.STS_TRANSFER_ONGOING;
    case 1:
    case "STS_TRANSFER_FAILED":
      return SIPTransferStatus.STS_TRANSFER_FAILED;
    case 2:
    case "STS_TRANSFER_SUCCESSFUL":
      return SIPTransferStatus.STS_TRANSFER_SUCCESSFUL;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPTransferStatus.UNRECOGNIZED;
  }
}

export function sIPTransferStatusToJSON(object: SIPTransferStatus): string {
  switch (object) {
    case SIPTransferStatus.STS_TRANSFER_ONGOING:
      return "STS_TRANSFER_ONGOING";
    case SIPTransferStatus.STS_TRANSFER_FAILED:
      return "STS_TRANSFER_FAILED";
    case SIPTransferStatus.STS_TRANSFER_SUCCESSFUL:
      return "STS_TRANSFER_SUCCESSFUL";
    case SIPTransferStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SIPFeature {
  NONE = 0,
  KRISP_ENABLED = 1,
  UNRECOGNIZED = -1,
}

export function sIPFeatureFromJSON(object: any): SIPFeature {
  switch (object) {
    case 0:
    case "NONE":
      return SIPFeature.NONE;
    case 1:
    case "KRISP_ENABLED":
      return SIPFeature.KRISP_ENABLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPFeature.UNRECOGNIZED;
  }
}

export function sIPFeatureToJSON(object: SIPFeature): string {
  switch (object) {
    case SIPFeature.NONE:
      return "NONE";
    case SIPFeature.KRISP_ENABLED:
      return "KRISP_ENABLED";
    case SIPFeature.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SIPCallDirection {
  SCD_UNKNOWN = 0,
  SCD_INBOUND = 1,
  SCD_OUTBOUND = 2,
  UNRECOGNIZED = -1,
}

export function sIPCallDirectionFromJSON(object: any): SIPCallDirection {
  switch (object) {
    case 0:
    case "SCD_UNKNOWN":
      return SIPCallDirection.SCD_UNKNOWN;
    case 1:
    case "SCD_INBOUND":
      return SIPCallDirection.SCD_INBOUND;
    case 2:
    case "SCD_OUTBOUND":
      return SIPCallDirection.SCD_OUTBOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPCallDirection.UNRECOGNIZED;
  }
}

export function sIPCallDirectionToJSON(object: SIPCallDirection): string {
  switch (object) {
    case SIPCallDirection.SCD_UNKNOWN:
      return "SCD_UNKNOWN";
    case SIPCallDirection.SCD_INBOUND:
      return "SCD_INBOUND";
    case SIPCallDirection.SCD_OUTBOUND:
      return "SCD_OUTBOUND";
    case SIPCallDirection.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** SIPStatus is returned as an error detail in CreateSIPParticipant. */
export interface SIPStatus {
  code: SIPStatusCode;
  status: string;
}

/** @deprecated */
export interface CreateSIPTrunkRequest {
  /**
   * CIDR or IPs that traffic is accepted from
   * An empty list means all inbound traffic is accepted.
   */
  inboundAddresses: string[];
  /** IP that SIP INVITE is sent too */
  outboundAddress: string;
  /** Number used to make outbound calls */
  outboundNumber: string;
  /** @deprecated */
  inboundNumbersRegex: string[];
  /**
   * Accepted `To` values. This Trunk will only accept a call made to
   * these numbers. This allows you to have distinct Trunks for different phone
   * numbers at the same provider.
   */
  inboundNumbers: string[];
  /**
   * Username and password used to authenticate inbound and outbound SIP invites
   * May be empty to have no Authentication
   */
  inboundUsername: string;
  inboundPassword: string;
  outboundUsername: string;
  outboundPassword: string;
  /** Optional human-readable name for the Trunk. */
  name: string;
  /** Optional user-defined metadata for the Trunk. */
  metadata: string;
}

/** @deprecated */
export interface SIPTrunkInfo {
  sipTrunkId: string;
  kind: SIPTrunkInfo_TrunkKind;
  /**
   * CIDR or IPs that traffic is accepted from
   * An empty list means all inbound traffic is accepted.
   */
  inboundAddresses: string[];
  /** IP that SIP INVITE is sent too */
  outboundAddress: string;
  /** Number used to make outbound calls */
  outboundNumber: string;
  /** Transport used for inbound and outbound calls. */
  transport: SIPTransport;
  /** @deprecated */
  inboundNumbersRegex: string[];
  /**
   * Accepted `To` values. This Trunk will only accept a call made to
   * these numbers. This allows you to have distinct Trunks for different phone
   * numbers at the same provider.
   */
  inboundNumbers: string[];
  /**
   * Username and password used to authenticate inbound and outbound SIP invites
   * May be empty to have no Authentication
   */
  inboundUsername: string;
  inboundPassword: string;
  outboundUsername: string;
  outboundPassword: string;
  /** Human-readable name for the Trunk. */
  name: string;
  /** User-defined metadata for the Trunk. */
  metadata: string;
}

export enum SIPTrunkInfo_TrunkKind {
  TRUNK_LEGACY = 0,
  TRUNK_INBOUND = 1,
  TRUNK_OUTBOUND = 2,
  UNRECOGNIZED = -1,
}

export function sIPTrunkInfo_TrunkKindFromJSON(object: any): SIPTrunkInfo_TrunkKind {
  switch (object) {
    case 0:
    case "TRUNK_LEGACY":
      return SIPTrunkInfo_TrunkKind.TRUNK_LEGACY;
    case 1:
    case "TRUNK_INBOUND":
      return SIPTrunkInfo_TrunkKind.TRUNK_INBOUND;
    case 2:
    case "TRUNK_OUTBOUND":
      return SIPTrunkInfo_TrunkKind.TRUNK_OUTBOUND;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SIPTrunkInfo_TrunkKind.UNRECOGNIZED;
  }
}

export function sIPTrunkInfo_TrunkKindToJSON(object: SIPTrunkInfo_TrunkKind): string {
  switch (object) {
    case SIPTrunkInfo_TrunkKind.TRUNK_LEGACY:
      return "TRUNK_LEGACY";
    case SIPTrunkInfo_TrunkKind.TRUNK_INBOUND:
      return "TRUNK_INBOUND";
    case SIPTrunkInfo_TrunkKind.TRUNK_OUTBOUND:
      return "TRUNK_OUTBOUND";
    case SIPTrunkInfo_TrunkKind.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateSIPInboundTrunkRequest {
  /** Trunk ID is ignored */
  trunk: SIPInboundTrunkInfo | undefined;
}

export interface UpdateSIPInboundTrunkRequest {
  sipTrunkId: string;
  action?:
    | { $case: "replace"; replace: SIPInboundTrunkInfo }
    | { $case: "update"; update: SIPInboundTrunkUpdate }
    | undefined;
}

export interface SIPInboundTrunkInfo {
  sipTrunkId: string;
  /** Human-readable name for the Trunk. */
  name: string;
  /** User-defined metadata for the Trunk. */
  metadata: string;
  /**
   * Numbers associated with LiveKit SIP. The Trunk will only accept calls made to these numbers.
   * Creating multiple Trunks with different phone numbers allows having different rules for a single provider.
   */
  numbers: string[];
  /**
   * CIDR or IPs that traffic is accepted from.
   * An empty list means all inbound traffic is accepted.
   */
  allowedAddresses: string[];
  /**
   * Numbers that are allowed to make calls to this Trunk.
   * An empty list means calls from any phone number is accepted.
   */
  allowedNumbers: string[];
  /**
   * Username and password used to authenticate inbound SIP invites.
   * May be empty to have no authentication.
   */
  authUsername: string;
  authPassword: string;
  /** Include these SIP X-* headers in 200 OK responses. */
  headers: { [key: string]: string };
  /** Map SIP X-* headers from INVITE to SIP participant attributes. */
  headersToAttributes: { [key: string]: string };
  /**
   * Map LiveKit attributes to SIP X-* headers when sending BYE or REFER requests.
   * Keys are the names of attributes and values are the names of X-* headers they will be mapped to.
   */
  attributesToHeaders: { [key: string]: string };
  /**
   * Map SIP headers from INVITE to sip.h.* participant attributes automatically.
   *
   * When the names of required headers is known, using headers_to_attributes is strongly recommended.
   *
   * When mapping INVITE headers to response headers with attributes_to_headers map,
   * lowercase header names should be used, for example: sip.h.x-custom-header.
   */
  includeHeaders: SIPHeaderOptions;
  /** Max time for the caller to wait for track subscription. */
  ringingTimeout:
    | Duration
    | undefined;
  /** Max call duration. */
  maxCallDuration: Duration | undefined;
  krispEnabled: boolean;
  mediaEncryption: SIPMediaEncryption;
}

export interface SIPInboundTrunkInfo_HeadersEntry {
  key: string;
  value: string;
}

export interface SIPInboundTrunkInfo_HeadersToAttributesEntry {
  key: string;
  value: string;
}

export interface SIPInboundTrunkInfo_AttributesToHeadersEntry {
  key: string;
  value: string;
}

export interface SIPInboundTrunkUpdate {
  numbers: ListUpdate | undefined;
  allowedAddresses: ListUpdate | undefined;
  allowedNumbers: ListUpdate | undefined;
  authUsername?: string | undefined;
  authPassword?: string | undefined;
  name?: string | undefined;
  metadata?: string | undefined;
  mediaEncryption?: SIPMediaEncryption | undefined;
}

export interface CreateSIPOutboundTrunkRequest {
  /** Trunk ID is ignored */
  trunk: SIPOutboundTrunkInfo | undefined;
}

export interface UpdateSIPOutboundTrunkRequest {
  sipTrunkId: string;
  action?:
    | { $case: "replace"; replace: SIPOutboundTrunkInfo }
    | { $case: "update"; update: SIPOutboundTrunkUpdate }
    | undefined;
}

export interface SIPOutboundTrunkInfo {
  sipTrunkId: string;
  /** Human-readable name for the Trunk. */
  name: string;
  /** User-defined metadata for the Trunk. */
  metadata: string;
  /**
   * Hostname or IP that SIP INVITE is sent too.
   * Note that this is not a SIP URI and should not contain the 'sip:' protocol prefix.
   */
  address: string;
  /** country where the call terminates as ISO 3166-1 alpha-2 (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). This will be used by the livekit infrastructure to route calls. */
  destinationCountry: string;
  /** SIP Transport used for outbound call. */
  transport: SIPTransport;
  /** Numbers used to make the calls. Random one from this list will be selected. */
  numbers: string[];
  /**
   * Username and password used to authenticate with SIP server.
   * May be empty to have no authentication.
   */
  authUsername: string;
  authPassword: string;
  /**
   * Include these SIP X-* headers in INVITE request.
   * These headers are sent as-is and may help identify this call as coming from LiveKit for the other SIP endpoint.
   */
  headers: { [key: string]: string };
  /**
   * Map SIP X-* headers from 200 OK to SIP participant attributes.
   * Keys are the names of X-* headers and values are the names of attributes they will be mapped to.
   */
  headersToAttributes: { [key: string]: string };
  /**
   * Map LiveKit attributes to SIP X-* headers when sending BYE or REFER requests.
   * Keys are the names of attributes and values are the names of X-* headers they will be mapped to.
   */
  attributesToHeaders: { [key: string]: string };
  /**
   * Map SIP headers from 200 OK to sip.h.* participant attributes automatically.
   *
   * When the names of required headers is known, using headers_to_attributes is strongly recommended.
   *
   * When mapping 200 OK headers to follow-up request headers with attributes_to_headers map,
   * lowercase header names should be used, for example: sip.h.x-custom-header.
   */
  includeHeaders: SIPHeaderOptions;
  mediaEncryption: SIPMediaEncryption;
}

export interface SIPOutboundTrunkInfo_HeadersEntry {
  key: string;
  value: string;
}

export interface SIPOutboundTrunkInfo_HeadersToAttributesEntry {
  key: string;
  value: string;
}

export interface SIPOutboundTrunkInfo_AttributesToHeadersEntry {
  key: string;
  value: string;
}

export interface SIPOutboundTrunkUpdate {
  address?: string | undefined;
  transport?: SIPTransport | undefined;
  destinationCountry?: string | undefined;
  numbers: ListUpdate | undefined;
  authUsername?: string | undefined;
  authPassword?: string | undefined;
  name?: string | undefined;
  metadata?: string | undefined;
  mediaEncryption?: SIPMediaEncryption | undefined;
}

export interface GetSIPInboundTrunkRequest {
  sipTrunkId: string;
}

export interface GetSIPInboundTrunkResponse {
  trunk: SIPInboundTrunkInfo | undefined;
}

export interface GetSIPOutboundTrunkRequest {
  sipTrunkId: string;
}

export interface GetSIPOutboundTrunkResponse {
  trunk: SIPOutboundTrunkInfo | undefined;
}

/** @deprecated */
export interface ListSIPTrunkRequest {
  page: Pagination | undefined;
}

/** @deprecated */
export interface ListSIPTrunkResponse {
  items: SIPTrunkInfo[];
}

/** ListSIPInboundTrunkRequest lists inbound trunks for given filters. If no filters are set, all trunks are listed. */
export interface ListSIPInboundTrunkRequest {
  page:
    | Pagination
    | undefined;
  /**
   * Trunk IDs to list. If this option is set, the response will contains trunks in the same order.
   * If any of the trunks is missing, a nil item in that position will be sent in the response.
   */
  trunkIds: string[];
  /** Only list trunks that contain one of the numbers, including wildcard trunks. */
  numbers: string[];
}

export interface ListSIPInboundTrunkResponse {
  items: SIPInboundTrunkInfo[];
}

/** ListSIPOutboundTrunkRequest lists outbound trunks for given filters. If no filters are set, all trunks are listed. */
export interface ListSIPOutboundTrunkRequest {
  page:
    | Pagination
    | undefined;
  /**
   * Trunk IDs to list. If this option is set, the response will contains trunks in the same order.
   * If any of the trunks is missing, a nil item in that position will be sent in the response.
   */
  trunkIds: string[];
  /** Only list trunks that contain one of the numbers, including wildcard trunks. */
  numbers: string[];
}

export interface ListSIPOutboundTrunkResponse {
  items: SIPOutboundTrunkInfo[];
}

export interface DeleteSIPTrunkRequest {
  sipTrunkId: string;
}

export interface SIPDispatchRuleDirect {
  /** What room should call be directed into */
  roomName: string;
  /** Optional pin required to enter room */
  pin: string;
}

export interface SIPDispatchRuleIndividual {
  /** Prefix used on new room name */
  roomPrefix: string;
  /** Optional pin required to enter room */
  pin: string;
}

export interface SIPDispatchRuleCallee {
  /** Prefix used on new room name */
  roomPrefix: string;
  /** Optional pin required to enter room */
  pin: string;
  /** Optionally append random suffix */
  randomize: boolean;
}

export interface SIPDispatchRule {
  rule?:
    | //
    /**
     * SIPDispatchRuleDirect is a `SIP Dispatch Rule` that puts a user directly into a room
     * This places users into an existing room. Optionally you can require a pin before a user can
     * enter the room
     */
    { $case: "dispatchRuleDirect"; dispatchRuleDirect: SIPDispatchRuleDirect }
    | //
    /** SIPDispatchRuleIndividual is a `SIP Dispatch Rule` that creates a new room for each caller. */
    { $case: "dispatchRuleIndividual"; dispatchRuleIndividual: SIPDispatchRuleIndividual }
    | //
    /** SIPDispatchRuleCallee is a `SIP Dispatch Rule` that creates a new room for each callee. */
    { $case: "dispatchRuleCallee"; dispatchRuleCallee: SIPDispatchRuleCallee }
    | undefined;
}

export interface CreateSIPDispatchRuleRequest {
  /** Rule ID is ignored */
  dispatchRule:
    | SIPDispatchRuleInfo
    | undefined;
  /** @deprecated */
  rule:
    | SIPDispatchRule
    | undefined;
  /**
   * What trunks are accepted for this dispatch rule
   * If empty all trunks will match this dispatch rule
   *
   * @deprecated
   */
  trunkIds: string[];
  /**
   * By default the From value (Phone number) is used for participant name/identity and added to attributes.
   * If true, a random value for identity will be used and numbers will be omitted from attributes.
   *
   * @deprecated
   */
  hidePhoneNumber: boolean;
  /**
   * Dispatch Rule will only accept a call made to these numbers (if set).
   *
   * @deprecated
   */
  inboundNumbers: string[];
  /**
   * Optional human-readable name for the Dispatch Rule.
   *
   * @deprecated
   */
  name: string;
  /**
   * User-defined metadata for the Dispatch Rule.
   * Participants created by this rule will inherit this metadata.
   *
   * @deprecated
   */
  metadata: string;
  /**
   * User-defined attributes for the Dispatch Rule.
   * Participants created by this rule will inherit these attributes.
   *
   * @deprecated
   */
  attributes: { [key: string]: string };
  /**
   * Cloud-only, config preset to use
   *
   * @deprecated
   */
  roomPreset: string;
  /**
   * RoomConfiguration to use if the participant initiates the room
   *
   * @deprecated
   */
  roomConfig: RoomConfiguration | undefined;
}

export interface CreateSIPDispatchRuleRequest_AttributesEntry {
  key: string;
  value: string;
}

export interface UpdateSIPDispatchRuleRequest {
  sipDispatchRuleId: string;
  action?:
    | { $case: "replace"; replace: SIPDispatchRuleInfo }
    | { $case: "update"; update: SIPDispatchRuleUpdate }
    | undefined;
}

export interface SIPDispatchRuleInfo {
  sipDispatchRuleId: string;
  rule: SIPDispatchRule | undefined;
  trunkIds: string[];
  hidePhoneNumber: boolean;
  /** Dispatch Rule will only accept a call made to these numbers (if set). */
  inboundNumbers: string[];
  /** Human-readable name for the Dispatch Rule. */
  name: string;
  /**
   * User-defined metadata for the Dispatch Rule.
   * Participants created by this rule will inherit this metadata.
   */
  metadata: string;
  /**
   * User-defined attributes for the Dispatch Rule.
   * Participants created by this rule will inherit these attributes.
   */
  attributes: { [key: string]: string };
  /** Cloud-only, config preset to use */
  roomPreset: string;
  /** RoomConfiguration to use if the participant initiates the room */
  roomConfig: RoomConfiguration | undefined;
  krispEnabled: boolean;
  /** NEXT ID: 13 */
  mediaEncryption: SIPMediaEncryption;
}

export interface SIPDispatchRuleInfo_AttributesEntry {
  key: string;
  value: string;
}

export interface SIPDispatchRuleUpdate {
  trunkIds: ListUpdate | undefined;
  rule: SIPDispatchRule | undefined;
  name?: string | undefined;
  metadata?: string | undefined;
  attributes: { [key: string]: string };
  mediaEncryption?: SIPMediaEncryption | undefined;
}

export interface SIPDispatchRuleUpdate_AttributesEntry {
  key: string;
  value: string;
}

/** ListSIPDispatchRuleRequest lists dispatch rules for given filters. If no filters are set, all rules are listed. */
export interface ListSIPDispatchRuleRequest {
  page:
    | Pagination
    | undefined;
  /**
   * Rule IDs to list. If this option is set, the response will contains rules in the same order.
   * If any of the rules is missing, a nil item in that position will be sent in the response.
   */
  dispatchRuleIds: string[];
  /** Only list rules that contain one of the Trunk IDs, including wildcard rules. */
  trunkIds: string[];
}

export interface ListSIPDispatchRuleResponse {
  items: SIPDispatchRuleInfo[];
}

export interface DeleteSIPDispatchRuleRequest {
  sipDispatchRuleId: string;
}

export interface SIPOutboundConfig {
  /** SIP server address */
  hostname: string;
  /** country where the call terminates as ISO 3166-1 alpha-2 (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2). This will be used by the livekit infrastructure to route calls. */
  destinationCountry: string;
  /** SIP Transport used for outbound call. */
  transport: SIPTransport;
  /**
   * Username and password used to authenticate with SIP server.
   * May be empty to have no authentication.
   */
  authUsername: string;
  authPassword: string;
  /**
   * Map SIP X-* headers from 200 OK to SIP participant attributes.
   * Keys are the names of X-* headers and values are the names of attributes they will be mapped to.
   */
  headersToAttributes: { [key: string]: string };
  /**
   * Map LiveKit attributes to SIP X-* headers when sending BYE or REFER requests.
   * Keys are the names of attributes and values are the names of X-* headers they will be mapped to.
   */
  attributesToHeaders: { [key: string]: string };
}

export interface SIPOutboundConfig_HeadersToAttributesEntry {
  key: string;
  value: string;
}

export interface SIPOutboundConfig_AttributesToHeadersEntry {
  key: string;
  value: string;
}

/**
 * A SIP Participant is a singular SIP session connected to a LiveKit room via
 * a SIP Trunk into a SIP DispatchRule
 */
export interface CreateSIPParticipantRequest {
  /** What SIP Trunk should be used to dial the user */
  sipTrunkId: string;
  trunk:
    | SIPOutboundConfig
    | undefined;
  /** What number should be dialed via SIP */
  sipCallTo: string;
  /** Optional SIP From number to use. If empty, trunk number is used. */
  sipNumber: string;
  /** What LiveKit room should this participant be connected too */
  roomName: string;
  /** Optional identity of the participant in LiveKit room */
  participantIdentity: string;
  /** Optional name of the participant in LiveKit room */
  participantName: string;
  /** Optional user-defined metadata. Will be attached to a created Participant in the room. */
  participantMetadata: string;
  /** Optional user-defined attributes. Will be attached to a created Participant in the room. */
  participantAttributes: { [key: string]: string };
  /**
   * Optionally send following DTMF digits (extension codes) when making a call.
   * Character 'w' can be used to add a 0.5 sec delay.
   */
  dtmf: string;
  /**
   * Optionally play dialtone in the room as an audible indicator for existing participants. The `play_ringtone` option is deprectated but has the same effect.
   *
   * @deprecated
   */
  playRingtone: boolean;
  playDialtone: boolean;
  /**
   * By default the From value (Phone number) is used for participant name/identity (if not set) and added to attributes.
   * If true, a random value for identity will be used and numbers will be omitted from attributes.
   */
  hidePhoneNumber: boolean;
  /** These headers are sent as-is and may help identify this call as coming from LiveKit for the other SIP endpoint. */
  headers: { [key: string]: string };
  /**
   * Map SIP headers from 200 OK to sip.h.* participant attributes automatically.
   *
   * When the names of required headers is known, using headers_to_attributes is strongly recommended.
   *
   * When mapping 200 OK headers to follow-up request headers with attributes_to_headers map,
   * lowercase header names should be used, for example: sip.h.x-custom-header.
   */
  includeHeaders: SIPHeaderOptions;
  /** Max time for the callee to answer the call. */
  ringingTimeout:
    | Duration
    | undefined;
  /** Max call duration. */
  maxCallDuration:
    | Duration
    | undefined;
  /** Enable voice isolation for the callee. */
  krispEnabled: boolean;
  mediaEncryption: SIPMediaEncryption;
  /** Wait for the answer for the call before returning. */
  waitUntilAnswered: boolean;
}

export interface CreateSIPParticipantRequest_ParticipantAttributesEntry {
  key: string;
  value: string;
}

export interface CreateSIPParticipantRequest_HeadersEntry {
  key: string;
  value: string;
}

export interface SIPParticipantInfo {
  participantId: string;
  participantIdentity: string;
  roomName: string;
  sipCallId: string;
}

export interface TransferSIPParticipantRequest {
  participantIdentity: string;
  roomName: string;
  transferTo: string;
  /** Optionally play dialtone to the SIP participant as an audible indicator of being transferred */
  playDialtone: boolean;
  /** Add the following headers to the REFER SIP request. */
  headers: { [key: string]: string };
  /** Max time for the transfer destination to answer the call. */
  ringingTimeout: Duration | undefined;
}

export interface TransferSIPParticipantRequest_HeadersEntry {
  key: string;
  value: string;
}

export interface SIPCallInfo {
  callId: string;
  trunkId: string;
  dispatchRuleId: string;
  region: string;
  roomName: string;
  /** ID of the current/previous room published to */
  roomId: string;
  participantIdentity: string;
  participantAttributes: { [key: string]: string };
  fromUri: SIPUri | undefined;
  toUri:
    | SIPUri
    | undefined;
  /** @deprecated */
  createdAt: string;
  /** @deprecated */
  startedAt: string;
  /** @deprecated */
  endedAt: string;
  enabledFeatures: SIPFeature[];
  callDirection: SIPCallDirection;
  callStatus: SIPCallStatus;
  createdAtNs: string;
  startedAtNs: string;
  endedAtNs: string;
  disconnectReason: DisconnectReason;
  error: string;
  callStatusCode: SIPStatus | undefined;
  audioCodec: string;
  mediaEncryption: string;
}

export interface SIPCallInfo_ParticipantAttributesEntry {
  key: string;
  value: string;
}

export interface SIPTransferInfo {
  transferId: string;
  callId: string;
  transferTo: string;
  transferInitiatedAtNs: string;
  transferCompletedAtNs: string;
  transferStatus: SIPTransferStatus;
  error: string;
  transferStatusCode: SIPStatus | undefined;
}

export interface SIPUri {
  user: string;
  host: string;
  ip: string;
  port: number;
  transport: SIPTransport;
}

function createBaseSIPStatus(): SIPStatus {
  return { code: 0, status: "" };
}

export const SIPStatus: MessageFns<SIPStatus> = {
  encode(message: SIPStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.code !== 0) {
      writer.uint32(8).int32(message.code);
    }
    if (message.status !== "") {
      writer.uint32(18).string(message.status);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.code = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.status = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPStatus {
    return {
      code: isSet(object.code) ? sIPStatusCodeFromJSON(object.code) : 0,
      status: isSet(object.status) ? globalThis.String(object.status) : "",
    };
  },

  toJSON(message: SIPStatus): unknown {
    const obj: any = {};
    if (message.code !== 0) {
      obj.code = sIPStatusCodeToJSON(message.code);
    }
    if (message.status !== "") {
      obj.status = message.status;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPStatus>): SIPStatus {
    return SIPStatus.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPStatus>): SIPStatus {
    const message = createBaseSIPStatus();
    message.code = object.code ?? 0;
    message.status = object.status ?? "";
    return message;
  },
};

function createBaseCreateSIPTrunkRequest(): CreateSIPTrunkRequest {
  return {
    inboundAddresses: [],
    outboundAddress: "",
    outboundNumber: "",
    inboundNumbersRegex: [],
    inboundNumbers: [],
    inboundUsername: "",
    inboundPassword: "",
    outboundUsername: "",
    outboundPassword: "",
    name: "",
    metadata: "",
  };
}

export const CreateSIPTrunkRequest: MessageFns<CreateSIPTrunkRequest> = {
  encode(message: CreateSIPTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.inboundAddresses) {
      writer.uint32(10).string(v!);
    }
    if (message.outboundAddress !== "") {
      writer.uint32(18).string(message.outboundAddress);
    }
    if (message.outboundNumber !== "") {
      writer.uint32(26).string(message.outboundNumber);
    }
    for (const v of message.inboundNumbersRegex) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.inboundNumbers) {
      writer.uint32(74).string(v!);
    }
    if (message.inboundUsername !== "") {
      writer.uint32(42).string(message.inboundUsername);
    }
    if (message.inboundPassword !== "") {
      writer.uint32(50).string(message.inboundPassword);
    }
    if (message.outboundUsername !== "") {
      writer.uint32(58).string(message.outboundUsername);
    }
    if (message.outboundPassword !== "") {
      writer.uint32(66).string(message.outboundPassword);
    }
    if (message.name !== "") {
      writer.uint32(82).string(message.name);
    }
    if (message.metadata !== "") {
      writer.uint32(90).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.inboundAddresses.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.outboundAddress = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outboundNumber = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.inboundNumbersRegex.push(reader.string());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.inboundNumbers.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inboundUsername = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inboundPassword = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.outboundUsername = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outboundPassword = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPTrunkRequest {
    return {
      inboundAddresses: globalThis.Array.isArray(object?.inboundAddresses)
        ? object.inboundAddresses.map((e: any) => globalThis.String(e))
        : [],
      outboundAddress: isSet(object.outboundAddress) ? globalThis.String(object.outboundAddress) : "",
      outboundNumber: isSet(object.outboundNumber) ? globalThis.String(object.outboundNumber) : "",
      inboundNumbersRegex: globalThis.Array.isArray(object?.inboundNumbersRegex)
        ? object.inboundNumbersRegex.map((e: any) => globalThis.String(e))
        : [],
      inboundNumbers: globalThis.Array.isArray(object?.inboundNumbers)
        ? object.inboundNumbers.map((e: any) => globalThis.String(e))
        : [],
      inboundUsername: isSet(object.inboundUsername) ? globalThis.String(object.inboundUsername) : "",
      inboundPassword: isSet(object.inboundPassword) ? globalThis.String(object.inboundPassword) : "",
      outboundUsername: isSet(object.outboundUsername) ? globalThis.String(object.outboundUsername) : "",
      outboundPassword: isSet(object.outboundPassword) ? globalThis.String(object.outboundPassword) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
    };
  },

  toJSON(message: CreateSIPTrunkRequest): unknown {
    const obj: any = {};
    if (message.inboundAddresses?.length) {
      obj.inboundAddresses = message.inboundAddresses;
    }
    if (message.outboundAddress !== "") {
      obj.outboundAddress = message.outboundAddress;
    }
    if (message.outboundNumber !== "") {
      obj.outboundNumber = message.outboundNumber;
    }
    if (message.inboundNumbersRegex?.length) {
      obj.inboundNumbersRegex = message.inboundNumbersRegex;
    }
    if (message.inboundNumbers?.length) {
      obj.inboundNumbers = message.inboundNumbers;
    }
    if (message.inboundUsername !== "") {
      obj.inboundUsername = message.inboundUsername;
    }
    if (message.inboundPassword !== "") {
      obj.inboundPassword = message.inboundPassword;
    }
    if (message.outboundUsername !== "") {
      obj.outboundUsername = message.outboundUsername;
    }
    if (message.outboundPassword !== "") {
      obj.outboundPassword = message.outboundPassword;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSIPTrunkRequest>): CreateSIPTrunkRequest {
    return CreateSIPTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSIPTrunkRequest>): CreateSIPTrunkRequest {
    const message = createBaseCreateSIPTrunkRequest();
    message.inboundAddresses = object.inboundAddresses?.map((e) => e) || [];
    message.outboundAddress = object.outboundAddress ?? "";
    message.outboundNumber = object.outboundNumber ?? "";
    message.inboundNumbersRegex = object.inboundNumbersRegex?.map((e) => e) || [];
    message.inboundNumbers = object.inboundNumbers?.map((e) => e) || [];
    message.inboundUsername = object.inboundUsername ?? "";
    message.inboundPassword = object.inboundPassword ?? "";
    message.outboundUsername = object.outboundUsername ?? "";
    message.outboundPassword = object.outboundPassword ?? "";
    message.name = object.name ?? "";
    message.metadata = object.metadata ?? "";
    return message;
  },
};

function createBaseSIPTrunkInfo(): SIPTrunkInfo {
  return {
    sipTrunkId: "",
    kind: 0,
    inboundAddresses: [],
    outboundAddress: "",
    outboundNumber: "",
    transport: 0,
    inboundNumbersRegex: [],
    inboundNumbers: [],
    inboundUsername: "",
    inboundPassword: "",
    outboundUsername: "",
    outboundPassword: "",
    name: "",
    metadata: "",
  };
}

export const SIPTrunkInfo: MessageFns<SIPTrunkInfo> = {
  encode(message: SIPTrunkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    if (message.kind !== 0) {
      writer.uint32(112).int32(message.kind);
    }
    for (const v of message.inboundAddresses) {
      writer.uint32(18).string(v!);
    }
    if (message.outboundAddress !== "") {
      writer.uint32(26).string(message.outboundAddress);
    }
    if (message.outboundNumber !== "") {
      writer.uint32(34).string(message.outboundNumber);
    }
    if (message.transport !== 0) {
      writer.uint32(104).int32(message.transport);
    }
    for (const v of message.inboundNumbersRegex) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.inboundNumbers) {
      writer.uint32(82).string(v!);
    }
    if (message.inboundUsername !== "") {
      writer.uint32(50).string(message.inboundUsername);
    }
    if (message.inboundPassword !== "") {
      writer.uint32(58).string(message.inboundPassword);
    }
    if (message.outboundUsername !== "") {
      writer.uint32(66).string(message.outboundUsername);
    }
    if (message.outboundPassword !== "") {
      writer.uint32(74).string(message.outboundPassword);
    }
    if (message.name !== "") {
      writer.uint32(90).string(message.name);
    }
    if (message.metadata !== "") {
      writer.uint32(98).string(message.metadata);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPTrunkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPTrunkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.kind = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.inboundAddresses.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.outboundAddress = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.outboundNumber = reader.string();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.transport = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.inboundNumbersRegex.push(reader.string());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.inboundNumbers.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inboundUsername = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inboundPassword = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.outboundUsername = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.outboundPassword = reader.string();
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPTrunkInfo {
    return {
      sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "",
      kind: isSet(object.kind) ? sIPTrunkInfo_TrunkKindFromJSON(object.kind) : 0,
      inboundAddresses: globalThis.Array.isArray(object?.inboundAddresses)
        ? object.inboundAddresses.map((e: any) => globalThis.String(e))
        : [],
      outboundAddress: isSet(object.outboundAddress) ? globalThis.String(object.outboundAddress) : "",
      outboundNumber: isSet(object.outboundNumber) ? globalThis.String(object.outboundNumber) : "",
      transport: isSet(object.transport) ? sIPTransportFromJSON(object.transport) : 0,
      inboundNumbersRegex: globalThis.Array.isArray(object?.inboundNumbersRegex)
        ? object.inboundNumbersRegex.map((e: any) => globalThis.String(e))
        : [],
      inboundNumbers: globalThis.Array.isArray(object?.inboundNumbers)
        ? object.inboundNumbers.map((e: any) => globalThis.String(e))
        : [],
      inboundUsername: isSet(object.inboundUsername) ? globalThis.String(object.inboundUsername) : "",
      inboundPassword: isSet(object.inboundPassword) ? globalThis.String(object.inboundPassword) : "",
      outboundUsername: isSet(object.outboundUsername) ? globalThis.String(object.outboundUsername) : "",
      outboundPassword: isSet(object.outboundPassword) ? globalThis.String(object.outboundPassword) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
    };
  },

  toJSON(message: SIPTrunkInfo): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    if (message.kind !== 0) {
      obj.kind = sIPTrunkInfo_TrunkKindToJSON(message.kind);
    }
    if (message.inboundAddresses?.length) {
      obj.inboundAddresses = message.inboundAddresses;
    }
    if (message.outboundAddress !== "") {
      obj.outboundAddress = message.outboundAddress;
    }
    if (message.outboundNumber !== "") {
      obj.outboundNumber = message.outboundNumber;
    }
    if (message.transport !== 0) {
      obj.transport = sIPTransportToJSON(message.transport);
    }
    if (message.inboundNumbersRegex?.length) {
      obj.inboundNumbersRegex = message.inboundNumbersRegex;
    }
    if (message.inboundNumbers?.length) {
      obj.inboundNumbers = message.inboundNumbers;
    }
    if (message.inboundUsername !== "") {
      obj.inboundUsername = message.inboundUsername;
    }
    if (message.inboundPassword !== "") {
      obj.inboundPassword = message.inboundPassword;
    }
    if (message.outboundUsername !== "") {
      obj.outboundUsername = message.outboundUsername;
    }
    if (message.outboundPassword !== "") {
      obj.outboundPassword = message.outboundPassword;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPTrunkInfo>): SIPTrunkInfo {
    return SIPTrunkInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPTrunkInfo>): SIPTrunkInfo {
    const message = createBaseSIPTrunkInfo();
    message.sipTrunkId = object.sipTrunkId ?? "";
    message.kind = object.kind ?? 0;
    message.inboundAddresses = object.inboundAddresses?.map((e) => e) || [];
    message.outboundAddress = object.outboundAddress ?? "";
    message.outboundNumber = object.outboundNumber ?? "";
    message.transport = object.transport ?? 0;
    message.inboundNumbersRegex = object.inboundNumbersRegex?.map((e) => e) || [];
    message.inboundNumbers = object.inboundNumbers?.map((e) => e) || [];
    message.inboundUsername = object.inboundUsername ?? "";
    message.inboundPassword = object.inboundPassword ?? "";
    message.outboundUsername = object.outboundUsername ?? "";
    message.outboundPassword = object.outboundPassword ?? "";
    message.name = object.name ?? "";
    message.metadata = object.metadata ?? "";
    return message;
  },
};

function createBaseCreateSIPInboundTrunkRequest(): CreateSIPInboundTrunkRequest {
  return { trunk: undefined };
}

export const CreateSIPInboundTrunkRequest: MessageFns<CreateSIPInboundTrunkRequest> = {
  encode(message: CreateSIPInboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trunk !== undefined) {
      SIPInboundTrunkInfo.encode(message.trunk, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPInboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPInboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trunk = SIPInboundTrunkInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPInboundTrunkRequest {
    return { trunk: isSet(object.trunk) ? SIPInboundTrunkInfo.fromJSON(object.trunk) : undefined };
  },

  toJSON(message: CreateSIPInboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.trunk !== undefined) {
      obj.trunk = SIPInboundTrunkInfo.toJSON(message.trunk);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSIPInboundTrunkRequest>): CreateSIPInboundTrunkRequest {
    return CreateSIPInboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSIPInboundTrunkRequest>): CreateSIPInboundTrunkRequest {
    const message = createBaseCreateSIPInboundTrunkRequest();
    message.trunk = (object.trunk !== undefined && object.trunk !== null)
      ? SIPInboundTrunkInfo.fromPartial(object.trunk)
      : undefined;
    return message;
  },
};

function createBaseUpdateSIPInboundTrunkRequest(): UpdateSIPInboundTrunkRequest {
  return { sipTrunkId: "", action: undefined };
}

export const UpdateSIPInboundTrunkRequest: MessageFns<UpdateSIPInboundTrunkRequest> = {
  encode(message: UpdateSIPInboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    switch (message.action?.$case) {
      case "replace":
        SIPInboundTrunkInfo.encode(message.action.replace, writer.uint32(18).fork()).join();
        break;
      case "update":
        SIPInboundTrunkUpdate.encode(message.action.update, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSIPInboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSIPInboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = { $case: "replace", replace: SIPInboundTrunkInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = { $case: "update", update: SIPInboundTrunkUpdate.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSIPInboundTrunkRequest {
    return {
      sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "",
      action: isSet(object.replace)
        ? { $case: "replace", replace: SIPInboundTrunkInfo.fromJSON(object.replace) }
        : isSet(object.update)
        ? { $case: "update", update: SIPInboundTrunkUpdate.fromJSON(object.update) }
        : undefined,
    };
  },

  toJSON(message: UpdateSIPInboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    if (message.action?.$case === "replace") {
      obj.replace = SIPInboundTrunkInfo.toJSON(message.action.replace);
    } else if (message.action?.$case === "update") {
      obj.update = SIPInboundTrunkUpdate.toJSON(message.action.update);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSIPInboundTrunkRequest>): UpdateSIPInboundTrunkRequest {
    return UpdateSIPInboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSIPInboundTrunkRequest>): UpdateSIPInboundTrunkRequest {
    const message = createBaseUpdateSIPInboundTrunkRequest();
    message.sipTrunkId = object.sipTrunkId ?? "";
    switch (object.action?.$case) {
      case "replace": {
        if (object.action?.replace !== undefined && object.action?.replace !== null) {
          message.action = { $case: "replace", replace: SIPInboundTrunkInfo.fromPartial(object.action.replace) };
        }
        break;
      }
      case "update": {
        if (object.action?.update !== undefined && object.action?.update !== null) {
          message.action = { $case: "update", update: SIPInboundTrunkUpdate.fromPartial(object.action.update) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSIPInboundTrunkInfo(): SIPInboundTrunkInfo {
  return {
    sipTrunkId: "",
    name: "",
    metadata: "",
    numbers: [],
    allowedAddresses: [],
    allowedNumbers: [],
    authUsername: "",
    authPassword: "",
    headers: {},
    headersToAttributes: {},
    attributesToHeaders: {},
    includeHeaders: 0,
    ringingTimeout: undefined,
    maxCallDuration: undefined,
    krispEnabled: false,
    mediaEncryption: 0,
  };
}

export const SIPInboundTrunkInfo: MessageFns<SIPInboundTrunkInfo> = {
  encode(message: SIPInboundTrunkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.metadata !== "") {
      writer.uint32(26).string(message.metadata);
    }
    for (const v of message.numbers) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.allowedAddresses) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.allowedNumbers) {
      writer.uint32(50).string(v!);
    }
    if (message.authUsername !== "") {
      writer.uint32(58).string(message.authUsername);
    }
    if (message.authPassword !== "") {
      writer.uint32(66).string(message.authPassword);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      SIPInboundTrunkInfo_HeadersEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.headersToAttributes).forEach(([key, value]) => {
      SIPInboundTrunkInfo_HeadersToAttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    Object.entries(message.attributesToHeaders).forEach(([key, value]) => {
      SIPInboundTrunkInfo_AttributesToHeadersEntry.encode({ key: key as any, value }, writer.uint32(114).fork()).join();
    });
    if (message.includeHeaders !== 0) {
      writer.uint32(120).int32(message.includeHeaders);
    }
    if (message.ringingTimeout !== undefined) {
      Duration.encode(message.ringingTimeout, writer.uint32(90).fork()).join();
    }
    if (message.maxCallDuration !== undefined) {
      Duration.encode(message.maxCallDuration, writer.uint32(98).fork()).join();
    }
    if (message.krispEnabled !== false) {
      writer.uint32(104).bool(message.krispEnabled);
    }
    if (message.mediaEncryption !== 0) {
      writer.uint32(128).int32(message.mediaEncryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPInboundTrunkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPInboundTrunkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.numbers.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.allowedAddresses.push(reader.string());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.allowedNumbers.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authUsername = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.authPassword = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = SIPInboundTrunkInfo_HeadersEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.headers[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = SIPInboundTrunkInfo_HeadersToAttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.headersToAttributes[entry10.key] = entry10.value;
          }
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          const entry14 = SIPInboundTrunkInfo_AttributesToHeadersEntry.decode(reader, reader.uint32());
          if (entry14.value !== undefined) {
            message.attributesToHeaders[entry14.key] = entry14.value;
          }
          continue;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.includeHeaders = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ringingTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.maxCallDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.krispEnabled = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 128) {
            break;
          }

          message.mediaEncryption = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPInboundTrunkInfo {
    return {
      sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.String(e)) : [],
      allowedAddresses: globalThis.Array.isArray(object?.allowedAddresses)
        ? object.allowedAddresses.map((e: any) => globalThis.String(e))
        : [],
      allowedNumbers: globalThis.Array.isArray(object?.allowedNumbers)
        ? object.allowedNumbers.map((e: any) => globalThis.String(e))
        : [],
      authUsername: isSet(object.authUsername) ? globalThis.String(object.authUsername) : "",
      authPassword: isSet(object.authPassword) ? globalThis.String(object.authPassword) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      headersToAttributes: isObject(object.headersToAttributes)
        ? Object.entries(object.headersToAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      attributesToHeaders: isObject(object.attributesToHeaders)
        ? Object.entries(object.attributesToHeaders).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      includeHeaders: isSet(object.includeHeaders) ? sIPHeaderOptionsFromJSON(object.includeHeaders) : 0,
      ringingTimeout: isSet(object.ringingTimeout) ? Duration.fromJSON(object.ringingTimeout) : undefined,
      maxCallDuration: isSet(object.maxCallDuration) ? Duration.fromJSON(object.maxCallDuration) : undefined,
      krispEnabled: isSet(object.krispEnabled) ? globalThis.Boolean(object.krispEnabled) : false,
      mediaEncryption: isSet(object.mediaEncryption) ? sIPMediaEncryptionFromJSON(object.mediaEncryption) : 0,
    };
  },

  toJSON(message: SIPInboundTrunkInfo): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.numbers?.length) {
      obj.numbers = message.numbers;
    }
    if (message.allowedAddresses?.length) {
      obj.allowedAddresses = message.allowedAddresses;
    }
    if (message.allowedNumbers?.length) {
      obj.allowedNumbers = message.allowedNumbers;
    }
    if (message.authUsername !== "") {
      obj.authUsername = message.authUsername;
    }
    if (message.authPassword !== "") {
      obj.authPassword = message.authPassword;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.headersToAttributes) {
      const entries = Object.entries(message.headersToAttributes);
      if (entries.length > 0) {
        obj.headersToAttributes = {};
        entries.forEach(([k, v]) => {
          obj.headersToAttributes[k] = v;
        });
      }
    }
    if (message.attributesToHeaders) {
      const entries = Object.entries(message.attributesToHeaders);
      if (entries.length > 0) {
        obj.attributesToHeaders = {};
        entries.forEach(([k, v]) => {
          obj.attributesToHeaders[k] = v;
        });
      }
    }
    if (message.includeHeaders !== 0) {
      obj.includeHeaders = sIPHeaderOptionsToJSON(message.includeHeaders);
    }
    if (message.ringingTimeout !== undefined) {
      obj.ringingTimeout = Duration.toJSON(message.ringingTimeout);
    }
    if (message.maxCallDuration !== undefined) {
      obj.maxCallDuration = Duration.toJSON(message.maxCallDuration);
    }
    if (message.krispEnabled !== false) {
      obj.krispEnabled = message.krispEnabled;
    }
    if (message.mediaEncryption !== 0) {
      obj.mediaEncryption = sIPMediaEncryptionToJSON(message.mediaEncryption);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPInboundTrunkInfo>): SIPInboundTrunkInfo {
    return SIPInboundTrunkInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPInboundTrunkInfo>): SIPInboundTrunkInfo {
    const message = createBaseSIPInboundTrunkInfo();
    message.sipTrunkId = object.sipTrunkId ?? "";
    message.name = object.name ?? "";
    message.metadata = object.metadata ?? "";
    message.numbers = object.numbers?.map((e) => e) || [];
    message.allowedAddresses = object.allowedAddresses?.map((e) => e) || [];
    message.allowedNumbers = object.allowedNumbers?.map((e) => e) || [];
    message.authUsername = object.authUsername ?? "";
    message.authPassword = object.authPassword ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.headersToAttributes = Object.entries(object.headersToAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.attributesToHeaders = Object.entries(object.attributesToHeaders ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.includeHeaders = object.includeHeaders ?? 0;
    message.ringingTimeout = (object.ringingTimeout !== undefined && object.ringingTimeout !== null)
      ? Duration.fromPartial(object.ringingTimeout)
      : undefined;
    message.maxCallDuration = (object.maxCallDuration !== undefined && object.maxCallDuration !== null)
      ? Duration.fromPartial(object.maxCallDuration)
      : undefined;
    message.krispEnabled = object.krispEnabled ?? false;
    message.mediaEncryption = object.mediaEncryption ?? 0;
    return message;
  },
};

function createBaseSIPInboundTrunkInfo_HeadersEntry(): SIPInboundTrunkInfo_HeadersEntry {
  return { key: "", value: "" };
}

export const SIPInboundTrunkInfo_HeadersEntry: MessageFns<SIPInboundTrunkInfo_HeadersEntry> = {
  encode(message: SIPInboundTrunkInfo_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPInboundTrunkInfo_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPInboundTrunkInfo_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPInboundTrunkInfo_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPInboundTrunkInfo_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPInboundTrunkInfo_HeadersEntry>): SIPInboundTrunkInfo_HeadersEntry {
    return SIPInboundTrunkInfo_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPInboundTrunkInfo_HeadersEntry>): SIPInboundTrunkInfo_HeadersEntry {
    const message = createBaseSIPInboundTrunkInfo_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPInboundTrunkInfo_HeadersToAttributesEntry(): SIPInboundTrunkInfo_HeadersToAttributesEntry {
  return { key: "", value: "" };
}

export const SIPInboundTrunkInfo_HeadersToAttributesEntry: MessageFns<SIPInboundTrunkInfo_HeadersToAttributesEntry> = {
  encode(
    message: SIPInboundTrunkInfo_HeadersToAttributesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPInboundTrunkInfo_HeadersToAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPInboundTrunkInfo_HeadersToAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPInboundTrunkInfo_HeadersToAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPInboundTrunkInfo_HeadersToAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SIPInboundTrunkInfo_HeadersToAttributesEntry>,
  ): SIPInboundTrunkInfo_HeadersToAttributesEntry {
    return SIPInboundTrunkInfo_HeadersToAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SIPInboundTrunkInfo_HeadersToAttributesEntry>,
  ): SIPInboundTrunkInfo_HeadersToAttributesEntry {
    const message = createBaseSIPInboundTrunkInfo_HeadersToAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPInboundTrunkInfo_AttributesToHeadersEntry(): SIPInboundTrunkInfo_AttributesToHeadersEntry {
  return { key: "", value: "" };
}

export const SIPInboundTrunkInfo_AttributesToHeadersEntry: MessageFns<SIPInboundTrunkInfo_AttributesToHeadersEntry> = {
  encode(
    message: SIPInboundTrunkInfo_AttributesToHeadersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPInboundTrunkInfo_AttributesToHeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPInboundTrunkInfo_AttributesToHeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPInboundTrunkInfo_AttributesToHeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPInboundTrunkInfo_AttributesToHeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<SIPInboundTrunkInfo_AttributesToHeadersEntry>,
  ): SIPInboundTrunkInfo_AttributesToHeadersEntry {
    return SIPInboundTrunkInfo_AttributesToHeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SIPInboundTrunkInfo_AttributesToHeadersEntry>,
  ): SIPInboundTrunkInfo_AttributesToHeadersEntry {
    const message = createBaseSIPInboundTrunkInfo_AttributesToHeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPInboundTrunkUpdate(): SIPInboundTrunkUpdate {
  return {
    numbers: undefined,
    allowedAddresses: undefined,
    allowedNumbers: undefined,
    authUsername: undefined,
    authPassword: undefined,
    name: undefined,
    metadata: undefined,
    mediaEncryption: undefined,
  };
}

export const SIPInboundTrunkUpdate: MessageFns<SIPInboundTrunkUpdate> = {
  encode(message: SIPInboundTrunkUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.numbers !== undefined) {
      ListUpdate.encode(message.numbers, writer.uint32(10).fork()).join();
    }
    if (message.allowedAddresses !== undefined) {
      ListUpdate.encode(message.allowedAddresses, writer.uint32(18).fork()).join();
    }
    if (message.allowedNumbers !== undefined) {
      ListUpdate.encode(message.allowedNumbers, writer.uint32(26).fork()).join();
    }
    if (message.authUsername !== undefined) {
      writer.uint32(34).string(message.authUsername);
    }
    if (message.authPassword !== undefined) {
      writer.uint32(42).string(message.authPassword);
    }
    if (message.name !== undefined) {
      writer.uint32(50).string(message.name);
    }
    if (message.metadata !== undefined) {
      writer.uint32(58).string(message.metadata);
    }
    if (message.mediaEncryption !== undefined) {
      writer.uint32(64).int32(message.mediaEncryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPInboundTrunkUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPInboundTrunkUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.numbers = ListUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.allowedAddresses = ListUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.allowedNumbers = ListUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authUsername = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authPassword = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.mediaEncryption = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPInboundTrunkUpdate {
    return {
      numbers: isSet(object.numbers) ? ListUpdate.fromJSON(object.numbers) : undefined,
      allowedAddresses: isSet(object.allowedAddresses) ? ListUpdate.fromJSON(object.allowedAddresses) : undefined,
      allowedNumbers: isSet(object.allowedNumbers) ? ListUpdate.fromJSON(object.allowedNumbers) : undefined,
      authUsername: isSet(object.authUsername) ? globalThis.String(object.authUsername) : undefined,
      authPassword: isSet(object.authPassword) ? globalThis.String(object.authPassword) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : undefined,
      mediaEncryption: isSet(object.mediaEncryption) ? sIPMediaEncryptionFromJSON(object.mediaEncryption) : undefined,
    };
  },

  toJSON(message: SIPInboundTrunkUpdate): unknown {
    const obj: any = {};
    if (message.numbers !== undefined) {
      obj.numbers = ListUpdate.toJSON(message.numbers);
    }
    if (message.allowedAddresses !== undefined) {
      obj.allowedAddresses = ListUpdate.toJSON(message.allowedAddresses);
    }
    if (message.allowedNumbers !== undefined) {
      obj.allowedNumbers = ListUpdate.toJSON(message.allowedNumbers);
    }
    if (message.authUsername !== undefined) {
      obj.authUsername = message.authUsername;
    }
    if (message.authPassword !== undefined) {
      obj.authPassword = message.authPassword;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.mediaEncryption !== undefined) {
      obj.mediaEncryption = sIPMediaEncryptionToJSON(message.mediaEncryption);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPInboundTrunkUpdate>): SIPInboundTrunkUpdate {
    return SIPInboundTrunkUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPInboundTrunkUpdate>): SIPInboundTrunkUpdate {
    const message = createBaseSIPInboundTrunkUpdate();
    message.numbers = (object.numbers !== undefined && object.numbers !== null)
      ? ListUpdate.fromPartial(object.numbers)
      : undefined;
    message.allowedAddresses = (object.allowedAddresses !== undefined && object.allowedAddresses !== null)
      ? ListUpdate.fromPartial(object.allowedAddresses)
      : undefined;
    message.allowedNumbers = (object.allowedNumbers !== undefined && object.allowedNumbers !== null)
      ? ListUpdate.fromPartial(object.allowedNumbers)
      : undefined;
    message.authUsername = object.authUsername ?? undefined;
    message.authPassword = object.authPassword ?? undefined;
    message.name = object.name ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.mediaEncryption = object.mediaEncryption ?? undefined;
    return message;
  },
};

function createBaseCreateSIPOutboundTrunkRequest(): CreateSIPOutboundTrunkRequest {
  return { trunk: undefined };
}

export const CreateSIPOutboundTrunkRequest: MessageFns<CreateSIPOutboundTrunkRequest> = {
  encode(message: CreateSIPOutboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trunk !== undefined) {
      SIPOutboundTrunkInfo.encode(message.trunk, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPOutboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPOutboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trunk = SIPOutboundTrunkInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPOutboundTrunkRequest {
    return { trunk: isSet(object.trunk) ? SIPOutboundTrunkInfo.fromJSON(object.trunk) : undefined };
  },

  toJSON(message: CreateSIPOutboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.trunk !== undefined) {
      obj.trunk = SIPOutboundTrunkInfo.toJSON(message.trunk);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSIPOutboundTrunkRequest>): CreateSIPOutboundTrunkRequest {
    return CreateSIPOutboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSIPOutboundTrunkRequest>): CreateSIPOutboundTrunkRequest {
    const message = createBaseCreateSIPOutboundTrunkRequest();
    message.trunk = (object.trunk !== undefined && object.trunk !== null)
      ? SIPOutboundTrunkInfo.fromPartial(object.trunk)
      : undefined;
    return message;
  },
};

function createBaseUpdateSIPOutboundTrunkRequest(): UpdateSIPOutboundTrunkRequest {
  return { sipTrunkId: "", action: undefined };
}

export const UpdateSIPOutboundTrunkRequest: MessageFns<UpdateSIPOutboundTrunkRequest> = {
  encode(message: UpdateSIPOutboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    switch (message.action?.$case) {
      case "replace":
        SIPOutboundTrunkInfo.encode(message.action.replace, writer.uint32(18).fork()).join();
        break;
      case "update":
        SIPOutboundTrunkUpdate.encode(message.action.update, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSIPOutboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSIPOutboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = { $case: "replace", replace: SIPOutboundTrunkInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = { $case: "update", update: SIPOutboundTrunkUpdate.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSIPOutboundTrunkRequest {
    return {
      sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "",
      action: isSet(object.replace)
        ? { $case: "replace", replace: SIPOutboundTrunkInfo.fromJSON(object.replace) }
        : isSet(object.update)
        ? { $case: "update", update: SIPOutboundTrunkUpdate.fromJSON(object.update) }
        : undefined,
    };
  },

  toJSON(message: UpdateSIPOutboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    if (message.action?.$case === "replace") {
      obj.replace = SIPOutboundTrunkInfo.toJSON(message.action.replace);
    } else if (message.action?.$case === "update") {
      obj.update = SIPOutboundTrunkUpdate.toJSON(message.action.update);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSIPOutboundTrunkRequest>): UpdateSIPOutboundTrunkRequest {
    return UpdateSIPOutboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSIPOutboundTrunkRequest>): UpdateSIPOutboundTrunkRequest {
    const message = createBaseUpdateSIPOutboundTrunkRequest();
    message.sipTrunkId = object.sipTrunkId ?? "";
    switch (object.action?.$case) {
      case "replace": {
        if (object.action?.replace !== undefined && object.action?.replace !== null) {
          message.action = { $case: "replace", replace: SIPOutboundTrunkInfo.fromPartial(object.action.replace) };
        }
        break;
      }
      case "update": {
        if (object.action?.update !== undefined && object.action?.update !== null) {
          message.action = { $case: "update", update: SIPOutboundTrunkUpdate.fromPartial(object.action.update) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSIPOutboundTrunkInfo(): SIPOutboundTrunkInfo {
  return {
    sipTrunkId: "",
    name: "",
    metadata: "",
    address: "",
    destinationCountry: "",
    transport: 0,
    numbers: [],
    authUsername: "",
    authPassword: "",
    headers: {},
    headersToAttributes: {},
    attributesToHeaders: {},
    includeHeaders: 0,
    mediaEncryption: 0,
  };
}

export const SIPOutboundTrunkInfo: MessageFns<SIPOutboundTrunkInfo> = {
  encode(message: SIPOutboundTrunkInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.metadata !== "") {
      writer.uint32(26).string(message.metadata);
    }
    if (message.address !== "") {
      writer.uint32(34).string(message.address);
    }
    if (message.destinationCountry !== "") {
      writer.uint32(114).string(message.destinationCountry);
    }
    if (message.transport !== 0) {
      writer.uint32(40).int32(message.transport);
    }
    for (const v of message.numbers) {
      writer.uint32(50).string(v!);
    }
    if (message.authUsername !== "") {
      writer.uint32(58).string(message.authUsername);
    }
    if (message.authPassword !== "") {
      writer.uint32(66).string(message.authPassword);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      SIPOutboundTrunkInfo_HeadersEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    Object.entries(message.headersToAttributes).forEach(([key, value]) => {
      SIPOutboundTrunkInfo_HeadersToAttributesEntry.encode({ key: key as any, value }, writer.uint32(82).fork()).join();
    });
    Object.entries(message.attributesToHeaders).forEach(([key, value]) => {
      SIPOutboundTrunkInfo_AttributesToHeadersEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.includeHeaders !== 0) {
      writer.uint32(96).int32(message.includeHeaders);
    }
    if (message.mediaEncryption !== 0) {
      writer.uint32(104).int32(message.mediaEncryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundTrunkInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPOutboundTrunkInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 14: {
          if (tag !== 114) {
            break;
          }

          message.destinationCountry = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.transport = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.numbers.push(reader.string());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.authUsername = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.authPassword = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = SIPOutboundTrunkInfo_HeadersEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.headers[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          const entry10 = SIPOutboundTrunkInfo_HeadersToAttributesEntry.decode(reader, reader.uint32());
          if (entry10.value !== undefined) {
            message.headersToAttributes[entry10.key] = entry10.value;
          }
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = SIPOutboundTrunkInfo_AttributesToHeadersEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.attributesToHeaders[entry11.key] = entry11.value;
          }
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.includeHeaders = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.mediaEncryption = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPOutboundTrunkInfo {
    return {
      sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      destinationCountry: isSet(object.destinationCountry) ? globalThis.String(object.destinationCountry) : "",
      transport: isSet(object.transport) ? sIPTransportFromJSON(object.transport) : 0,
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.String(e)) : [],
      authUsername: isSet(object.authUsername) ? globalThis.String(object.authUsername) : "",
      authPassword: isSet(object.authPassword) ? globalThis.String(object.authPassword) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      headersToAttributes: isObject(object.headersToAttributes)
        ? Object.entries(object.headersToAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      attributesToHeaders: isObject(object.attributesToHeaders)
        ? Object.entries(object.attributesToHeaders).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      includeHeaders: isSet(object.includeHeaders) ? sIPHeaderOptionsFromJSON(object.includeHeaders) : 0,
      mediaEncryption: isSet(object.mediaEncryption) ? sIPMediaEncryptionFromJSON(object.mediaEncryption) : 0,
    };
  },

  toJSON(message: SIPOutboundTrunkInfo): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.destinationCountry !== "") {
      obj.destinationCountry = message.destinationCountry;
    }
    if (message.transport !== 0) {
      obj.transport = sIPTransportToJSON(message.transport);
    }
    if (message.numbers?.length) {
      obj.numbers = message.numbers;
    }
    if (message.authUsername !== "") {
      obj.authUsername = message.authUsername;
    }
    if (message.authPassword !== "") {
      obj.authPassword = message.authPassword;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.headersToAttributes) {
      const entries = Object.entries(message.headersToAttributes);
      if (entries.length > 0) {
        obj.headersToAttributes = {};
        entries.forEach(([k, v]) => {
          obj.headersToAttributes[k] = v;
        });
      }
    }
    if (message.attributesToHeaders) {
      const entries = Object.entries(message.attributesToHeaders);
      if (entries.length > 0) {
        obj.attributesToHeaders = {};
        entries.forEach(([k, v]) => {
          obj.attributesToHeaders[k] = v;
        });
      }
    }
    if (message.includeHeaders !== 0) {
      obj.includeHeaders = sIPHeaderOptionsToJSON(message.includeHeaders);
    }
    if (message.mediaEncryption !== 0) {
      obj.mediaEncryption = sIPMediaEncryptionToJSON(message.mediaEncryption);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPOutboundTrunkInfo>): SIPOutboundTrunkInfo {
    return SIPOutboundTrunkInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPOutboundTrunkInfo>): SIPOutboundTrunkInfo {
    const message = createBaseSIPOutboundTrunkInfo();
    message.sipTrunkId = object.sipTrunkId ?? "";
    message.name = object.name ?? "";
    message.metadata = object.metadata ?? "";
    message.address = object.address ?? "";
    message.destinationCountry = object.destinationCountry ?? "";
    message.transport = object.transport ?? 0;
    message.numbers = object.numbers?.map((e) => e) || [];
    message.authUsername = object.authUsername ?? "";
    message.authPassword = object.authPassword ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.headersToAttributes = Object.entries(object.headersToAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.attributesToHeaders = Object.entries(object.attributesToHeaders ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.includeHeaders = object.includeHeaders ?? 0;
    message.mediaEncryption = object.mediaEncryption ?? 0;
    return message;
  },
};

function createBaseSIPOutboundTrunkInfo_HeadersEntry(): SIPOutboundTrunkInfo_HeadersEntry {
  return { key: "", value: "" };
}

export const SIPOutboundTrunkInfo_HeadersEntry: MessageFns<SIPOutboundTrunkInfo_HeadersEntry> = {
  encode(message: SIPOutboundTrunkInfo_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundTrunkInfo_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPOutboundTrunkInfo_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPOutboundTrunkInfo_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPOutboundTrunkInfo_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPOutboundTrunkInfo_HeadersEntry>): SIPOutboundTrunkInfo_HeadersEntry {
    return SIPOutboundTrunkInfo_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPOutboundTrunkInfo_HeadersEntry>): SIPOutboundTrunkInfo_HeadersEntry {
    const message = createBaseSIPOutboundTrunkInfo_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPOutboundTrunkInfo_HeadersToAttributesEntry(): SIPOutboundTrunkInfo_HeadersToAttributesEntry {
  return { key: "", value: "" };
}

export const SIPOutboundTrunkInfo_HeadersToAttributesEntry: MessageFns<SIPOutboundTrunkInfo_HeadersToAttributesEntry> =
  {
    encode(
      message: SIPOutboundTrunkInfo_HeadersToAttributesEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundTrunkInfo_HeadersToAttributesEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSIPOutboundTrunkInfo_HeadersToAttributesEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SIPOutboundTrunkInfo_HeadersToAttributesEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: SIPOutboundTrunkInfo_HeadersToAttributesEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create(
      base?: DeepPartial<SIPOutboundTrunkInfo_HeadersToAttributesEntry>,
    ): SIPOutboundTrunkInfo_HeadersToAttributesEntry {
      return SIPOutboundTrunkInfo_HeadersToAttributesEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SIPOutboundTrunkInfo_HeadersToAttributesEntry>,
    ): SIPOutboundTrunkInfo_HeadersToAttributesEntry {
      const message = createBaseSIPOutboundTrunkInfo_HeadersToAttributesEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseSIPOutboundTrunkInfo_AttributesToHeadersEntry(): SIPOutboundTrunkInfo_AttributesToHeadersEntry {
  return { key: "", value: "" };
}

export const SIPOutboundTrunkInfo_AttributesToHeadersEntry: MessageFns<SIPOutboundTrunkInfo_AttributesToHeadersEntry> =
  {
    encode(
      message: SIPOutboundTrunkInfo_AttributesToHeadersEntry,
      writer: BinaryWriter = new BinaryWriter(),
    ): BinaryWriter {
      if (message.key !== "") {
        writer.uint32(10).string(message.key);
      }
      if (message.value !== "") {
        writer.uint32(18).string(message.value);
      }
      return writer;
    },

    decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundTrunkInfo_AttributesToHeadersEntry {
      const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
      let end = length === undefined ? reader.len : reader.pos + length;
      const message = createBaseSIPOutboundTrunkInfo_AttributesToHeadersEntry();
      while (reader.pos < end) {
        const tag = reader.uint32();
        switch (tag >>> 3) {
          case 1: {
            if (tag !== 10) {
              break;
            }

            message.key = reader.string();
            continue;
          }
          case 2: {
            if (tag !== 18) {
              break;
            }

            message.value = reader.string();
            continue;
          }
        }
        if ((tag & 7) === 4 || tag === 0) {
          break;
        }
        reader.skip(tag & 7);
      }
      return message;
    },

    fromJSON(object: any): SIPOutboundTrunkInfo_AttributesToHeadersEntry {
      return {
        key: isSet(object.key) ? globalThis.String(object.key) : "",
        value: isSet(object.value) ? globalThis.String(object.value) : "",
      };
    },

    toJSON(message: SIPOutboundTrunkInfo_AttributesToHeadersEntry): unknown {
      const obj: any = {};
      if (message.key !== "") {
        obj.key = message.key;
      }
      if (message.value !== "") {
        obj.value = message.value;
      }
      return obj;
    },

    create(
      base?: DeepPartial<SIPOutboundTrunkInfo_AttributesToHeadersEntry>,
    ): SIPOutboundTrunkInfo_AttributesToHeadersEntry {
      return SIPOutboundTrunkInfo_AttributesToHeadersEntry.fromPartial(base ?? {});
    },
    fromPartial(
      object: DeepPartial<SIPOutboundTrunkInfo_AttributesToHeadersEntry>,
    ): SIPOutboundTrunkInfo_AttributesToHeadersEntry {
      const message = createBaseSIPOutboundTrunkInfo_AttributesToHeadersEntry();
      message.key = object.key ?? "";
      message.value = object.value ?? "";
      return message;
    },
  };

function createBaseSIPOutboundTrunkUpdate(): SIPOutboundTrunkUpdate {
  return {
    address: undefined,
    transport: undefined,
    destinationCountry: undefined,
    numbers: undefined,
    authUsername: undefined,
    authPassword: undefined,
    name: undefined,
    metadata: undefined,
    mediaEncryption: undefined,
  };
}

export const SIPOutboundTrunkUpdate: MessageFns<SIPOutboundTrunkUpdate> = {
  encode(message: SIPOutboundTrunkUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.address !== undefined) {
      writer.uint32(10).string(message.address);
    }
    if (message.transport !== undefined) {
      writer.uint32(16).int32(message.transport);
    }
    if (message.destinationCountry !== undefined) {
      writer.uint32(74).string(message.destinationCountry);
    }
    if (message.numbers !== undefined) {
      ListUpdate.encode(message.numbers, writer.uint32(26).fork()).join();
    }
    if (message.authUsername !== undefined) {
      writer.uint32(34).string(message.authUsername);
    }
    if (message.authPassword !== undefined) {
      writer.uint32(42).string(message.authPassword);
    }
    if (message.name !== undefined) {
      writer.uint32(50).string(message.name);
    }
    if (message.metadata !== undefined) {
      writer.uint32(58).string(message.metadata);
    }
    if (message.mediaEncryption !== undefined) {
      writer.uint32(64).int32(message.mediaEncryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundTrunkUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPOutboundTrunkUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transport = reader.int32() as any;
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.destinationCountry = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.numbers = ListUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authUsername = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.authPassword = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.mediaEncryption = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPOutboundTrunkUpdate {
    return {
      address: isSet(object.address) ? globalThis.String(object.address) : undefined,
      transport: isSet(object.transport) ? sIPTransportFromJSON(object.transport) : undefined,
      destinationCountry: isSet(object.destinationCountry) ? globalThis.String(object.destinationCountry) : undefined,
      numbers: isSet(object.numbers) ? ListUpdate.fromJSON(object.numbers) : undefined,
      authUsername: isSet(object.authUsername) ? globalThis.String(object.authUsername) : undefined,
      authPassword: isSet(object.authPassword) ? globalThis.String(object.authPassword) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : undefined,
      mediaEncryption: isSet(object.mediaEncryption) ? sIPMediaEncryptionFromJSON(object.mediaEncryption) : undefined,
    };
  },

  toJSON(message: SIPOutboundTrunkUpdate): unknown {
    const obj: any = {};
    if (message.address !== undefined) {
      obj.address = message.address;
    }
    if (message.transport !== undefined) {
      obj.transport = sIPTransportToJSON(message.transport);
    }
    if (message.destinationCountry !== undefined) {
      obj.destinationCountry = message.destinationCountry;
    }
    if (message.numbers !== undefined) {
      obj.numbers = ListUpdate.toJSON(message.numbers);
    }
    if (message.authUsername !== undefined) {
      obj.authUsername = message.authUsername;
    }
    if (message.authPassword !== undefined) {
      obj.authPassword = message.authPassword;
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.mediaEncryption !== undefined) {
      obj.mediaEncryption = sIPMediaEncryptionToJSON(message.mediaEncryption);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPOutboundTrunkUpdate>): SIPOutboundTrunkUpdate {
    return SIPOutboundTrunkUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPOutboundTrunkUpdate>): SIPOutboundTrunkUpdate {
    const message = createBaseSIPOutboundTrunkUpdate();
    message.address = object.address ?? undefined;
    message.transport = object.transport ?? undefined;
    message.destinationCountry = object.destinationCountry ?? undefined;
    message.numbers = (object.numbers !== undefined && object.numbers !== null)
      ? ListUpdate.fromPartial(object.numbers)
      : undefined;
    message.authUsername = object.authUsername ?? undefined;
    message.authPassword = object.authPassword ?? undefined;
    message.name = object.name ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.mediaEncryption = object.mediaEncryption ?? undefined;
    return message;
  },
};

function createBaseGetSIPInboundTrunkRequest(): GetSIPInboundTrunkRequest {
  return { sipTrunkId: "" };
}

export const GetSIPInboundTrunkRequest: MessageFns<GetSIPInboundTrunkRequest> = {
  encode(message: GetSIPInboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSIPInboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSIPInboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSIPInboundTrunkRequest {
    return { sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "" };
  },

  toJSON(message: GetSIPInboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSIPInboundTrunkRequest>): GetSIPInboundTrunkRequest {
    return GetSIPInboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSIPInboundTrunkRequest>): GetSIPInboundTrunkRequest {
    const message = createBaseGetSIPInboundTrunkRequest();
    message.sipTrunkId = object.sipTrunkId ?? "";
    return message;
  },
};

function createBaseGetSIPInboundTrunkResponse(): GetSIPInboundTrunkResponse {
  return { trunk: undefined };
}

export const GetSIPInboundTrunkResponse: MessageFns<GetSIPInboundTrunkResponse> = {
  encode(message: GetSIPInboundTrunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trunk !== undefined) {
      SIPInboundTrunkInfo.encode(message.trunk, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSIPInboundTrunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSIPInboundTrunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trunk = SIPInboundTrunkInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSIPInboundTrunkResponse {
    return { trunk: isSet(object.trunk) ? SIPInboundTrunkInfo.fromJSON(object.trunk) : undefined };
  },

  toJSON(message: GetSIPInboundTrunkResponse): unknown {
    const obj: any = {};
    if (message.trunk !== undefined) {
      obj.trunk = SIPInboundTrunkInfo.toJSON(message.trunk);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSIPInboundTrunkResponse>): GetSIPInboundTrunkResponse {
    return GetSIPInboundTrunkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSIPInboundTrunkResponse>): GetSIPInboundTrunkResponse {
    const message = createBaseGetSIPInboundTrunkResponse();
    message.trunk = (object.trunk !== undefined && object.trunk !== null)
      ? SIPInboundTrunkInfo.fromPartial(object.trunk)
      : undefined;
    return message;
  },
};

function createBaseGetSIPOutboundTrunkRequest(): GetSIPOutboundTrunkRequest {
  return { sipTrunkId: "" };
}

export const GetSIPOutboundTrunkRequest: MessageFns<GetSIPOutboundTrunkRequest> = {
  encode(message: GetSIPOutboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSIPOutboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSIPOutboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSIPOutboundTrunkRequest {
    return { sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "" };
  },

  toJSON(message: GetSIPOutboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSIPOutboundTrunkRequest>): GetSIPOutboundTrunkRequest {
    return GetSIPOutboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSIPOutboundTrunkRequest>): GetSIPOutboundTrunkRequest {
    const message = createBaseGetSIPOutboundTrunkRequest();
    message.sipTrunkId = object.sipTrunkId ?? "";
    return message;
  },
};

function createBaseGetSIPOutboundTrunkResponse(): GetSIPOutboundTrunkResponse {
  return { trunk: undefined };
}

export const GetSIPOutboundTrunkResponse: MessageFns<GetSIPOutboundTrunkResponse> = {
  encode(message: GetSIPOutboundTrunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trunk !== undefined) {
      SIPOutboundTrunkInfo.encode(message.trunk, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSIPOutboundTrunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSIPOutboundTrunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trunk = SIPOutboundTrunkInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSIPOutboundTrunkResponse {
    return { trunk: isSet(object.trunk) ? SIPOutboundTrunkInfo.fromJSON(object.trunk) : undefined };
  },

  toJSON(message: GetSIPOutboundTrunkResponse): unknown {
    const obj: any = {};
    if (message.trunk !== undefined) {
      obj.trunk = SIPOutboundTrunkInfo.toJSON(message.trunk);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSIPOutboundTrunkResponse>): GetSIPOutboundTrunkResponse {
    return GetSIPOutboundTrunkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSIPOutboundTrunkResponse>): GetSIPOutboundTrunkResponse {
    const message = createBaseGetSIPOutboundTrunkResponse();
    message.trunk = (object.trunk !== undefined && object.trunk !== null)
      ? SIPOutboundTrunkInfo.fromPartial(object.trunk)
      : undefined;
    return message;
  },
};

function createBaseListSIPTrunkRequest(): ListSIPTrunkRequest {
  return { page: undefined };
}

export const ListSIPTrunkRequest: MessageFns<ListSIPTrunkRequest> = {
  encode(message: ListSIPTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      Pagination.encode(message.page, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.page = Pagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPTrunkRequest {
    return { page: isSet(object.page) ? Pagination.fromJSON(object.page) : undefined };
  },

  toJSON(message: ListSIPTrunkRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = Pagination.toJSON(message.page);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPTrunkRequest>): ListSIPTrunkRequest {
    return ListSIPTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPTrunkRequest>): ListSIPTrunkRequest {
    const message = createBaseListSIPTrunkRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? Pagination.fromPartial(object.page)
      : undefined;
    return message;
  },
};

function createBaseListSIPTrunkResponse(): ListSIPTrunkResponse {
  return { items: [] };
}

export const ListSIPTrunkResponse: MessageFns<ListSIPTrunkResponse> = {
  encode(message: ListSIPTrunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      SIPTrunkInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPTrunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPTrunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(SIPTrunkInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPTrunkResponse {
    return {
      items: globalThis.Array.isArray(object?.items) ? object.items.map((e: any) => SIPTrunkInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListSIPTrunkResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SIPTrunkInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPTrunkResponse>): ListSIPTrunkResponse {
    return ListSIPTrunkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPTrunkResponse>): ListSIPTrunkResponse {
    const message = createBaseListSIPTrunkResponse();
    message.items = object.items?.map((e) => SIPTrunkInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSIPInboundTrunkRequest(): ListSIPInboundTrunkRequest {
  return { page: undefined, trunkIds: [], numbers: [] };
}

export const ListSIPInboundTrunkRequest: MessageFns<ListSIPInboundTrunkRequest> = {
  encode(message: ListSIPInboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      Pagination.encode(message.page, writer.uint32(26).fork()).join();
    }
    for (const v of message.trunkIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.numbers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPInboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPInboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.page = Pagination.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trunkIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.numbers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPInboundTrunkRequest {
    return {
      page: isSet(object.page) ? Pagination.fromJSON(object.page) : undefined,
      trunkIds: globalThis.Array.isArray(object?.trunkIds) ? object.trunkIds.map((e: any) => globalThis.String(e)) : [],
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListSIPInboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = Pagination.toJSON(message.page);
    }
    if (message.trunkIds?.length) {
      obj.trunkIds = message.trunkIds;
    }
    if (message.numbers?.length) {
      obj.numbers = message.numbers;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPInboundTrunkRequest>): ListSIPInboundTrunkRequest {
    return ListSIPInboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPInboundTrunkRequest>): ListSIPInboundTrunkRequest {
    const message = createBaseListSIPInboundTrunkRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? Pagination.fromPartial(object.page)
      : undefined;
    message.trunkIds = object.trunkIds?.map((e) => e) || [];
    message.numbers = object.numbers?.map((e) => e) || [];
    return message;
  },
};

function createBaseListSIPInboundTrunkResponse(): ListSIPInboundTrunkResponse {
  return { items: [] };
}

export const ListSIPInboundTrunkResponse: MessageFns<ListSIPInboundTrunkResponse> = {
  encode(message: ListSIPInboundTrunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      SIPInboundTrunkInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPInboundTrunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPInboundTrunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(SIPInboundTrunkInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPInboundTrunkResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => SIPInboundTrunkInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSIPInboundTrunkResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SIPInboundTrunkInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPInboundTrunkResponse>): ListSIPInboundTrunkResponse {
    return ListSIPInboundTrunkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPInboundTrunkResponse>): ListSIPInboundTrunkResponse {
    const message = createBaseListSIPInboundTrunkResponse();
    message.items = object.items?.map((e) => SIPInboundTrunkInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSIPOutboundTrunkRequest(): ListSIPOutboundTrunkRequest {
  return { page: undefined, trunkIds: [], numbers: [] };
}

export const ListSIPOutboundTrunkRequest: MessageFns<ListSIPOutboundTrunkRequest> = {
  encode(message: ListSIPOutboundTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      Pagination.encode(message.page, writer.uint32(26).fork()).join();
    }
    for (const v of message.trunkIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.numbers) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPOutboundTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPOutboundTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.page = Pagination.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trunkIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.numbers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPOutboundTrunkRequest {
    return {
      page: isSet(object.page) ? Pagination.fromJSON(object.page) : undefined,
      trunkIds: globalThis.Array.isArray(object?.trunkIds) ? object.trunkIds.map((e: any) => globalThis.String(e)) : [],
      numbers: globalThis.Array.isArray(object?.numbers) ? object.numbers.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListSIPOutboundTrunkRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = Pagination.toJSON(message.page);
    }
    if (message.trunkIds?.length) {
      obj.trunkIds = message.trunkIds;
    }
    if (message.numbers?.length) {
      obj.numbers = message.numbers;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPOutboundTrunkRequest>): ListSIPOutboundTrunkRequest {
    return ListSIPOutboundTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPOutboundTrunkRequest>): ListSIPOutboundTrunkRequest {
    const message = createBaseListSIPOutboundTrunkRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? Pagination.fromPartial(object.page)
      : undefined;
    message.trunkIds = object.trunkIds?.map((e) => e) || [];
    message.numbers = object.numbers?.map((e) => e) || [];
    return message;
  },
};

function createBaseListSIPOutboundTrunkResponse(): ListSIPOutboundTrunkResponse {
  return { items: [] };
}

export const ListSIPOutboundTrunkResponse: MessageFns<ListSIPOutboundTrunkResponse> = {
  encode(message: ListSIPOutboundTrunkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      SIPOutboundTrunkInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPOutboundTrunkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPOutboundTrunkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(SIPOutboundTrunkInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPOutboundTrunkResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => SIPOutboundTrunkInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSIPOutboundTrunkResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SIPOutboundTrunkInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPOutboundTrunkResponse>): ListSIPOutboundTrunkResponse {
    return ListSIPOutboundTrunkResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPOutboundTrunkResponse>): ListSIPOutboundTrunkResponse {
    const message = createBaseListSIPOutboundTrunkResponse();
    message.items = object.items?.map((e) => SIPOutboundTrunkInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteSIPTrunkRequest(): DeleteSIPTrunkRequest {
  return { sipTrunkId: "" };
}

export const DeleteSIPTrunkRequest: MessageFns<DeleteSIPTrunkRequest> = {
  encode(message: DeleteSIPTrunkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSIPTrunkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSIPTrunkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSIPTrunkRequest {
    return { sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "" };
  },

  toJSON(message: DeleteSIPTrunkRequest): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSIPTrunkRequest>): DeleteSIPTrunkRequest {
    return DeleteSIPTrunkRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSIPTrunkRequest>): DeleteSIPTrunkRequest {
    const message = createBaseDeleteSIPTrunkRequest();
    message.sipTrunkId = object.sipTrunkId ?? "";
    return message;
  },
};

function createBaseSIPDispatchRuleDirect(): SIPDispatchRuleDirect {
  return { roomName: "", pin: "" };
}

export const SIPDispatchRuleDirect: MessageFns<SIPDispatchRuleDirect> = {
  encode(message: SIPDispatchRuleDirect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomName !== "") {
      writer.uint32(10).string(message.roomName);
    }
    if (message.pin !== "") {
      writer.uint32(18).string(message.pin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRuleDirect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRuleDirect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRuleDirect {
    return {
      roomName: isSet(object.roomName) ? globalThis.String(object.roomName) : "",
      pin: isSet(object.pin) ? globalThis.String(object.pin) : "",
    };
  },

  toJSON(message: SIPDispatchRuleDirect): unknown {
    const obj: any = {};
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.pin !== "") {
      obj.pin = message.pin;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRuleDirect>): SIPDispatchRuleDirect {
    return SIPDispatchRuleDirect.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRuleDirect>): SIPDispatchRuleDirect {
    const message = createBaseSIPDispatchRuleDirect();
    message.roomName = object.roomName ?? "";
    message.pin = object.pin ?? "";
    return message;
  },
};

function createBaseSIPDispatchRuleIndividual(): SIPDispatchRuleIndividual {
  return { roomPrefix: "", pin: "" };
}

export const SIPDispatchRuleIndividual: MessageFns<SIPDispatchRuleIndividual> = {
  encode(message: SIPDispatchRuleIndividual, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomPrefix !== "") {
      writer.uint32(10).string(message.roomPrefix);
    }
    if (message.pin !== "") {
      writer.uint32(18).string(message.pin);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRuleIndividual {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRuleIndividual();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomPrefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pin = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRuleIndividual {
    return {
      roomPrefix: isSet(object.roomPrefix) ? globalThis.String(object.roomPrefix) : "",
      pin: isSet(object.pin) ? globalThis.String(object.pin) : "",
    };
  },

  toJSON(message: SIPDispatchRuleIndividual): unknown {
    const obj: any = {};
    if (message.roomPrefix !== "") {
      obj.roomPrefix = message.roomPrefix;
    }
    if (message.pin !== "") {
      obj.pin = message.pin;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRuleIndividual>): SIPDispatchRuleIndividual {
    return SIPDispatchRuleIndividual.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRuleIndividual>): SIPDispatchRuleIndividual {
    const message = createBaseSIPDispatchRuleIndividual();
    message.roomPrefix = object.roomPrefix ?? "";
    message.pin = object.pin ?? "";
    return message;
  },
};

function createBaseSIPDispatchRuleCallee(): SIPDispatchRuleCallee {
  return { roomPrefix: "", pin: "", randomize: false };
}

export const SIPDispatchRuleCallee: MessageFns<SIPDispatchRuleCallee> = {
  encode(message: SIPDispatchRuleCallee, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.roomPrefix !== "") {
      writer.uint32(10).string(message.roomPrefix);
    }
    if (message.pin !== "") {
      writer.uint32(18).string(message.pin);
    }
    if (message.randomize !== false) {
      writer.uint32(24).bool(message.randomize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRuleCallee {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRuleCallee();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.roomPrefix = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pin = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.randomize = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRuleCallee {
    return {
      roomPrefix: isSet(object.roomPrefix) ? globalThis.String(object.roomPrefix) : "",
      pin: isSet(object.pin) ? globalThis.String(object.pin) : "",
      randomize: isSet(object.randomize) ? globalThis.Boolean(object.randomize) : false,
    };
  },

  toJSON(message: SIPDispatchRuleCallee): unknown {
    const obj: any = {};
    if (message.roomPrefix !== "") {
      obj.roomPrefix = message.roomPrefix;
    }
    if (message.pin !== "") {
      obj.pin = message.pin;
    }
    if (message.randomize !== false) {
      obj.randomize = message.randomize;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRuleCallee>): SIPDispatchRuleCallee {
    return SIPDispatchRuleCallee.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRuleCallee>): SIPDispatchRuleCallee {
    const message = createBaseSIPDispatchRuleCallee();
    message.roomPrefix = object.roomPrefix ?? "";
    message.pin = object.pin ?? "";
    message.randomize = object.randomize ?? false;
    return message;
  },
};

function createBaseSIPDispatchRule(): SIPDispatchRule {
  return { rule: undefined };
}

export const SIPDispatchRule: MessageFns<SIPDispatchRule> = {
  encode(message: SIPDispatchRule, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.rule?.$case) {
      case "dispatchRuleDirect":
        SIPDispatchRuleDirect.encode(message.rule.dispatchRuleDirect, writer.uint32(10).fork()).join();
        break;
      case "dispatchRuleIndividual":
        SIPDispatchRuleIndividual.encode(message.rule.dispatchRuleIndividual, writer.uint32(18).fork()).join();
        break;
      case "dispatchRuleCallee":
        SIPDispatchRuleCallee.encode(message.rule.dispatchRuleCallee, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRule {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRule();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = {
            $case: "dispatchRuleDirect",
            dispatchRuleDirect: SIPDispatchRuleDirect.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = {
            $case: "dispatchRuleIndividual",
            dispatchRuleIndividual: SIPDispatchRuleIndividual.decode(reader, reader.uint32()),
          };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.rule = {
            $case: "dispatchRuleCallee",
            dispatchRuleCallee: SIPDispatchRuleCallee.decode(reader, reader.uint32()),
          };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRule {
    return {
      rule: isSet(object.dispatchRuleDirect)
        ? { $case: "dispatchRuleDirect", dispatchRuleDirect: SIPDispatchRuleDirect.fromJSON(object.dispatchRuleDirect) }
        : isSet(object.dispatchRuleIndividual)
        ? {
          $case: "dispatchRuleIndividual",
          dispatchRuleIndividual: SIPDispatchRuleIndividual.fromJSON(object.dispatchRuleIndividual),
        }
        : isSet(object.dispatchRuleCallee)
        ? { $case: "dispatchRuleCallee", dispatchRuleCallee: SIPDispatchRuleCallee.fromJSON(object.dispatchRuleCallee) }
        : undefined,
    };
  },

  toJSON(message: SIPDispatchRule): unknown {
    const obj: any = {};
    if (message.rule?.$case === "dispatchRuleDirect") {
      obj.dispatchRuleDirect = SIPDispatchRuleDirect.toJSON(message.rule.dispatchRuleDirect);
    } else if (message.rule?.$case === "dispatchRuleIndividual") {
      obj.dispatchRuleIndividual = SIPDispatchRuleIndividual.toJSON(message.rule.dispatchRuleIndividual);
    } else if (message.rule?.$case === "dispatchRuleCallee") {
      obj.dispatchRuleCallee = SIPDispatchRuleCallee.toJSON(message.rule.dispatchRuleCallee);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRule>): SIPDispatchRule {
    return SIPDispatchRule.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRule>): SIPDispatchRule {
    const message = createBaseSIPDispatchRule();
    switch (object.rule?.$case) {
      case "dispatchRuleDirect": {
        if (object.rule?.dispatchRuleDirect !== undefined && object.rule?.dispatchRuleDirect !== null) {
          message.rule = {
            $case: "dispatchRuleDirect",
            dispatchRuleDirect: SIPDispatchRuleDirect.fromPartial(object.rule.dispatchRuleDirect),
          };
        }
        break;
      }
      case "dispatchRuleIndividual": {
        if (object.rule?.dispatchRuleIndividual !== undefined && object.rule?.dispatchRuleIndividual !== null) {
          message.rule = {
            $case: "dispatchRuleIndividual",
            dispatchRuleIndividual: SIPDispatchRuleIndividual.fromPartial(object.rule.dispatchRuleIndividual),
          };
        }
        break;
      }
      case "dispatchRuleCallee": {
        if (object.rule?.dispatchRuleCallee !== undefined && object.rule?.dispatchRuleCallee !== null) {
          message.rule = {
            $case: "dispatchRuleCallee",
            dispatchRuleCallee: SIPDispatchRuleCallee.fromPartial(object.rule.dispatchRuleCallee),
          };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseCreateSIPDispatchRuleRequest(): CreateSIPDispatchRuleRequest {
  return {
    dispatchRule: undefined,
    rule: undefined,
    trunkIds: [],
    hidePhoneNumber: false,
    inboundNumbers: [],
    name: "",
    metadata: "",
    attributes: {},
    roomPreset: "",
    roomConfig: undefined,
  };
}

export const CreateSIPDispatchRuleRequest: MessageFns<CreateSIPDispatchRuleRequest> = {
  encode(message: CreateSIPDispatchRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dispatchRule !== undefined) {
      SIPDispatchRuleInfo.encode(message.dispatchRule, writer.uint32(82).fork()).join();
    }
    if (message.rule !== undefined) {
      SIPDispatchRule.encode(message.rule, writer.uint32(10).fork()).join();
    }
    for (const v of message.trunkIds) {
      writer.uint32(18).string(v!);
    }
    if (message.hidePhoneNumber !== false) {
      writer.uint32(24).bool(message.hidePhoneNumber);
    }
    for (const v of message.inboundNumbers) {
      writer.uint32(50).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(34).string(message.name);
    }
    if (message.metadata !== "") {
      writer.uint32(42).string(message.metadata);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      CreateSIPDispatchRuleRequest_AttributesEntry.encode({ key: key as any, value }, writer.uint32(58).fork()).join();
    });
    if (message.roomPreset !== "") {
      writer.uint32(66).string(message.roomPreset);
    }
    if (message.roomConfig !== undefined) {
      RoomConfiguration.encode(message.roomConfig, writer.uint32(74).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPDispatchRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPDispatchRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.dispatchRule = SIPDispatchRuleInfo.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.rule = SIPDispatchRule.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trunkIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.hidePhoneNumber = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.inboundNumbers.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          const entry7 = CreateSIPDispatchRuleRequest_AttributesEntry.decode(reader, reader.uint32());
          if (entry7.value !== undefined) {
            message.attributes[entry7.key] = entry7.value;
          }
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.roomPreset = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.roomConfig = RoomConfiguration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPDispatchRuleRequest {
    return {
      dispatchRule: isSet(object.dispatchRule) ? SIPDispatchRuleInfo.fromJSON(object.dispatchRule) : undefined,
      rule: isSet(object.rule) ? SIPDispatchRule.fromJSON(object.rule) : undefined,
      trunkIds: globalThis.Array.isArray(object?.trunkIds) ? object.trunkIds.map((e: any) => globalThis.String(e)) : [],
      hidePhoneNumber: isSet(object.hidePhoneNumber) ? globalThis.Boolean(object.hidePhoneNumber) : false,
      inboundNumbers: globalThis.Array.isArray(object?.inboundNumbers)
        ? object.inboundNumbers.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      roomPreset: isSet(object.roomPreset) ? globalThis.String(object.roomPreset) : "",
      roomConfig: isSet(object.roomConfig) ? RoomConfiguration.fromJSON(object.roomConfig) : undefined,
    };
  },

  toJSON(message: CreateSIPDispatchRuleRequest): unknown {
    const obj: any = {};
    if (message.dispatchRule !== undefined) {
      obj.dispatchRule = SIPDispatchRuleInfo.toJSON(message.dispatchRule);
    }
    if (message.rule !== undefined) {
      obj.rule = SIPDispatchRule.toJSON(message.rule);
    }
    if (message.trunkIds?.length) {
      obj.trunkIds = message.trunkIds;
    }
    if (message.hidePhoneNumber !== false) {
      obj.hidePhoneNumber = message.hidePhoneNumber;
    }
    if (message.inboundNumbers?.length) {
      obj.inboundNumbers = message.inboundNumbers;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.roomPreset !== "") {
      obj.roomPreset = message.roomPreset;
    }
    if (message.roomConfig !== undefined) {
      obj.roomConfig = RoomConfiguration.toJSON(message.roomConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSIPDispatchRuleRequest>): CreateSIPDispatchRuleRequest {
    return CreateSIPDispatchRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSIPDispatchRuleRequest>): CreateSIPDispatchRuleRequest {
    const message = createBaseCreateSIPDispatchRuleRequest();
    message.dispatchRule = (object.dispatchRule !== undefined && object.dispatchRule !== null)
      ? SIPDispatchRuleInfo.fromPartial(object.dispatchRule)
      : undefined;
    message.rule = (object.rule !== undefined && object.rule !== null)
      ? SIPDispatchRule.fromPartial(object.rule)
      : undefined;
    message.trunkIds = object.trunkIds?.map((e) => e) || [];
    message.hidePhoneNumber = object.hidePhoneNumber ?? false;
    message.inboundNumbers = object.inboundNumbers?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.metadata = object.metadata ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.roomPreset = object.roomPreset ?? "";
    message.roomConfig = (object.roomConfig !== undefined && object.roomConfig !== null)
      ? RoomConfiguration.fromPartial(object.roomConfig)
      : undefined;
    return message;
  },
};

function createBaseCreateSIPDispatchRuleRequest_AttributesEntry(): CreateSIPDispatchRuleRequest_AttributesEntry {
  return { key: "", value: "" };
}

export const CreateSIPDispatchRuleRequest_AttributesEntry: MessageFns<CreateSIPDispatchRuleRequest_AttributesEntry> = {
  encode(
    message: CreateSIPDispatchRuleRequest_AttributesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPDispatchRuleRequest_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPDispatchRuleRequest_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPDispatchRuleRequest_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSIPDispatchRuleRequest_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateSIPDispatchRuleRequest_AttributesEntry>,
  ): CreateSIPDispatchRuleRequest_AttributesEntry {
    return CreateSIPDispatchRuleRequest_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateSIPDispatchRuleRequest_AttributesEntry>,
  ): CreateSIPDispatchRuleRequest_AttributesEntry {
    const message = createBaseCreateSIPDispatchRuleRequest_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseUpdateSIPDispatchRuleRequest(): UpdateSIPDispatchRuleRequest {
  return { sipDispatchRuleId: "", action: undefined };
}

export const UpdateSIPDispatchRuleRequest: MessageFns<UpdateSIPDispatchRuleRequest> = {
  encode(message: UpdateSIPDispatchRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipDispatchRuleId !== "") {
      writer.uint32(10).string(message.sipDispatchRuleId);
    }
    switch (message.action?.$case) {
      case "replace":
        SIPDispatchRuleInfo.encode(message.action.replace, writer.uint32(18).fork()).join();
        break;
      case "update":
        SIPDispatchRuleUpdate.encode(message.action.update, writer.uint32(26).fork()).join();
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateSIPDispatchRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateSIPDispatchRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipDispatchRuleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = { $case: "replace", replace: SIPDispatchRuleInfo.decode(reader, reader.uint32()) };
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.action = { $case: "update", update: SIPDispatchRuleUpdate.decode(reader, reader.uint32()) };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateSIPDispatchRuleRequest {
    return {
      sipDispatchRuleId: isSet(object.sipDispatchRuleId) ? globalThis.String(object.sipDispatchRuleId) : "",
      action: isSet(object.replace)
        ? { $case: "replace", replace: SIPDispatchRuleInfo.fromJSON(object.replace) }
        : isSet(object.update)
        ? { $case: "update", update: SIPDispatchRuleUpdate.fromJSON(object.update) }
        : undefined,
    };
  },

  toJSON(message: UpdateSIPDispatchRuleRequest): unknown {
    const obj: any = {};
    if (message.sipDispatchRuleId !== "") {
      obj.sipDispatchRuleId = message.sipDispatchRuleId;
    }
    if (message.action?.$case === "replace") {
      obj.replace = SIPDispatchRuleInfo.toJSON(message.action.replace);
    } else if (message.action?.$case === "update") {
      obj.update = SIPDispatchRuleUpdate.toJSON(message.action.update);
    }
    return obj;
  },

  create(base?: DeepPartial<UpdateSIPDispatchRuleRequest>): UpdateSIPDispatchRuleRequest {
    return UpdateSIPDispatchRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UpdateSIPDispatchRuleRequest>): UpdateSIPDispatchRuleRequest {
    const message = createBaseUpdateSIPDispatchRuleRequest();
    message.sipDispatchRuleId = object.sipDispatchRuleId ?? "";
    switch (object.action?.$case) {
      case "replace": {
        if (object.action?.replace !== undefined && object.action?.replace !== null) {
          message.action = { $case: "replace", replace: SIPDispatchRuleInfo.fromPartial(object.action.replace) };
        }
        break;
      }
      case "update": {
        if (object.action?.update !== undefined && object.action?.update !== null) {
          message.action = { $case: "update", update: SIPDispatchRuleUpdate.fromPartial(object.action.update) };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseSIPDispatchRuleInfo(): SIPDispatchRuleInfo {
  return {
    sipDispatchRuleId: "",
    rule: undefined,
    trunkIds: [],
    hidePhoneNumber: false,
    inboundNumbers: [],
    name: "",
    metadata: "",
    attributes: {},
    roomPreset: "",
    roomConfig: undefined,
    krispEnabled: false,
    mediaEncryption: 0,
  };
}

export const SIPDispatchRuleInfo: MessageFns<SIPDispatchRuleInfo> = {
  encode(message: SIPDispatchRuleInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipDispatchRuleId !== "") {
      writer.uint32(10).string(message.sipDispatchRuleId);
    }
    if (message.rule !== undefined) {
      SIPDispatchRule.encode(message.rule, writer.uint32(18).fork()).join();
    }
    for (const v of message.trunkIds) {
      writer.uint32(26).string(v!);
    }
    if (message.hidePhoneNumber !== false) {
      writer.uint32(32).bool(message.hidePhoneNumber);
    }
    for (const v of message.inboundNumbers) {
      writer.uint32(58).string(v!);
    }
    if (message.name !== "") {
      writer.uint32(42).string(message.name);
    }
    if (message.metadata !== "") {
      writer.uint32(50).string(message.metadata);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      SIPDispatchRuleInfo_AttributesEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (message.roomPreset !== "") {
      writer.uint32(74).string(message.roomPreset);
    }
    if (message.roomConfig !== undefined) {
      RoomConfiguration.encode(message.roomConfig, writer.uint32(82).fork()).join();
    }
    if (message.krispEnabled !== false) {
      writer.uint32(88).bool(message.krispEnabled);
    }
    if (message.mediaEncryption !== 0) {
      writer.uint32(96).int32(message.mediaEncryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRuleInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRuleInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipDispatchRuleId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = SIPDispatchRule.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.trunkIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.hidePhoneNumber = reader.bool();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.inboundNumbers.push(reader.string());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = SIPDispatchRuleInfo_AttributesEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.attributes[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.roomPreset = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.roomConfig = RoomConfiguration.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.krispEnabled = reader.bool();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.mediaEncryption = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRuleInfo {
    return {
      sipDispatchRuleId: isSet(object.sipDispatchRuleId) ? globalThis.String(object.sipDispatchRuleId) : "",
      rule: isSet(object.rule) ? SIPDispatchRule.fromJSON(object.rule) : undefined,
      trunkIds: globalThis.Array.isArray(object?.trunkIds) ? object.trunkIds.map((e: any) => globalThis.String(e)) : [],
      hidePhoneNumber: isSet(object.hidePhoneNumber) ? globalThis.Boolean(object.hidePhoneNumber) : false,
      inboundNumbers: globalThis.Array.isArray(object?.inboundNumbers)
        ? object.inboundNumbers.map((e: any) => globalThis.String(e))
        : [],
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : "",
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      roomPreset: isSet(object.roomPreset) ? globalThis.String(object.roomPreset) : "",
      roomConfig: isSet(object.roomConfig) ? RoomConfiguration.fromJSON(object.roomConfig) : undefined,
      krispEnabled: isSet(object.krispEnabled) ? globalThis.Boolean(object.krispEnabled) : false,
      mediaEncryption: isSet(object.mediaEncryption) ? sIPMediaEncryptionFromJSON(object.mediaEncryption) : 0,
    };
  },

  toJSON(message: SIPDispatchRuleInfo): unknown {
    const obj: any = {};
    if (message.sipDispatchRuleId !== "") {
      obj.sipDispatchRuleId = message.sipDispatchRuleId;
    }
    if (message.rule !== undefined) {
      obj.rule = SIPDispatchRule.toJSON(message.rule);
    }
    if (message.trunkIds?.length) {
      obj.trunkIds = message.trunkIds;
    }
    if (message.hidePhoneNumber !== false) {
      obj.hidePhoneNumber = message.hidePhoneNumber;
    }
    if (message.inboundNumbers?.length) {
      obj.inboundNumbers = message.inboundNumbers;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.metadata !== "") {
      obj.metadata = message.metadata;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.roomPreset !== "") {
      obj.roomPreset = message.roomPreset;
    }
    if (message.roomConfig !== undefined) {
      obj.roomConfig = RoomConfiguration.toJSON(message.roomConfig);
    }
    if (message.krispEnabled !== false) {
      obj.krispEnabled = message.krispEnabled;
    }
    if (message.mediaEncryption !== 0) {
      obj.mediaEncryption = sIPMediaEncryptionToJSON(message.mediaEncryption);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRuleInfo>): SIPDispatchRuleInfo {
    return SIPDispatchRuleInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRuleInfo>): SIPDispatchRuleInfo {
    const message = createBaseSIPDispatchRuleInfo();
    message.sipDispatchRuleId = object.sipDispatchRuleId ?? "";
    message.rule = (object.rule !== undefined && object.rule !== null)
      ? SIPDispatchRule.fromPartial(object.rule)
      : undefined;
    message.trunkIds = object.trunkIds?.map((e) => e) || [];
    message.hidePhoneNumber = object.hidePhoneNumber ?? false;
    message.inboundNumbers = object.inboundNumbers?.map((e) => e) || [];
    message.name = object.name ?? "";
    message.metadata = object.metadata ?? "";
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.roomPreset = object.roomPreset ?? "";
    message.roomConfig = (object.roomConfig !== undefined && object.roomConfig !== null)
      ? RoomConfiguration.fromPartial(object.roomConfig)
      : undefined;
    message.krispEnabled = object.krispEnabled ?? false;
    message.mediaEncryption = object.mediaEncryption ?? 0;
    return message;
  },
};

function createBaseSIPDispatchRuleInfo_AttributesEntry(): SIPDispatchRuleInfo_AttributesEntry {
  return { key: "", value: "" };
}

export const SIPDispatchRuleInfo_AttributesEntry: MessageFns<SIPDispatchRuleInfo_AttributesEntry> = {
  encode(message: SIPDispatchRuleInfo_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRuleInfo_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRuleInfo_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRuleInfo_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPDispatchRuleInfo_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRuleInfo_AttributesEntry>): SIPDispatchRuleInfo_AttributesEntry {
    return SIPDispatchRuleInfo_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRuleInfo_AttributesEntry>): SIPDispatchRuleInfo_AttributesEntry {
    const message = createBaseSIPDispatchRuleInfo_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPDispatchRuleUpdate(): SIPDispatchRuleUpdate {
  return {
    trunkIds: undefined,
    rule: undefined,
    name: undefined,
    metadata: undefined,
    attributes: {},
    mediaEncryption: undefined,
  };
}

export const SIPDispatchRuleUpdate: MessageFns<SIPDispatchRuleUpdate> = {
  encode(message: SIPDispatchRuleUpdate, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.trunkIds !== undefined) {
      ListUpdate.encode(message.trunkIds, writer.uint32(10).fork()).join();
    }
    if (message.rule !== undefined) {
      SIPDispatchRule.encode(message.rule, writer.uint32(18).fork()).join();
    }
    if (message.name !== undefined) {
      writer.uint32(26).string(message.name);
    }
    if (message.metadata !== undefined) {
      writer.uint32(34).string(message.metadata);
    }
    Object.entries(message.attributes).forEach(([key, value]) => {
      SIPDispatchRuleUpdate_AttributesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.mediaEncryption !== undefined) {
      writer.uint32(48).int32(message.mediaEncryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRuleUpdate {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRuleUpdate();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.trunkIds = ListUpdate.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.rule = SIPDispatchRule.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.metadata = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = SIPDispatchRuleUpdate_AttributesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.attributes[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.mediaEncryption = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRuleUpdate {
    return {
      trunkIds: isSet(object.trunkIds) ? ListUpdate.fromJSON(object.trunkIds) : undefined,
      rule: isSet(object.rule) ? SIPDispatchRule.fromJSON(object.rule) : undefined,
      name: isSet(object.name) ? globalThis.String(object.name) : undefined,
      metadata: isSet(object.metadata) ? globalThis.String(object.metadata) : undefined,
      attributes: isObject(object.attributes)
        ? Object.entries(object.attributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      mediaEncryption: isSet(object.mediaEncryption) ? sIPMediaEncryptionFromJSON(object.mediaEncryption) : undefined,
    };
  },

  toJSON(message: SIPDispatchRuleUpdate): unknown {
    const obj: any = {};
    if (message.trunkIds !== undefined) {
      obj.trunkIds = ListUpdate.toJSON(message.trunkIds);
    }
    if (message.rule !== undefined) {
      obj.rule = SIPDispatchRule.toJSON(message.rule);
    }
    if (message.name !== undefined) {
      obj.name = message.name;
    }
    if (message.metadata !== undefined) {
      obj.metadata = message.metadata;
    }
    if (message.attributes) {
      const entries = Object.entries(message.attributes);
      if (entries.length > 0) {
        obj.attributes = {};
        entries.forEach(([k, v]) => {
          obj.attributes[k] = v;
        });
      }
    }
    if (message.mediaEncryption !== undefined) {
      obj.mediaEncryption = sIPMediaEncryptionToJSON(message.mediaEncryption);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRuleUpdate>): SIPDispatchRuleUpdate {
    return SIPDispatchRuleUpdate.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRuleUpdate>): SIPDispatchRuleUpdate {
    const message = createBaseSIPDispatchRuleUpdate();
    message.trunkIds = (object.trunkIds !== undefined && object.trunkIds !== null)
      ? ListUpdate.fromPartial(object.trunkIds)
      : undefined;
    message.rule = (object.rule !== undefined && object.rule !== null)
      ? SIPDispatchRule.fromPartial(object.rule)
      : undefined;
    message.name = object.name ?? undefined;
    message.metadata = object.metadata ?? undefined;
    message.attributes = Object.entries(object.attributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.mediaEncryption = object.mediaEncryption ?? undefined;
    return message;
  },
};

function createBaseSIPDispatchRuleUpdate_AttributesEntry(): SIPDispatchRuleUpdate_AttributesEntry {
  return { key: "", value: "" };
}

export const SIPDispatchRuleUpdate_AttributesEntry: MessageFns<SIPDispatchRuleUpdate_AttributesEntry> = {
  encode(message: SIPDispatchRuleUpdate_AttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPDispatchRuleUpdate_AttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPDispatchRuleUpdate_AttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPDispatchRuleUpdate_AttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPDispatchRuleUpdate_AttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPDispatchRuleUpdate_AttributesEntry>): SIPDispatchRuleUpdate_AttributesEntry {
    return SIPDispatchRuleUpdate_AttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPDispatchRuleUpdate_AttributesEntry>): SIPDispatchRuleUpdate_AttributesEntry {
    const message = createBaseSIPDispatchRuleUpdate_AttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListSIPDispatchRuleRequest(): ListSIPDispatchRuleRequest {
  return { page: undefined, dispatchRuleIds: [], trunkIds: [] };
}

export const ListSIPDispatchRuleRequest: MessageFns<ListSIPDispatchRuleRequest> = {
  encode(message: ListSIPDispatchRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.page !== undefined) {
      Pagination.encode(message.page, writer.uint32(26).fork()).join();
    }
    for (const v of message.dispatchRuleIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.trunkIds) {
      writer.uint32(18).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPDispatchRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPDispatchRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.page = Pagination.decode(reader, reader.uint32());
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dispatchRuleIds.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trunkIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPDispatchRuleRequest {
    return {
      page: isSet(object.page) ? Pagination.fromJSON(object.page) : undefined,
      dispatchRuleIds: globalThis.Array.isArray(object?.dispatchRuleIds)
        ? object.dispatchRuleIds.map((e: any) => globalThis.String(e))
        : [],
      trunkIds: globalThis.Array.isArray(object?.trunkIds) ? object.trunkIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListSIPDispatchRuleRequest): unknown {
    const obj: any = {};
    if (message.page !== undefined) {
      obj.page = Pagination.toJSON(message.page);
    }
    if (message.dispatchRuleIds?.length) {
      obj.dispatchRuleIds = message.dispatchRuleIds;
    }
    if (message.trunkIds?.length) {
      obj.trunkIds = message.trunkIds;
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPDispatchRuleRequest>): ListSIPDispatchRuleRequest {
    return ListSIPDispatchRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPDispatchRuleRequest>): ListSIPDispatchRuleRequest {
    const message = createBaseListSIPDispatchRuleRequest();
    message.page = (object.page !== undefined && object.page !== null)
      ? Pagination.fromPartial(object.page)
      : undefined;
    message.dispatchRuleIds = object.dispatchRuleIds?.map((e) => e) || [];
    message.trunkIds = object.trunkIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListSIPDispatchRuleResponse(): ListSIPDispatchRuleResponse {
  return { items: [] };
}

export const ListSIPDispatchRuleResponse: MessageFns<ListSIPDispatchRuleResponse> = {
  encode(message: ListSIPDispatchRuleResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.items) {
      SIPDispatchRuleInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSIPDispatchRuleResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSIPDispatchRuleResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.items.push(SIPDispatchRuleInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSIPDispatchRuleResponse {
    return {
      items: globalThis.Array.isArray(object?.items)
        ? object.items.map((e: any) => SIPDispatchRuleInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSIPDispatchRuleResponse): unknown {
    const obj: any = {};
    if (message.items?.length) {
      obj.items = message.items.map((e) => SIPDispatchRuleInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSIPDispatchRuleResponse>): ListSIPDispatchRuleResponse {
    return ListSIPDispatchRuleResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSIPDispatchRuleResponse>): ListSIPDispatchRuleResponse {
    const message = createBaseListSIPDispatchRuleResponse();
    message.items = object.items?.map((e) => SIPDispatchRuleInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDeleteSIPDispatchRuleRequest(): DeleteSIPDispatchRuleRequest {
  return { sipDispatchRuleId: "" };
}

export const DeleteSIPDispatchRuleRequest: MessageFns<DeleteSIPDispatchRuleRequest> = {
  encode(message: DeleteSIPDispatchRuleRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipDispatchRuleId !== "") {
      writer.uint32(10).string(message.sipDispatchRuleId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteSIPDispatchRuleRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteSIPDispatchRuleRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipDispatchRuleId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteSIPDispatchRuleRequest {
    return { sipDispatchRuleId: isSet(object.sipDispatchRuleId) ? globalThis.String(object.sipDispatchRuleId) : "" };
  },

  toJSON(message: DeleteSIPDispatchRuleRequest): unknown {
    const obj: any = {};
    if (message.sipDispatchRuleId !== "") {
      obj.sipDispatchRuleId = message.sipDispatchRuleId;
    }
    return obj;
  },

  create(base?: DeepPartial<DeleteSIPDispatchRuleRequest>): DeleteSIPDispatchRuleRequest {
    return DeleteSIPDispatchRuleRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DeleteSIPDispatchRuleRequest>): DeleteSIPDispatchRuleRequest {
    const message = createBaseDeleteSIPDispatchRuleRequest();
    message.sipDispatchRuleId = object.sipDispatchRuleId ?? "";
    return message;
  },
};

function createBaseSIPOutboundConfig(): SIPOutboundConfig {
  return {
    hostname: "",
    destinationCountry: "",
    transport: 0,
    authUsername: "",
    authPassword: "",
    headersToAttributes: {},
    attributesToHeaders: {},
  };
}

export const SIPOutboundConfig: MessageFns<SIPOutboundConfig> = {
  encode(message: SIPOutboundConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.hostname !== "") {
      writer.uint32(10).string(message.hostname);
    }
    if (message.destinationCountry !== "") {
      writer.uint32(58).string(message.destinationCountry);
    }
    if (message.transport !== 0) {
      writer.uint32(16).int32(message.transport);
    }
    if (message.authUsername !== "") {
      writer.uint32(26).string(message.authUsername);
    }
    if (message.authPassword !== "") {
      writer.uint32(34).string(message.authPassword);
    }
    Object.entries(message.headersToAttributes).forEach(([key, value]) => {
      SIPOutboundConfig_HeadersToAttributesEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    Object.entries(message.attributesToHeaders).forEach(([key, value]) => {
      SIPOutboundConfig_AttributesToHeadersEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPOutboundConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.hostname = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.destinationCountry = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.transport = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.authUsername = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.authPassword = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = SIPOutboundConfig_HeadersToAttributesEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.headersToAttributes[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = SIPOutboundConfig_AttributesToHeadersEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.attributesToHeaders[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPOutboundConfig {
    return {
      hostname: isSet(object.hostname) ? globalThis.String(object.hostname) : "",
      destinationCountry: isSet(object.destinationCountry) ? globalThis.String(object.destinationCountry) : "",
      transport: isSet(object.transport) ? sIPTransportFromJSON(object.transport) : 0,
      authUsername: isSet(object.authUsername) ? globalThis.String(object.authUsername) : "",
      authPassword: isSet(object.authPassword) ? globalThis.String(object.authPassword) : "",
      headersToAttributes: isObject(object.headersToAttributes)
        ? Object.entries(object.headersToAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      attributesToHeaders: isObject(object.attributesToHeaders)
        ? Object.entries(object.attributesToHeaders).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SIPOutboundConfig): unknown {
    const obj: any = {};
    if (message.hostname !== "") {
      obj.hostname = message.hostname;
    }
    if (message.destinationCountry !== "") {
      obj.destinationCountry = message.destinationCountry;
    }
    if (message.transport !== 0) {
      obj.transport = sIPTransportToJSON(message.transport);
    }
    if (message.authUsername !== "") {
      obj.authUsername = message.authUsername;
    }
    if (message.authPassword !== "") {
      obj.authPassword = message.authPassword;
    }
    if (message.headersToAttributes) {
      const entries = Object.entries(message.headersToAttributes);
      if (entries.length > 0) {
        obj.headersToAttributes = {};
        entries.forEach(([k, v]) => {
          obj.headersToAttributes[k] = v;
        });
      }
    }
    if (message.attributesToHeaders) {
      const entries = Object.entries(message.attributesToHeaders);
      if (entries.length > 0) {
        obj.attributesToHeaders = {};
        entries.forEach(([k, v]) => {
          obj.attributesToHeaders[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<SIPOutboundConfig>): SIPOutboundConfig {
    return SIPOutboundConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPOutboundConfig>): SIPOutboundConfig {
    const message = createBaseSIPOutboundConfig();
    message.hostname = object.hostname ?? "";
    message.destinationCountry = object.destinationCountry ?? "";
    message.transport = object.transport ?? 0;
    message.authUsername = object.authUsername ?? "";
    message.authPassword = object.authPassword ?? "";
    message.headersToAttributes = Object.entries(object.headersToAttributes ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.attributesToHeaders = Object.entries(object.attributesToHeaders ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseSIPOutboundConfig_HeadersToAttributesEntry(): SIPOutboundConfig_HeadersToAttributesEntry {
  return { key: "", value: "" };
}

export const SIPOutboundConfig_HeadersToAttributesEntry: MessageFns<SIPOutboundConfig_HeadersToAttributesEntry> = {
  encode(message: SIPOutboundConfig_HeadersToAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundConfig_HeadersToAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPOutboundConfig_HeadersToAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPOutboundConfig_HeadersToAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPOutboundConfig_HeadersToAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPOutboundConfig_HeadersToAttributesEntry>): SIPOutboundConfig_HeadersToAttributesEntry {
    return SIPOutboundConfig_HeadersToAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SIPOutboundConfig_HeadersToAttributesEntry>,
  ): SIPOutboundConfig_HeadersToAttributesEntry {
    const message = createBaseSIPOutboundConfig_HeadersToAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPOutboundConfig_AttributesToHeadersEntry(): SIPOutboundConfig_AttributesToHeadersEntry {
  return { key: "", value: "" };
}

export const SIPOutboundConfig_AttributesToHeadersEntry: MessageFns<SIPOutboundConfig_AttributesToHeadersEntry> = {
  encode(message: SIPOutboundConfig_AttributesToHeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPOutboundConfig_AttributesToHeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPOutboundConfig_AttributesToHeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPOutboundConfig_AttributesToHeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPOutboundConfig_AttributesToHeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPOutboundConfig_AttributesToHeadersEntry>): SIPOutboundConfig_AttributesToHeadersEntry {
    return SIPOutboundConfig_AttributesToHeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<SIPOutboundConfig_AttributesToHeadersEntry>,
  ): SIPOutboundConfig_AttributesToHeadersEntry {
    const message = createBaseSIPOutboundConfig_AttributesToHeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateSIPParticipantRequest(): CreateSIPParticipantRequest {
  return {
    sipTrunkId: "",
    trunk: undefined,
    sipCallTo: "",
    sipNumber: "",
    roomName: "",
    participantIdentity: "",
    participantName: "",
    participantMetadata: "",
    participantAttributes: {},
    dtmf: "",
    playRingtone: false,
    playDialtone: false,
    hidePhoneNumber: false,
    headers: {},
    includeHeaders: 0,
    ringingTimeout: undefined,
    maxCallDuration: undefined,
    krispEnabled: false,
    mediaEncryption: 0,
    waitUntilAnswered: false,
  };
}

export const CreateSIPParticipantRequest: MessageFns<CreateSIPParticipantRequest> = {
  encode(message: CreateSIPParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sipTrunkId !== "") {
      writer.uint32(10).string(message.sipTrunkId);
    }
    if (message.trunk !== undefined) {
      SIPOutboundConfig.encode(message.trunk, writer.uint32(162).fork()).join();
    }
    if (message.sipCallTo !== "") {
      writer.uint32(18).string(message.sipCallTo);
    }
    if (message.sipNumber !== "") {
      writer.uint32(122).string(message.sipNumber);
    }
    if (message.roomName !== "") {
      writer.uint32(26).string(message.roomName);
    }
    if (message.participantIdentity !== "") {
      writer.uint32(34).string(message.participantIdentity);
    }
    if (message.participantName !== "") {
      writer.uint32(58).string(message.participantName);
    }
    if (message.participantMetadata !== "") {
      writer.uint32(66).string(message.participantMetadata);
    }
    Object.entries(message.participantAttributes).forEach(([key, value]) => {
      CreateSIPParticipantRequest_ParticipantAttributesEntry.encode(
        { key: key as any, value },
        writer.uint32(74).fork(),
      ).join();
    });
    if (message.dtmf !== "") {
      writer.uint32(42).string(message.dtmf);
    }
    if (message.playRingtone !== false) {
      writer.uint32(48).bool(message.playRingtone);
    }
    if (message.playDialtone !== false) {
      writer.uint32(104).bool(message.playDialtone);
    }
    if (message.hidePhoneNumber !== false) {
      writer.uint32(80).bool(message.hidePhoneNumber);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      CreateSIPParticipantRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(130).fork()).join();
    });
    if (message.includeHeaders !== 0) {
      writer.uint32(136).int32(message.includeHeaders);
    }
    if (message.ringingTimeout !== undefined) {
      Duration.encode(message.ringingTimeout, writer.uint32(90).fork()).join();
    }
    if (message.maxCallDuration !== undefined) {
      Duration.encode(message.maxCallDuration, writer.uint32(98).fork()).join();
    }
    if (message.krispEnabled !== false) {
      writer.uint32(112).bool(message.krispEnabled);
    }
    if (message.mediaEncryption !== 0) {
      writer.uint32(144).int32(message.mediaEncryption);
    }
    if (message.waitUntilAnswered !== false) {
      writer.uint32(152).bool(message.waitUntilAnswered);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sipTrunkId = reader.string();
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.trunk = SIPOutboundConfig.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sipCallTo = reader.string();
          continue;
        }
        case 15: {
          if (tag !== 122) {
            break;
          }

          message.sipNumber = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.participantName = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.participantMetadata = reader.string();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = CreateSIPParticipantRequest_ParticipantAttributesEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.participantAttributes[entry9.key] = entry9.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.dtmf = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.playRingtone = reader.bool();
          continue;
        }
        case 13: {
          if (tag !== 104) {
            break;
          }

          message.playDialtone = reader.bool();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.hidePhoneNumber = reader.bool();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          const entry16 = CreateSIPParticipantRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry16.value !== undefined) {
            message.headers[entry16.key] = entry16.value;
          }
          continue;
        }
        case 17: {
          if (tag !== 136) {
            break;
          }

          message.includeHeaders = reader.int32() as any;
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          message.ringingTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.maxCallDuration = Duration.decode(reader, reader.uint32());
          continue;
        }
        case 14: {
          if (tag !== 112) {
            break;
          }

          message.krispEnabled = reader.bool();
          continue;
        }
        case 18: {
          if (tag !== 144) {
            break;
          }

          message.mediaEncryption = reader.int32() as any;
          continue;
        }
        case 19: {
          if (tag !== 152) {
            break;
          }

          message.waitUntilAnswered = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPParticipantRequest {
    return {
      sipTrunkId: isSet(object.sipTrunkId) ? globalThis.String(object.sipTrunkId) : "",
      trunk: isSet(object.trunk) ? SIPOutboundConfig.fromJSON(object.trunk) : undefined,
      sipCallTo: isSet(object.sipCallTo) ? globalThis.String(object.sipCallTo) : "",
      sipNumber: isSet(object.sipNumber) ? globalThis.String(object.sipNumber) : "",
      roomName: isSet(object.roomName) ? globalThis.String(object.roomName) : "",
      participantIdentity: isSet(object.participantIdentity) ? globalThis.String(object.participantIdentity) : "",
      participantName: isSet(object.participantName) ? globalThis.String(object.participantName) : "",
      participantMetadata: isSet(object.participantMetadata) ? globalThis.String(object.participantMetadata) : "",
      participantAttributes: isObject(object.participantAttributes)
        ? Object.entries(object.participantAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      dtmf: isSet(object.dtmf) ? globalThis.String(object.dtmf) : "",
      playRingtone: isSet(object.playRingtone) ? globalThis.Boolean(object.playRingtone) : false,
      playDialtone: isSet(object.playDialtone) ? globalThis.Boolean(object.playDialtone) : false,
      hidePhoneNumber: isSet(object.hidePhoneNumber) ? globalThis.Boolean(object.hidePhoneNumber) : false,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      includeHeaders: isSet(object.includeHeaders) ? sIPHeaderOptionsFromJSON(object.includeHeaders) : 0,
      ringingTimeout: isSet(object.ringingTimeout) ? Duration.fromJSON(object.ringingTimeout) : undefined,
      maxCallDuration: isSet(object.maxCallDuration) ? Duration.fromJSON(object.maxCallDuration) : undefined,
      krispEnabled: isSet(object.krispEnabled) ? globalThis.Boolean(object.krispEnabled) : false,
      mediaEncryption: isSet(object.mediaEncryption) ? sIPMediaEncryptionFromJSON(object.mediaEncryption) : 0,
      waitUntilAnswered: isSet(object.waitUntilAnswered) ? globalThis.Boolean(object.waitUntilAnswered) : false,
    };
  },

  toJSON(message: CreateSIPParticipantRequest): unknown {
    const obj: any = {};
    if (message.sipTrunkId !== "") {
      obj.sipTrunkId = message.sipTrunkId;
    }
    if (message.trunk !== undefined) {
      obj.trunk = SIPOutboundConfig.toJSON(message.trunk);
    }
    if (message.sipCallTo !== "") {
      obj.sipCallTo = message.sipCallTo;
    }
    if (message.sipNumber !== "") {
      obj.sipNumber = message.sipNumber;
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    if (message.participantName !== "") {
      obj.participantName = message.participantName;
    }
    if (message.participantMetadata !== "") {
      obj.participantMetadata = message.participantMetadata;
    }
    if (message.participantAttributes) {
      const entries = Object.entries(message.participantAttributes);
      if (entries.length > 0) {
        obj.participantAttributes = {};
        entries.forEach(([k, v]) => {
          obj.participantAttributes[k] = v;
        });
      }
    }
    if (message.dtmf !== "") {
      obj.dtmf = message.dtmf;
    }
    if (message.playRingtone !== false) {
      obj.playRingtone = message.playRingtone;
    }
    if (message.playDialtone !== false) {
      obj.playDialtone = message.playDialtone;
    }
    if (message.hidePhoneNumber !== false) {
      obj.hidePhoneNumber = message.hidePhoneNumber;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.includeHeaders !== 0) {
      obj.includeHeaders = sIPHeaderOptionsToJSON(message.includeHeaders);
    }
    if (message.ringingTimeout !== undefined) {
      obj.ringingTimeout = Duration.toJSON(message.ringingTimeout);
    }
    if (message.maxCallDuration !== undefined) {
      obj.maxCallDuration = Duration.toJSON(message.maxCallDuration);
    }
    if (message.krispEnabled !== false) {
      obj.krispEnabled = message.krispEnabled;
    }
    if (message.mediaEncryption !== 0) {
      obj.mediaEncryption = sIPMediaEncryptionToJSON(message.mediaEncryption);
    }
    if (message.waitUntilAnswered !== false) {
      obj.waitUntilAnswered = message.waitUntilAnswered;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSIPParticipantRequest>): CreateSIPParticipantRequest {
    return CreateSIPParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSIPParticipantRequest>): CreateSIPParticipantRequest {
    const message = createBaseCreateSIPParticipantRequest();
    message.sipTrunkId = object.sipTrunkId ?? "";
    message.trunk = (object.trunk !== undefined && object.trunk !== null)
      ? SIPOutboundConfig.fromPartial(object.trunk)
      : undefined;
    message.sipCallTo = object.sipCallTo ?? "";
    message.sipNumber = object.sipNumber ?? "";
    message.roomName = object.roomName ?? "";
    message.participantIdentity = object.participantIdentity ?? "";
    message.participantName = object.participantName ?? "";
    message.participantMetadata = object.participantMetadata ?? "";
    message.participantAttributes = Object.entries(object.participantAttributes ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.dtmf = object.dtmf ?? "";
    message.playRingtone = object.playRingtone ?? false;
    message.playDialtone = object.playDialtone ?? false;
    message.hidePhoneNumber = object.hidePhoneNumber ?? false;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.includeHeaders = object.includeHeaders ?? 0;
    message.ringingTimeout = (object.ringingTimeout !== undefined && object.ringingTimeout !== null)
      ? Duration.fromPartial(object.ringingTimeout)
      : undefined;
    message.maxCallDuration = (object.maxCallDuration !== undefined && object.maxCallDuration !== null)
      ? Duration.fromPartial(object.maxCallDuration)
      : undefined;
    message.krispEnabled = object.krispEnabled ?? false;
    message.mediaEncryption = object.mediaEncryption ?? 0;
    message.waitUntilAnswered = object.waitUntilAnswered ?? false;
    return message;
  },
};

function createBaseCreateSIPParticipantRequest_ParticipantAttributesEntry(): CreateSIPParticipantRequest_ParticipantAttributesEntry {
  return { key: "", value: "" };
}

export const CreateSIPParticipantRequest_ParticipantAttributesEntry: MessageFns<
  CreateSIPParticipantRequest_ParticipantAttributesEntry
> = {
  encode(
    message: CreateSIPParticipantRequest_ParticipantAttributesEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPParticipantRequest_ParticipantAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPParticipantRequest_ParticipantAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPParticipantRequest_ParticipantAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSIPParticipantRequest_ParticipantAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<CreateSIPParticipantRequest_ParticipantAttributesEntry>,
  ): CreateSIPParticipantRequest_ParticipantAttributesEntry {
    return CreateSIPParticipantRequest_ParticipantAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<CreateSIPParticipantRequest_ParticipantAttributesEntry>,
  ): CreateSIPParticipantRequest_ParticipantAttributesEntry {
    const message = createBaseCreateSIPParticipantRequest_ParticipantAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateSIPParticipantRequest_HeadersEntry(): CreateSIPParticipantRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const CreateSIPParticipantRequest_HeadersEntry: MessageFns<CreateSIPParticipantRequest_HeadersEntry> = {
  encode(message: CreateSIPParticipantRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSIPParticipantRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSIPParticipantRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSIPParticipantRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSIPParticipantRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSIPParticipantRequest_HeadersEntry>): CreateSIPParticipantRequest_HeadersEntry {
    return CreateSIPParticipantRequest_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSIPParticipantRequest_HeadersEntry>): CreateSIPParticipantRequest_HeadersEntry {
    const message = createBaseCreateSIPParticipantRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPParticipantInfo(): SIPParticipantInfo {
  return { participantId: "", participantIdentity: "", roomName: "", sipCallId: "" };
}

export const SIPParticipantInfo: MessageFns<SIPParticipantInfo> = {
  encode(message: SIPParticipantInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participantId !== "") {
      writer.uint32(10).string(message.participantId);
    }
    if (message.participantIdentity !== "") {
      writer.uint32(18).string(message.participantIdentity);
    }
    if (message.roomName !== "") {
      writer.uint32(26).string(message.roomName);
    }
    if (message.sipCallId !== "") {
      writer.uint32(34).string(message.sipCallId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPParticipantInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPParticipantInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participantId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sipCallId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPParticipantInfo {
    return {
      participantId: isSet(object.participantId) ? globalThis.String(object.participantId) : "",
      participantIdentity: isSet(object.participantIdentity) ? globalThis.String(object.participantIdentity) : "",
      roomName: isSet(object.roomName) ? globalThis.String(object.roomName) : "",
      sipCallId: isSet(object.sipCallId) ? globalThis.String(object.sipCallId) : "",
    };
  },

  toJSON(message: SIPParticipantInfo): unknown {
    const obj: any = {};
    if (message.participantId !== "") {
      obj.participantId = message.participantId;
    }
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.sipCallId !== "") {
      obj.sipCallId = message.sipCallId;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPParticipantInfo>): SIPParticipantInfo {
    return SIPParticipantInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPParticipantInfo>): SIPParticipantInfo {
    const message = createBaseSIPParticipantInfo();
    message.participantId = object.participantId ?? "";
    message.participantIdentity = object.participantIdentity ?? "";
    message.roomName = object.roomName ?? "";
    message.sipCallId = object.sipCallId ?? "";
    return message;
  },
};

function createBaseTransferSIPParticipantRequest(): TransferSIPParticipantRequest {
  return {
    participantIdentity: "",
    roomName: "",
    transferTo: "",
    playDialtone: false,
    headers: {},
    ringingTimeout: undefined,
  };
}

export const TransferSIPParticipantRequest: MessageFns<TransferSIPParticipantRequest> = {
  encode(message: TransferSIPParticipantRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.participantIdentity !== "") {
      writer.uint32(10).string(message.participantIdentity);
    }
    if (message.roomName !== "") {
      writer.uint32(18).string(message.roomName);
    }
    if (message.transferTo !== "") {
      writer.uint32(26).string(message.transferTo);
    }
    if (message.playDialtone !== false) {
      writer.uint32(32).bool(message.playDialtone);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      TransferSIPParticipantRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    if (message.ringingTimeout !== undefined) {
      Duration.encode(message.ringingTimeout, writer.uint32(50).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferSIPParticipantRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferSIPParticipantRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transferTo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.playDialtone = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = TransferSIPParticipantRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.headers[entry5.key] = entry5.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.ringingTimeout = Duration.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferSIPParticipantRequest {
    return {
      participantIdentity: isSet(object.participantIdentity) ? globalThis.String(object.participantIdentity) : "",
      roomName: isSet(object.roomName) ? globalThis.String(object.roomName) : "",
      transferTo: isSet(object.transferTo) ? globalThis.String(object.transferTo) : "",
      playDialtone: isSet(object.playDialtone) ? globalThis.Boolean(object.playDialtone) : false,
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      ringingTimeout: isSet(object.ringingTimeout) ? Duration.fromJSON(object.ringingTimeout) : undefined,
    };
  },

  toJSON(message: TransferSIPParticipantRequest): unknown {
    const obj: any = {};
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.transferTo !== "") {
      obj.transferTo = message.transferTo;
    }
    if (message.playDialtone !== false) {
      obj.playDialtone = message.playDialtone;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.ringingTimeout !== undefined) {
      obj.ringingTimeout = Duration.toJSON(message.ringingTimeout);
    }
    return obj;
  },

  create(base?: DeepPartial<TransferSIPParticipantRequest>): TransferSIPParticipantRequest {
    return TransferSIPParticipantRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<TransferSIPParticipantRequest>): TransferSIPParticipantRequest {
    const message = createBaseTransferSIPParticipantRequest();
    message.participantIdentity = object.participantIdentity ?? "";
    message.roomName = object.roomName ?? "";
    message.transferTo = object.transferTo ?? "";
    message.playDialtone = object.playDialtone ?? false;
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.ringingTimeout = (object.ringingTimeout !== undefined && object.ringingTimeout !== null)
      ? Duration.fromPartial(object.ringingTimeout)
      : undefined;
    return message;
  },
};

function createBaseTransferSIPParticipantRequest_HeadersEntry(): TransferSIPParticipantRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const TransferSIPParticipantRequest_HeadersEntry: MessageFns<TransferSIPParticipantRequest_HeadersEntry> = {
  encode(message: TransferSIPParticipantRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TransferSIPParticipantRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTransferSIPParticipantRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TransferSIPParticipantRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: TransferSIPParticipantRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<TransferSIPParticipantRequest_HeadersEntry>): TransferSIPParticipantRequest_HeadersEntry {
    return TransferSIPParticipantRequest_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<TransferSIPParticipantRequest_HeadersEntry>,
  ): TransferSIPParticipantRequest_HeadersEntry {
    const message = createBaseTransferSIPParticipantRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPCallInfo(): SIPCallInfo {
  return {
    callId: "",
    trunkId: "",
    dispatchRuleId: "",
    region: "",
    roomName: "",
    roomId: "",
    participantIdentity: "",
    participantAttributes: {},
    fromUri: undefined,
    toUri: undefined,
    createdAt: "0",
    startedAt: "0",
    endedAt: "0",
    enabledFeatures: [],
    callDirection: 0,
    callStatus: 0,
    createdAtNs: "0",
    startedAtNs: "0",
    endedAtNs: "0",
    disconnectReason: 0,
    error: "",
    callStatusCode: undefined,
    audioCodec: "",
    mediaEncryption: "",
  };
}

export const SIPCallInfo: MessageFns<SIPCallInfo> = {
  encode(message: SIPCallInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.callId !== "") {
      writer.uint32(10).string(message.callId);
    }
    if (message.trunkId !== "") {
      writer.uint32(18).string(message.trunkId);
    }
    if (message.dispatchRuleId !== "") {
      writer.uint32(130).string(message.dispatchRuleId);
    }
    if (message.region !== "") {
      writer.uint32(138).string(message.region);
    }
    if (message.roomName !== "") {
      writer.uint32(26).string(message.roomName);
    }
    if (message.roomId !== "") {
      writer.uint32(34).string(message.roomId);
    }
    if (message.participantIdentity !== "") {
      writer.uint32(42).string(message.participantIdentity);
    }
    Object.entries(message.participantAttributes).forEach(([key, value]) => {
      SIPCallInfo_ParticipantAttributesEntry.encode({ key: key as any, value }, writer.uint32(146).fork()).join();
    });
    if (message.fromUri !== undefined) {
      SIPUri.encode(message.fromUri, writer.uint32(50).fork()).join();
    }
    if (message.toUri !== undefined) {
      SIPUri.encode(message.toUri, writer.uint32(58).fork()).join();
    }
    if (message.createdAt !== "0") {
      writer.uint32(72).int64(message.createdAt);
    }
    if (message.startedAt !== "0") {
      writer.uint32(80).int64(message.startedAt);
    }
    if (message.endedAt !== "0") {
      writer.uint32(88).int64(message.endedAt);
    }
    writer.uint32(114).fork();
    for (const v of message.enabledFeatures) {
      writer.int32(v);
    }
    writer.join();
    if (message.callDirection !== 0) {
      writer.uint32(120).int32(message.callDirection);
    }
    if (message.callStatus !== 0) {
      writer.uint32(64).int32(message.callStatus);
    }
    if (message.createdAtNs !== "0") {
      writer.uint32(176).int64(message.createdAtNs);
    }
    if (message.startedAtNs !== "0") {
      writer.uint32(184).int64(message.startedAtNs);
    }
    if (message.endedAtNs !== "0") {
      writer.uint32(192).int64(message.endedAtNs);
    }
    if (message.disconnectReason !== 0) {
      writer.uint32(96).int32(message.disconnectReason);
    }
    if (message.error !== "") {
      writer.uint32(106).string(message.error);
    }
    if (message.callStatusCode !== undefined) {
      SIPStatus.encode(message.callStatusCode, writer.uint32(154).fork()).join();
    }
    if (message.audioCodec !== "") {
      writer.uint32(162).string(message.audioCodec);
    }
    if (message.mediaEncryption !== "") {
      writer.uint32(170).string(message.mediaEncryption);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPCallInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPCallInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.callId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.trunkId = reader.string();
          continue;
        }
        case 16: {
          if (tag !== 130) {
            break;
          }

          message.dispatchRuleId = reader.string();
          continue;
        }
        case 17: {
          if (tag !== 138) {
            break;
          }

          message.region = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.roomName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.roomId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.participantIdentity = reader.string();
          continue;
        }
        case 18: {
          if (tag !== 146) {
            break;
          }

          const entry18 = SIPCallInfo_ParticipantAttributesEntry.decode(reader, reader.uint32());
          if (entry18.value !== undefined) {
            message.participantAttributes[entry18.key] = entry18.value;
          }
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.fromUri = SIPUri.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.toUri = SIPUri.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createdAt = reader.int64().toString();
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.startedAt = reader.int64().toString();
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.endedAt = reader.int64().toString();
          continue;
        }
        case 14: {
          if (tag === 112) {
            message.enabledFeatures.push(reader.int32() as any);

            continue;
          }

          if (tag === 114) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.enabledFeatures.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 15: {
          if (tag !== 120) {
            break;
          }

          message.callDirection = reader.int32() as any;
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.callStatus = reader.int32() as any;
          continue;
        }
        case 22: {
          if (tag !== 176) {
            break;
          }

          message.createdAtNs = reader.int64().toString();
          continue;
        }
        case 23: {
          if (tag !== 184) {
            break;
          }

          message.startedAtNs = reader.int64().toString();
          continue;
        }
        case 24: {
          if (tag !== 192) {
            break;
          }

          message.endedAtNs = reader.int64().toString();
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.disconnectReason = reader.int32() as any;
          continue;
        }
        case 13: {
          if (tag !== 106) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 19: {
          if (tag !== 154) {
            break;
          }

          message.callStatusCode = SIPStatus.decode(reader, reader.uint32());
          continue;
        }
        case 20: {
          if (tag !== 162) {
            break;
          }

          message.audioCodec = reader.string();
          continue;
        }
        case 21: {
          if (tag !== 170) {
            break;
          }

          message.mediaEncryption = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPCallInfo {
    return {
      callId: isSet(object.callId) ? globalThis.String(object.callId) : "",
      trunkId: isSet(object.trunkId) ? globalThis.String(object.trunkId) : "",
      dispatchRuleId: isSet(object.dispatchRuleId) ? globalThis.String(object.dispatchRuleId) : "",
      region: isSet(object.region) ? globalThis.String(object.region) : "",
      roomName: isSet(object.roomName) ? globalThis.String(object.roomName) : "",
      roomId: isSet(object.roomId) ? globalThis.String(object.roomId) : "",
      participantIdentity: isSet(object.participantIdentity) ? globalThis.String(object.participantIdentity) : "",
      participantAttributes: isObject(object.participantAttributes)
        ? Object.entries(object.participantAttributes).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      fromUri: isSet(object.fromUri) ? SIPUri.fromJSON(object.fromUri) : undefined,
      toUri: isSet(object.toUri) ? SIPUri.fromJSON(object.toUri) : undefined,
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "0",
      startedAt: isSet(object.startedAt) ? globalThis.String(object.startedAt) : "0",
      endedAt: isSet(object.endedAt) ? globalThis.String(object.endedAt) : "0",
      enabledFeatures: globalThis.Array.isArray(object?.enabledFeatures)
        ? object.enabledFeatures.map((e: any) => sIPFeatureFromJSON(e))
        : [],
      callDirection: isSet(object.callDirection) ? sIPCallDirectionFromJSON(object.callDirection) : 0,
      callStatus: isSet(object.callStatus) ? sIPCallStatusFromJSON(object.callStatus) : 0,
      createdAtNs: isSet(object.createdAtNs) ? globalThis.String(object.createdAtNs) : "0",
      startedAtNs: isSet(object.startedAtNs) ? globalThis.String(object.startedAtNs) : "0",
      endedAtNs: isSet(object.endedAtNs) ? globalThis.String(object.endedAtNs) : "0",
      disconnectReason: isSet(object.disconnectReason) ? disconnectReasonFromJSON(object.disconnectReason) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      callStatusCode: isSet(object.callStatusCode) ? SIPStatus.fromJSON(object.callStatusCode) : undefined,
      audioCodec: isSet(object.audioCodec) ? globalThis.String(object.audioCodec) : "",
      mediaEncryption: isSet(object.mediaEncryption) ? globalThis.String(object.mediaEncryption) : "",
    };
  },

  toJSON(message: SIPCallInfo): unknown {
    const obj: any = {};
    if (message.callId !== "") {
      obj.callId = message.callId;
    }
    if (message.trunkId !== "") {
      obj.trunkId = message.trunkId;
    }
    if (message.dispatchRuleId !== "") {
      obj.dispatchRuleId = message.dispatchRuleId;
    }
    if (message.region !== "") {
      obj.region = message.region;
    }
    if (message.roomName !== "") {
      obj.roomName = message.roomName;
    }
    if (message.roomId !== "") {
      obj.roomId = message.roomId;
    }
    if (message.participantIdentity !== "") {
      obj.participantIdentity = message.participantIdentity;
    }
    if (message.participantAttributes) {
      const entries = Object.entries(message.participantAttributes);
      if (entries.length > 0) {
        obj.participantAttributes = {};
        entries.forEach(([k, v]) => {
          obj.participantAttributes[k] = v;
        });
      }
    }
    if (message.fromUri !== undefined) {
      obj.fromUri = SIPUri.toJSON(message.fromUri);
    }
    if (message.toUri !== undefined) {
      obj.toUri = SIPUri.toJSON(message.toUri);
    }
    if (message.createdAt !== "0") {
      obj.createdAt = message.createdAt;
    }
    if (message.startedAt !== "0") {
      obj.startedAt = message.startedAt;
    }
    if (message.endedAt !== "0") {
      obj.endedAt = message.endedAt;
    }
    if (message.enabledFeatures?.length) {
      obj.enabledFeatures = message.enabledFeatures.map((e) => sIPFeatureToJSON(e));
    }
    if (message.callDirection !== 0) {
      obj.callDirection = sIPCallDirectionToJSON(message.callDirection);
    }
    if (message.callStatus !== 0) {
      obj.callStatus = sIPCallStatusToJSON(message.callStatus);
    }
    if (message.createdAtNs !== "0") {
      obj.createdAtNs = message.createdAtNs;
    }
    if (message.startedAtNs !== "0") {
      obj.startedAtNs = message.startedAtNs;
    }
    if (message.endedAtNs !== "0") {
      obj.endedAtNs = message.endedAtNs;
    }
    if (message.disconnectReason !== 0) {
      obj.disconnectReason = disconnectReasonToJSON(message.disconnectReason);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.callStatusCode !== undefined) {
      obj.callStatusCode = SIPStatus.toJSON(message.callStatusCode);
    }
    if (message.audioCodec !== "") {
      obj.audioCodec = message.audioCodec;
    }
    if (message.mediaEncryption !== "") {
      obj.mediaEncryption = message.mediaEncryption;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPCallInfo>): SIPCallInfo {
    return SIPCallInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPCallInfo>): SIPCallInfo {
    const message = createBaseSIPCallInfo();
    message.callId = object.callId ?? "";
    message.trunkId = object.trunkId ?? "";
    message.dispatchRuleId = object.dispatchRuleId ?? "";
    message.region = object.region ?? "";
    message.roomName = object.roomName ?? "";
    message.roomId = object.roomId ?? "";
    message.participantIdentity = object.participantIdentity ?? "";
    message.participantAttributes = Object.entries(object.participantAttributes ?? {}).reduce<
      { [key: string]: string }
    >((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.fromUri = (object.fromUri !== undefined && object.fromUri !== null)
      ? SIPUri.fromPartial(object.fromUri)
      : undefined;
    message.toUri = (object.toUri !== undefined && object.toUri !== null)
      ? SIPUri.fromPartial(object.toUri)
      : undefined;
    message.createdAt = object.createdAt ?? "0";
    message.startedAt = object.startedAt ?? "0";
    message.endedAt = object.endedAt ?? "0";
    message.enabledFeatures = object.enabledFeatures?.map((e) => e) || [];
    message.callDirection = object.callDirection ?? 0;
    message.callStatus = object.callStatus ?? 0;
    message.createdAtNs = object.createdAtNs ?? "0";
    message.startedAtNs = object.startedAtNs ?? "0";
    message.endedAtNs = object.endedAtNs ?? "0";
    message.disconnectReason = object.disconnectReason ?? 0;
    message.error = object.error ?? "";
    message.callStatusCode = (object.callStatusCode !== undefined && object.callStatusCode !== null)
      ? SIPStatus.fromPartial(object.callStatusCode)
      : undefined;
    message.audioCodec = object.audioCodec ?? "";
    message.mediaEncryption = object.mediaEncryption ?? "";
    return message;
  },
};

function createBaseSIPCallInfo_ParticipantAttributesEntry(): SIPCallInfo_ParticipantAttributesEntry {
  return { key: "", value: "" };
}

export const SIPCallInfo_ParticipantAttributesEntry: MessageFns<SIPCallInfo_ParticipantAttributesEntry> = {
  encode(message: SIPCallInfo_ParticipantAttributesEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPCallInfo_ParticipantAttributesEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPCallInfo_ParticipantAttributesEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPCallInfo_ParticipantAttributesEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SIPCallInfo_ParticipantAttributesEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<SIPCallInfo_ParticipantAttributesEntry>): SIPCallInfo_ParticipantAttributesEntry {
    return SIPCallInfo_ParticipantAttributesEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPCallInfo_ParticipantAttributesEntry>): SIPCallInfo_ParticipantAttributesEntry {
    const message = createBaseSIPCallInfo_ParticipantAttributesEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSIPTransferInfo(): SIPTransferInfo {
  return {
    transferId: "",
    callId: "",
    transferTo: "",
    transferInitiatedAtNs: "0",
    transferCompletedAtNs: "0",
    transferStatus: 0,
    error: "",
    transferStatusCode: undefined,
  };
}

export const SIPTransferInfo: MessageFns<SIPTransferInfo> = {
  encode(message: SIPTransferInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.transferId !== "") {
      writer.uint32(10).string(message.transferId);
    }
    if (message.callId !== "") {
      writer.uint32(18).string(message.callId);
    }
    if (message.transferTo !== "") {
      writer.uint32(26).string(message.transferTo);
    }
    if (message.transferInitiatedAtNs !== "0") {
      writer.uint32(32).int64(message.transferInitiatedAtNs);
    }
    if (message.transferCompletedAtNs !== "0") {
      writer.uint32(40).int64(message.transferCompletedAtNs);
    }
    if (message.transferStatus !== 0) {
      writer.uint32(48).int32(message.transferStatus);
    }
    if (message.error !== "") {
      writer.uint32(58).string(message.error);
    }
    if (message.transferStatusCode !== undefined) {
      SIPStatus.encode(message.transferStatusCode, writer.uint32(66).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPTransferInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPTransferInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.transferId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.callId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.transferTo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.transferInitiatedAtNs = reader.int64().toString();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.transferCompletedAtNs = reader.int64().toString();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.transferStatus = reader.int32() as any;
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.error = reader.string();
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.transferStatusCode = SIPStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPTransferInfo {
    return {
      transferId: isSet(object.transferId) ? globalThis.String(object.transferId) : "",
      callId: isSet(object.callId) ? globalThis.String(object.callId) : "",
      transferTo: isSet(object.transferTo) ? globalThis.String(object.transferTo) : "",
      transferInitiatedAtNs: isSet(object.transferInitiatedAtNs)
        ? globalThis.String(object.transferInitiatedAtNs)
        : "0",
      transferCompletedAtNs: isSet(object.transferCompletedAtNs)
        ? globalThis.String(object.transferCompletedAtNs)
        : "0",
      transferStatus: isSet(object.transferStatus) ? sIPTransferStatusFromJSON(object.transferStatus) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
      transferStatusCode: isSet(object.transferStatusCode) ? SIPStatus.fromJSON(object.transferStatusCode) : undefined,
    };
  },

  toJSON(message: SIPTransferInfo): unknown {
    const obj: any = {};
    if (message.transferId !== "") {
      obj.transferId = message.transferId;
    }
    if (message.callId !== "") {
      obj.callId = message.callId;
    }
    if (message.transferTo !== "") {
      obj.transferTo = message.transferTo;
    }
    if (message.transferInitiatedAtNs !== "0") {
      obj.transferInitiatedAtNs = message.transferInitiatedAtNs;
    }
    if (message.transferCompletedAtNs !== "0") {
      obj.transferCompletedAtNs = message.transferCompletedAtNs;
    }
    if (message.transferStatus !== 0) {
      obj.transferStatus = sIPTransferStatusToJSON(message.transferStatus);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    if (message.transferStatusCode !== undefined) {
      obj.transferStatusCode = SIPStatus.toJSON(message.transferStatusCode);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPTransferInfo>): SIPTransferInfo {
    return SIPTransferInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPTransferInfo>): SIPTransferInfo {
    const message = createBaseSIPTransferInfo();
    message.transferId = object.transferId ?? "";
    message.callId = object.callId ?? "";
    message.transferTo = object.transferTo ?? "";
    message.transferInitiatedAtNs = object.transferInitiatedAtNs ?? "0";
    message.transferCompletedAtNs = object.transferCompletedAtNs ?? "0";
    message.transferStatus = object.transferStatus ?? 0;
    message.error = object.error ?? "";
    message.transferStatusCode = (object.transferStatusCode !== undefined && object.transferStatusCode !== null)
      ? SIPStatus.fromPartial(object.transferStatusCode)
      : undefined;
    return message;
  },
};

function createBaseSIPUri(): SIPUri {
  return { user: "", host: "", ip: "", port: 0, transport: 0 };
}

export const SIPUri: MessageFns<SIPUri> = {
  encode(message: SIPUri, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.user !== "") {
      writer.uint32(10).string(message.user);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.ip !== "") {
      writer.uint32(26).string(message.ip);
    }
    if (message.port !== 0) {
      writer.uint32(32).uint32(message.port);
    }
    if (message.transport !== 0) {
      writer.uint32(40).int32(message.transport);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SIPUri {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSIPUri();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.user = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.ip = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.port = reader.uint32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.transport = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SIPUri {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : "",
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      ip: isSet(object.ip) ? globalThis.String(object.ip) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
      transport: isSet(object.transport) ? sIPTransportFromJSON(object.transport) : 0,
    };
  },

  toJSON(message: SIPUri): unknown {
    const obj: any = {};
    if (message.user !== "") {
      obj.user = message.user;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.ip !== "") {
      obj.ip = message.ip;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    if (message.transport !== 0) {
      obj.transport = sIPTransportToJSON(message.transport);
    }
    return obj;
  },

  create(base?: DeepPartial<SIPUri>): SIPUri {
    return SIPUri.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SIPUri>): SIPUri {
    const message = createBaseSIPUri();
    message.user = object.user ?? "";
    message.host = object.host ?? "";
    message.ip = object.ip ?? "";
    message.port = object.port ?? 0;
    message.transport = object.transport ?? 0;
    return message;
  },
};

/** rpc CreateSIPTrunk(CreateSIPTrunkRequest) returns (SIPTrunkInfo) { option deprecated = true; }; DELETED */
export type SIPDefinition = typeof SIPDefinition;
export const SIPDefinition = {
  name: "SIP",
  fullName: "livekit.SIP",
  methods: {
    /** @deprecated */
    listSIPTrunk: {
      name: "ListSIPTrunk",
      requestType: ListSIPTrunkRequest,
      requestStream: false,
      responseType: ListSIPTrunkResponse,
      responseStream: false,
      options: {},
    },
    createSIPInboundTrunk: {
      name: "CreateSIPInboundTrunk",
      requestType: CreateSIPInboundTrunkRequest,
      requestStream: false,
      responseType: SIPInboundTrunkInfo,
      responseStream: false,
      options: {},
    },
    createSIPOutboundTrunk: {
      name: "CreateSIPOutboundTrunk",
      requestType: CreateSIPOutboundTrunkRequest,
      requestStream: false,
      responseType: SIPOutboundTrunkInfo,
      responseStream: false,
      options: {},
    },
    updateSIPInboundTrunk: {
      name: "UpdateSIPInboundTrunk",
      requestType: UpdateSIPInboundTrunkRequest,
      requestStream: false,
      responseType: SIPInboundTrunkInfo,
      responseStream: false,
      options: {},
    },
    updateSIPOutboundTrunk: {
      name: "UpdateSIPOutboundTrunk",
      requestType: UpdateSIPOutboundTrunkRequest,
      requestStream: false,
      responseType: SIPOutboundTrunkInfo,
      responseStream: false,
      options: {},
    },
    getSIPInboundTrunk: {
      name: "GetSIPInboundTrunk",
      requestType: GetSIPInboundTrunkRequest,
      requestStream: false,
      responseType: GetSIPInboundTrunkResponse,
      responseStream: false,
      options: {},
    },
    getSIPOutboundTrunk: {
      name: "GetSIPOutboundTrunk",
      requestType: GetSIPOutboundTrunkRequest,
      requestStream: false,
      responseType: GetSIPOutboundTrunkResponse,
      responseStream: false,
      options: {},
    },
    listSIPInboundTrunk: {
      name: "ListSIPInboundTrunk",
      requestType: ListSIPInboundTrunkRequest,
      requestStream: false,
      responseType: ListSIPInboundTrunkResponse,
      responseStream: false,
      options: {},
    },
    listSIPOutboundTrunk: {
      name: "ListSIPOutboundTrunk",
      requestType: ListSIPOutboundTrunkRequest,
      requestStream: false,
      responseType: ListSIPOutboundTrunkResponse,
      responseStream: false,
      options: {},
    },
    deleteSIPTrunk: {
      name: "DeleteSIPTrunk",
      requestType: DeleteSIPTrunkRequest,
      requestStream: false,
      responseType: SIPTrunkInfo,
      responseStream: false,
      options: {},
    },
    createSIPDispatchRule: {
      name: "CreateSIPDispatchRule",
      requestType: CreateSIPDispatchRuleRequest,
      requestStream: false,
      responseType: SIPDispatchRuleInfo,
      responseStream: false,
      options: {},
    },
    updateSIPDispatchRule: {
      name: "UpdateSIPDispatchRule",
      requestType: UpdateSIPDispatchRuleRequest,
      requestStream: false,
      responseType: SIPDispatchRuleInfo,
      responseStream: false,
      options: {},
    },
    listSIPDispatchRule: {
      name: "ListSIPDispatchRule",
      requestType: ListSIPDispatchRuleRequest,
      requestStream: false,
      responseType: ListSIPDispatchRuleResponse,
      responseStream: false,
      options: {},
    },
    deleteSIPDispatchRule: {
      name: "DeleteSIPDispatchRule",
      requestType: DeleteSIPDispatchRuleRequest,
      requestStream: false,
      responseType: SIPDispatchRuleInfo,
      responseStream: false,
      options: {},
    },
    createSIPParticipant: {
      name: "CreateSIPParticipant",
      requestType: CreateSIPParticipantRequest,
      requestStream: false,
      responseType: SIPParticipantInfo,
      responseStream: false,
      options: {},
    },
    transferSIPParticipant: {
      name: "TransferSIPParticipant",
      requestType: TransferSIPParticipantRequest,
      requestStream: false,
      responseType: Empty,
      responseStream: false,
      options: {},
    },
  },
} as const;

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
