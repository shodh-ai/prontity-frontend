// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v6.31.0
// source: interaction.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "rox.interaction";

/** Enum to define what kind of UI action the agent wants the client to perform */
export enum ClientUIActionType {
  NO_ACTION = 0,
  SHOW_ALERT = 1,
  UPDATE_TEXT_CONTENT = 2,
  TOGGLE_ELEMENT_VISIBILITY = 3,

  START_TIMER = 4,
  STOP_TIMER = 5,
  PAUSE_TIMER = 6,
  RESET_TIMER = 7,
  UPDATE_PROGRESS_INDICATOR = 8,
  UPDATE_SCORE_OR_PROGRESS = 9,
  /** SHOW_ELEMENT - UI Control & State Actions */
  SHOW_ELEMENT = 10,
  HIDE_ELEMENT = 11,
  /** NAVIGATE_TO_PAGE - Navigation Actions */
  NAVIGATE_TO_PAGE = 12,
  /** UPDATE_LIVE_TRANSCRIPT - Content Display Actions */
  UPDATE_LIVE_TRANSCRIPT = 13,
  DISPLAY_TRANSCRIPT_OR_TEXT = 14,
  DISPLAY_REMARKS_LIST = 15,
  /** SET_BUTTON_PROPERTIES - Button & Input Actions */
  SET_BUTTON_PROPERTIES = 21,
  ENABLE_BUTTON = 22,
  DISABLE_BUTTON = 23,
  SHOW_BUTTON_OPTIONS = 24,
  CLEAR_INPUT_FIELD = 25,
  /** SET_EDITOR_READONLY_SECTIONS - Editor & Content Actions */
  SET_EDITOR_READONLY_SECTIONS = 26,
  /** PLAY_AUDIO_CUE - Feedback & Loading Actions */
  PLAY_AUDIO_CUE = 27,
  /** SHOW_LOADING_INDICATOR - Add more actions here as needed */
  SHOW_LOADING_INDICATOR = 28,

  /** HIGHLIGHT_TEXT_RANGES - Action to highlight text ranges */
  HIGHLIGHT_TEXT_RANGES = 29,
  /** SUGGEST_TEXT_EDIT - Action to suggest a text edit */
  SUGGEST_TEXT_EDIT = 30,
  /** SHOW_INLINE_SUGGESTION - Action to show a non-intrusive inline suggestion */
  SHOW_INLINE_SUGGESTION = 31,
  /** SHOW_TOOLTIP_OR_COMMENT - Action to display a tooltip or comment */
  SHOW_TOOLTIP_OR_COMMENT = 32,
  /** SET_EDITOR_CONTENT - Action to set the entire content of an editor */
  SET_EDITOR_CONTENT = 33,
  /** APPEND_TEXT_TO_EDITOR_REALTIME - Action to append text chunks to an editor */
  APPEND_TEXT_TO_EDITOR_REALTIME = 34,

  UNRECOGNIZED = -1,
}

export function clientUIActionTypeFromJSON(object: any): ClientUIActionType {
  switch (object) {
    case 0:
    case "NO_ACTION":
      return ClientUIActionType.NO_ACTION;
    case 1:
    case "SHOW_ALERT":
      return ClientUIActionType.SHOW_ALERT;
    case 2:
    case "UPDATE_TEXT_CONTENT":
      return ClientUIActionType.UPDATE_TEXT_CONTENT;
    case 3:
    case "TOGGLE_ELEMENT_VISIBILITY":
      return ClientUIActionType.TOGGLE_ELEMENT_VISIBILITY;
    case 4:
    case "START_TIMER":
      return ClientUIActionType.START_TIMER;
    case 5:
    case "STOP_TIMER":
      return ClientUIActionType.STOP_TIMER;
    case 6:
    case "PAUSE_TIMER":
      return ClientUIActionType.PAUSE_TIMER;
    case 7:
    case "RESET_TIMER":
      return ClientUIActionType.RESET_TIMER;
    case 8:
    case "UPDATE_PROGRESS_INDICATOR":
      return ClientUIActionType.UPDATE_PROGRESS_INDICATOR;
    case 9:
    case "UPDATE_SCORE_OR_PROGRESS":
      return ClientUIActionType.UPDATE_SCORE_OR_PROGRESS;
    case 10:
    case "SHOW_ELEMENT":
      return ClientUIActionType.SHOW_ELEMENT;
    case 11:
    case "HIDE_ELEMENT":
      return ClientUIActionType.HIDE_ELEMENT;
    case 12:
    case "NAVIGATE_TO_PAGE":
      return ClientUIActionType.NAVIGATE_TO_PAGE;
    case 13:
    case "UPDATE_LIVE_TRANSCRIPT":
      return ClientUIActionType.UPDATE_LIVE_TRANSCRIPT;
    case 14:
    case "DISPLAY_TRANSCRIPT_OR_TEXT":
      return ClientUIActionType.DISPLAY_TRANSCRIPT_OR_TEXT;
    case 15:
    case "DISPLAY_REMARKS_LIST":
      return ClientUIActionType.DISPLAY_REMARKS_LIST;
    case 21:
    case "SET_BUTTON_PROPERTIES":
      return ClientUIActionType.SET_BUTTON_PROPERTIES;
    case 22:
    case "ENABLE_BUTTON":
      return ClientUIActionType.ENABLE_BUTTON;
    case 23:
    case "DISABLE_BUTTON":
      return ClientUIActionType.DISABLE_BUTTON;
    case 24:
    case "SHOW_BUTTON_OPTIONS":
      return ClientUIActionType.SHOW_BUTTON_OPTIONS;
    case 25:
    case "CLEAR_INPUT_FIELD":
      return ClientUIActionType.CLEAR_INPUT_FIELD;
    case 26:
    case "SET_EDITOR_READONLY_SECTIONS":
      return ClientUIActionType.SET_EDITOR_READONLY_SECTIONS;
    case 27:
    case "PLAY_AUDIO_CUE":
      return ClientUIActionType.PLAY_AUDIO_CUE;
    case 28:
    case "SHOW_LOADING_INDICATOR":
      return ClientUIActionType.SHOW_LOADING_INDICATOR;

    case "HIGHLIGHT_TEXT_RANGES":
      return ClientUIActionType.HIGHLIGHT_TEXT_RANGES;
    case 29:
    case "SUGGEST_TEXT_EDIT":
      return ClientUIActionType.SUGGEST_TEXT_EDIT;
    case 30:
    case "SHOW_INLINE_SUGGESTION":
      return ClientUIActionType.SHOW_INLINE_SUGGESTION;
    case 31:
    case "SHOW_TOOLTIP_OR_COMMENT":
      return ClientUIActionType.SHOW_TOOLTIP_OR_COMMENT;
    case 32:
    case "SET_EDITOR_CONTENT":
      return ClientUIActionType.SET_EDITOR_CONTENT;
    case 33:
    case "APPEND_TEXT_TO_EDITOR_REALTIME":
      return ClientUIActionType.APPEND_TEXT_TO_EDITOR_REALTIME;

    case -1:
    case "UNRECOGNIZED":
    default:
      return ClientUIActionType.UNRECOGNIZED;
  }
}

export function clientUIActionTypeToJSON(object: ClientUIActionType): string {
  switch (object) {
    case ClientUIActionType.NO_ACTION:
      return "NO_ACTION";
    case ClientUIActionType.SHOW_ALERT:
      return "SHOW_ALERT";
    case ClientUIActionType.UPDATE_TEXT_CONTENT:
      return "UPDATE_TEXT_CONTENT";
    case ClientUIActionType.TOGGLE_ELEMENT_VISIBILITY:
      return "TOGGLE_ELEMENT_VISIBILITY";
    case ClientUIActionType.START_TIMER:
      return "START_TIMER";
    case ClientUIActionType.STOP_TIMER:
      return "STOP_TIMER";
    case ClientUIActionType.PAUSE_TIMER:
      return "PAUSE_TIMER";
    case ClientUIActionType.RESET_TIMER:
      return "RESET_TIMER";
    case ClientUIActionType.UPDATE_PROGRESS_INDICATOR:
      return "UPDATE_PROGRESS_INDICATOR";
    case ClientUIActionType.UPDATE_SCORE_OR_PROGRESS:
      return "UPDATE_SCORE_OR_PROGRESS";
    case ClientUIActionType.SHOW_ELEMENT:
      return "SHOW_ELEMENT";
    case ClientUIActionType.HIDE_ELEMENT:
      return "HIDE_ELEMENT";
    case ClientUIActionType.NAVIGATE_TO_PAGE:
      return "NAVIGATE_TO_PAGE";
    case ClientUIActionType.UPDATE_LIVE_TRANSCRIPT:
      return "UPDATE_LIVE_TRANSCRIPT";
    case ClientUIActionType.DISPLAY_TRANSCRIPT_OR_TEXT:
      return "DISPLAY_TRANSCRIPT_OR_TEXT";
    case ClientUIActionType.DISPLAY_REMARKS_LIST:
      return "DISPLAY_REMARKS_LIST";
    case ClientUIActionType.SET_BUTTON_PROPERTIES:
      return "SET_BUTTON_PROPERTIES";
    case ClientUIActionType.ENABLE_BUTTON:
      return "ENABLE_BUTTON";
    case ClientUIActionType.DISABLE_BUTTON:
      return "DISABLE_BUTTON";
    case ClientUIActionType.SHOW_BUTTON_OPTIONS:
      return "SHOW_BUTTON_OPTIONS";
    case ClientUIActionType.CLEAR_INPUT_FIELD:
      return "CLEAR_INPUT_FIELD";
    case ClientUIActionType.SET_EDITOR_READONLY_SECTIONS:
      return "SET_EDITOR_READONLY_SECTIONS";
    case ClientUIActionType.PLAY_AUDIO_CUE:
      return "PLAY_AUDIO_CUE";
    case ClientUIActionType.SHOW_LOADING_INDICATOR:
      return "SHOW_LOADING_INDICATOR";
    case ClientUIActionType.HIGHLIGHT_TEXT_RANGES:
      return "HIGHLIGHT_TEXT_RANGES";
    case ClientUIActionType.SUGGEST_TEXT_EDIT:
      return "SUGGEST_TEXT_EDIT";
    case ClientUIActionType.SHOW_INLINE_SUGGESTION:
      return "SHOW_INLINE_SUGGESTION";
    case ClientUIActionType.SHOW_TOOLTIP_OR_COMMENT:
      return "SHOW_TOOLTIP_OR_COMMENT";
    case ClientUIActionType.SET_EDITOR_CONTENT:
      return "SET_EDITOR_CONTENT";
    case ClientUIActionType.APPEND_TEXT_TO_EDITOR_REALTIME:
      return "APPEND_TEXT_TO_EDITOR_REALTIME
    case ClientUIActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** For simple notifications if agent calls client and no specific response is needed. */
export interface Empty {
}

/** Message sent from frontend when a button is clicked */
export interface FrontendButtonClickRequest {
  /** Identifier for the button, e.g., "my_action_button" */
  buttonId: string;
  /** Optional: any string data you want to send */
  customData: string;
}

/** Response from the agent for the button click */
export interface AgentResponse {
  /** e.g., "Button click processed" */
  statusMessage: string;
  /** Optional: any data agent wants to return */
  dataPayload: string;
}

/** Message for dispatching UI actions to the frontend */
export interface UIAction {
  actionType: UIAction_ActionType;
  /** Payload for alert actions */
  alert?: Alert | undefined;
}

export enum UIAction_ActionType {
  UNSPECIFIED = 0,
  ALERT = 1,
  /**
   * DISMISS_ALERT - You can add other specific UI action types here later
   * e.g., SHOW_MODAL = 3; UPDATE_ELEMENT = 4;
   */
  DISMISS_ALERT = 2,
  UNRECOGNIZED = -1,
}

export function uIAction_ActionTypeFromJSON(object: any): UIAction_ActionType {
  switch (object) {
    case 0:
    case "UNSPECIFIED":
      return UIAction_ActionType.UNSPECIFIED;
    case 1:
    case "ALERT":
      return UIAction_ActionType.ALERT;
    case 2:
    case "DISMISS_ALERT":
      return UIAction_ActionType.DISMISS_ALERT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return UIAction_ActionType.UNRECOGNIZED;
  }
}

export function uIAction_ActionTypeToJSON(object: UIAction_ActionType): string {
  switch (object) {
    case UIAction_ActionType.UNSPECIFIED:
      return "UNSPECIFIED";
    case UIAction_ActionType.ALERT:
      return "ALERT";
    case UIAction_ActionType.DISMISS_ALERT:
      return "DISMISS_ALERT";
    case UIAction_ActionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface Alert {
  title: string;
  message: string;
  buttons: AlertButton[];
}

export interface AlertButton {
  label: string;
  /** The action to perform when this button is clicked (e.g., DISMISS_ALERT) */
  action: UIAction | undefined;
}

/** Message to represent a single text highlight range */
export interface HighlightRangeProto {
  /** Unique identifier for the highlight */
  id: string;
  /** Start position (ProseMirror index) */
  start: number;
  /** End position (ProseMirror index) */
  end: number;
  /** Type of highlight (e.g., 'grammar', 'suggestion') */
  type: string;
  /** Optional message/comment */
  message?:
    | string
    | undefined;
  /** Optional original text needing correction */
  wrongVersion?:
    | string
    | undefined;
  /** Optional suggested correction */
  correctVersion?: string | undefined;
}

/** Message to represent a single text edit suggestion */
export interface SuggestTextEditPayloadProto {
  /** Unique identifier for the suggestion */
  suggestionId: string;
  /** Start position (ProseMirror index) */
  startPos: number;
  /** End position (ProseMirror index) */
  endPos: number;
  /** The text to be replaced */
  originalText: string;
  /** The suggested new text */
  newText: string;
}

/** Message for showing an inline, non-intrusive suggestion */
export interface ShowInlineSuggestionPayloadProto {
  /** Unique ID for this suggestion */
  suggestionId: string;
  /** Start position in the editor (ProseMirror index) */
  startPos: number;
  /** End position in the editor (ProseMirror index) */
  endPos: number;
  /** Text to show on hover/click (e.g., "Consider rephrasing for clarity.") */
  suggestionText: string;
  /** Type of suggestion (e.g., "grammar", "style", "clarity") - for potential styling/iconography */
  suggestionType: string;
}

/** Message for showing a tooltip or comment */
export interface ShowTooltipOrCommentPayloadProto {
  /** Unique ID for this tooltip/comment */
  id: string;
  /** Start position in the editor (ProseMirror index) */
  startPos: number;
  /** End position in the editor (ProseMirror index) */
  endPos: number;
  /** The content of the tooltip/comment */
  text: string;
  /** E.g., "info", "suggestion", "error", "question" - for styling/iconography */
  tooltipType: string;
}

/** Message for setting the entire content of a rich text editor */
export interface SetEditorContentPayloadProto {
  contentFormat?:
    | //
    /** Full HTML content */
    { $case: "htmlContent"; htmlContent: string }
    | //
    /** Tiptap JSON content as a string */
    { $case: "jsonContent"; jsonContent: string }
    | undefined;
}

/** Message for appending text to an editor in real-time */
export interface AppendTextToEditorRealtimePayloadProto {
  /** The chunk of text to append */
  textChunk: string;
  /** Optional: ID to group related chunks if part of a continuous stream */
  streamId?:
    | string
    | undefined;
  /** Indicates if this is the last chunk in a stream */
  isFinalChunk?: boolean | undefined;
}

/** Request from Agent to Client to perform a UI action */
export interface AgentToClientUIActionRequest {
  /** Optional: for tracking/correlation */
  requestId: string;
  actionType: ClientUIActionType;
  /** Optional: ID of the HTML element to target */
  targetElementId: string;
  /** Flexible parameters, e.g., */
  parameters: { [key: string]: string };
  /** Payload for HIGHLIGHT_TEXT_RANGES */
  highlightRangesPayload: HighlightRangeProto[];
  /** Payload for SUGGEST_TEXT_EDIT */
  suggestTextEditPayload?:
    | SuggestTextEditPayloadProto
    | undefined;
  /** Payload for SHOW_INLINE_SUGGESTION */
  showInlineSuggestionPayload?:
    | ShowInlineSuggestionPayloadProto
    | undefined;
  /** Payload for SHOW_TOOLTIP_OR_COMMENT */
  showTooltipOrCommentPayload?:
    | ShowTooltipOrCommentPayloadProto
    | undefined;
  /** Payload for SET_EDITOR_CONTENT */
  setEditorContentPayload?:
    | SetEditorContentPayloadProto
    | undefined;
  /** Payload for APPEND_TEXT_TO_EDITOR_REALTIME */
  appendTextToEditorRealtimePayload?: AppendTextToEditorRealtimePayloadProto | undefined;
}

export interface AgentToClientUIActionRequest_ParametersEntry {
  key: string;
  value: string;
}

/** Response from Client to Agent after attempting the UI action */
export interface ClientUIActionResponse {
  /** Corresponds to AgentToClientUIActionRequest.request_id */
  requestId: string;
  success: boolean;
  /** e.g., "Alert shown", "Element #myText updated", "Error: Element #xyz not found" */
  message: string;
}

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<Empty>): Empty {
    return Empty.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<Empty>): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseFrontendButtonClickRequest(): FrontendButtonClickRequest {
  return { buttonId: "", customData: "" };
}

export const FrontendButtonClickRequest: MessageFns<FrontendButtonClickRequest> = {
  encode(message: FrontendButtonClickRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.buttonId !== "") {
      writer.uint32(10).string(message.buttonId);
    }
    if (message.customData !== "") {
      writer.uint32(18).string(message.customData);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FrontendButtonClickRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFrontendButtonClickRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.buttonId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.customData = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FrontendButtonClickRequest {
    return {
      buttonId: isSet(object.buttonId) ? globalThis.String(object.buttonId) : "",
      customData: isSet(object.customData) ? globalThis.String(object.customData) : "",
    };
  },

  toJSON(message: FrontendButtonClickRequest): unknown {
    const obj: any = {};
    if (message.buttonId !== "") {
      obj.buttonId = message.buttonId;
    }
    if (message.customData !== "") {
      obj.customData = message.customData;
    }
    return obj;
  },

  create(base?: DeepPartial<FrontendButtonClickRequest>): FrontendButtonClickRequest {
    return FrontendButtonClickRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FrontendButtonClickRequest>): FrontendButtonClickRequest {
    const message = createBaseFrontendButtonClickRequest();
    message.buttonId = object.buttonId ?? "";
    message.customData = object.customData ?? "";
    return message;
  },
};

function createBaseAgentResponse(): AgentResponse {
  return { statusMessage: "", dataPayload: "" };
}

export const AgentResponse: MessageFns<AgentResponse> = {
  encode(message: AgentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.statusMessage !== "") {
      writer.uint32(10).string(message.statusMessage);
    }
    if (message.dataPayload !== "") {
      writer.uint32(18).string(message.dataPayload);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.statusMessage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataPayload = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentResponse {
    return {
      statusMessage: isSet(object.statusMessage) ? globalThis.String(object.statusMessage) : "",
      dataPayload: isSet(object.dataPayload) ? globalThis.String(object.dataPayload) : "",
    };
  },

  toJSON(message: AgentResponse): unknown {
    const obj: any = {};
    if (message.statusMessage !== "") {
      obj.statusMessage = message.statusMessage;
    }
    if (message.dataPayload !== "") {
      obj.dataPayload = message.dataPayload;
    }
    return obj;
  },

  create(base?: DeepPartial<AgentResponse>): AgentResponse {
    return AgentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentResponse>): AgentResponse {
    const message = createBaseAgentResponse();
    message.statusMessage = object.statusMessage ?? "";
    message.dataPayload = object.dataPayload ?? "";
    return message;
  },
};

function createBaseUIAction(): UIAction {
  return { actionType: 0, alert: undefined };
}

export const UIAction: MessageFns<UIAction> = {
  encode(message: UIAction, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.actionType !== 0) {
      writer.uint32(8).int32(message.actionType);
    }
    if (message.alert !== undefined) {
      Alert.encode(message.alert, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UIAction {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUIAction();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.alert = Alert.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UIAction {
    return {
      actionType: isSet(object.actionType) ? uIAction_ActionTypeFromJSON(object.actionType) : 0,
      alert: isSet(object.alert) ? Alert.fromJSON(object.alert) : undefined,
    };
  },

  toJSON(message: UIAction): unknown {
    const obj: any = {};
    if (message.actionType !== 0) {
      obj.actionType = uIAction_ActionTypeToJSON(message.actionType);
    }
    if (message.alert !== undefined) {
      obj.alert = Alert.toJSON(message.alert);
    }
    return obj;
  },

  create(base?: DeepPartial<UIAction>): UIAction {
    return UIAction.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<UIAction>): UIAction {
    const message = createBaseUIAction();
    message.actionType = object.actionType ?? 0;
    message.alert = (object.alert !== undefined && object.alert !== null) ? Alert.fromPartial(object.alert) : undefined;
    return message;
  },
};

function createBaseAlert(): Alert {
  return { title: "", message: "", buttons: [] };
}

export const Alert: MessageFns<Alert> = {
  encode(message: Alert, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.title !== "") {
      writer.uint32(10).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(18).string(message.message);
    }
    for (const v of message.buttons) {
      AlertButton.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Alert {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlert();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.title = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.buttons.push(AlertButton.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Alert {
    return {
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      buttons: globalThis.Array.isArray(object?.buttons) ? object.buttons.map((e: any) => AlertButton.fromJSON(e)) : [],
    };
  },

  toJSON(message: Alert): unknown {
    const obj: any = {};
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.buttons?.length) {
      obj.buttons = message.buttons.map((e) => AlertButton.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<Alert>): Alert {
    return Alert.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<Alert>): Alert {
    const message = createBaseAlert();
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    message.buttons = object.buttons?.map((e) => AlertButton.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAlertButton(): AlertButton {
  return { label: "", action: undefined };
}

export const AlertButton: MessageFns<AlertButton> = {
  encode(message: AlertButton, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.label !== "") {
      writer.uint32(10).string(message.label);
    }
    if (message.action !== undefined) {
      UIAction.encode(message.action, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AlertButton {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAlertButton();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.label = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.action = UIAction.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AlertButton {
    return {
      label: isSet(object.label) ? globalThis.String(object.label) : "",
      action: isSet(object.action) ? UIAction.fromJSON(object.action) : undefined,
    };
  },

  toJSON(message: AlertButton): unknown {
    const obj: any = {};
    if (message.label !== "") {
      obj.label = message.label;
    }
    if (message.action !== undefined) {
      obj.action = UIAction.toJSON(message.action);
    }
    return obj;
  },

  create(base?: DeepPartial<AlertButton>): AlertButton {
    return AlertButton.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AlertButton>): AlertButton {
    const message = createBaseAlertButton();
    message.label = object.label ?? "";
    message.action = (object.action !== undefined && object.action !== null)
      ? UIAction.fromPartial(object.action)
      : undefined;
    return message;
  },
};

function createBaseHighlightRangeProto(): HighlightRangeProto {
  return { id: "", start: 0, end: 0, type: "", message: undefined, wrongVersion: undefined, correctVersion: undefined };
}

export const HighlightRangeProto: MessageFns<HighlightRangeProto> = {
  encode(message: HighlightRangeProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.start !== 0) {
      writer.uint32(16).int32(message.start);
    }
    if (message.end !== 0) {
      writer.uint32(24).int32(message.end);
    }
    if (message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    if (message.message !== undefined) {
      writer.uint32(42).string(message.message);
    }
    if (message.wrongVersion !== undefined) {
      writer.uint32(50).string(message.wrongVersion);
    }
    if (message.correctVersion !== undefined) {
      writer.uint32(58).string(message.correctVersion);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HighlightRangeProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHighlightRangeProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.start = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.end = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.wrongVersion = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.correctVersion = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HighlightRangeProto {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      start: isSet(object.start) ? globalThis.Number(object.start) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : undefined,
      wrongVersion: isSet(object.wrongVersion) ? globalThis.String(object.wrongVersion) : undefined,
      correctVersion: isSet(object.correctVersion) ? globalThis.String(object.correctVersion) : undefined,
    };
  },

  toJSON(message: HighlightRangeProto): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.start !== 0) {
      obj.start = Math.round(message.start);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.message !== undefined) {
      obj.message = message.message;
    }
    if (message.wrongVersion !== undefined) {
      obj.wrongVersion = message.wrongVersion;
    }
    if (message.correctVersion !== undefined) {
      obj.correctVersion = message.correctVersion;
    }
    return obj;
  },

  create(base?: DeepPartial<HighlightRangeProto>): HighlightRangeProto {
    return HighlightRangeProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<HighlightRangeProto>): HighlightRangeProto {
    const message = createBaseHighlightRangeProto();
    message.id = object.id ?? "";
    message.start = object.start ?? 0;
    message.end = object.end ?? 0;
    message.type = object.type ?? "";
    message.message = object.message ?? undefined;
    message.wrongVersion = object.wrongVersion ?? undefined;
    message.correctVersion = object.correctVersion ?? undefined;
    return message;
  },
};

function createBaseSuggestTextEditPayloadProto(): SuggestTextEditPayloadProto {
  return { suggestionId: "", startPos: 0, endPos: 0, originalText: "", newText: "" };
}

export const SuggestTextEditPayloadProto: MessageFns<SuggestTextEditPayloadProto> = {
  encode(message: SuggestTextEditPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestionId !== "") {
      writer.uint32(10).string(message.suggestionId);
    }
    if (message.startPos !== 0) {
      writer.uint32(16).int32(message.startPos);
    }
    if (message.endPos !== 0) {
      writer.uint32(24).int32(message.endPos);
    }
    if (message.originalText !== "") {
      writer.uint32(34).string(message.originalText);
    }
    if (message.newText !== "") {
      writer.uint32(42).string(message.newText);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SuggestTextEditPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSuggestTextEditPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.suggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startPos = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endPos = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.originalText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.newText = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SuggestTextEditPayloadProto {
    return {
      suggestionId: isSet(object.suggestionId) ? globalThis.String(object.suggestionId) : "",
      startPos: isSet(object.startPos) ? globalThis.Number(object.startPos) : 0,
      endPos: isSet(object.endPos) ? globalThis.Number(object.endPos) : 0,
      originalText: isSet(object.originalText) ? globalThis.String(object.originalText) : "",
      newText: isSet(object.newText) ? globalThis.String(object.newText) : "",
    };
  },

  toJSON(message: SuggestTextEditPayloadProto): unknown {
    const obj: any = {};
    if (message.suggestionId !== "") {
      obj.suggestionId = message.suggestionId;
    }
    if (message.startPos !== 0) {
      obj.startPos = Math.round(message.startPos);
    }
    if (message.endPos !== 0) {
      obj.endPos = Math.round(message.endPos);
    }
    if (message.originalText !== "") {
      obj.originalText = message.originalText;
    }
    if (message.newText !== "") {
      obj.newText = message.newText;
    }
    return obj;
  },

  create(base?: DeepPartial<SuggestTextEditPayloadProto>): SuggestTextEditPayloadProto {
    return SuggestTextEditPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SuggestTextEditPayloadProto>): SuggestTextEditPayloadProto {
    const message = createBaseSuggestTextEditPayloadProto();
    message.suggestionId = object.suggestionId ?? "";
    message.startPos = object.startPos ?? 0;
    message.endPos = object.endPos ?? 0;
    message.originalText = object.originalText ?? "";
    message.newText = object.newText ?? "";
    return message;
  },
};

function createBaseShowInlineSuggestionPayloadProto(): ShowInlineSuggestionPayloadProto {
  return { suggestionId: "", startPos: 0, endPos: 0, suggestionText: "", suggestionType: "" };
}

export const ShowInlineSuggestionPayloadProto: MessageFns<ShowInlineSuggestionPayloadProto> = {
  encode(message: ShowInlineSuggestionPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.suggestionId !== "") {
      writer.uint32(10).string(message.suggestionId);
    }
    if (message.startPos !== 0) {
      writer.uint32(16).int32(message.startPos);
    }
    if (message.endPos !== 0) {
      writer.uint32(24).int32(message.endPos);
    }
    if (message.suggestionText !== "") {
      writer.uint32(34).string(message.suggestionText);
    }
    if (message.suggestionType !== "") {
      writer.uint32(42).string(message.suggestionType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowInlineSuggestionPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowInlineSuggestionPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.suggestionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startPos = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endPos = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.suggestionText = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.suggestionType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowInlineSuggestionPayloadProto {
    return {
      suggestionId: isSet(object.suggestionId) ? globalThis.String(object.suggestionId) : "",
      startPos: isSet(object.startPos) ? globalThis.Number(object.startPos) : 0,
      endPos: isSet(object.endPos) ? globalThis.Number(object.endPos) : 0,
      suggestionText: isSet(object.suggestionText) ? globalThis.String(object.suggestionText) : "",
      suggestionType: isSet(object.suggestionType) ? globalThis.String(object.suggestionType) : "",
    };
  },

  toJSON(message: ShowInlineSuggestionPayloadProto): unknown {
    const obj: any = {};
    if (message.suggestionId !== "") {
      obj.suggestionId = message.suggestionId;
    }
    if (message.startPos !== 0) {
      obj.startPos = Math.round(message.startPos);
    }
    if (message.endPos !== 0) {
      obj.endPos = Math.round(message.endPos);
    }
    if (message.suggestionText !== "") {
      obj.suggestionText = message.suggestionText;
    }
    if (message.suggestionType !== "") {
      obj.suggestionType = message.suggestionType;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowInlineSuggestionPayloadProto>): ShowInlineSuggestionPayloadProto {
    return ShowInlineSuggestionPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowInlineSuggestionPayloadProto>): ShowInlineSuggestionPayloadProto {
    const message = createBaseShowInlineSuggestionPayloadProto();
    message.suggestionId = object.suggestionId ?? "";
    message.startPos = object.startPos ?? 0;
    message.endPos = object.endPos ?? 0;
    message.suggestionText = object.suggestionText ?? "";
    message.suggestionType = object.suggestionType ?? "";
    return message;
  },
};

function createBaseShowTooltipOrCommentPayloadProto(): ShowTooltipOrCommentPayloadProto {
  return { id: "", startPos: 0, endPos: 0, text: "", tooltipType: "" };
}

export const ShowTooltipOrCommentPayloadProto: MessageFns<ShowTooltipOrCommentPayloadProto> = {
  encode(message: ShowTooltipOrCommentPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.startPos !== 0) {
      writer.uint32(16).int32(message.startPos);
    }
    if (message.endPos !== 0) {
      writer.uint32(24).int32(message.endPos);
    }
    if (message.text !== "") {
      writer.uint32(34).string(message.text);
    }
    if (message.tooltipType !== "") {
      writer.uint32(42).string(message.tooltipType);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ShowTooltipOrCommentPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseShowTooltipOrCommentPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.startPos = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.endPos = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.text = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.tooltipType = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ShowTooltipOrCommentPayloadProto {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      startPos: isSet(object.startPos) ? globalThis.Number(object.startPos) : 0,
      endPos: isSet(object.endPos) ? globalThis.Number(object.endPos) : 0,
      text: isSet(object.text) ? globalThis.String(object.text) : "",
      tooltipType: isSet(object.tooltipType) ? globalThis.String(object.tooltipType) : "",
    };
  },

  toJSON(message: ShowTooltipOrCommentPayloadProto): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.startPos !== 0) {
      obj.startPos = Math.round(message.startPos);
    }
    if (message.endPos !== 0) {
      obj.endPos = Math.round(message.endPos);
    }
    if (message.text !== "") {
      obj.text = message.text;
    }
    if (message.tooltipType !== "") {
      obj.tooltipType = message.tooltipType;
    }
    return obj;
  },

  create(base?: DeepPartial<ShowTooltipOrCommentPayloadProto>): ShowTooltipOrCommentPayloadProto {
    return ShowTooltipOrCommentPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ShowTooltipOrCommentPayloadProto>): ShowTooltipOrCommentPayloadProto {
    const message = createBaseShowTooltipOrCommentPayloadProto();
    message.id = object.id ?? "";
    message.startPos = object.startPos ?? 0;
    message.endPos = object.endPos ?? 0;
    message.text = object.text ?? "";
    message.tooltipType = object.tooltipType ?? "";
    return message;
  },
};

function createBaseSetEditorContentPayloadProto(): SetEditorContentPayloadProto {
  return { contentFormat: undefined };
}

export const SetEditorContentPayloadProto: MessageFns<SetEditorContentPayloadProto> = {
  encode(message: SetEditorContentPayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    switch (message.contentFormat?.$case) {
      case "htmlContent":
        writer.uint32(10).string(message.contentFormat.htmlContent);
        break;
      case "jsonContent":
        writer.uint32(18).string(message.contentFormat.jsonContent);
        break;
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SetEditorContentPayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSetEditorContentPayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.contentFormat = { $case: "htmlContent", htmlContent: reader.string() };
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentFormat = { $case: "jsonContent", jsonContent: reader.string() };
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SetEditorContentPayloadProto {
    return {
      contentFormat: isSet(object.htmlContent)
        ? { $case: "htmlContent", htmlContent: globalThis.String(object.htmlContent) }
        : isSet(object.jsonContent)
        ? { $case: "jsonContent", jsonContent: globalThis.String(object.jsonContent) }
        : undefined,
    };
  },

  toJSON(message: SetEditorContentPayloadProto): unknown {
    const obj: any = {};
    if (message.contentFormat?.$case === "htmlContent") {
      obj.htmlContent = message.contentFormat.htmlContent;
    } else if (message.contentFormat?.$case === "jsonContent") {
      obj.jsonContent = message.contentFormat.jsonContent;
    }
    return obj;
  },

  create(base?: DeepPartial<SetEditorContentPayloadProto>): SetEditorContentPayloadProto {
    return SetEditorContentPayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SetEditorContentPayloadProto>): SetEditorContentPayloadProto {
    const message = createBaseSetEditorContentPayloadProto();
    switch (object.contentFormat?.$case) {
      case "htmlContent": {
        if (object.contentFormat?.htmlContent !== undefined && object.contentFormat?.htmlContent !== null) {
          message.contentFormat = { $case: "htmlContent", htmlContent: object.contentFormat.htmlContent };
        }
        break;
      }
      case "jsonContent": {
        if (object.contentFormat?.jsonContent !== undefined && object.contentFormat?.jsonContent !== null) {
          message.contentFormat = { $case: "jsonContent", jsonContent: object.contentFormat.jsonContent };
        }
        break;
      }
    }
    return message;
  },
};

function createBaseAppendTextToEditorRealtimePayloadProto(): AppendTextToEditorRealtimePayloadProto {
  return { textChunk: "", streamId: undefined, isFinalChunk: undefined };
}

export const AppendTextToEditorRealtimePayloadProto: MessageFns<AppendTextToEditorRealtimePayloadProto> = {
  encode(message: AppendTextToEditorRealtimePayloadProto, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.textChunk !== "") {
      writer.uint32(10).string(message.textChunk);
    }
    if (message.streamId !== undefined) {
      writer.uint32(18).string(message.streamId);
    }
    if (message.isFinalChunk !== undefined) {
      writer.uint32(24).bool(message.isFinalChunk);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AppendTextToEditorRealtimePayloadProto {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAppendTextToEditorRealtimePayloadProto();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.textChunk = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.streamId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isFinalChunk = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AppendTextToEditorRealtimePayloadProto {
    return {
      textChunk: isSet(object.textChunk) ? globalThis.String(object.textChunk) : "",
      streamId: isSet(object.streamId) ? globalThis.String(object.streamId) : undefined,
      isFinalChunk: isSet(object.isFinalChunk) ? globalThis.Boolean(object.isFinalChunk) : undefined,
    };
  },

  toJSON(message: AppendTextToEditorRealtimePayloadProto): unknown {
    const obj: any = {};
    if (message.textChunk !== "") {
      obj.textChunk = message.textChunk;
    }
    if (message.streamId !== undefined) {
      obj.streamId = message.streamId;
    }
    if (message.isFinalChunk !== undefined) {
      obj.isFinalChunk = message.isFinalChunk;
    }
    return obj;
  },

  create(base?: DeepPartial<AppendTextToEditorRealtimePayloadProto>): AppendTextToEditorRealtimePayloadProto {
    return AppendTextToEditorRealtimePayloadProto.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AppendTextToEditorRealtimePayloadProto>): AppendTextToEditorRealtimePayloadProto {
    const message = createBaseAppendTextToEditorRealtimePayloadProto();
    message.textChunk = object.textChunk ?? "";
    message.streamId = object.streamId ?? undefined;
    message.isFinalChunk = object.isFinalChunk ?? undefined;
    return message;
  },
};

function createBaseAgentToClientUIActionRequest(): AgentToClientUIActionRequest {
  return {
    requestId: "",
    actionType: 0,
    targetElementId: "",
    parameters: {},
    highlightRangesPayload: [],
    suggestTextEditPayload: undefined,
    showInlineSuggestionPayload: undefined,
    showTooltipOrCommentPayload: undefined,
    setEditorContentPayload: undefined,
    appendTextToEditorRealtimePayload: undefined,
  };
}

export const AgentToClientUIActionRequest: MessageFns<AgentToClientUIActionRequest> = {
  encode(message: AgentToClientUIActionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.actionType !== 0) {
      writer.uint32(16).int32(message.actionType);
    }
    if (message.targetElementId !== "") {
      writer.uint32(26).string(message.targetElementId);
    }
    Object.entries(message.parameters).forEach(([key, value]) => {
      AgentToClientUIActionRequest_ParametersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    for (const v of message.highlightRangesPayload) {
      HighlightRangeProto.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.suggestTextEditPayload !== undefined) {
      SuggestTextEditPayloadProto.encode(message.suggestTextEditPayload, writer.uint32(50).fork()).join();
    }
    if (message.showInlineSuggestionPayload !== undefined) {
      ShowInlineSuggestionPayloadProto.encode(message.showInlineSuggestionPayload, writer.uint32(58).fork()).join();
    }
    if (message.showTooltipOrCommentPayload !== undefined) {
      ShowTooltipOrCommentPayloadProto.encode(message.showTooltipOrCommentPayload, writer.uint32(66).fork()).join();
    }
    if (message.setEditorContentPayload !== undefined) {
      SetEditorContentPayloadProto.encode(message.setEditorContentPayload, writer.uint32(74).fork()).join();
    }
    if (message.appendTextToEditorRealtimePayload !== undefined) {
      AppendTextToEditorRealtimePayloadProto.encode(message.appendTextToEditorRealtimePayload, writer.uint32(82).fork())
        .join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentToClientUIActionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentToClientUIActionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.actionType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.targetElementId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = AgentToClientUIActionRequest_ParametersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.parameters[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.highlightRangesPayload.push(HighlightRangeProto.decode(reader, reader.uint32()));
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.suggestTextEditPayload = SuggestTextEditPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.showInlineSuggestionPayload = ShowInlineSuggestionPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.showTooltipOrCommentPayload = ShowTooltipOrCommentPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.setEditorContentPayload = SetEditorContentPayloadProto.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.appendTextToEditorRealtimePayload = AppendTextToEditorRealtimePayloadProto.decode(
            reader,
            reader.uint32(),
          );
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentToClientUIActionRequest {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      actionType: isSet(object.actionType) ? clientUIActionTypeFromJSON(object.actionType) : 0,
      targetElementId: isSet(object.targetElementId) ? globalThis.String(object.targetElementId) : "",
      parameters: isObject(object.parameters)
        ? Object.entries(object.parameters).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      highlightRangesPayload: globalThis.Array.isArray(object?.highlightRangesPayload)
        ? object.highlightRangesPayload.map((e: any) => HighlightRangeProto.fromJSON(e))
        : [],
      suggestTextEditPayload: isSet(object.suggestTextEditPayload)
        ? SuggestTextEditPayloadProto.fromJSON(object.suggestTextEditPayload)
        : undefined,
      showInlineSuggestionPayload: isSet(object.showInlineSuggestionPayload)
        ? ShowInlineSuggestionPayloadProto.fromJSON(object.showInlineSuggestionPayload)
        : undefined,
      showTooltipOrCommentPayload: isSet(object.showTooltipOrCommentPayload)
        ? ShowTooltipOrCommentPayloadProto.fromJSON(object.showTooltipOrCommentPayload)
        : undefined,
      setEditorContentPayload: isSet(object.setEditorContentPayload)
        ? SetEditorContentPayloadProto.fromJSON(object.setEditorContentPayload)
        : undefined,
      appendTextToEditorRealtimePayload: isSet(object.appendTextToEditorRealtimePayload)
        ? AppendTextToEditorRealtimePayloadProto.fromJSON(object.appendTextToEditorRealtimePayload)
        : undefined,
    };
  },

  toJSON(message: AgentToClientUIActionRequest): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.actionType !== 0) {
      obj.actionType = clientUIActionTypeToJSON(message.actionType);
    }
    if (message.targetElementId !== "") {
      obj.targetElementId = message.targetElementId;
    }
    if (message.parameters) {
      const entries = Object.entries(message.parameters);
      if (entries.length > 0) {
        obj.parameters = {};
        entries.forEach(([k, v]) => {
          obj.parameters[k] = v;
        });
      }
    }
    if (message.highlightRangesPayload?.length) {
      obj.highlightRangesPayload = message.highlightRangesPayload.map((e) => HighlightRangeProto.toJSON(e));
    }
    if (message.suggestTextEditPayload !== undefined) {
      obj.suggestTextEditPayload = SuggestTextEditPayloadProto.toJSON(message.suggestTextEditPayload);
    }
    if (message.showInlineSuggestionPayload !== undefined) {
      obj.showInlineSuggestionPayload = ShowInlineSuggestionPayloadProto.toJSON(message.showInlineSuggestionPayload);
    }
    if (message.showTooltipOrCommentPayload !== undefined) {
      obj.showTooltipOrCommentPayload = ShowTooltipOrCommentPayloadProto.toJSON(message.showTooltipOrCommentPayload);
    }
    if (message.setEditorContentPayload !== undefined) {
      obj.setEditorContentPayload = SetEditorContentPayloadProto.toJSON(message.setEditorContentPayload);
    }
    if (message.appendTextToEditorRealtimePayload !== undefined) {
      obj.appendTextToEditorRealtimePayload = AppendTextToEditorRealtimePayloadProto.toJSON(
        message.appendTextToEditorRealtimePayload,
      );
    }
    return obj;
  },

  create(base?: DeepPartial<AgentToClientUIActionRequest>): AgentToClientUIActionRequest {
    return AgentToClientUIActionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<AgentToClientUIActionRequest>): AgentToClientUIActionRequest {
    const message = createBaseAgentToClientUIActionRequest();
    message.requestId = object.requestId ?? "";
    message.actionType = object.actionType ?? 0;
    message.targetElementId = object.targetElementId ?? "";
    message.parameters = Object.entries(object.parameters ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    message.highlightRangesPayload = object.highlightRangesPayload?.map((e) => HighlightRangeProto.fromPartial(e)) ||
      [];
    message.suggestTextEditPayload =
      (object.suggestTextEditPayload !== undefined && object.suggestTextEditPayload !== null)
        ? SuggestTextEditPayloadProto.fromPartial(object.suggestTextEditPayload)
        : undefined;
    message.showInlineSuggestionPayload =
      (object.showInlineSuggestionPayload !== undefined && object.showInlineSuggestionPayload !== null)
        ? ShowInlineSuggestionPayloadProto.fromPartial(object.showInlineSuggestionPayload)
        : undefined;
    message.showTooltipOrCommentPayload =
      (object.showTooltipOrCommentPayload !== undefined && object.showTooltipOrCommentPayload !== null)
        ? ShowTooltipOrCommentPayloadProto.fromPartial(object.showTooltipOrCommentPayload)
        : undefined;
    message.setEditorContentPayload =
      (object.setEditorContentPayload !== undefined && object.setEditorContentPayload !== null)
        ? SetEditorContentPayloadProto.fromPartial(object.setEditorContentPayload)
        : undefined;
    message.appendTextToEditorRealtimePayload =
      (object.appendTextToEditorRealtimePayload !== undefined && object.appendTextToEditorRealtimePayload !== null)
        ? AppendTextToEditorRealtimePayloadProto.fromPartial(object.appendTextToEditorRealtimePayload)
        : undefined;
    return message;
  },
};

function createBaseAgentToClientUIActionRequest_ParametersEntry(): AgentToClientUIActionRequest_ParametersEntry {
  return { key: "", value: "" };
}

export const AgentToClientUIActionRequest_ParametersEntry: MessageFns<AgentToClientUIActionRequest_ParametersEntry> = {
  encode(
    message: AgentToClientUIActionRequest_ParametersEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AgentToClientUIActionRequest_ParametersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAgentToClientUIActionRequest_ParametersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AgentToClientUIActionRequest_ParametersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AgentToClientUIActionRequest_ParametersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(
    base?: DeepPartial<AgentToClientUIActionRequest_ParametersEntry>,
  ): AgentToClientUIActionRequest_ParametersEntry {
    return AgentToClientUIActionRequest_ParametersEntry.fromPartial(base ?? {});
  },
  fromPartial(
    object: DeepPartial<AgentToClientUIActionRequest_ParametersEntry>,
  ): AgentToClientUIActionRequest_ParametersEntry {
    const message = createBaseAgentToClientUIActionRequest_ParametersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseClientUIActionResponse(): ClientUIActionResponse {
  return { requestId: "", success: false, message: "" };
}

export const ClientUIActionResponse: MessageFns<ClientUIActionResponse> = {
  encode(message: ClientUIActionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.requestId !== "") {
      writer.uint32(10).string(message.requestId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.message !== "") {
      writer.uint32(26).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ClientUIActionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseClientUIActionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.requestId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.message = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ClientUIActionResponse {
    return {
      requestId: isSet(object.requestId) ? globalThis.String(object.requestId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ClientUIActionResponse): unknown {
    const obj: any = {};
    if (message.requestId !== "") {
      obj.requestId = message.requestId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create(base?: DeepPartial<ClientUIActionResponse>): ClientUIActionResponse {
    return ClientUIActionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ClientUIActionResponse>): ClientUIActionResponse {
    const message = createBaseClientUIActionResponse();
    message.requestId = object.requestId ?? "";
    message.success = object.success ?? false;
    message.message = object.message ?? "";
    return message;
  },
};

/** Service the agent will implement (called by frontend) */
export interface AgentInteraction {
  HandleFrontendButton(request: FrontendButtonClickRequest): Promise<AgentResponse>;
}

export const AgentInteractionServiceName = "rox.interaction.AgentInteraction";
export class AgentInteractionClientImpl implements AgentInteraction {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || AgentInteractionServiceName;
    this.rpc = rpc;
    this.HandleFrontendButton = this.HandleFrontendButton.bind(this);
  }
  HandleFrontendButton(request: FrontendButtonClickRequest): Promise<AgentResponse> {
    const data = FrontendButtonClickRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "HandleFrontendButton", data);
    return promise.then((data) => AgentResponse.decode(new BinaryReader(data)));
  }
}

/** Service the CLIENT will implement, and the AGENT will call */
export interface ClientSideUI {
  PerformUIAction(request: AgentToClientUIActionRequest): Promise<ClientUIActionResponse>;
}

export const ClientSideUIServiceName = "rox.interaction.ClientSideUI";
export class ClientSideUIClientImpl implements ClientSideUI {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ClientSideUIServiceName;
    this.rpc = rpc;
    this.PerformUIAction = this.PerformUIAction.bind(this);
  }
  PerformUIAction(request: AgentToClientUIActionRequest): Promise<ClientUIActionResponse> {
    const data = AgentToClientUIActionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PerformUIAction", data);
    return promise.then((data) => ClientUIActionResponse.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends { $case: string } ? { [K in keyof Omit<T, "$case">]?: DeepPartial<T[K]> } & { $case: T["$case"] }
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
